#!/usr/bin/awk -f

# Usage: change to the directory which has the files you want to convert
# then type oct2mat files.  This will convert all files in that directory,
# storing the output in $HOME/matlab., auplot_points=1000; endif
#
# Copyright 2001,2002,2003,2004 Paul Kienzle
# Copyright 2010 Alois Schloegl 
#
# Goal: automatically convert most octave code so that it will run on matlab.
#    * Preferably, the code should run on matlab4, but the lack of varargin
#    support makes this awkward for some functions.
#    * Code that isn't convertible automatically, should be marked as octave
#    specific or matlab specific.  Note that system specific code can be
#    selected at the time of preprocessing.
#    * I'm assuming primary development is done in octave, so it will not
#    need preprocessing.  Similarly, octave coding style and octave
#    features should not be compromised for the sake of translation.
#    * Translation should be possible on a machine without octave installed,
#    so no cheating and using the parse tree from within octave.
# Matlab specific and octave specific code
#    #<mat line -> line %<mat
#    line #<oct -> %<oct line
#    * So if something is specific to matlab, prefix the line with #<mat
#    and if it is specific to octave, postfix the line with #<oct.  This
#    can be used to replace ... with varargin, but it will not work for
#    very well for things like legend text in which only a bit of the
#    line needs to be changed.  This would require a proper preprocessor,
#    and would mean that all files would have to be preprocessed before
#    submitting them to either octave or matlab.
#    * Consider adding version specific flags: #<oct20 #<oct21 #<mat4 #<mat5
# Handles
#    ! -> ~
#    "str" -> 'str'
#    "s'r" -> 's''r'
#    endfunction ->
#    endblah -> end
#    # -> %
#    blah() -> blah
#    gset blah -> 
#    blah \<nl> -> blah ...<nl>
#    blah ( blah1 <nl> blah2 ) -> blah ( blah1 ...<nl> blah2 )
#    SEEK_SET, SEEK_CUR, SEEK_END -> -1, 0, 1
#    __error_text__ -> lasterr
# Support functions:
#    octave2matlab/*.m and octave2matlab/borrow/*.m 
#    Note: these routines should be run through octave2matlab
#    striplegend removes ;blah; from string
# Does not yet handle:
#    k++; k--; blah(k++), blah(k--);
#    +=, *=, -=, /=, etc.
#    __y -> y__
#    x=y=blah;   ->  y=blah; x=y;
#    function [x y]=blah -> function [x, y]=blah
#    global y=blah; -> global y; if isempty(y), y=blah; end
#    [0,blah()](1:n), [1:10](3:5)
#    blah()(1:n), (1:10)(3:5)
#    num2cell(1:n)(3:5), {1,2,3,4,5,6,7}(3:5)  
#    do a until (c);
#    end -> <nl>   if 'end' happens to be the end for the function def.
#    unwind_protect doblah unwind_protect_cleanup cleanblah end_unwind_protect
#        -> try doblah cleanblah catch cleanblah end
#        instead sends them all to null
# Does not handle octave's builtin variables
#    Ideally, references to globals would be eliminated entirely but that is
#    of course impossible (the halting problem and all that), so instead
#    any octave builtin variable that is referred to in the function must
#    be declared global at the start of the function.  This is tricky without
#    a parser.
# Does not handle plotting:
#    * In octave, title, xlabel, ylabel, grid, axis, etc. come before plot
#    but in matlab they come after.  This can be handled automatically
#    with a few functions:
#       octave_decorate to be called before title, xlabel, etc.:
#          if ishold and __octave_hold, hold('off') and clear __octave_hold
#          if ~ishold, axes;
#          set __octave_decorate
#       octave_plot to be called before plot:
#          if __octave_decorate and ~ishold 
#             hold('on'); set __octave_hold
#          clear __octave_decorate
#       octave_hold to be called before hold:
#          if __octave_hold, hold('off') and clear __octave_hold
#       octave_subplot to be called before subplot
#          clear __octave_decorate, __octave_hold
#    * Legends will be a problem.  Will have to strip them out of calls
#    to plot and add them back in calls to legend. This will need
#    a modified version of plot since it may be receiving its format
#    string as a variable.
#    * Matlab5 does not accept numbers in lieu of colours or symbols.  Could
#    be folded into the legend fixes if so inclined.
#    * matlab restores graph state automatically on the next plot, octave
#    generally does it manually while the plot is still displayed.  The
#    manual state restoration must not be executed under matlab, since it 
#    will modify the existing graph.  This is a prime candidate for #<oct
#    tags.
#    * figure(0) is not valid in matlab
# Variable argument/return lists:
#    Only possible in Matlab 5
#    Problems with va_arg() used as a parameter to a function call, since
#       cannot increment __idx until after the function call. Subsequent
#       va_arg() within the same function call will need __idx+1,__idx+2,...
#    function [...] = blah -> function [varargout] = blah
#    vrval(i)=blah -> varargout(i) = { blah }
#    function blah(blah,...) -> function blah(blah,varargin)
#    va_start() -> __idx = 1;
#    blah(va_arg()) -> blah(varargin(__idx))<nl> __idx = __idx+1;
# Comments and strings
#    * don't convert text therein, except of course for examples and text
#    destined for eval.  May need home-brew eval which does all the
#    translations herein.
#    * gets confused with transpose operator (which looks very much like a
#    string delimiter, so it isn't surprising).  Make sure transpose and
#    and strings don't appear on the same line of code or there may be
#    confusion

function fixquotes(x)
{
  inquote=incomment=0;
  y="";
  for (i=1; i <= length(x); i++) {
    ch = substr(x,i,1);
## test scripts are in comment blocks, so process them anyway
#    if (incomment) 
#      y = y ch;
#    else 
    if (inquote)
      if (ch==quote_ch) {
	inquote=0;
	y = y "'";
      }
      else if (ch=="'") y = y ch ch;
      else y = y ch;
    else if (ch == "'") {
      inquote = 1;
      quote_ch = ch;
      y = y ch;
    }
    else if (ch == "\"") {
      inquote = 1;
      quote_ch = ch;
      y = y "'";
    }
    else if (ch == "%") {
      incomment = 1;
      y = y ch;
    }
    else y = y ch;
  }
  return y;
}

# given a string beginning with "{", "(" or "[", attempts to find 
# a matching "}", ")" or "]" w.r.t. nesting.
# Can also match backwards, i.e. }{, )( and ][.
function matching_paren(s) {
  if (length(s) == 0)
    return 0;
  lpar = substr(s, 0, 1);
  if (lpar == "{")
    rpar = "}";
  else if (lpar == "}")
    rpar = "{";
  else if (lpar == "(")
    rpar = ")";
  else if (lpar == ")")
    rpar = "(";
  else if (lpar == "[")
    rpar = "]";
  else if (lpar == "]")
    rpar = "[";
  else
    return 0;

  lev = 1;
  rem = substr(s, 2);
  while (lev > 0 && length(rem) > 0) {
    idxl = index(rem, lpar);
    idxr = index(rem, rpar);
    if (idxr > 0) {
      if (idxl > 0 && idxl < idxr) {
	lev += 1;
	rem = substr(rem, idxl+1);
      } else {
	lev -= 1;
	rem = substr(rem, idxr+1);
      }
    } else
      rem = "";
  }

  if (lev == 0)
    return length(s) - length(rem);
  else
    return 0;
}

function reverse(s)
{
  p = ""
  for(i=length(s); i > 0; i--) { p = p substr(s, i, 1) }
  return p
}

function tmpvarname()
{
  tmpcounter += 1;
  return "o2m_tmp_" tmpcounter
}

function subst_indexed_expr(line, rpos) {
  if (line ~ /\<while\>/) {
    bad = 1;
    print "cannot convert indexed expression in while() clause at line " NR > "/dev/stderr"
    return line;
  }

  ## strip leading whitespace.
  if (match(line, /^[ \t]+/)) {
    n = RLENGTH;
    spc = substr(line, 1, n);
    line = substr(line, n+1);
    return spc subst_indexed_expr(line, rpos - n);
  }

  par = substr(line, rpos, 1);
  lpiece = substr(line, 1, rpos);
  lpiece = reverse(lpiece);
  n = matching_paren(lpiece);
  if (n == 0) {
    bad = 1;
    print "couldn't find matching parenthesis at line " NR > "/dev/stderr"
    return line;
  }
  rem = substr(lpiece, n+1);

  ## check for a semicolon
  sem = index(rem, ";");
  if (sem > 0) {
    sem = length(lpiece) + 1 - (n + sem);
    lpart = substr(line, 1, sem);
    rpart = substr(line, sem+1);
    return lpart subst_indexed_expr(rpart, rpos - sem);
  }

  if (par == ")") {
    ## Attempt to include an indexed token.
    if (match(rem, /^[ \t]*\w+/))
      n += RLENGTH;
  }

  varname = tmpvarname();
  prestmt = varname " = " substr(line, rpos-n+1, n) ";\n";
  return prestmt substr(line, 1, rpos-n) varname substr(line, rpos+1);
}


#BEGIN { target=ENVIRON["HOME"] "/matlab/"; }
BEGIN { 
        target="/tmp/oct2mat/"; 
        ocnt = 0; 
	tmpcounter = 0;
	bad = 0;
}

FNR==1 {
  if (file) { 
    if (file=="-") print body "\n" copyright;
    else print body "\n" copyright > file;
  }
  body=copyright="";
  if (FILENAME=="-") file="-"; else file=target FILENAME; 
  incopyright=0;
  print "Converting " FILENAME;
}

/^## Copyright/ { incopyright=1; }
/^$/ { incopyright=0; }
/^[^#]/ {incopyright=0; }

{
    if (sub("#<oct","")) $0 = "#<oct" $0;
    if (sub("#<mat","")) $0 = sprintf("%-73s#<mat",$0);
    gsub("#" , "%");
    gsub("[(][)]","");
    gsub("gset[^;%]*;","");
    gsub("gset[^;]*%","%");
    gsub("gset[^;]*$","");
    gsub("endfunction","");
    gsub("endif","end");
    gsub("endwhile","end");
    gsub("endfor","end");
    gsub("endswitch","end");
    gsub("endclassdef","end");
    gsub("end_try_catch","end");
    gsub("SEEK_CUR",0);
    gsub("SEEK_END",1);
    gsub("SEEK_SET",-1);
    gsub("usage","error");
    gsub("__error_text__","lasterr");
    gsub("unwind_protect_cleanup","end");
    gsub("end_unwind_protect","");
    gsub("unwind_protect","try");
    gsub("!","~");
    gsub("[\\\\]$","..."); 

    if (1) { ## EXPERIMENTAL...

      if ($0 ~ /(\+|-|\.?\*|\.?\/|\.?\^)=/) {
	## try to substitute computed assignments.
	## +=, -=, &=, |= don't generally need extra parens.
	$0 = gensub(/([^ ;]*[a-zA-Z0-9\)\}])([ \t]*)(\+|-|\&|\|)=/, "\\1\\2=\\2\\1\\2\\3", "g");
	## *=, /=, ^= and their dotted counterparts need parenthesizing the RHS.
	$0 = gensub(/([^ ;]*[a-zA-Z0-9\)\}])([ \t]*)(\.?\*|\.?\/|\.?\^)=([ \t]*)([^;]+)/,
	   "\\1\\2=\\2\\1\\2\\3\\4(\\5)", "g");
      }

      ## match expression indexing.
      bad = 0;
      while (match($0, /\)[ \t]*\(/) && !bad) { 
	# (expr)(index) or name(expr)(index)
	$0 = subst_indexed_expr($0, RSTART);
      } 

      bad = 0;
      while (match($0, /\)[ \t]*\{/) && !bad) { 
	# (expr){index} or name(expr){index}
	$0 = subst_indexed_expr($0, RSTART);
      } 

      bad = 0;
      while (match($0, /\][ \t]*\(/) && !bad) { 
	# [expr](index)
	$0 = subst_indexed_expr($0, RSTART);
      } 

      bad = 0;
      while (match($0, /\][ \t]*\{/) && !bad) { 
	# [expr]{index}
	$0 = subst_indexed_expr($0, RSTART);
      } 
    } ## EXPERIMENTAL

#### add ... when line is not closed ####
    {
        line = $0;
        lcnt = gsub(/\(/,"",line);
        rcnt = gsub(/\)/,"",line);        
        ocnt = ocnt+lcnt-rcnt;
        if (ocnt > 0 && !index($0 ,"...") )
                $0 = $0 " ...";
    }
#### replace obsolete functions ####
    gsub(/cell \(\);/, "{};");
    gsub(/= t_cdf \(/ , "= tcdf (");
    gsub("is_matrix","ismatrix");
    if (incopyright) copyright = copyright "\n" fixquotes($0); 
    else body = body "\n" fixquotes($0);
}
    
END  {
  if (file) { 
    if (file=="-") print body "\n" copyright;
    else print body "\n" copyright > file;
  }
}
