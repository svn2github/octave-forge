@c -*- texinfo -*-

@c Copyright (C) 2008, 2009, 2010, 2011, 2012 Moreno Marzolla
@c
@c This file is part of the queueing toolbox, a Queueing Networks
@c analysis package for GNU Octave.
@c
@c The queueing toolbox is free software; you can redistribute it
@c and/or modify it under the terms of the GNU General Public License
@c as published by the Free Software Foundation; either version 3 of
@c the License, or (at your option) any later version.
@c
@c The queueing toolbox is distributed in the hope that it will be
@c useful, but WITHOUT ANY WARRANTY; without even the implied warranty
@c of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
@c GNU General Public License for more details.
@c
@c You should have received a copy of the GNU General Public License
@c along with the queueing toolbox; see the file COPYING.  If not, see
@c <http://www.gnu.org/licenses/>.

@node Getting Started
@chapter Introduction and Getting Started

@menu
* Analysis of Closed Networks::
* Analysis of Open Networks::
@end menu

In this chapter we give some usage examples of the @code{queueing}
package. The reader is assumed to be familiar with Queueing Networks
(although some basic terminology and notation will be given
here). Additional usage examples are embedded in most of the function
files; to display and execute the demos associated with function
@emph{fname} you can type @command{demo @emph{fname}} at the Octave
prompt. For example

@example
@kbd{demo qnclosed}
@end example

@noindent executes all demos (if any) for the @command{qnclosed} function.

@node Analysis of Closed Networks
@section Analysis of Closed Networks

Let us consider a simple closed network with @math{K=3} service
centers. Each center is of type @math{M/M/1}--FCFS. We denote with
@math{S_i} the average service time at center @math{i}, @math{i=1, 2,
3}. Let @math{S_1 = 1.0}, @math{S_2 = 2.0} and @math{S_3 = 0.8}. The
routing of jobs within the network is described with a @emph{routing
probability matrix} @math{P}. Specifically, a request completing
service at center @math{i} is enqueued at center @math{j} with
probability @math{P_{ij}}.  Let us assume the following routing
probability matrix:

@iftex
@tex
$$
P = \pmatrix{ 0 & 0.3 & 0.7 \cr
              1 & 0 & 0 \cr
              1 & 0 & 0 }
$$
@end tex
@end iftex
@ifnottex
@example
    [ 0  0.3  0.7 ] 
P = [ 1  0    0   ]
    [ 1  0    0   ]
@end example
@end ifnottex

For example, according to matric @math{P} a job completing service at
center 1 is routed to center 2 with probability 0.3, and is routed to
center 3 with probability 0.7.

The network above can be analyzed with the @command{qnclosed}
function; if there is just a single class of requests, as in the
example above, @command{qnclosed} calls @command{qnclosedsinglemva}
which implements the Mean Value Analysys (MVA) algorithm for
single-class, product-form network.

@command{qnclosed} requires the following parameters:

@table @var

@item N
Number of requests in the network (since we are considering a closed
network, the number of requests is fixed)

@item S
Array of average service times at the centers: @code{@var{S}(k)} is
the average service time at center @math{k}.

@item V
Array of visit ratios: @code{@var{V}(k)} is the average number of
visits to center @math{k}.

@end table

As can be seen, we must compute the @emph{visit ratios} (or visit
counts) @math{V_k} for each center @math{k}. The visit counts satisfy
the following equations:

@iftex
@tex
$$
V_j = \sum_{i=1}^K V_i P_{ij}
$$
@end tex
@end iftex
@ifnottex
@example     
V_j = sum_i V_i P_ij
@end example
@end ifnottex

We can compute @math{V_k} from the routing probability matrix
@math{P_{ij}} using the @command{qnvisits} function:

@example
@group
@kbd{P = [0 0.3 0.7; 1 0 0; 1 0 0];}
@kbd{V = qnvisits(P)}
   @result{} V = 1.00000 0.30000 0.70000
@end group
@end example

We can check that the computed values satisfy the above equation by
evaluating the following expression:

@example
@kbd{V*P}
     @result{} ans = 1.00000 0.30000 0.70000
@end example

@noindent which is equal to @math{V}.
Hence, we can analyze the network for a given population size @math{N}
(for example, @math{N=10}) as follows:

@example
@group
@kbd{N = 10;}
@kbd{S = [1 2 0.8];}
@kbd{P = [0 0.3 0.7; 1 0 0; 1 0 0];}
@kbd{V = qnvisits(P);}
@kbd{[U R Q X] = qnclosed( N, S, V )}
   @result{} U = 0.99139 0.59483 0.55518 
   @result{} R = 7.4360  4.7531  1.7500 
   @result{} Q = 7.3719  1.4136  1.2144 
   @result{} X = 0.99139 0.29742 0.69397 
@end group
@end example

The output of @command{qnclosed} includes the vector of utilizations
@math{U_k} at center @math{k}, response time @math{R_k}, average
number of customers @math{Q_k} and throughput @math{X_k}. In our
example, the throughput of center 1 is @math{X_1 = 0.99139}, and the
average number of requests in center 3 is @math{Q_3 = 1.2144}. The
utilization of center 1 is @math{U_1 = 0.99139}, which is the higher
value among the service centers. Tus, center 1 is the @emph{bottleneck
device}.

This network can also be analyzed with the @command{qnsolve}
function. @command{qnsolve} can handle open, closed or mixed networks,
and allows the network to be described in a very flexible way.  First,
let @var{Q1}, @var{Q2} and @var{Q3} be the variables describing the
service centers. Each variable is instantiated with the
@command{qnmknode} function.

@example
@group
@kbd{Q1 = qnmknode( "m/m/m-fcfs", 1 );}
@kbd{Q2 = qnmknode( "m/m/m-fcfs", 2 );}
@kbd{Q3 = qnmknode( "m/m/m-fcfs", 0.8 );}
@end group
@end example

The first parameter of @command{qnmknode} is a string describing the
type of the node. Here we use @code{"m/m/m-fcfs"} to denote a
@math{M/M/m}--FCFS center. The second parameter gives the average
service time. An optional third parameter can be used to specify the
number @math{m} of service centers. If omitted, it is assumed
@math{m=1} (single-server node).

Now, the network can be analyzed as follows:

@example
@group
@kbd{N = 10;}
@kbd{V = [1 0.3 0.7];}
@kbd{[U R Q X] = qnsolve( "closed", N, @{ Q1, Q2, Q3 @}, V )}
   @result{} U = 0.99139 0.59483 0.55518 
   @result{} R = 7.4360  4.7531  1.7500 
   @result{} Q = 7.3719  1.4136  1.2144 
   @result{} X = 0.99139 0.29742 0.69397 
@end group
@end example

Of course, we get exactly the same results. Other functions can be used
for closed networks, @pxref{Algorithms for Product-Form QNs}.

@node Analysis of Open Networks
@section Analysis of Open Networks

Open networks can be analyzed in a similar way. Let us consider
an open network with @math{K=3} service centers, and routing
probability matrix as follows:

@iftex
@tex
$$
P = \pmatrix{ 0 & 0.3 & 0.5 \cr
              1 & 0 & 0 \cr
              1 & 0 & 0 }
$$
@end tex
@end iftex
@ifnottex
@example
    [ 0  0.3  0.5 ]
P = [ 1  0    0   ]
    [ 1  0    0   ]
@end example
@end ifnottex

In this network, requests can leave the system from center 1 with
probability @math{(1-(0.3+0.5) = 0.2}. We suppose that external jobs
arrive at center 1 with rate @math{\lambda_1 = 0.15}; there are no
arrivals at centers 2 and 3.

Similarly to closed networks, we first need to compute the visit
counts @math{V_k} to center @math{k}. Again, we use the
@command{qnvisits} function as follows:

@example
@group
@kbd{P = [0 0.3 0.5; 1 0 0; 1 0 0];}
@kbd{lambda = [0.15 0 0];}
@kbd{V = qnvisits(P, lambda)}
   @result{} V = 5.00000 1.50000 2.50000
@end group
@end example

@noindent where @code{@var{lambda}(k)} is the arrival rate at center @math{k},
and @var{P} is the routing matrix. The visit counts @math{V_k} for
open networks satisfy the following equation:

@iftex
@tex
$$
V_j = P_{0j} + \sum_{i=1}^K V_i P_{ij}
$$
@end tex
@end iftex
@ifnottex
@example
V_j = sum_i V_i P_ij
@end example
@end ifnottex

where @math{P_{0j}} is the probability of an external arrival to
center @math{j}. This can be computed as:

@tex
$$
P_{0j} = {\lambda_j  \over \sum_{i=1}^K \lambda_i }
$$
@end tex

Assuming the same service times as in the previous example, the
network can be analyzed with the @command{qnopen} function, as
follows:

@example
@group
@kbd{S = [1 2 0.8];}
@kbd{[U R Q X] = qnopen( sum(lambda), S, V )}
   @result{} U = 0.75000 0.45000 0.30000 
   @result{} R = 4.0000  3.6364  1.1429
   @result{} Q = 3.00000 0.81818 0.42857
   @result{} X = 0.75000 0.22500 0.37500 
@end group
@end example

The first parameter of the @command{qnopen} function is the (scalar)
aggregate arrival rate.

Again, it is possible to use the @command{qnsolve} high-level function:

@example
@group
@kbd{Q1 = qnmknode( "m/m/m-fcfs", 1 );}
@kbd{Q2 = qnmknode( "m/m/m-fcfs", 2 );}
@kbd{Q3 = qnmknode( "m/m/m-fcfs", 0.8 );}
@kbd{lambda = [0.15 0 0];}
@kbd{[U R Q X] = qnsolve( "open", sum(lambda), @{ Q1, Q2, Q3 @}, V )}
   @result{} U = 0.75000 0.45000 0.30000 
   @result{} R = 4.0000  3.6364  1.1429
   @result{} Q = 3.00000 0.81818 0.42857
   @result{} X = 0.75000 0.22500 0.37500 
@end group
@end example

@c @node Markov Chains Analysis
@c @section Markov Chains Analysis

@c @subsection Discrete-Time Markov Chains

@c (TODO)

@c @subsection Continuous-Time Markov Chains

@c (TODO)

