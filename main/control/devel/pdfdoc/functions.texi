@section Examples and Demos

 @deftypefn{Function File} {@var{sys} =} BMWengine ()
 @deftypefnx{Function File} {@var{sys} =} BMWengine (@var{"scaled"})
 @deftypefnx{Function File} {@var{sys} =} BMWengine (@var{"unscaled"})
 Model of the BMW 4-cylinder engine at ETH Zurich's control laboratory.
 @example
 @group
 OPERATING POINT
 Drosselklappenstellung     alpha_DK = 10.3 Grad
 Saugrohrdruck              p_s = 0.48 bar
 Motordrehzahl              n = 860 U/min
 Lambda-Messwert            lambda = 1.000
 Relativer Wandfilminhalt   nu = 1

 INPUTS
 U_1 Sollsignal Drosselklappenstellung   [Grad]
 U_2 Relative Einspritzmenge             [-]
 U_3 Zuendzeitpunkt                      [Grad KW]
 M_L Lastdrehmoment                      [Nm]

 STATES
 X_1 Drosselklappenstellung     [Grad]
 X_2 Saugrohrdruck              [bar]
 X_3 Motordrehzahl              [U/min]
 X_4 Messwert Lamba-Sonde       [-]
 X_5 Relativer Wandfilminhalt   [-]

 OUTPUTS
 Y_1 Motordrehzahl              [U/min]    
 Y_2 Messwert Lambda-Sonde      [-]

 SCALING
 U_1N, X_1N   1 Grad
 U_2N, X_4N, X_5N, Y_2N   0.05
 U_3N   1.6 Grad KW
 X_2N   0.05 bar
 X_3N, Y_1N   200 U/min
 @end group
 @end example
 @end deftypefn

 @deftypefn {Function File} {@var{sys} =} Boeing707 ()
 Creates a linearized state-space model of a Boeing 707-321 aircraft
 at @var{v}=80 m/s 
 @iftex
 @tex
 ($M = 0.26$, $G_{a0} = -3^{circ}$, ${lpha}_0 = 4^{circ}$, ${kappa}= 50^{circ}$).
 @end tex
 @end iftex
 @ifinfo
 (@var{M} = 0.26, @var{Ga0} = -3 deg, @var{alpha0} = 4 deg, @var{kappa} = 50 deg).
 @end ifinfo

 System inputs: (1) thrust and (2) elevator angle.

 System outputs:  (1) airspeed and (2) pitch angle.

 @strong{Reference}: R. Brockhaus: @cite{Flugregelung} (Flight
 Control), Springer, 1994.
 @end deftypefn
 ===============================================================================
 Robust Control of a Mass-Damper-Spring System     Lukas Reichlin    August 2011
 ===============================================================================
 Reference: Gu, D.W., Petkov, P.Hr. and Konstantinov, M.M.
            Robust Control Design with Matlab, Springer 2005
 ===============================================================================
 ===============================================================================
 optiPID                          Lukas Reichlin                       July 2009
 ===============================================================================
 Numerical Optimization of an A/H PID Controller
 Required OCTAVE Packages: control, optim (and its dependencies)
 Required MATLAB Toolboxes: Control, Optimization
 ===============================================================================

 @deftypefn{Function File} {@var{sys} =} WestlandLynx ()
 Model of the Westland Lynx Helicopter about hover.
 @example
 @group
 INPUTS
 main rotor collective
 longitudinal cyclic
 lateral cyclic
 tail rotor collective

 STATES
 pitch attitude           theta       [rad]
 roll attitude            phi         [rad]
 roll rate (body-axis)    p           [rad/s]
 pitch rate (body-axis)   q           [rad/s]
 yaw rate                 xi          [rad/s]
 forward velocity         v_x         [ft/s]
 lateral velocity         v_y         [ft/s]
 vertical velocity        v_z         [ft/s]

 OUTPUTS
 heave velocity           H_dot       [ft/s]
 pitch attitude           theta       [rad]
 roll attitude            phi         [rad]
 heading rate             psi_dot     [rad/s]
 roll rate                p           [rad/s]
 pitch rate               q           [rad/s]

 Reference:
 Skogestad, S. and Postlethwaite I.
 Multivariable Feedback Control: Analysis and Design
 Second Edition
 Wiley 2005
 http://www.nt.ntnu.no/users/skoge/book/2nd_edition/matlab_m/matfiles.html
 @end group
 @end example
 @end deftypefn
@section Linear Time Invariant Models

 @deftypefn {Function File} {@var{sys} =} dss (@var{sys})
 @deftypefnx {Function File} {@var{sys} =} dss (@var{d})
 @deftypefnx {Function File} {@var{sys} =} dss (@var{a}, @var{b}, @var{c}, @var{d}, @var{e}, @dots{})
 @deftypefnx {Function File} {@var{sys} =} dss (@var{a}, @var{b}, @var{c}, @var{d}, @var{e}, @var{tsam}, @dots{})
 Create or convert to descriptor state-space model.

 @strong{Inputs}
 @table @var
 @item a
 State transition matrix (n-by-n).
 @item b
 Input matrix (n-by-m).
 @item c
 Measurement matrix (p-by-n).
 @item d
 Feedthrough matrix (p-by-m).
 @item e
 Descriptor matrix (n-by-n).
 @item tsam
 Sampling time in seconds.  If @var{tsam} is not specified, 
 a continuous-time model is assumed.
 @item @dots{}
 Optional pairs of properties and values.
 Type @command{set (dss)} for more information.
 @end table

 @strong{Outputs}
 @table @var
 @item sys
 Descriptor state-space model.
 @end table

 @strong{Equations}
 @example
 @group
   .
 E x = A x + B u
   y = C x + D u
 @end group
 @end example

 @seealso{ss, tf}
 @end deftypefn

 @deftypefn {Function File} {@var{sys} =} frd (@var{sys})
 @deftypefnx {Function File} {@var{sys} =} frd (@var{sys}, @var{w})
 @deftypefnx {Function File} {@var{sys} =} frd (@var{H}, @var{w}, @dots{})
 @deftypefnx {Function File} {@var{sys} =} frd (@var{H}, @var{w}, @var{tsam}, @dots{})
 Create or convert to frequency response data.

 @strong{Inputs}
 @table @var
 @item sys
 LTI model.  If second argument @var{w} is omitted, the interesting
 frequency range is calculated by the zeros and poles of @var{sys}.
 @item H
 Frequency response array (p-by-m-by-lw).  In the SISO case,
 a vector (lw-by-1) or (1-by-lw) is accepted as well.
 @item w
 Frequency vector (lw-by-1) in radian per second [rad/s].
 @item tsam
 Sampling time in seconds.  If @var{tsam} is not specified,
 a continuous-time model is assumed.
 @item @dots{}
 Optional pairs of properties and values.
 Type @command{set (frd)} for more information.
 @end table

 @strong{Outputs}
 @table @var
 @item sys
 Frequency response data object.
 @end table

 @seealso{dss, ss, tf}
 @end deftypefn

 @deftypefn {Function File} {@var{sys} =} ss (@var{sys})
 @deftypefnx {Function File} {@var{sys} =} ss (@var{d})
 @deftypefnx {Function File} {@var{sys} =} ss (@var{a}, @var{b})
 @deftypefnx {Function File} {@var{sys} =} ss (@var{a}, @var{b}, @var{c})
 @deftypefnx {Function File} {@var{sys} =} ss (@var{a}, @var{b}, @var{c}, @var{d}, @dots{})
 @deftypefnx {Function File} {@var{sys} =} ss (@var{a}, @var{b}, @var{c}, @var{d}, @var{tsam}, @dots{})
 Create or convert to state-space model.

 @strong{Inputs}
 @table @var
 @item a
 State transition matrix (n-by-n).
 @item b
 Input matrix (n-by-m).
 @item c
 Measurement matrix (p-by-n).
 If @var{c} is empty @code{[]} or not specified, an identity matrix is assumed.
 @item d
 Feedthrough matrix (p-by-m).
 If @var{d} is empty @code{[]} or not specified, a zero matrix is assumed.
 @item tsam
 Sampling time in seconds.  If @var{tsam} is not specified, a continuous-time model is assumed.
 @item @dots{}
 Optional pairs of properties and values.
 Type @command{set (ss)} for more information.
 @end table

 @strong{Outputs}
 @table @var
 @item sys
 State-space model.
 @end table

 @strong{Example}
 @example
 @group
 octave:1> a = [1 2 3; 4 5 6; 7 8 9];
 octave:2> b = [10; 11; 12];
 octave:3> stname = @{"V", "A", "kJ"@};
 octave:4> sys = ss (a, b, [], [], "stname", stname)
 
 sys.a =
         V   A  kJ
    V    1   2   3
    A    4   5   6
    kJ   7   8   9
 
 sys.b =
        u1
    V   10
    A   11
    kJ  12
 
 sys.c =
         V   A  kJ
    y1   1   0   0
    y2   0   1   0
    y3   0   0   1
 
 sys.d =
        u1
    y1   0
    y2   0
    y3   0
 
 Continuous-time model.
 octave:5> 
 @end group
 @end example

 @seealso{tf, dss}
 @end deftypefn

 @deftypefn {Function File} {@var{s} =} tf (@var{"s"})
 @deftypefnx {Function File} {@var{z} =} tf (@var{"z"}, @var{tsam})
 @deftypefnx {Function File} {@var{sys} =} tf (@var{sys})
 @deftypefnx {Function File} {@var{sys} =} tf (@var{num}, @var{den}, @dots{})
 @deftypefnx {Function File} {@var{sys} =} tf (@var{num}, @var{den}, @var{tsam}, @dots{})
 Create or convert to transfer function model.

 @strong{Inputs}
 @table @var
 @item num
 Numerator or cell of numerators.  Each numerator must be a row vector
 containing the exponents of the polynomial in descending order.
 @item den
 Denominator or cell of denominators.  Each denominator must be a row vector
 containing the exponents of the polynomial in descending order.
 @item tsam
 Sampling time in seconds.  If @var{tsam} is not specified, a continuous-time
 model is assumed.
 @item @dots{}
 Optional pairs of properties and values.
 Type @command{set (tf)} for more information.
 @end table

 @strong{Outputs}
 @table @var
 @item sys
 Transfer function model.
 @end table

 @strong{Example}
 @example
 @group
 octave:1> s = tf ("s");
 octave:2> G = 1/(s+1)

 Transfer function "G" from input "u1" to output ...
         1  
  y1:  -----
       s + 1

 octave:3> z = tf ("z", 0.2);
 octave:4> H = 0.095/(z-0.9)
 
 Transfer function "H" from input "u1" to output ...
        0.095 
  y1:  -------
       z - 0.9
 
 Sampling time: 0.2 s
 octave:5> 
 @end group
 @end example

 @seealso{ss, dss}
 @end deftypefn
@section Model Data Access

 @deftypefn {Function File} {[@var{a}, @var{b}, @var{c}, @var{d}, @var{e}, @var{tsam}] =} dssdata (@var{sys})
 @deftypefnx {Function File} {[@var{a}, @var{b}, @var{c}, @var{d}, @var{e}, @var{tsam}] =} dssdata (@var{sys}, @var{[]})
 Access descriptor state-space model data.
 Argument @var{sys} is not limited to descriptor state-space models.
 If @var{sys} is not a descriptor state-space model, it is converted automatically.

 @strong{Inputs}
 @table @var
 @item sys
 Any type of LTI model.
 @item []
 In case @var{sys} is not a dss model (descriptor matrix @var{e} empty),
 @code{dssdata (sys, [])} returns the empty element @code{e = []} whereas
 @code{dssdata (sys)} returns the identity matrix @code{e = eye (size (a))}.
 @end table

 @strong{Outputs}
 @table @var
 @item a
 State transition matrix (n-by-n).
 @item b
 Input matrix (n-by-m).
 @item c
 Measurement matrix (p-by-n).
 @item d
 Feedthrough matrix (p-by-m).
 @item e
 Descriptor matrix (n-by-n).
 @item tsam
 Sampling time in seconds.  If @var{sys} is a continuous-time model,
 a zero is returned.
 @end table
 @end deftypefn

 @deftypefn {Function File} {[@var{H}, @var{w}, @var{tsam}] =} frdata (@var{sys})
 @deftypefnx {Function File} {[@var{H}, @var{w}, @var{tsam}] =} frdata (@var{sys}, @var{"vector"})
 Access frequency response data.
 Argument @var{sys} is not limited to frequency response data objects.
 If @var{sys} is not a frd object, it is converted automatically.

 @strong{Inputs}
 @table @var
 @item sys
 Any type of LTI model.
 @item "v", "vector"
 In case @var{sys} is a SISO model, this option returns the frequency response
 as a column vector (lw-by-1) instead of an array (p-by-m-by-lw).
 @end table

 @strong{Outputs}
 @table @var
 @item H
 Frequency response array (p-by-m-by-lw).  In the SISO case,
 a vector (lw-by-1) is possible as well.
 @item w
 Frequency vector (lw-by-1) in radian per second [rad/s].
 @item tsam
 Sampling time in seconds.  If @var{sys} is a continuous-time model,
 a zero is returned.
 @end table
 @end deftypefn

 @deftypefn {Function File} get (@var{sys})
 @deftypefnx {Function File} {@var{value} =} get (@var{sys}, @var{"property"})
 Access property values of LTI objects.
 @end deftypefn

 @deftypefn {Function File} set (@var{sys})
 @deftypefnx {Function File} {@var{sys} =} set (@var{sys}, @var{"property"}, @var{value})
 Set or modify properties of LTI objects.
 @end deftypefn

 @deftypefn {Function File} {[@var{a}, @var{b}, @var{c}, @var{d}, @var{tsam}] =} ssdata (@var{sys})
 Access state-space model data.
 Argument @var{sys} is not limited to state-space models.
 If @var{sys} is not a state-space model, it is converted automatically.

 @strong{Inputs}
 @table @var
 @item sys
 Any type of LTI model.
 @end table

 @strong{Outputs}
 @table @var
 @item a
 State transition matrix (n-by-n).
 @item b
 Input matrix (n-by-m).
 @item c
 Measurement matrix (p-by-n).
 @item d
 Feedthrough matrix (p-by-m).
 @item tsam
 Sampling time in seconds.  If @var{sys} is a continuous-time model,
 a zero is returned.
 @end table
 @end deftypefn

 @deftypefn {Function File} {[@var{num}, @var{den}, @var{tsam}] =} tfdata (@var{sys})
 @deftypefnx {Function File} {[@var{num}, @var{den}, @var{tsam}] =} tfdata (@var{sys}, @var{"tfpoly"})
 Access transfer function data.
 @end deftypefn
@section Model Conversions

 @deftypefn {Function File} {@var{sys} =} c2d (@var{sys}, @var{tsam})
 @deftypefnx {Function File} {@var{sys} =} c2d (@var{sys}, @var{tsam}, @var{method})
 Convert the continuous lti model into its discrete time equivalent.
 @end deftypefn

 @deftypefn {Function File} {[@var{scaledsys}, @var{info}] =} prescale (@var{sys})
 Prescale state-space model.
 Uses SLICOT TB01ID and TG01AD by courtesy of
 @uref{http://www.slicot.org, NICONET e.V.}.
 Frequency response commands perform automatic scaling unless model property
 @var{scaled} is set to @var{true}.

 @strong{Inputs}
 @table @var
 @item sys
 LTI model.
 @end table

 @strong{Outputs}
 @table @var
 @item scaledsys
 Scaled state-space model.
 @item info
 Structure containing additional information.
 @item info.SL
 Left scaling factors.  @code{Tl = diag (info.SL)}.
 @item info.SR
 Right scaling factors.  @code{Tr = diag (info.SR)}.
 @end table

 @strong{Equations}
 @example
 @group
 Es = Tl E Tr
 As = Tl A Tr
 Bs = Tl B
 Cs =    C Tr
 Ds =    D

 For proper state-space models, Tl and Tr are inverse of each other.
 @end group
 @end example
 @end deftypefn

 @deftypefn {Function File} {@var{sys} =} xperm (@var{sys}, @var{st_idx})
 Reorder states in state-space models.
 @end deftypefn
@section Model Interconnections

 @deftypefn {Function File} {@var{sys} =} append (@var{sys1}, @var{sys2})
 Group LTI models by appending their inputs and outputs.
 @end deftypefn

 @deftypefn {Function File} {@var{sys} =} blkdiag (@var{sys1}, @var{sys2})
 Block-diagonal concatenation of LTI models.
 @end deftypefn

 @deftypefn {Function File} {@var{sys} =} connect (@var{sys}, @var{cm}, @var{inputs}, @var{outputs})
 Arbitrary interconnections between the inputs and outputs of an LTI model.
 @end deftypefn

 @deftypefn {Function File} {@var{sys} =} feedback (@var{sys1})
 @deftypefnx {Function File} {@var{sys} =} feedback (@var{sys1}, @var{"+"})
 @deftypefnx {Function File} {@var{sys} =} feedback (@var{sys1}, @var{sys2})
 @deftypefnx {Function File} {@var{sys} =} feedback (@var{sys1}, @var{sys2}, @var{"+"})
 @deftypefnx {Function File} {@var{sys} =} feedback (@var{sys1}, @var{sys2}, @var{feedin}, @var{feedout})
 @deftypefnx {Function File} {@var{sys} =} feedback (@var{sys1}, @var{sys2}, @var{feedin}, @var{feedout}, @var{"+"})
 Feedback connection of two LTI models.

 @strong{Block Diagram}
 @example
 @group
  u    +         +--------+             y
 ------>(+)----->|  sys1  |-------+------->
         ^ -     +--------+       |
         |                        |
         |       +--------+       |
         +-------|  sys2  |<------+
                 +--------+
 @end group
 @end example
 @end deftypefn

 @deftypefn {Function File} {@var{sys} =} lft (@var{sys1}, @var{sys2})
 @deftypefnx {Function File} {@var{sys} =} lft (@var{sys1}, @var{sys2}, @var{nu}, @var{ny})
 Linear fractional tranformation, also known as Redheffer star product.

 @strong{Inputs}
 @table @var
 @item sys1
 Upper LTI model.
 @item sys2
 Lower LTI model.
 @item nu
 The last nu inputs of @var{sys1} are connected with the first nu outputs of @var{sys2}.
 If not specified, @code{min (m1, p2)} is taken.
 @item ny
 The last ny outputs of @var{sys1} are connected with the first ny inputs of @var{sys2}.
 If not specified, @code{min (p1, m2)} is taken.
 @end table

 @strong{Outputs}
 @table @var
 @item sys
 Resulting LTI model.
 @end table

 @strong{Block Diagram}
 @example
 @group
       .............sys..............
       :         +--------+         :
 w1 ------------>|        |------------> z1
       :         |  sys1  |         :
       : u +---->|        |-----+ y :
       :   |     +--------+     |   :          Lower LFT
       :   |                    |   :
       :   |     +--------+     |   :          lft (sys1, sys2)
       :   +-----|  sys2  |<----+   :
       :         +--------+         :
       :............................:


       .............sys..............
       :         +--------+         :
       : u +---->|  sys1  |-----+ y :
       :   |     +--------+     |   :          Upper LFT
       :   |                    |   :
       :   |     +--------+     |   :          lft (sys1, sys2)
       :   +-----|        |<----+   :
       :         |  sys2  |         :
 z2 <------------|        |<------------ w2
       :         +--------+         :
       :............................:


       .............sys..............
       :         +--------+         :
 w1 ------------>|        |------------> z1
       :         |  sys1  |         :
       : u +---->|        |-----+ y :
       :   |     +--------+     |   :
       :   |                    |   :          lft (sys1, sys2, nu, ny)
       :   |     +--------+     |   :
       :   +-----|        |<----+   :
       :         |  sys2  |         :
 z2 <------------|        |<------------ w2
       :         +--------+         :
       :............................: 
 @end group
 @end example
 @end deftypefn

 @deftypefn {Function File} {@var{sys} =} mconnect (@var{sys}, @var{m})
 @deftypefnx {Function File} {@var{sys} =} mconnect (@var{sys}, @var{m}, @var{inputs}, @var{outputs})
 Arbitrary interconnections between the inputs and outputs of an LTI model.

 @strong{Inputs}
 @table @var
 @item sys
 LTI system.
 @item m
 Connection matrix.  Each row belongs to an input and each column represents an output.
 @item inputs
 Vector of indices of those inputs which are retained.  If not specified, all inputs are kept.
 @item outputs
 Vector of indices of those outputs which are retained.  If not specified, all outputs are kept.
 @end table

 @strong{Outputs}
 @table @var
 @item sys
 Interconnected system.
 @end table

 @strong{Example}
 @example
 @group
 Solve the system equations of
 y(t) = G e(t)
 e(t) = u(t) + M y(t)
 in order to build
 y(t) = H u(t)
 The matrix M for a (p-by-m) system G
 has m rows and p columns (m-by-p).

 Example for a 3x2 system:
 u1 = -1*y1 + 5*y2 + 0*y3
 u2 = pi*y1 + 0*y2 - 7*y3

     | -1      5      0 |
 M = | pi      0      7 |
 @end group
 @end example
 @end deftypefn

 @deftypefn{Function File} {@var{sys} =} parallel (@var{sys1}, @var{sys2})
 Parallel connection of two LTI systems.

 @strong{Block Diagram}
 @example
 @group
     ..........................
     :      +--------+        :
     :  +-->|  sys1  |---+    :
  u  :  |   +--------+   | +  :  y
 -------+                O--------->
     :  |   +--------+   | +  :
     :  +-->|  sys2  |---+    :
     :      +--------+        :
     :.........sys............:

 sys = parallel (sys1, sys2)
 @end group
 @end example
 @end deftypefn

 @deftypefn {Function File} {@var{sys} =} series (@var{sys1}, @var{sys2})
 @deftypefnx {Function File} {@var{sys} =} series (@var{sys1}, @var{sys2}, @var{outputs1}, @var{inputs2})
 Series connection of two LTI models.

 @strong{Block Diagram}
 @example
 @group
     .....................................
  u  :  +--------+ y1    u2  +--------+  :  y
 ------>|  sys1  |---------->|  sys2  |------->
     :  +--------+           +--------+  :
     :................sys.................

 sys = series (sys1, sys2)


     .....................................
     :                   v2  +--------+  :
     :            ---------->|        |  :  y
     :  +--------+ y1    u2  |  sys2  |------->
  u  :  |        |---------->|        |  :
 ------>|  sys1  |       z1  +--------+  :
     :  |        |---------->            :
     :  +--------+                       :
     :................sys.................

 outputs1 = [1]
 inputs2 = [2]
 sys = series (sys1, sys2, outputs1, inputs2)
 @end group
 @end example
 @end deftypefn
@section Model Characteristics

 @deftypefn {Function File} {@var{co} =} ctrb (@var{sys})
 @deftypefnx {Function File} {@var{co} =} ctrb (@var{a}, @var{b})
 Controllability matrix.
 @end deftypefn

 @deftypefn {Function File} {@var{k} =} dcgain (@var{sys})
 DC gain of LTI model.

 @strong{Inputs}
 @table @var
 @item sys
 LTI system.
 @end table

 @strong{Outputs}
 @table @var
 @item k
 DC gain matrice.  For a system with m inputs and p outputs, the array @var{k}
 has dimensions [p, m].
 @end table

 @seealso{freqresp}
 @end deftypefn

 @deftypefn {Function File} {@var{W} =} gram (@var{sys}, @var{mode})
 @deftypefnx {Function File} {@var{Wc} =} gram (@var{a}, @var{b})
 @code{gram (@var{sys}, "c")} returns the controllability gramian of
 the (continuous- or discrete-time) system @var{sys}.
 @code{gram (@var{sys}, "o")} returns the observability gramian of the
 (continuous- or discrete-time) system @var{sys}.
 @code{gram (@var{a}, @var{b})} returns the controllability gramian
 @var{Wc} of the continuous-time system @math{dx/dt = a x + b u};
 i.e., @var{Wc} satisfies @math{a Wc + m Wc' + b b' = 0}.

 @end deftypefn

 @deftypefn{Function File} {@var{hsv} =} hsvd (@var{sys})
 @deftypefnx{Function File} {@var{hsv} =} hsvd (@var{sys}, @var{"offset"}, @var{alpha})
 Hankel singular values of the stable part of an LTI model.  If no output arguments are
 given, the Hankel singular values are displayed in a plot.
 Uses SLICOT AB13AD by courtesy of
 @uref{http://www.slicot.org, NICONET e.V.}
 @end deftypefn

 @deftypefn {Function File} {@var{bool} =} isct (@var{sys})
 Determine whether LTI model is a continuous-time system.
 @end deftypefn

 @deftypefn {Function File} {@var{bool} =} isctrb (@var{sys})
 @deftypefnx {Function File} {@var{bool} =} isctrb (@var{sys}, @var{tol})
 @deftypefnx {Function File} {@var{bool} =} isctrb (@var{a}, @var{b})
 @deftypefnx {Function File} {@var{bool} =} isctrb (@var{a}, @var{b}, @var{e})
 @deftypefnx {Function File} {@var{bool} =} isctrb (@var{a}, @var{b}, @var{[]}, @var{tol})
 @deftypefnx {Function File} {@var{bool} =} isctrb (@var{a}, @var{b}, @var{e}, @var{tol})
 Logical check for system controllability.
 Uses SLICOT AB01OD and TG01HD by courtesy of
 @uref{http://www.slicot.org, NICONET e.V.}

 @strong{Inputs}
 @table @var
 @item sys
 LTI model.
 @item a
 State transition matrix.
 @item b
 Input matrix.
 @item e
 Descriptor matrix.
 @item tol
 Optional roundoff parameter.  Default value is 0.
 @end table

 @strong{Outputs}
 @table @var
 @item bool = 0
 System is not controllable.
 @item bool = 1
 System is controllable.
 @end table

 @seealso{isobsv}
 @end deftypefn

 @deftypefn {Function File} {@var{bool} =} isdetectable (@var{sys})
 @deftypefnx {Function File} {@var{bool} =} isdetectable (@var{sys}, @var{tol})
 @deftypefnx {Function File} {@var{bool} =} isdetectable (@var{a}, @var{c})
 @deftypefnx {Function File} {@var{bool} =} isdetectable (@var{a}, @var{c}, @var{e})
 @deftypefnx {Function File} {@var{bool} =} isdetectable (@var{a}, @var{c}, @var{[]}, @var{tol})
 @deftypefnx {Function File} {@var{bool} =} isdetectable (@var{a}, @var{c}, @var{e}, @var{tol})
 @deftypefnx {Function File} {@var{bool} =} isdetectable (@var{a}, @var{c}, @var{[]}, @var{[]}, @var{dflg})
 @deftypefnx {Function File} {@var{bool} =} isdetectable (@var{a}, @var{c}, @var{e}, @var{[]}, @var{dflg})
 @deftypefnx {Function File} {@var{bool} =} isdetectable (@var{a}, @var{c}, @var{[]}, @var{tol}, @var{dflg})
 @deftypefnx {Function File} {@var{bool} =} isdetectable (@var{a}, @var{c}, @var{e}, @var{tol}, @var{dflg})
 Logical test for system detectability.
 All unstable modes must be observable or all unobservable states must be stable.
 Uses SLICOT AB01OD and TG01HD by courtesy of
 @uref{http://www.slicot.org, NICONET e.V.}

 @strong{Inputs}
 @table @var
 @item sys
 LTI system.
 @item a
 State transition matrix.
 @item c
 Measurement matrix.
 @item e
 Descriptor matrix.
 @item tol
 Optional tolerance for stability.  Default value is 0.
 @item dflg = 0
 Matrices (@var{a}, @var{c}) are part of a continuous-time system.  Default Value.
 @item dflg = 1
 Matrices (@var{a}, @var{c}) are part of a discrete-time system.
 @end table

 @strong{Outputs}
 @table @var
 @item bool = 0
 System is not detectable.
 @item bool = 1
 System is detectable.
 @end table

 See @command{isstabilizable} for description of computational method.
 @seealso{isstabilizable, isstable, isctrb, isobsv}
 @end deftypefn

 @deftypefn {Function File} {@var{bool} =} isdt (@var{sys})
 Determine whether LTI model is a discrete-time system.
 @end deftypefn

 @deftypefn {Function File} {@var{bool} =} isminimumphase (@var{sys})
 @deftypefnx {Function File} {@var{bool} =} isminimumphase (@var{sys}, @var{tol})
 Determine whether LTI system is minimum phase.
 If a square system @var{P} is minimum-phase, its inverse @var{P^-1} is stable.
 @end deftypefn

 @deftypefn {Function File} {@var{bool} =} isobsv (@var{sys})
 @deftypefnx {Function File} {@var{bool} =} isobsv (@var{sys}, @var{tol})
 @deftypefnx {Function File} {@var{bool} =} isobsv (@var{a}, @var{c})
 @deftypefnx {Function File} {@var{bool} =} isobsv (@var{a}, @var{c}, @var{e})
 @deftypefnx {Function File} {@var{bool} =} isobsv (@var{a}, @var{c}, @var{[]}, @var{tol})
 @deftypefnx {Function File} {@var{bool} =} isobsv (@var{a}, @var{c}, @var{e}, @var{tol})
 Logical check for system observability.
 Uses SLICOT AB01OD and TG01HD by courtesy of
 @uref{http://www.slicot.org, NICONET e.V.}

 @strong{Inputs}
 @table @var
 @item sys
 LTI model.
 @item a
 State transition matrix.
 @item c
 Measurement matrix.
 @item e
 Descriptor matrix.
 @item tol
 Optional roundoff parameter.  Default value is 0.
 @end table

 @strong{Outputs}
 @table @var
 @item bool = 0
 System is not observable.
 @item bool = 1
 System is observable.
 @end table

 @seealso{isctrb}
 @end deftypefn

 @deftypefn {Function File} {@var{bool} =} issiso (@var{sys})
 Determine whether LTI model is single-input/single-output (SISO).
 @end deftypefn

 @deftypefn {Function File} {@var{bool} =} isstabilizable (@var{sys})
 @deftypefnx {Function File} {@var{bool} =} isstabilizable (@var{sys}, @var{tol})
 @deftypefnx {Function File} {@var{bool} =} isstabilizable (@var{a}, @var{b})
 @deftypefnx {Function File} {@var{bool} =} isstabilizable (@var{a}, @var{b}, @var{e})
 @deftypefnx {Function File} {@var{bool} =} isstabilizable (@var{a}, @var{b}, @var{[]}, @var{tol})
 @deftypefnx {Function File} {@var{bool} =} isstabilizable (@var{a}, @var{b}, @var{e}, @var{tol})
 @deftypefnx {Function File} {@var{bool} =} isstabilizable (@var{a}, @var{b}, @var{[]}, @var{[]}, @var{dflg})
 @deftypefnx {Function File} {@var{bool} =} isstabilizable (@var{a}, @var{b}, @var{e}, @var{[]}, @var{dflg})
 @deftypefnx {Function File} {@var{bool} =} isstabilizable (@var{a}, @var{b}, @var{[]}, @var{tol}, @var{dflg})
 @deftypefnx {Function File} {@var{bool} =} isstabilizable (@var{a}, @var{b}, @var{e}, @var{tol}, @var{dflg})
 Logical check for system stabilizability.
 All unstable modes must be controllable or all uncontrollable states must be stable.
 Uses SLICOT AB01OD and TG01HD by courtesy of
 @uref{http://www.slicot.org, NICONET e.V.}

 @strong{Inputs}
 @table @var
 @item sys
 LTI system.
 @item a
 State transition matrix.
 @item b
 Input matrix.
 @item e
 Descriptor matrix.
 @item tol
 Optional tolerance for stability.  Default value is 0.
 @item dflg = 0
 Matrices (@var{a}, @var{b}) are part of a continuous-time system.  Default Value.
 @item dflg = 1
 Matrices (@var{a}, @var{b}) are part of a discrete-time system.
 @end table

 @strong{Outputs}
 @table @var
 @item bool = 0
 System is not stabilizable.
 @item bool = 1
 System is stabilizable.
 @end table

 @strong{Method}
 @example
 @group
 * Calculate staircase form (SLICOT AB01OD)
 * Extract unobservable part of state transition matrix
 * Calculate eigenvalues of unobservable part
 * Check whether
   real (ev) < -tol*(1 + abs (ev))   continuous-time
   abs (ev) < 1 - tol                discrete-time
 @end group
 @end example
 @seealso{isdetectable, isstable, isctrb, isobsv}
 @end deftypefn

 @deftypefn {Function File} {@var{bool} =} isstable (@var{sys})
 @deftypefnx {Function File} {@var{bool} =} isstable (@var{sys}, @var{tol})
 Determine whether LTI system is stable.
 @end deftypefn

 @deftypefn {Function File} {@var{gain} =} norm (@var{sys}, @var{2})
 @deftypefnx {Function File} {[@var{gain}, @var{wpeak}] =} norm (@var{sys}, @var{inf})
 @deftypefnx {Function File} {[@var{gain}, @var{wpeak}] =} norm (@var{sys}, @var{inf}, @var{tol})
 Return H-2 or L-inf norm of LTI model.
 Uses SLICOT AB13BD and AB13DD by courtesy of
 @uref{http://www.slicot.org, NICONET e.V.}
 @end deftypefn

 @deftypefn {Function File} {@var{ob} =} obsv (@var{sys})
 @deftypefnx {Function File} {@var{ob} =} obsv (@var{a}, @var{c})
 Observability matrix.
 @end deftypefn

 @deftypefn {Function File} {@var{p} =} pole (@var{sys})
 Compute poles of LTI system.
 @end deftypefn

 @deftypefn {Function File} pzmap (@var{sys})
 @deftypefnx {Function File} {[@var{p}, @var{z}] =} pzmap (@var{sys})
 Plot the poles and zeros of an LTI system in the complex plane.
 @end deftypefn

 @deftypefn {Function File} {@var{nvec} =} size (@var{ltisys})
 @deftypefnx {Function File} {@var{n} =} size (@var{ltisys}, @var{idx})
 @deftypefnx {Function File} {[@var{ny}, @var{nu}] =} size (@var{ltisys})
 LTI model size, i.e. number of outputs and inputs.
 @end deftypefn

 @deftypefn {Function File} {@var{z} =} zero (@var{sys})
 @deftypefnx {Function File} {[@var{z}, @var{k}] =} zero (@var{sys})
 Compute transmission zeros and gain of LTI model.
 @end deftypefn
@section Model Simplification

 @deftypefn {Function File} {@var{sys} =} minreal (@var{sys})
 @deftypefnx {Function File} {@var{sys} =} minreal (@var{sys}, @var{tol})
 Minimal realization or zero-pole cancellation of LTI models.
 @end deftypefn

 @deftypefn {Function File} {@var{sys} =} sminreal (@var{sys})
 @deftypefnx {Function File} {@var{sys} =} sminreal (@var{sys}, @var{tol})
 Perform state-space model reduction based on structure.
 Remove states which have no influence on the input-output behaviour.
 The physical meaning of the states is retained.

 @strong{Inputs}
 @table @var
 @item sys
 State-space model.
 @item tol
 Optional tolerance for controllability and observability. 
 Entries of the state-space matrices whose moduli are less or equal to @var{tol}
 are assumed to be zero.  Default value is 0.
 @end table

 @strong{Outputs}
 @table @var
 @item sys
 Reduced state-space model.
 @end table

 @seealso{minreal}
 @end deftypefn
@section Time Domain Analysis

 @deftypefn{Function File} {[@var{p}, @var{q}] =} covar (@var{sys}, @var{w})
 Return the steady-state covariance.

 @strong{Inputs}
 @table @var
 @item sys
 LTI model.
 @item w
 Intensity of white noise inputs which drive @var{sys}.
 @end table

 @strong{Outputs}
 @table @var
 @item p
 Output covariance.
 @item q
 State covariance.
 @end table

 @seealso{lyap, dlyap}
 @end deftypefn

 @deftypefn{Function File} {[@var{u}, @var{t}] =} gensig (@var{sigtype}, @var{tau})
 @deftypefnx{Function File} {[@var{u}, @var{t}] =} gensig (@var{sigtype}, @var{tau}, @var{tfinal})
 @deftypefnx{Function File} {[@var{u}, @var{t}] =} gensig (@var{sigtype}, @var{tau}, @var{tfinal}, @var{tsam})
 Generate periodic signal.  Useful in combination with lsim.

 @strong{Inputs}
 @table @var
 @item sigtype = "sin"
 Sine wave.
 @item sigtype = "cos"
 Cosine wave.
 @item sigtype = "square"
 Square wave.
 @item sigtype = "pulse"
 Periodic pulse.
 @item tau
 Duration of one period in seconds.
 @item tfinal
 Optional duration of the signal in seconds.  Default duration is 5 periods.
 @item tsam
 Optional sampling time in seconds.  Default spacing is tau/64.
 @end table

 @strong{Outputs}
 @table @var
 @item u
 Vector of signal values.
 @item t
 Time vector of the signal.
 @end table

 @seealso{lsim}
 @end deftypefn

 @deftypefn{Function File} {[@var{y}, @var{t}, @var{x}] =} impulse (@var{sys})
 @deftypefnx{Function File} {[@var{y}, @var{t}, @var{x}] =} impulse (@var{sys}, @var{t})
 @deftypefnx{Function File} {[@var{y}, @var{t}, @var{x}] =} impulse (@var{sys}, @var{tfinal})
 @deftypefnx{Function File} {[@var{y}, @var{t}, @var{x}] =} impulse (@var{sys}, @var{tfinal}, @var{dt})
 Impulse response of LTI system.
 If no output arguments are given, the response is printed on the screen.

 @strong{Inputs}
 @table @var
 @item sys
 LTI model.
 @item t
 Time vector.  Should be evenly spaced.  If not specified, it is calculated by
 the poles of the system to reflect adequately the response transients.
 @item tfinal
 Optional simulation horizon.  If not specified, it is calculated by
 the poles of the system to reflect adequately the response transients.
 @item dt
 Optional sampling time.  Be sure to choose it small enough to capture transient
 phenomena.  If not specified, it is calculated by the poles of the system.
 @end table

 @strong{Outputs}
 @table @var
 @item y
 Output response array.  Has as many rows as time samples (length of t)
 and as many columns as outputs.
 @item t
 Time row vector.
 @item x
 State trajectories array.  Has @code{length (t)} rows and as many columns as states.
 @end table

 @seealso{initial, lsim, step}
 @end deftypefn

 @deftypefn{Function File} {[@var{y}, @var{t}, @var{x}] =} initial (@var{sys}, @var{x0})
 @deftypefnx{Function File} {[@var{y}, @var{t}, @var{x}] =} initial (@var{sys}, @var{x0}, @var{t})
 @deftypefnx{Function File} {[@var{y}, @var{t}, @var{x}] =} initial (@var{sys}, @var{x0}, @var{tfinal})
 @deftypefnx{Function File} {[@var{y}, @var{t}, @var{x}] =} initial (@var{sys}, @var{x0}, @var{tfinal}, @var{dt})
 Initial condition response of state-space model.
 If no output arguments are given, the response is printed on the screen.

 @strong{Inputs}
 @table @var
 @item sys
 State-space model.
 @item x0
 Vector of initial conditions for each state.
 @item t
 Optional time vector.  Should be evenly spaced.  If not specified, it is calculated
 by the poles of the system to reflect adequately the response transients.
 @item tfinal
 Optional simulation horizon.  If not specified, it is calculated by
 the poles of the system to reflect adequately the response transients.
 @item dt
 Optional sampling time.  Be sure to choose it small enough to capture transient
 phenomena.  If not specified, it is calculated by the poles of the system.
 @end table

 @strong{Outputs}
 @table @var
 @item y
 Output response array.  Has as many rows as time samples (length of t)
 and as many columns as outputs.
 @item t
 Time row vector.
 @item x
 State trajectories array.  Has @code{length (t)} rows and as many columns as states.
 @end table

 @strong{Example}
 @example
 @group
                    .
 Continuous Time:   x = A x ,   y = C x ,   x(0) = x0

 Discrete Time:   x[k+1] = A x[k] ,   y[k] = C x[k] ,   x[0] = x0
 @end group
 @end example

 @seealso{impulse, lsim, step}
 @end deftypefn

 @deftypefn{Function File} {[@var{y}, @var{t}, @var{x}] =} lsim (@var{sys}, @var{u})
 @deftypefnx{Function File} {[@var{y}, @var{t}, @var{x}] =} lsim (@var{sys}, @var{u}, @var{t})
 @deftypefnx{Function File} {[@var{y}, @var{t}, @var{x}] =} lsim (@var{sys}, @var{u}, @var{t}, @var{x0})
 @deftypefnx{Function File} {[@var{y}, @var{t}, @var{x}] =} lsim (@var{sys}, @var{u}, @var{t}, @var{[]}, @var{method})
 @deftypefnx{Function File} {[@var{y}, @var{t}, @var{x}] =} lsim (@var{sys}, @var{u}, @var{t}, @var{x0}, @var{method})
 Simulate LTI model response to arbitrary inputs.  If no output arguments are given,
 the system response is plotted on the screen.

 @strong{Inputs}
 @table @var
 @item sys
 LTI model.  System must be proper, i.e. it must not have more zeros than poles.
 @item u
 Vector or array of input signal.  Needs @code{length(t)} rows and as many columns
 as there are inputs.  If @var{sys} is a single-input system, row vectors @var{u}
 of length @code{length(t)} are accepted as well.
 @item t
 Time vector.  Should be evenly spaced.  If @var{sys} is a continuous-time system
 and @var{t} is a real scalar, @var{sys} is discretized with sampling time
 @code{tsam = t/(rows(u)-1)}.  If @var{sys} is a discrete-time system and @var{t}
 is not specified, vector @var{t} is assumed to be @code{0 : tsam : tsam*(rows(u)-1)}.
 @item x0
 Vector of initial conditions for each state.  If not specified, a zero vector is assumed.
 @item method
 Discretization method for continuous-time models.  Default value is zoh
 (zero-order hold).  All methods from @code{c2d} are supported. 
 @end table

 @strong{Outputs}
 @table @var
 @item y
 Output response array.  Has as many rows as time samples (length of t)
 and as many columns as outputs.
 @item t
 Time row vector.  It is always evenly spaced.
 @item x
 State trajectories array.  Has @code{length (t)} rows and as many columns as states.
 @end table

 @seealso{impulse, initial, step}
 @end deftypefn

 @deftypefn{Function File} {[@var{y}, @var{t}, @var{x}] =} step (@var{sys})
 @deftypefnx{Function File} {[@var{y}, @var{t}, @var{x}] =} step (@var{sys}, @var{t})
 @deftypefnx{Function File} {[@var{y}, @var{t}, @var{x}] =} step (@var{sys}, @var{tfinal})
 @deftypefnx{Function File} {[@var{y}, @var{t}, @var{x}] =} step (@var{sys}, @var{tfinal}, @var{dt})
 Step response of LTI system.
 If no output arguments are given, the response is printed on the screen.

 @strong{Inputs}
 @table @var
 @item sys
 LTI model.
 @item t
 Time vector.  Should be evenly spaced.  If not specified, it is calculated by
 the poles of the system to reflect adequately the response transients.
 @item tfinal
 Optional simulation horizon.  If not specified, it is calculated by
 the poles of the system to reflect adequately the response transients.
 @item dt
 Optional sampling time.  Be sure to choose it small enough to capture transient
 phenomena.  If not specified, it is calculated by the poles of the system.
 @end table

 @strong{Outputs}
 @table @var
 @item y
 Output response array.  Has as many rows as time samples (length of t)
 and as many columns as outputs.
 @item t
 Time row vector.
 @item x
 State trajectories array.  Has @code{length (t)} rows and as many columns as states.
 @end table

 @seealso{impulse, initial, lsim}
 @end deftypefn
@section Frequency Domain Analysis

 @deftypefn {Function File} {[@var{mag}, @var{pha}, @var{w}] =} bode (@var{sys})
 @deftypefnx {Function File} {[@var{mag}, @var{pha}, @var{w}] =} bode (@var{sys}, @var{w})
 Bode diagram of frequency response.  If no output arguments are given,
 the response is printed on the screen.

 @strong{Inputs}
 @table @var
 @item sys
 LTI system.  Must be a single-input and single-output (SISO) system.
 @item w
 Optional vector of frequency values.  If @var{w} is not specified,
 it is calculated by the zeros and poles of the system.
 @end table

 @strong{Outputs}
 @table @var
 @item mag
 Vector of magnitude.  Has length of frequency vector @var{w}.
 @item pha
 Vector of phase.  Has length of frequency vector @var{w}.
 @item w
 Vector of frequency values used.
 @end table

 @seealso{nichols, nyquist, sigma}
 @end deftypefn

 @deftypefn {Function File} {[@var{mag}, @var{w}] =} bodemag (@var{sys})
 @deftypefnx {Function File} {[@var{mag}, @var{w}] =} bodemag (@var{sys}, @var{w})
 Bode magnitude diagram of frequency response.  If no output arguments are given,
 the response is printed on the screen.

 @strong{Inputs}
 @table @var
 @item sys
 LTI system.  Must be a single-input and single-output (SISO) system.
 @item w
 Optional vector of frequency values.  If @var{w} is not specified,
 it is calculated by the zeros and poles of the system.
 @end table

 @strong{Outputs}
 @table @var
 @item mag
 Vector of magnitude.  Has length of frequency vector @var{w}.
 @item w
 Vector of frequency values used.
 @end table

 @seealso{bode, nichols, nyquist, sigma}
 @end deftypefn

 @deftypefn{Function File} {@var{H} =} freqresp (@var{sys}, @var{w})
 Evaluate frequency response at given frequencies.

 @strong{Inputs}
 @table @var
 @item sys
 LTI system.
 @item w
 Vector of frequency values.
 @end table

 @strong{Outputs}
 @table @var
 @item H
 Array of frequency response.  For a system with m inputs and p outputs, the array @var{H}
 has dimensions [p, m, length (w)].
 The frequency response at the frequency w(k) is given by H(:,:,k).
 @end table

 @seealso{dcgain}
 @end deftypefn

 @deftypefn{Function File} {[@var{gamma}, @var{phi}, @var{w_gamma}, @var{w_phi}] =} margin (@var{sys})
 @deftypefnx{Function File} {[@var{gamma}, @var{phi}, @var{w_gamma}, @var{w_phi}] =} margin (@var{sys}, @var{tol})
 Gain and phase margin of a system.  If no output arguments are given, both gain and phase margin
 are plotted on a bode diagram.  Otherwise, the margins and their corresponding frequencies are
 computed and returned.

 @strong{Inputs}
 @table @var
 @item sys
 LTI model.  Must be a single-input and single-output (SISO) system.
 @item tol
 Imaginary parts below @var{tol} are assumed to be zero.
 If not specified, default value @code{sqrt (eps)} is taken.
 @end table

 @strong{Outputs}
 @table @var
 @item gamma
 Gain margin (as gain, not dBs).
 @item phi
 Phase margin (in degrees).
 @item w_gamma
 Frequency for the gain margin (in rad/s).
 @item w_phi
 Frequency for the phase margin (in rad/s).
 @end table

 @strong{Equations}
 @example
 @group
 CONTINUOUS SYSTEMS
 Gain Margin
         _               _
 L(jw) = L(jw)      BTW: L(jw) = L(-jw) = conj (L(jw))

 num(jw)   num(-jw)
 ------- = --------
 den(jw)   den(-jw)

 num(jw) den(-jw) = num(-jw) den(jw)

 imag (num(jw) den(-jw)) = 0
 imag (num(-jw) den(jw)) = 0

 Phase Margin
           |num(jw)|
 |L(jw)| = |-------| = 1
           |den(jw)|
   _     2      2
 z z = Re z + Im z

 num(jw)   num(-jw)
 ------- * -------- = 1
 den(jw)   den(-jw)

 num(jw) num(-jw) - den(jw) den(-jw) = 0

 real (num(jw) num(-jw) - den(jw) den(-jw)) = 0


 DISCRETE SYSTEMS
 Gain Margin
                              jwT         log z
 L(z) = L(1/z)      BTW: z = e    --> w = -----
                                           j T
 num(z)   num(1/z)
 ------ = --------
 den(z)   den(1/z)

 num(z) den(1/z) - num(1/z) den(z) = 0

 Phase Margin
          |num(z)|
 |L(z)| = |------| = 1
          |den(z)|

 L(z) L(1/z) = 1

 num(z)   num(1/z)
 ------ * -------- = 1
 den(z)   den(1/z)

 num(z) num(1/z) - den(z) den(1/z) = 0

 PS: How to get L(1/z)
           4       3       2
 p(z) = a z  +  b z  +  c z  +  d z  +  e

             -4      -3      -2      -1
 p(1/z) = a z  +  b z  +  c z  +  d z  +  e

           -4                    2       3       4
        = z   ( a  +  b z  +  c z  +  d z  +  e z  )

               4       3       2                     4
        = ( e z  +  d z  +  c z  +  b z  +  a ) / ( z  )
 @end group
 @end example

 @seealso{roots}
 @end deftypefn

 @deftypefn {Function File} {[@var{mag}, @var{pha}, @var{w}] =} nichols (@var{sys})
 @deftypefnx {Function File} {[@var{mag}, @var{pha}, @var{w}] =} nichols (@var{sys}, @var{w})
 Nichols chart of frequency response.  If no output arguments are given,
 the response is printed on the screen.

 @strong{Inputs}
 @table @var
 @item sys
 LTI system.  Must be a single-input and single-output (SISO) system.
 @item w
 Optional vector of frequency values.  If @var{w} is not specified,
 it is calculated by the zeros and poles of the system.
 @end table

 @strong{Outputs}
 @table @var
 @item mag
 Vector of magnitude.  Has length of frequency vector @var{w}.
 @item pha
 Vector of phase.  Has length of frequency vector @var{w}.
 @item w
 Vector of frequency values used.
 @end table

 @seealso{bode, nyquist, sigma}
 @end deftypefn

 @deftypefn {Function File} {[@var{re}, @var{im}, @var{w}] =} nyquist (@var{sys})
 @deftypefnx {Function File} {[@var{re}, @var{im}, @var{w}] =} nyquist (@var{sys}, @var{w})
 Nyquist diagram of frequency response.  If no output arguments are given,
 the response is printed on the screen.

 @strong{Inputs}
 @table @var
 @item sys
 LTI system.  Must be a single-input and single-output (SISO) system.
 @item w
 Optional vector of frequency values.  If @var{w} is not specified,
 it is calculated by the zeros and poles of the system.
 @end table

 @strong{Outputs}
 @table @var
 @item re
 Vector of real parts.  Has length of frequency vector @var{w}.
 @item im
 Vector of imaginary parts.  Has length of frequency vector @var{w}.
 @item w
 Vector of frequency values used.
 @end table

 @seealso{bode, nichols, sigma}
 @end deftypefn

 @deftypefn{Function File} {[@var{sv}, @var{w}] =} sigma (@var{sys})
 @deftypefnx{Function File} {[@var{sv}, @var{w}] =} sigma (@var{sys}, @var{w})
 @deftypefnx{Function File} {[@var{sv}, @var{w}] =} sigma (@var{sys}, @var{[]}, @var{ptype})
 @deftypefnx{Function File} {[@var{sv}, @var{w}] =} sigma (@var{sys}, @var{w}, @var{ptype})
 Singular values of frequency response.  If no output arguments are given,
 the singular value plot is printed on the screen;

 @strong{Inputs}
 @table @var
 @item sys
 LTI system.  Multiple inputs and/or outputs (MIMO systems) make practical sense.
 @item w
 Optional vector of frequency values.  If @var{w} is not specified,
 it is calculated by the zeros and poles of the system.
 @item ptype = 0
 Singular values of the frequency response @var{H} of system @var{sys}.  Default Value.
 @item ptype = 1
 Singular values of the frequency response @code{inv(H)}; i.e. inversed system.
 @item ptype = 2
 Singular values of the frequency response @code{I + H}; i.e. inversed sensitivity
 (or return difference) if @code{H = P * C}.
 @item ptype = 3
 Singular values of the frequency response @code{I + inv(H)}; i.e. inversed complementary
 sensitivity if @code{H = P * C}.
 @end table

 @strong{Outputs}
 @table @var
 @item sv
 Array of singular values.  For a system with m inputs and p outputs, the array sv
 has @code{min (m, p)} rows and as many columns as frequency points @code{length (w)}.
 The singular values at the frequency @code{w(k)} are given by @code{sv(:,k)}.
 @item w
 Vector of frequency values used.
 @end table

 @seealso{bodemag, svd}
 @end deftypefn
@section Pole Placement

 @deftypefn {Function File} {@var{f} =} place (@var{sys}, @var{p})
 @deftypefnx {Function File} {@var{f} =} place (@var{a}, @var{b}, @var{p})
 @deftypefnx {Function File} {[@var{f}, @var{nfp}, @var{nap}, @var{nup}] =} place (@var{sys}, @var{p}, @var{alpha})
 @deftypefnx {Function File} {[@var{f}, @var{nfp}, @var{nap}, @var{nup}] =} place (@var{a}, @var{b}, @var{p}, @var{alpha})
 Pole assignment for a given matrix pair (@var{A},@var{B}) such that @code{p = eig (A-B*F)}.
 If parameter @var{alpha} is specified, poles with real parts (continuous-time)
 or moduli (discrete-time) below @var{alpha} are left untouched.
 Uses SLICOT SB01BD by courtesy of
 @uref{http://www.slicot.org, NICONET e.V.}

 @strong{Inputs}
 @table @var
 @item sys
 LTI system.
 @item a
 State transition matrix (n-by-n) of a continuous-time system.
 @item b
 Input matrix (n-by-m) of a continuous-time system.
 @item p
 Desired eigenvalues of the closed-loop system state-matrix @var{A-B*F}.
 @code{length (p) <= rows (A)}.
 @item alpha
 Specifies the maximum admissible value, either for real
 parts or for moduli, of the eigenvalues of @var{A} which will
 not be modified by the eigenvalue assignment algorithm.
 @code{alpha >= 0} for discrete-time systems.
 @end table

 @strong{Outputs}
 @table @var
 @item f
 State feedback gain matrix.
 @item nfp
 The number of fixed poles, i.e. eigenvalues of @var{A} having
 real parts less than @var{alpha}, or moduli less than @var{alpha}.
 These eigenvalues are not modified by @command{place}.
 @item nap
 The number of assigned eigenvalues.  @code{nap = n-nfp-nup}.
 @item nup
 The number of uncontrollable eigenvalues detected by the
 eigenvalue assignment algorithm.
 @end table

 @strong{Note}
 @example
 Place is also suitable to design estimator gains:
 @group
 L = place (A.', C.', p).'
 L = place (sys.', p).'   
 @deftypefn {Function File} rlocus (@var{sys}) 
 @deftypefnx {Function File} {[@var{rldata}, @var{k}] =} rlocus (@var{sys}[, @var{increment}, @var{min_k}, @var{max_k}]) 
 Display root locus plot of the specified @acronym{SISO} system.

 @strong{Inputs}
 @table @var
 @item sys
 LTI model.  Must be a single-input and single-output (SISO) system.
 @item min_k
 Minimum value of @var{k}.
 @item max_k
 Maximum value of @var{k}.
 @item increment
 The increment used in computing gain values.
 @end table

 @strong{Outputs}
 @table @var 
 @item rldata
 Data points plotted: in column 1 real values, in column 2 the imaginary values.
 @item k
 Gains for real axis break points.
 @end table

 @strong{Block Diagram}
 @example
 @group
  u    +         +---+      +------+             y
 ------>(+)----->| k |----->| SISO |-------+------->
         ^ -     +---+      +------+       |
         |                                 |
         +---------------------------------+
 @end group
 @end example
 @end deftypefn
@section Linear-Quadratic Control

 @deftypefn {Function File} {[@var{g}, @var{x}, @var{l}] =} dlqr (@var{sys}, @var{q}, @var{r})
 @deftypefnx {Function File} {[@var{g}, @var{x}, @var{l}] =} dlqr (@var{sys}, @var{q}, @var{r}, @var{s})
 @deftypefnx {Function File} {[@var{g}, @var{x}, @var{l}] =} dlqr (@var{a}, @var{b}, @var{q}, @var{r})
 @deftypefnx {Function File} {[@var{g}, @var{x}, @var{l}] =} dlqr (@var{a}, @var{b}, @var{q}, @var{r}, @var{s})
 @deftypefnx {Function File} {[@var{g}, @var{x}, @var{l}] =} dlqr (@var{a}, @var{b}, @var{q}, @var{r}, @var{[]}, @var{e})
 @deftypefnx {Function File} {[@var{g}, @var{x}, @var{l}] =} dlqr (@var{a}, @var{b}, @var{q}, @var{r}, @var{s}, @var{e})
 Linear-quadratic regulator for discrete-time systems.

 @strong{Inputs}
 @table @var
 @item sys
 Continuous or discrete-time LTI model.
 @item a
 State transition matrix of discrete-time system.
 @item b
 Input matrix of discrete-time system.
 @item q
 State weighting matrix.
 @item r
 Input weighting matrix.
 @item s
 Optional cross term matrix.  If @var{s} is not specified, a zero matrix is assumed.
 @item e
 Optional descriptor matrix.  If @var{e} is not specified, an identity matrix is assumed.
 @end table

 @strong{Outputs}
 @table @var
 @item g
 State feedback matrix.
 @item x
 Unique stabilizing solution of the discrete-time Riccati equation.
 @item l
 Closed-loop poles.
 @end table

 @strong{Equations}
 @example
 @group
 x[k+1] = A x[k] + B u[k],   x[0] = x0

         inf
 J(x0) = SUM (x' Q x  +  u' R u  +  2 x' S u)
         k=0

 L = eig (A - B*G)
 @end group
 @end example
 @seealso{dare, care, lqr}
 @end deftypefn

 @deftypefn {Function File} {@var{est} =} estim (@var{sys}, @var{l})
 @deftypefnx {Function File} {@var{est} =} estim (@var{sys}, @var{l}, @var{sensors}, @var{known})
 Return state estimator for a given estimator gain.

 @strong{Inputs}
 @table @var
 @item sys
 LTI model.
 @item l
 State feedback matrix.
 @item sensors
 Indices of measured output signals y from @var{sys}.  If omitted, all outputs are measured.
 @item known
 Indices of known input signals u (deterministic) to @var{sys}.  All other inputs to @var{sys}
 are assumed stochastic.  If argument @var{known} is omitted, no inputs u are known.
 @end table

 @strong{Outputs}
 @table @var
 @item est
 State-space model of estimator.
 @end table
 @seealso{kalman, place}
 @end deftypefn

 @deftypefn {Function File} {[@var{est}, @var{g}, @var{x}] =} kalman (@var{sys}, @var{q}, @var{r})
 @deftypefnx {Function File} {[@var{est}, @var{g}, @var{x}] =} kalman (@var{sys}, @var{q}, @var{r}, @var{s})
 @deftypefnx {Function File} {[@var{est}, @var{g}, @var{x}] =} kalman (@var{sys}, @var{q}, @var{r}, @var{[]}, @var{sensors}, @var{known})
 @deftypefnx {Function File} {[@var{est}, @var{g}, @var{x}] =} kalman (@var{sys}, @var{q}, @var{r}, @var{s}, @var{sensors}, @var{known})
 Design Kalman estimator for LTI systems.

 @strong{Inputs}
 @table @var
 @item sys
 Nominal plant model.
 @item q
 Covariance of white process noise.
 @item r
 Covariance of white measurement noise.
 @item s
 Optional cross term covariance.  Default value is 0.
 @item sensors
 Indices of measured output signals y from @var{sys}.  If omitted, all outputs are measured.
 @item known
 Indices of known input signals u (deterministic) to @var{sys}.  All other inputs to @var{sys}
 are assumed stochastic.  If argument @var{known} is omitted, no inputs u are known.
 @end table

 @strong{Outputs}
 @table @var
 @item est
 State-space model of the Kalman estimator.
 @item g
 Estimator gain.
 @item x
 Solution of the Riccati equation.
 @end table

 @strong{Block Diagram}
 @example
 @group
                                  u  +-------+         ^
       +---------------------------->|       |-------> y
       |    +-------+     +       y  |  est  |         ^
 u ----+--->|       |----->(+)------>|       |-------> x
            |  sys  |       ^ +      +-------+
 w -------->|       |       |
            +-------+       | v

 Q = cov (w, w')     R = cov (v, v')     S = cov (w, v')
 @end group
 @end example

 @seealso{care, dare, estim, lqr}
 @end deftypefn

 @deftypefn {Function File} {[@var{g}, @var{x}, @var{l}] =} lqr (@var{sys}, @var{q}, @var{r})
 @deftypefnx {Function File} {[@var{g}, @var{x}, @var{l}] =} lqr (@var{sys}, @var{q}, @var{r}, @var{s})
 @deftypefnx {Function File} {[@var{g}, @var{x}, @var{l}] =} lqr (@var{a}, @var{b}, @var{q}, @var{r})
 @deftypefnx {Function File} {[@var{g}, @var{x}, @var{l}] =} lqr (@var{a}, @var{b}, @var{q}, @var{r}, @var{s})
 @deftypefnx {Function File} {[@var{g}, @var{x}, @var{l}] =} lqr (@var{a}, @var{b}, @var{q}, @var{r}, @var{[]}, @var{e})
 @deftypefnx {Function File} {[@var{g}, @var{x}, @var{l}] =} lqr (@var{a}, @var{b}, @var{q}, @var{r}, @var{s}, @var{e})
 Linear-quadratic regulator.

 @strong{Inputs}
 @table @var
 @item sys
 Continuous or discrete-time LTI model.
 @item a
 State transition matrix of continuous-time system.
 @item b
 Input matrix of continuous-time system.
 @item q
 State weighting matrix.
 @item r
 Input weighting matrix.
 @item s
 Optional cross term matrix.  If @var{s} is not specified, a zero matrix is assumed.
 @item e
 Optional descriptor matrix.  If @var{e} is not specified, an identity matrix is assumed.
 @end table

 @strong{Outputs}
 @table @var
 @item g
 State feedback matrix.
 @item x
 Unique stabilizing solution of the continuous-time Riccati equation.
 @item l
 Closed-loop poles.
 @end table

 @strong{Equations}
 @example
 @group
 .
 x = A x + B u,   x(0) = x0

         inf
 J(x0) = INT (x' Q x  +  u' R u  +  2 x' S u)  dt
          0

 L = eig (A - B*G)
 @end group
 @end example
 @seealso{care, dare, dlqr}
 @end deftypefn
@section Robust Control

 @deftypefn{Function File} {@var{P} =} augw (@var{G}, @var{W1}, @var{W2}, @var{W3})
 Extend plant for stacked S/KS/T problem.  Subsequently, the robust control problem
 can be solved by h2syn or hinfsyn.

 @strong{Inputs}
 @table @var
 @item G
 LTI model of plant.
 @item W1
 LTI model of performance weight.  Bounds the largest singular values of sensitivity @var{S}.
 Model must be empty @code{[]}, SISO or of appropriate size.
 @item W2
 LTI model to penalize large control inputs.  Bounds the largest singular values of @var{KS}.
 Model must be empty @code{[]}, SISO or of appropriate size.
 @item W3
 LTI model of robustness and noise sensitivity weight.  Bounds the largest singular values of 
 complementary sensitivity @var{T}.  Model must be empty @code{[]}, SISO or of appropriate size.
 @end table

 All inputs must be proper/realizable.
 Scalars, vectors and matrices are possible instead of LTI models.

 @strong{Outputs}
 @table @var
 @item P
 State-space model of augmented plant.
 @end table

 @strong{Block Diagram}
 @example
 @group

     | W1 | -W1*G |     z1 = W1 r  -  W1 G u
     | 0  |  W2   |     z2 =          W2   u
 P = | 0  |  W3*G |     z3 =          W3 G u
     |----+-------|
     | I  |    -G |     e  =    r  -     G u
                                                       +------+  z1
             +---------------------------------------->|  W1  |----->
             |                                         +------+
             |                                         +------+  z2
             |                 +---------------------->|  W2  |----->
             |                 |                       +------+
  r   +    e |   +--------+  u |   +--------+  y       +------+  z3
 ----->(+)---+-->|  K(s)  |----+-->|  G(s)  |----+---->|  W3  |----->
        ^ -      +--------+        +--------+    |     +------+
        |                                        |
        +----------------------------------------+

                +--------+
                |        |-----> z1 (p1x1)          z1 = W1 e
  r (px1) ----->|  P(s)  |-----> z2 (p2x1)          z2 = W2 u
                |        |-----> z3 (p3x1)          z3 = W3 y
  u (mx1) ----->|        |-----> e (px1)            e = r - y
                +--------+

                +--------+  
        r ----->|        |-----> z
                |  P(s)  |
        u +---->|        |-----+ e
          |     +--------+     |
          |                    |
          |     +--------+     |
          +-----|  K(s)  |<----+
                +--------+

 Reference:
 Skogestad, S. and Postlethwaite I.
 Multivariable Feedback Control: Analysis and Design
 Second Edition
 Wiley 2005
 Chapter 3.8: General Control Problem Formulation
 @end group
 @end example
 @seealso{h2syn, hinfsyn, mixsyn}
 @end deftypefn

 @deftypefn{Function File} {[@var{K}, @var{N}, @var{gamma}, @var{rcond}] =} h2syn (@var{P}, @var{nmeas}, @var{ncon})
 H-2 control synthesis for LTI plant.
 Uses SLICOT SB10HD and SB10ED by courtesy of
 @uref{http://www.slicot.org, NICONET e.V.}

 @strong{Inputs}
 @table @var
 @item P
 Generalized plant.  Must be a proper/realizable LTI model.
 @item nmeas
 Number of measured outputs v.  The last nmeas outputs of @var{P} are connected to the
 inputs of controller @var{K}.  The remaining outputs z (indices 1 to p-nmeas) are used
 to calculate the H-2 norm.
 @item ncon
 Number of controlled inputs u.  The last ncon inputs of @var{P} are connected to the
 outputs of controller @var{K}.  The remaining inputs w (indices 1 to m-ncon) are excited
 by a harmonic test signal.
 @end table

 @strong{Outputs}
 @table @var
 @item K
 State-space model of the H-2 optimal controller.
 @item N
 State-space model of the lower LFT of @var{P} and @var{K}.
 @item gamma
 H-2 norm of @var{N}.
 @end table

 @strong{Block Diagram}
 @example
 @group

 gamma = min||N(K)||             N = lft (P, K)
          K         2

                +--------+  
        w ----->|        |-----> z
                |  P(s)  |
        u +---->|        |-----+ v
          |     +--------+     |
          |                    |
          |     +--------+     |
          +-----|  K(s)  |<----+
                +--------+

                +--------+      
        w ----->|  N(s)  |-----> z
                +--------+
 @end group
 @end example
 @seealso{augw, lqr, dlqr, kalman}
 @end deftypefn

 @deftypefn{Function File} {[@var{K}, @var{N}, @var{gamma}, @var{rcond}] =} hinfsyn (@var{P}, @var{nmeas}, @var{ncon})
 @deftypefnx{Function File} {[@var{K}, @var{N}, @var{gamma}, @var{rcond}] =} hinfsyn (@var{P}, @var{nmeas}, @var{ncon}, @var{gmax})
 H-infinity control synthesis for LTI plant.
 Uses SLICOT SB10FD and SB10DD by courtesy of
 @uref{http://www.slicot.org, NICONET e.V.}

 @strong{Inputs}
 @table @var
 @item P
 Generalized plant.  Must be a proper/realizable LTI model.
 @item nmeas
 Number of measured outputs v.  The last nmeas outputs of @var{P} are connected to the
 inputs of controller @var{K}.  The remaining outputs z (indices 1 to p-nmeas) are used
 to calculate the H-infinity norm.
 @item ncon
 Number of controlled inputs u.  The last ncon inputs of @var{P} are connected to the
 outputs of controller @var{K}.  The remaining inputs w (indices 1 to m-ncon) are excited
 by a harmonic test signal.
 @item gmax
 The maximum value of the H-infinity norm of @var{N}.  It is assumed that @var{gmax} is
 sufficiently large so that the controller is admissible.
 @end table

 @strong{Outputs}
 @table @var
 @item K
 State-space model of the H-infinity (sub-)optimal controller.
 @item N
 State-space model of the lower LFT of @var{P} and @var{K}.
 @item gamma
 L-infinity norm of @var{N}.
 @end table

 @strong{Block Diagram}
 @example
 @group

 gamma = min||N(K)||             N = lft (P, K)
          K         inf

                +--------+  
        w ----->|        |-----> z
                |  P(s)  |
        u +---->|        |-----+ v
          |     +--------+     |
          |                    |
          |     +--------+     |
          +-----|  K(s)  |<----+
                +--------+

                +--------+      
        w ----->|  N(s)  |-----> z
                +--------+
 @end group
 @end example
 @seealso{augw, mixsyn}
 @end deftypefn

 @deftypefn{Function File} {[@var{K}, @var{N}, @var{gamma}] =} mixsyn (@var{G}, @var{W1}, @var{W2}, @var{W3}, @dots{})
 Solve stacked S/KS/T H-inf problem.  Bound the largest singular values
 of @var{S} (for performance), @var{K S} (to penalize large inputs) and
 @var{T} (for robustness and to avoid sensitivity to noise).
 In other words, the inputs r are excited by a harmonic test signal.
 Then the algorithm tries to find a controller @var{K} which minimizes
 the H-infinity norm calculated from the outputs z.

 @strong{Inputs}
 @table @var
 @item G
 LTI model of plant.
 @item W1
 LTI model of performance weight.  Bounds the largest singular values of sensitivity @var{S}.
 Model must be empty @code{[]}, SISO or of appropriate size.
 @item W2
 LTI model to penalize large control inputs.  Bounds the largest singular values of @var{KS}.
 Model must be empty @code{[]}, SISO or of appropriate size.
 @item W3
 LTI model of robustness and noise sensitivity weight.  Bounds the largest singular values of 
 complementary sensitivity @var{T}.  Model must be empty @code{[]}, SISO or of appropriate size.
 @item @dots{}
 Optional arguments of @command{hinfsyn}.  Type @command{help hinfsyn} for more information.
 @end table

 All inputs must be proper/realizable.
 Scalars, vectors and matrices are possible instead of LTI models.

 @strong{Outputs}
 @table @var
 @item K
 State-space model of the H-infinity (sub-)optimal controller.
 @item N
 State-space model of the lower LFT of @var{P} and @var{K}.
 @item gamma
 L-infinity norm of @var{N}.
 @end table

 @strong{Block Diagram}
 @example
 @group

                                     | W1 S   |
 gamma = min||N(K)||             N = | W2 K S | = lft (P, K)
          K         inf              | W3 T   |
                                                       +------+  z1
             +---------------------------------------->|  W1  |----->
             |                                         +------+
             |                                         +------+  z2
             |                 +---------------------->|  W2  |----->
             |                 |                       +------+
  r   +    e |   +--------+  u |   +--------+  y       +------+  z3
 ----->(+)---+-->|  K(s)  |----+-->|  G(s)  |----+---->|  W3  |----->
        ^ -      +--------+        +--------+    |     +------+
        |                                        |
        +----------------------------------------+

                +--------+
                |        |-----> z1 (p1x1)          z1 = W1 e
  r (px1) ----->|  P(s)  |-----> z2 (p2x1)          z2 = W2 u
                |        |-----> z3 (p3x1)          z3 = W3 y
  u (mx1) ----->|        |-----> e (px1)            e = r - y
                +--------+

                +--------+  
        r ----->|        |-----> z
                |  P(s)  |
        u +---->|        |-----+ e
          |     +--------+     |
          |                    |
          |     +--------+     |
          +-----|  K(s)  |<----+
                +--------+

                +--------+      
        r ----->|  N(s)  |-----> z
                +--------+

 Extended Plant:  P = augw (G, W1, W2, W3)
 Controller:      K = mixsyn (G, W1, W2, W3)
 Entire System:   N = lft (P, K)
 Open Loop:       L = G * K
 Closed Loop:     T = feedback (L)

 Reference:
 Skogestad, S. and Postlethwaite I.
 Multivariable Feedback Control: Analysis and Design
 Second Edition
 Wiley 2005
 Chapter 3.8: General Control Problem Formulation
 @end group
 @end example
 @seealso{hinfsyn, augw}
 @end deftypefn

 @deftypefn{Function File} {[@var{K}, @var{N}, @var{gamma}, @var{info}] =} ncfsyn (@var{G}, @var{W1}, @var{W2}, @var{factor})
 Normalized Coprime Factor (NCF) H-infinity synthesis.
 Compute positive feedback controller using the McFarlane/Glover Loop Shaping Design Procedure.
 Uses SLICOT SB10ID, SB10KD and SB10ZD by courtesy of
 @uref{http://www.slicot.org, NICONET e.V.}

 @strong{Inputs}
 @table @var
 @item G
 LTI model of plant.
 @item W1
 LTI model of precompensator.  Model must be SISO or of appropriate size.
 An identity matrix is taken if @var{W1} is not specified or if an empty model
 @code{[]} is passed.
 @item W2
 LTI model of postcompensator.  Model must be SISO or of appropriate size.
 An identity matrix is taken if @var{W2} is not specified or if an empty model
 @code{[]} is passed.
 @item factor
 @code{factor = 1} implies that an optimal controller is required.
 @code{factor > 1} implies that a suboptimal controller is required,
 achieving a performance taht is @var{factor} times less than optimal.
 Default value is 1.
 @end table

 @strong{Outputs}
 @table @var
 @item K
 State-space model of the H-infinity loop-shaping controller.
 @item N
 State-space model of the closed loop depicted below.
 @item gamma
 L-infinity norm of @var{N}.
 @item info
 Structure containing additional information.
 @item info.emax
 Nugap robustness.  @code{emax = inv (gamma)}.
 @item info.Gs
 Shaped plant.  @code{Gs = W2 * G * W1}.
 @item info.Ks
 Controller for shaped plant.  @code{Ks = ncfsyn (Gs)}.
 @item info.rcond
 Estimates of the reciprocal condition numbers of the Riccati equations.
 @end table

 @strong{Block Diagram of N}
 @example
 @group

             ^ z1              ^ z2
             |                 |
  w1  +      |   +--------+    |            +--------+
 ----->(+)---+-->|   Ks   |----+--->(+)---->|   Gs   |----+
        ^ +      +--------+          ^      +--------+    |
        |                        w2  |                    |
        |                                                 |
        +-------------------------------------------------+
 @end group
 @end example
 @end deftypefn
@section Matrix Equation Solvers

 @deftypefn {Function File} {[@var{x}, @var{l}, @var{g}] =} care (@var{a}, @var{b}, @var{q}, @var{r})
 @deftypefnx {Function File} {[@var{x}, @var{l}, @var{g}] =} care (@var{a}, @var{b}, @var{q}, @var{r}, @var{s})
 @deftypefnx {Function File} {[@var{x}, @var{l}, @var{g}] =} care (@var{a}, @var{b}, @var{q}, @var{r}, @var{[]}, @var{e})
 @deftypefnx {Function File} {[@var{x}, @var{l}, @var{g}] =} care (@var{a}, @var{b}, @var{q}, @var{r}, @var{s}, @var{e})
 Solve continuous-time algebraic Riccati equation (ARE).
 Uses SLICOT SB02OD and SG02AD by courtesy of
 @uref{http://www.slicot.org, NICONET e.V.}

 @strong{Inputs}
 @table @var
 @item a
 Real matrix (n-by-n).
 @item b
 Real matrix (n-by-m).
 @item q
 Real matrix (n-by-n).
 @item r
 Real matrix (m-by-m).
 @item s
 Optional real matrix (n-by-m).  If @var{s} is not specified, a zero matrix is assumed.
 @item e
 Optional descriptor matrix (n-by-n).  If @var{e} is not specified, an identity matrix is assumed.
 @end table

 @strong{Outputs}
 @table @var
 @item x
 Unique stabilizing solution of the continuous-time Riccati equation (n-by-n).
 @item l
 Closed-loop poles (n-by-1).
 @item g
 Corresponding gain matrix (m-by-n).
 @end table

 @strong{Equations}
 @example
 @group
                -1
 A'X + XA - XB R  B'X + Q = 0
 
                      -1
 A'X + XA - (XB + S) R  (B'X + S') + Q = 0

      -1
 G = R  B'X

      -1
 G = R  (B'X + S')

 L = eig (A - B*G)

                     -1
 A'XE + E'XA - E'XB R   B'XE + Q = 0

                           -1
 A'XE + E'XA - (E'XB + S) R   (B'XE + S') + Q = 0

      -1
 G = R  B'XE

      -1
 G = R  (B'XE + S)

 L = eig (A - B*G, E)
 @end group
 @end example
 @seealso{dare, lqr, dlqr, kalman}
 @end deftypefn

 @deftypefn {Function File} {[@var{x}, @var{l}, @var{g}] =} dare (@var{a}, @var{b}, @var{q}, @var{r})
 @deftypefnx {Function File} {[@var{x}, @var{l}, @var{g}] =} dare (@var{a}, @var{b}, @var{q}, @var{r}, @var{s})
 @deftypefnx {Function File} {[@var{x}, @var{l}, @var{g}] =} dare (@var{a}, @var{b}, @var{q}, @var{r}, @var{[]}, @var{e})
 @deftypefnx {Function File} {[@var{x}, @var{l}, @var{g}] =} dare (@var{a}, @var{b}, @var{q}, @var{r}, @var{s}, @var{e})
 Solve discrete-time algebraic Riccati equation (ARE).
 Uses SLICOT SB02OD and SG02AD by courtesy of
 @uref{http://www.slicot.org, NICONET e.V.}

 @strong{Inputs}
 @table @var
 @item a
 Real matrix (n-by-n).
 @item b
 Real matrix (n-by-m).
 @item q
 Real matrix (n-by-n).
 @item r
 Real matrix (m-by-m).
 @item s
 Optional real matrix (n-by-m).  If @var{s} is not specified, a zero matrix is assumed.
 @item e
 Optional descriptor matrix (n-by-n).  If @var{e} is not specified, an identity matrix is assumed.
 @end table

 @strong{Outputs}
 @table @var
 @item x
 Unique stabilizing solution of the discrete-time Riccati equation (n-by-n).
 @item l
 Closed-loop poles (n-by-1).
 @item g
 Corresponding gain matrix (m-by-n).
 @end table

 @strong{Equations}
 @example
 @group
                           -1
 A'XA - X - A'XB (B'XB + R)   B'XA + Q = 0

                                 -1
 A'XA - X - (A'XB + S) (B'XB + R)   (B'XA + S') + Q = 0

               -1
 G = (B'XB + R)   B'XA

               -1
 G = (B'XB + R)   (B'XA + S')

 L = eig (A - B*G)

                              -1
 A'XA - E'XE - A'XB (B'XB + R)   B'XA + Q = 0

                                    -1
 A'XA - E'XE - (A'XB + S) (B'XB + R)   (B'XA + S') + Q = 0

               -1
 G = (B'XB + R)   B'XA

               -1
 G = (B'XB + R)   (B'XA + S')

 L = eig (A - B*G, E)
 @end group
 @end example
 @seealso{care, lqr, dlqr, kalman}
 @end deftypefn

 @deftypefn{Function File} {@var{x} =} dlyap (@var{a}, @var{b})
 @deftypefnx{Function File} {@var{x} =} dlyap (@var{a}, @var{b}, @var{c})
 @deftypefnx{Function File} {@var{x} =} dlyap (@var{a}, @var{b}, @var{[]}, @var{e})
 Solve discrete-time Lyapunov or Sylvester equations.
 Uses SLICOT SB03MD, SB04QD and SG03AD by courtesy of
 @uref{http://www.slicot.org, NICONET e.V.}

 @strong{Equations}
 @example
 @group
 AXA' - X + B = 0      (Lyapunov Equation)

 AXB' - X + C = 0      (Sylvester Equation)

 AXA' - EXE' + B = 0   (Generalized Lyapunov Equation)
 @end group
 @end example

 @seealso{dlyapchol, lyap, lyapchol}
 @end deftypefn

 @deftypefn{Function File} {@var{u} =} dlyapchol (@var{a}, @var{b})
 @deftypefnx{Function File} {@var{u} =} dlyapchol (@var{a}, @var{b}, @var{e})
 Compute Cholesky factor of discrete-time Lyapunov equations.
 Uses SLICOT SB03OD and SG03BD by courtesy of
 @uref{http://www.slicot.org, NICONET e.V.}

 @strong{Equations}
 @example
 @group
 A U' U A'  -  U' U  +  B B'  =  0           (Lyapunov Equation)

 A U' U A'  -  E U' U E'  +  B B'  =  0      (Generalized Lyapunov Equation)
 @end group
 @end example

 @seealso{dlyap, lyap, lyapchol}
 @end deftypefn

 @deftypefn{Function File} {@var{x} =} lyap (@var{a}, @var{b})
 @deftypefnx{Function File} {@var{x} =} lyap (@var{a}, @var{b}, @var{c})
 @deftypefnx{Function File} {@var{x} =} lyap (@var{a}, @var{b}, @var{[]}, @var{e})
 Solve continuous-time Lyapunov or Sylvester equations.
 Uses SLICOT SB03MD, SB04MD and SG03AD by courtesy of
 @uref{http://www.slicot.org, NICONET e.V.}

 @strong{Equations}
 @example
 @group
 AX + XA' + B = 0      (Lyapunov Equation)

 AX + XB + C = 0       (Sylvester Equation)

 AXE' + EXA' + B = 0   (Generalized Lyapunov Equation)
 @end group
 @end example

 @seealso{lyapchol, dlyap, dlyapchol}
 @end deftypefn

 @deftypefn{Function File} {@var{u} =} lyapchol (@var{a}, @var{b})
 @deftypefnx{Function File} {@var{u} =} lyapchol (@var{a}, @var{b}, @var{e})
 Compute Cholesky factor of continuous-time Lyapunov equations.
 Uses SLICOT SB03OD and SG03BD by courtesy of
 @uref{http://www.slicot.org, NICONET e.V.}

 @strong{Equations}
 @example
 @group
 A U' U  +  U' U A'  +  B B'  =  0           (Lyapunov Equation)

 A U' U E'  +  E U' U A'  +  B B'  =  0      (Generalized Lyapunov Equation)
 @end group
 @end example

 @seealso{lyap, dlyap, dlyapchol}
 @end deftypefn
@section Overloaded Operators

 Horizontal concatenation of LTI objects.  If necessary, object conversion
 is done by sys_group.  Used by Octave for "[lti1, lti2]".

 Inversion of LTI objects.

 Binary subtraction of LTI objects.  If necessary, object conversion
 is done by sys_group.  Used by Octave for "lti1 - lti2".

 Matrix left division of LTI objects.  If necessary, object conversion
 is done by sys_group in mtimes.  Used by Octave for "lti1  lti2".

 Matrix power of LTI objects.  The exponent must be an integer.
 Used by Octave for "lti^int".

 Matrix right division of LTI objects.  If necessary, object conversion
 is done by sys_group in mtimes.  Used by Octave for "lti1 / lti2".

 Matrix multiplication of LTI objects.  If necessary, object conversion
 is done by sys_group.  Used by Octave for "lti1 * lti2".

 Binary addition of LTI objects.  If necessary, object conversion
 is done by sys_group.  Used by Octave for "lti1 + lti2".
 Operation is also known as "parallel connection".

 Subscripted assignment for LTI objects.
 Used by Octave for "sys.property = value".

 Subscripted reference for LTI objects.
 Used by Octave for "sys = sys(2:4, :)" or "val = sys.prop".

 Transpose of LTI objects.  Used by Octave for "sys.'".

 Unary minus of LTI object.  Used by Octave for "-lti".

 Vertical concatenation of LTI objects.  If necessary, object conversion
 is done by sys_group.  Used by Octave for "[lti1; lti2]".
@section Miscellaneous

 @deftypefn {Function File} {@var{strvec} =} strseq (@var{str}, @var{idx})
 Return a cell vector of indexed strings by appending the indices @var{idx}
 to the string @var{str}.

 @example
 strseq ("x", 1:3) = @{"x1"; "x2"; "x3"@}
 strseq ("u", [1, 2, 5]) = @{"u1"; "u2"; "u5"@}
 @end example
 @end deftypefn

 @deftypefn {Script File} test_control
 Execute all available tests at once.
 @end deftypefn
