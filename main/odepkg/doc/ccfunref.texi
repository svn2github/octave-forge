@subsection Source file @file{odepkg_auxiliary_functions.cc}

@deftypefn {Function} octave_value odepkg_auxiliary_getmapvalue (std::string vnam, Octave_map vmap)

Return the @code{octave_value} from the field that is identified by the string @var{vnam} of the @code{Octave_map} that is given by @var{vmap}. The input arguments of this function are

@itemize @minus
@item @var{vnam}: The name of the field whose value is returned
@item @var{vmap}: The map that is checked for the presence of the field
@end itemize
@end deftypefn


@deftypefn {Function} octave_idx_type odepkg_auxiliary_isvector (octave_value vval)

Return the constant @code{true} if the value of the input argument @var{vval} is a valid numerical vector of @code{length > 1} or return the constant @code{false} otherwise. The input argument of this function is

@itemize @minus
@item @var{vval}: The @code{octave_value} that is checked for being a valid numerical vector
@end itemize
@end deftypefn


@deftypefn {Function} octave_value_list odepkg_auxiliary_evaleventfun (octave_value veve, octave_value vt, octave_value vy, octave_value_list vextarg, octave_idx_type vdeci)

Return the values that come from the evaluation of the @code{Events} user function. The return arguments depend on the call to this function, ie. if @var{vdeci} is @code{0} then initilaization of the @code{Events} function is performed. If @var{vdeci} is @code{1} then a normal evaluation of the @code{Events} function is performed and the information from the @code{Events} evaluation is returned (cf. @file{odepkg_event_handle.m} for further details). If @var{vdeci} is @code{2} then cleanup of the @code{Events} function is performed and nothing is returned. The input arguments of this function are
@itemize @minus
@item @var{veve}: The @code{Events} function that is evaluated
@item @var{vt}: The time stamp at which the events function is called
@item @var{vy}: The solutions of the set of ODEs at time @var{vt}
@item @var{vextarg}: Extra arguments that are feed through to the @code{Events} function
@item @var{vdeci}: A decision flag that describes what evaluation should be done
@end itemize
@end deftypefn


@deftypefn {Function} octave_idx_type odepkg_auxiliary_evalplotfun (octave_value vplt, octave_value vsel, octave_value vt, octave_value vy, octave_value_list vextarg, octave_idx_type vdeci)

Return a constant that comes from the evaluation of the @code{OutputFcn} function. The return argument depends on the call to this function, ie. if @var{vdeci} is @code{0} then initilaization of the @code{OutputFcn} function is performed and nothing is returned. If @var{vdeci} is @code{1} then a normal evaluation of the @code{OutputFcn} function is performed and either the constant @code{true} is returned if solving should be stopped or @code{false} is returned if solving should be continued (cf. @file{odeplot.m} for further details). If @var{vdeci} is @code{2} then cleanup of the @code{OutputFcn} function is performed and nothing is returned. The input arguments of this function are
@itemize @minus
@item @var{vplt}: The @code{OutputFcn} function that is evaluated
@item @var{vsel}: The output selection vector for which values should be treated
@item @var{vt}: The time stamp at which the events function is called
@item @var{vy}: The solutions of the set of ODEs at time @var{vt}
@item @var{vextarg}: Extra arguments that are feed through to the @code{OutputFcn} function
@item @var{vdeci}: A decision flag that describes what evaluation should be done
@end itemize
@end deftypefn


@deftypefn {Function} octave_value_list odepkg_auxiliary_evaljacide (octave_value vjac, octave_value vt, octave_value vy, octave_value vdy, octave_value_list vextarg)

Return two matrices that come from the evaluation of the @code{Jacobian} function. The input arguments of this function are
@itemize @minus
@item @var{vjac}: The @code{Jacobian} function that is evaluated
@item @var{vt}: The time stamp at which the events function is called
@item @var{vy}: The solutions of the set of IDEs at time @var{vt}
@item @var{vdy}: The derivatives of the set of IDEs at time @var{vt}
@item @var{vextarg}: Extra arguments that are feed through to the @code{Jacobian} function
@end itemize

@indent @b{Note:} This function can only be used for IDE problem solvers.
@end deftypefn


@deftypefn {Function} octave_value odepkg_auxiliary_evaljacode (octave_value vjac, octave_value vt, octave_value vy, octave_value_list vextarg)

Return a matrix that comes from the evaluation of the @code{Jacobian} function. The input arguments of this function are
@itemize @minus
@item @var{vjac}: The @code{Jacobian} function that is evaluated
@item @var{vt}: The time stamp at which the events function is called
@item @var{vy}: The solutions of the set of ODEs at time @var{vt}
@item @var{vextarg}: Extra arguments that are feed through to the @code{Jacobian} function
@end itemize

@indent @b{Note:} This function can only be used for ODE and DAE problem solvers.
@end deftypefn


@deftypefn {Function} octave_value odepkg_auxiliary_evalmassode (octave_value vmass, octave_value vstate, octave_value vt, octave_value vy, octave_value_list vextarg)

Return a matrix that comes from the evaluation of the @code{Mass} function. The input arguments of this function are
@itemize @minus
@item @var{vmass}: The @code{Mass} function that is evaluated
@item @var{vstate}: The state variable that either is the string @code{'none'}, @code{'weak'} or @code{'strong'}
@item @var{vt}: The time stamp at which the events function is called
@item @var{vy}: The solutions of the set of ODEs at time @var{vt}
@item @var{vextarg}: Extra arguments that are feed through to the @code{Mass} function
@end itemize

@indent @b{Note:} This function can only be used for ODE and DAE problem solvers.
@end deftypefn


@deftypefn {Function} octave_value odepkg_auxiliary_makestats (octave_value_list vstats, octave_idx_type vprnt)

Return an @var{octave_value} that contains fields about performance informations of a finished solving process. The input arguments of this function are
@itemize @minus
@item @var{vstats}: The statistics informations that need to be handled
@enumerate
@item hello
@end enumerate
@item @var{vprnt}: If @code{true} then the statistics information also is displayed on screen
@end itemize
@end deftypefn


@deftypefn {Function} octave_idx_type odepkg_auxiliary_mebdfanalysis (octave_idx_type verr)
TODO
@end deftypefn


@deftypefn {Function} octave_idx_type odepkg_auxiliary_solstore (octave_value &vt, octave_value &vy, octave_value vsel, octave_idx_type vdeci)

If @var{vdeci} is @code{0} (@var{vt} is a pointer to the initial time step and @var{vy} is a pointer to the initial values vector) then this function is initialized. Otherwise if @var{vdeci} is @code{1} (@var{vt} is a pointer to another time step and @var{vy} is a pointer to the solution vector) the values of @var{vt} and @var{vy} are added to the internal variable, if @var{vdeci} is @code{2} then the internal vectors are returned. The input arguments of this function are
@itemize @minus
@item @var{vt}: The time stamp at which the events function is called
@item @var{vy}: The solutions of the set of ODEs at time @var{vt}
@item @var{vsel}: The selection vector for which values should be treated
@item @var{vdeci}: A decision flag that describes what evaluation should be done
@end itemize
@end deftypefn


@subsection Source File @file{odepkg_octsolver_mebdfi.cc}

@deftp {Typedef} {octave_idx_type (*odepkg_mebdfi_usrtype)}
This @code{typedef} is used to define the input and output arguments of the user function for the IDE problem that is further needed by the Fortran core solver @code{mebdfi}. The implementation of this @code{typedef} is

@example
typedef octave_idx_type (*odepkg_mebdfi_usrtype)
  (const octave_idx_type& N, const double& T, const double* Y, 
   double* DELTA, const double* YPRIME, const octave_idx_type* IPAR,
   const double* RPAR, const octave_idx_type& IERR);
@end example
@end deftp


@deftp {Typedef} {octave_idx_type (*odepkg_mebdfi_jactype)}

This @code{typedef} is used to define the input and output arguments of the @code{Jacobian} function for the IDE problem that is further needed by the Fortran core solver @code{mebdfi}. The implementation of this @code{typedef} is

@example
typedef octave_idx_type (*odepkg_mebdfi_jactype)
  (const double& T, const double* Y, double* PD, const octave_idx_type& N,
   const double* YPRIME, const octave_idx_type* MBND, const double& CON,
   const octave_idx_type* IPAR, const double* RPAR, const octave_idx_type& IERR);
@end example
@end deftp


@deftp {Prototype} {F77_RET_T F77_FUNC (mebdfi, MEBDFI)} (const octave_idx_type& N, const double& T0, const double& HO, const double* Y0, const double* YPRIME, const double& TOUT, const double& TEND, const octave_idx_type& MF, octave_idx_type& IDID, const octave_idx_type& LOUT, const octave_idx_type& LWORK, const double* WORK, const octave_idx_type& LIWORK, const octave_idx_type* IWORK, const octave_idx_type* MBND, const octave_idx_type& MAXDER, const octave_idx_type& ITOL, const double* RTOL, const double* ATOL, const double* RPAR, const octave_idx_type* IPAR, odepkg_mebdfi_jactype, odepkg_mebdfi_usrtype, octave_idx_type& IERR);

The prototype @code{F77_FUNC (mebdfi, MEBDFI)} is used to represent the information about the Fortran core solver @code{mebdfi} that is defined in the Fortran source file @file{mebdfi.f} (cf. the Fortran source file @file{mebdfi.f} for further details).
@end deftp


@deftypevr {Variable} {static octave_value_list} {vmebdfiextarg}

This static variable is used to store the extra arguments that are needed by some or by all of the @code{OutputFcn}, the @code{Jacobian} function and the @code{Events} function while solving the IDE problem.
@end deftypevr


@deftypevr {Variable} {static octave_value} {*vmebdfiodefun}

This static variable is used to store the value for the user function that defines the set of IDEs.
@end deftypevr


@deftypevr {Variable} {static octave_value} {vmebdfijacfun}

This static variable is used to store the value for the @code{Jacobian} function or the @code{Jacobian} matrix that is needed if Jacobian evaluation should be performed.
@end deftypevr


@deftypefn {Function} {octave_idx_type} {odepkg_mebdfi_usrfcn} (const octave_idx_type& N, const double& T, const double* Y, double* DELTA, const double* YPRIME, GCC_ATTR_UNUSED const octave_idx_type* IPAR, GCC_ATTR_UNUSED const double* RPAR, GCC_ATTR_UNUSED const octave_idx_type& IERR)

Return @code{true} if the evaluation of the user function was successful, return @code{false} otherwise. This function is directly called from the Fortran core solver @code{mebdfi}. The input arguments of this function are

@itemize @minus
@item @var{N}: The number of equations that are defined for the IDE--problem
@item @var{T}: The actual time stamp for the current function evaluation
@item @var{Y}: The function values from the last successful integration step of length @var{N}
@item @var{DELTA}: The residual vector that needs to be calculated of length @var{N}
@item @var{YPRIME}: The derivative values from the last successful integration step of length @var{N}
@item @var{IPAR}: The integer parameters that are passed to the user function (unused)
@item @var{RPAR}: The real parameters that are passed to the user function (unused)
@item @var{IERR}: The error flag that can be set on each evaluation (unused)
@end itemize
@end deftypefn


@deftypefn {Function} {octave_idx_type} {odepkg_mebdfi_jacfcn} (const double& T, const double* Y, double* PD, const octave_idx_type& N, const double* YPRIME, GCC_ATTR_UNUSED const octave_idx_type* MBND, const double& CON, GCC_ATTR_UNUSED const octave_idx_type* IPAR, GCC_ATTR_UNUSED const double* RPAR, GCC_ATTR_UNUSED const octave_idx_type& IERR)

Return @code{true} if the evaluation of the Jacobian function (that is defined for a special IDE problem in Octave) was successful, otherwise return @code{false}. This function is directly called from the Fortran core solver @code{mebdfi}. The input arguments of this function are

@itemize @minus
@item @var{T}: The actual time stamp for the current function evaluation
@item @var{Y}: The function values from the last successful integration step of length @var{N}
@item @var{PD}: The values of partial derivatives of the Jacobian matrix of size @var{N}
@item @var{N}: The number of equations that are defined for the IDE--problem
@item @var{YPRIME}: The derivative values from the last successful integration step of length @var{N}
@item @var{MBND}: A vector of size 4 describing the sizes of a banded Jacobian (unused)
@item @var{CON}: A constant value that is set before the evaluation of the Jacobian function
@item @var{IPAR}: The integer parameters that are passed to the user function (unused)
@item @var{RPAR}: The real parameters that are passed to the user function (unused)
@item @var{IERR}: The error flag that can be set on each evaluation (unused)
@end itemize
@end deftypefn


@deftypefn {Function} {} {DEFUN_DLD} {(odebdi, args, nargout, 'help string')}

Return the results of the solving process of the IDE problem from the Fortran core solver @code{mebdfi} to the caller function (cf. @command{help odebdi} within Octave for further details about this function). the Argument @var{odebdi} is the name of the function that can be used in Octave and @var{'help string'} is the help text that is displayed if the command @command{help odebdi} is called from Octave. The input arguments of this function are
@itemize @minus
@item @var{args}: The input arguments in form of an @code{octave_value_list}
@item @var{nargout}: The number of output arguments that are required
@end itemize
@end deftypefn


