#!/usr/bin/env perl
#
# Albert Danial Mar 21 2002
#
# Creates .html files documenting all the functions in octave and
# octave-forge.  Needs:
#  - a master index list mapping functions to toolboxes (trim.idx)
#  - an .html file created by cvs-tree
#  - a directory pointing to the source of the latest release of octave
#
use strict;
use File::Find;
use File::Basename;
use Text::Wrap;
use FileHandle;
use IPC::Open3;
use POSIX ":sys_wait_h";

my $script  = basename($0);
my $OCTAVE  = "../octave";  # location of the octave sources; symlink them
			    # beside octave-forge if they are somewhere else
			    # or modify this script
my $CVSTREE = "cvs-tree.html";
die "Cannot read $CVSTREE  -- edit $script and define the\n",
    ".html file which was produced by the cvs-tree script\n" unless -r $CVSTREE;

# initialize the indexing variables
my %index_by_TB_cat   = (); # i_TB_cat{toolbox}{category} = list of functions
my %index_by_function = (); # i_function{function} =[ [toolbox_1,category_1],
#                         [toolbox_2,category_2],..]
my %TB_description    = ();
my %index_notes = (); # index_notes{function} = comment

# find and load all indices
my @index_files = ();
find(\&index_files, ".");
sub index_files { # {{{1 populates global array @files
    return unless -f and /INDEX$/;  # INDEX files
    push @index_files, "$File::Find::dir/$_";
} # 1}}}
foreach my $f ( @index_files ) {
    load_index($f,
	       \%index_by_TB_cat,
	       \%TB_description,
	       \%index_by_function);
}

my $location = `pwd`;
my $PATH     = "";
if ($location =~ m\^(.*)/admin$\) {
    chdir "..";
    $PATH = "$1/";
}

# locate all C++ and m-files in octave-forge, and all m-files in octave
# don't need C++ files from octave because we have DOCSTRINGS
my @m_files = ();
my @C_files = ();
find(\&cc_and_m_files, ".");
find(\&cc_and_m_files, "$OCTAVE/scripts");
sub cc_and_m_files { # {{{1 populates global array @files
    return unless -f and /\.(m|cc)$/;  # .m and .cc files
    if (/\.m$/) {
        push @m_files, "$File::Find::dir/$_";
    } else {
        push @C_files, "$File::Find::dir/$_";
    }
} # 1}}}

my %function_description  = ();
my %octave_forge_function = ();
my @uncategorized = ();
my %n_appearances = ();
my $n_functions = 0;

# grab help from C++ files
foreach my $f ( @C_files ) {
    if ( open(IN,$f) ) {
	while (<IN>) {
	    # skip to the next function
	    next unless /^DEFUN_DLD/;

	    # extract function name to pattern space
	    /\((\w*)\s*,/;
	    # remember function name
	    my $function = $1;
	    # skip to next line if comment doesn't start on this line
	    # XXX FIXME XXX maybe we want a loop here?
	    $_ = <IN> unless /\"/;
	    # skip to the beginning of the comment string by
	    # chopping everything up to opening "
	    my $desc = $_;
            $desc =~ s/^[^\"]*\"//;
	    # join lines until you get the end of the comment string
	    # plus a bit more.  You need the "plus a bit more" because
	    # C compilers allow implicitly concatenated string constants
	    # "A" "B" ==> "AB".
	    while ($desc !~ /[^\\]\"\s*\S/ && $desc !~ /^\"/) {
		# if line ends in '\', chop it and the following '\n'
		$desc =~ s/\\\s*\n//;
		# join with the next line
		$desc .= <IN>;
		# eliminate consecutive quotes, being careful to ignore
		# preceding slashes. XXX FIXME XXX what about \\" ?
		$desc =~ s/([^\\])\"\s*\"/$1/;
	    }
	    $desc = "" if $desc =~ /^\"/; # chop everything if it was ""
	    $desc =~ s/\\n/\n/g;          # insert fake line ends
	    $desc =~ s/([^\"])\".*$/$1/;  # chop everything after final '"'
	    $desc =~ s/\\\"/\"/;          # convert \"; XXX FIXME XXX \\"

	    # register the function with a brief description
	    register_function($function,$desc,$f);
	}
	close (IN);
    } else {
	print STDERR "Could not open file ($f): $!\n";
    }
}

# grab help from m-files (octave-forge and octave)
foreach my $f ( @m_files ) {
    my $desc     = extract_description($f);
    my $function = basename($f, ('.m'));
    die "Null function?? [$f]\n" unless $function;
    register_function($function,$desc,$f);
}

# grab help from octave's DOCSTRINGS
if (open (IN,"$OCTAVE/src/DOCSTRINGS")) {
    $_ = <IN>;
    while (/^\c_/) {
	my $function = $_;
	$function =~ s/^\c_//;
	$function =~ s/\n$//;
	my $desc = "";
	while (<IN>) {
	    last if /^\c_/;
	    $desc .= $_;
	}
	register_function($function,$desc,$OCTAVE);
    }
    close(IN);
}
else {
    print STDERR "could not open $OCTAVE/src/DOCSTRINGS !\n";
}

if (@uncategorized) {
    print scalar(@uncategorized), " uncategorized functions ";
    print "(out of ", $n_functions, " total)\n";
    my $rs = $,; $, = "\n";
    print sort(@uncategorized); $, = $rs;
    print "\n";
#    print wrap("\t", "\t", join(" ", sort @uncategorized)), "\n";
}


write_html(\%index_by_TB_cat,
           \%TB_description,
           \%function_description,
           \%octave_forge_function,
           \%index_by_function);


sub first_sentence { # {{{1
# grab the first real sentence from the function documentation
    my ($desc) = @_;
    my $retval = '';
    my $line;
    my $next;
    my @lines;

    my $trace = 0;
    # $trace = 1 if $desc =~ /Levenberg/;
    return "" unless defined $desc;
    if ($desc =~ /^[^\n]*-\*- texinfo -\*-/) {

	# help text contains texinfo.  Strip the indicator and run it
	# through makeinfo. (XXX FIXME XXX this needs to be a function)
	$desc =~ s/-\*- texinfo -\*-\w*//;
	my $cmd = "makeinfo --fill-column 1600 --no-warn --no-validate --no-headers --force";
	open3(*Writer, *Reader, *Errer, $cmd) or die "Could not run info";
	print Writer "\@macro seealso {args}\n\n\@noindent\nSee also: \\args\\.\n\@end macro\n";
	print Writer "$desc"; close(Writer);
	@lines = <Reader>; close(Reader);
	my @err = <Errer>; close(Errer);
	waitpid(-1,&WNOHANG);

	# Display source and errors, if any
	if (@err) {
	    my $n = 1;
	    foreach $line ( split(/\n/,$desc) ) {
		printf "%2d: %s\n",$n++,$line;
	    }
	    print ">>> @err";
	}

	# Print trace showing formatted output
#	print "<texinfo--------------------------------\n";
#	print @lines;
#	print "--------------------------------texinfo>\n";

	# Skip prototype and blank lines
	while (1) {
	    return "" unless @lines;
	    $line = shift @lines;
	    next if $line =~ /^\s*-/;
	    next if $line =~ /^\s*$/;
	    last;
	}

    } else {

#	print "<plain--------------------------------\n";
#	print $desc;
#	print "--------------------------------plain>\n";

	# Skip prototype and blank lines
	@lines = split(/\n/,$desc);
	while (1) {
	    return "" if ($#lines < 0);
	    $line = shift @lines;
	    next if $line =~ /^\s*[Uu][Ss][Aa][Gg][Ee]/; # skip " usage "

	    $line =~ s/^\s*\w+\s*://;             # chop " blah : "
	    print "strip blah: $line\n" if $trace;
	    $line =~ s/^\s*[Ff]unction\s+//;      # chop " function "
	    print "strip function $line\n" if $trace;
	    $line =~ s/^\s*\[.*\]\s*=\s*//;       # chop " [a,b] = "
	    print "strip []= $line\n" if $trace;
	    $line =~ s/^\s*\w+\s*=\s*//;          # chop " a = "
	    print "strip a= $line\n" if $trace;
	    $line =~ s/^\s*\w+\s*\([^\)]*\)\s*//; # chop " f(x) "
	    print "strip f(x) $line\n" if $trace;
	    $line =~ s/^\s*[;:]\s*//;                # chop " ; "
	    print "strip ; $line\n" if $trace;

	    $line =~ s/^\s*[[:upper:]][[:upper:]0-9_]+//; # chop " BLAH"
	    print "strip BLAH $line\n" if $trace;
	    $line =~ s/^\s*\w*\s*[-]+\s+//;        # chop " blah --- "
	    print "strip blah --- $line\n" if $trace;
	    $line =~ s/^\s*\w+ *\t\s*//;          # chop " blah <TAB> "
	    print "strip blah <TAB> $line\n" if $trace;
	    $line =~ s/^\s*\w+\s\s+//;            # chop " blah  "
	    print "strip blah <NL> $line\n" if $trace;

#	    next if $line =~ /^\s*\[/;           # skip  [a,b] = f(x)
#	    next if $line =~ /^\s*\w+\s*(=|\()/; # skip a = f(x) OR f(x)
	    next if $line =~ /^\s*or\s*$/;      # skip blah \n or \n blah
	    next if $line =~ /^\s*$/;            # skip blank line
	    next if $line =~ /^\s?!\//;          # skip # !/usr/bin/octave
	    # XXX FIXME XXX should be testing for unmatched () in proto
	    # before going to the next line!
	    last;
	}
    }

    # Try to make a complete sentence, including the '.'
    if ( "$line " !~ /[^.][.]\s/ && $#lines >= 0) {
	my $next = $lines[0];
	$line =~ s/\s*$//;  # trim trailing blanks on last
	$next =~ s/^\s*//;    # trim leading blanks on next
	$line .= " $next" if "$next " =~ /[^.][.]\s/; # ends the sentence
    }

    # Tidy up the sentence.
    chomp $line;          # trim trailing newline, if there is one
    $line =~ s/^\s*//;    # trim leading blanks on line
    $line =~ s/([^.][.])\s.*$/$1/; # trim everything after the sentence
    print "Skipping:\n$desc---\n" if $line eq "";

    # And return it.
    return $line;

} # 1}}}
sub register_function { # {{{1
# register the function and its one-line description
    my ($function,      # in   $index{toolbox}{category} = [functions]
        $desc,          # in   $toolbox_desc{toolbox} = description
	$file,
       )      = @_;
    ++$n_appearances{$function};
    if ($n_appearances{$function} > 1) {
#        print "$file:$function appeared previously\n";
    } else {
        ++$n_functions;
    }
    $octave_forge_function{$function} = 1 unless $file =~ /^$OCTAVE/;
    if (!defined $index_by_function{$function}) {
        push @uncategorized, "$file/$function";
    }

    my $oneline = first_sentence($desc);
    printf "%30s %s\n", $function, $oneline;
    $function_description{$function} = $oneline;
#    push @function_description{$function}}, "$file\n$oneline\n$desc";
    #printf "%-12s %-20s %s\n", $function,
    #                           $index_by_function{$function}[0],
    #                           $index_by_function{$function}[1];
} # 1}}}
sub extract_description { # {{{1
# grab the entire documentation comment from an m-file
    my ($file) = @_;
    my $retval = '';

    if( open( IN, "$file")) {
	# skip leading blank lines
	while (<IN>) {
	    last if /\S/;
	}
	if( m/\s*[%\#][\s\#%]* Copyright/) {
	    # next block is copyright statement, skip it
	    while (<IN>) {
		last unless /^\s*[%\#]/;
	    }
	}
	# Skip everything until the next comment block
	while ( !/^\s*[\#%]/ ) {
	    $_ = <IN>;
	    last if not defined $_;
	}
        # Return the next comment block as the documentation
        while (/^\s*[\#%]/) {
	    s/^[\s%\#]*//;    # strip leading comment characters
            s/[\cM\s]*$//;   # strip trailing spaces.
	    $retval .= "$_\n";
	    $_ = <IN>;
	    last if not defined $_;
	}
        close(IN);
	return $retval;
    }
    else {
	print STDERR "Could not open file ($file): $!\n";
    }
} # 1}}}
sub load_index { # {{{1
    my ($file,             # in
        $rhha_TB_cat,      # out   $TB_cat{toolbox}{category} = [functions]
        $rh_toolbox_desc,  # out   $toolbox_desc{toolbox} = description
        $rhaa_func,        # out   $func{function} = [[toolbox_1,category_1],
                           #                          [toolbox_2,category_2],..]
       )      = @_;
    my $toolbox     = "extra";
    my $category    = "";
    my $description = "";
    my $function    = "";
    open(IN, $file) or die "Cannot read $file:  $!\n";
    my %map;   # simple macros for use in notes
    while (<IN>) {
        next if /^\s*$/; # skip blank lines
	next if /^\s*\#/; # skip comment lines
        chomp;
        if      (/^(.*?)\s*>>\s*(.*?)$/) {
	    # toolbox lines contain "word >> description"
            $toolbox     = $1;
            $description = $2;
            $category    = "";
            $rh_toolbox_desc->{$toolbox} = $description;
	} elsif (/^\s*\$(\w+)\s*=\s*(\S.*\S)\s*$/) {
	    # define a variable as "$var = expansion"
	    $map{$1} = $2;
        } elsif (/^(\w.*?)\s*$/) {
	    # category lines start in the left most column
            $category    = $1;
        } elsif (/^\s+(\S+)\s*=\s*(\S.*\S)\s*$/) {
	    my $func = $1;
	    my $desc = $2;

	    # expand all $id in the description
	    my @parts = split('\$', "$desc");
	    foreach my $i ( 1 .. $#parts ) {
		$parts[$i] =~ /^(\w+)(\W.*)$/ or $parts[$i] =~ /^(\w+)()$/;
		$parts[$i] = "$map{$1}$2";
	    }
	    $desc = join("",@parts);

	    $index_notes{$func} = $desc;
	    die "Function $function (line $.) has no category" unless $category;
	    push @{$rhha_TB_cat->{$toolbox}{$category}}, $func;
	    push @{$rhaa_func->{$func}}, [$toolbox, $category];
	} else {
            s/^\s+//;
            my @list = split /\s+/;
            while ($#list >= 0) {
                $function    = shift @list;
                die "Function $function (line $.) has no category" unless $category;
                push @{$rhha_TB_cat->{$toolbox}{$category}}, $function;
                push @{$rhaa_func->{$function}}, [$toolbox, $category];

            }
        }
    }
    close(IN);
} # 1}}}
sub write_html { # {{{1
    my ($rhha_TB_cat,      # in   $index{toolbox}{category} = [functions]
        $rh_toolbox_desc,  # in   $toolbox_desc{toolbox} = description
        $rh_func_desc,     # in   $func_desc{function}   = description
        $rh_oct_forge_f,   # in   $oct_forge_f{function} = 1 if function is
                           #           implemented in octave-forge
        $rhaa_func_TB_cat, # i_function{function} = [[toolbox, category],...]
       )      = @_;
    my $max_TB_across_top = 7;
    my $all_toolboxes = "<center>\n";
    my $n = 0;

    # make empty html directories
    unlink <index/*.html>;
    unlink <index/f/*.html>;
    mkdir "index";
    mkdir "index/f";


    foreach my $TB (sort keys %{$rhha_TB_cat}) {
        ++$n;
        if ($n > $max_TB_across_top) {
            $n = 0;
            $all_toolboxes .= "<a href=\"$TB.html\">$TB</a> <br> ";
        } else {
            $all_toolboxes .= "<a href=\"$TB.html\">$TB</a> | ";
        }
    }
    $all_toolboxes =~ s/\s+\|\s*$//;  # strip last pipe separator
    $all_toolboxes .= "<br><br>";
    my $A_to_Z     = "";
    foreach ('A'..'Z') {
        $A_to_Z .= "<a href=\"all_functions.html#$_\">$_</a> | ";
    }
    $A_to_Z         =~ s/\s+\|\s*$//;  # strip last pipe separator
    my $all_toolboxes_A_Z = $all_toolboxes . "$A_to_Z </center>\n";
    $all_toolboxes .= "</center>\n";

    # Write a file for each toolbox.
    #
    $Text::Wrap::columns = 50;
    foreach my $TB (sort keys %{$rhha_TB_cat}) {
        my $file   = "index/$TB.html";
        my %anchor = ();

        open(OUT, ">$file") or die "Cannot write $file:  $!\n";
        print OUT "<html><head>
        <title>$TB</title>
           <meta name=\"keywords\" content=\"\"> </head><body>\n";

        print OUT $all_toolboxes_A_Z;
        # Heading 1:  The categories for this toolbox.
        print OUT "<p><h1>$rh_toolbox_desc->{$TB}</h1>\n";
        print OUT "<ul>\n";
        foreach my $cat (sort keys %{$rhha_TB_cat->{$TB}}) {
            $anchor{$cat} = $cat;
            $anchor{$cat} =~ s/\W+//g;
            print OUT "    <li><a href=\"#$anchor{$cat}\">$cat</a></li>\n";
        }
        print OUT "</ul>\n";

        # Heading 2:  Each category has a table of its functions and
        #             their descriptions.
        foreach my $cat (sort keys %{$rhha_TB_cat->{$TB}}) {
            print OUT '<h2><a name="', $anchor{$cat}, '">', $cat, "</a></h2>\n";
            print OUT "<table>\n";
            foreach my $func (sort @{$rhha_TB_cat->{$TB}{$cat}}) {

                # column 1:  the function (x-ref to full description in
                #                          cvs-tree's html file)
                print OUT "<tr><td>";
                if (defined $rh_oct_forge_f->{$func}) {
                    print OUT '<a href="',"../$CVSTREE#$func",'">',$func,"</a>";
                } else {
                    print OUT $func;
                }
                print OUT "</td>\n";

                # column 2: the description, if it exists
                #
		if (! defined $rh_func_desc->{$func} ) {
		    my $notes = $index_notes{$func};
		    $notes = "not implemented" if $notes eq "";
		    $notes =~ s|<code>|</b></i><code>|g;
		    $notes =~ s|</code>|</code><i><b>|g;
                    print OUT "    <td><i><b>$notes</b></i>";
		} elsif ($rh_func_desc->{$func} eq "") {
                    print OUT "    <td><i><b>no description</b></i>";
		} else {
		    print OUT "    <td>", $rh_func_desc->{$func};
#		        wrap("", "<br>",$rh_func_desc->{$func});
                }
                print OUT "</td></tr>\n";
            }
            print OUT "</table>\n";
        }
        print OUT "</body></html>\n";
        close(OUT);
    }

    # Write the file containing all functions alphabetically.
    #
    my $file   = "index/all_functions.html";
    open(OUT, ">$file") or die "Cannot write $file:  $!\n";
    print OUT "<html><head>
    <title>Octave-Forge Functions Alphabetically</title>
       <meta name=\"keywords\" content=\"\"> </head><body>\n";
    print OUT $all_toolboxes;

    foreach my $Letter ('A'..'Z') {
        print OUT "<p><p><center><b><a name=\"$Letter\">$Letter</a></b> ";
        print OUT '&nbsp; &nbsp; &nbsp; || &nbsp; &nbsp; &nbsp; ',
                  "$A_to_Z </center>\n";
        print OUT "<table>\n";
        foreach my $func (sort keys %{$rhaa_func_TB_cat}) {
            next unless uc(substr($func, 0, 1)) eq $Letter;
            # the loop below has more than one iteration only for functions
            # which appear in multiple toolboxes
            for (my $i=0; $i < scalar @{$rhaa_func_TB_cat->{$func}}; $i++){

                # column 1:  the function (x-ref to full description in
                #                          cvs-tree's html file)
                print OUT "<tr><td>";
                if (defined $rh_oct_forge_f->{$func}) {
                    print OUT '<a href="',"../$CVSTREE#$func",'">',$func,"</a>";
                } else {
                    print OUT $func;
                }
                print OUT "</td>\n";

                # column 2:  the toolbox (x-ref to the <toolbox>.html file)
                my $TB = $rhaa_func_TB_cat->{$func}[$i][0];
                print OUT '    <td><a href="', $TB, '.html">', $TB, "</a>\n";

#                # column 3:  the category within the toolbox
#                $Text::Wrap::columns = 40;
#                print OUT "    <td>",
#                      wrap("", "<br>",
#                           $rhaa_func_TB_cat->{$func}[$i][1]), "</td>\n";

                # column 4:  the function's description
                $Text::Wrap::columns = 50;
                print OUT "    <td>";
                print OUT wrap("", "<br>", $rh_func_desc->{$func})
                    if defined $rh_func_desc->{$func};
                print  OUT "</td>\n";
            }
        }
        print OUT "</table>\n";
    }
    print OUT "</body></html>\n";
    close(OUT);
} # 1}}}
__END__
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
This program is granted to the public domain.
THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.
