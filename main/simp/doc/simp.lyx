#LyX 1.5.6 created this file. For more info see http://www.lyx.org/
\lyxformat 276
\begin_document
\begin_header
\textclass article
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\paperfontsize default
\spacing single
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Single Interval Mathematics Package for Octave
\end_layout

\begin_layout Standard

\newpage

\end_layout

\begin_layout Standard
\begin_inset LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard

\newpage

\end_layout

\begin_layout Section
Author and version
\end_layout

\begin_layout Standard
I am Simone Pernice and I am the writer of the SIMP pachage.
 If you find any bug or you want to add features, you can contact me at
 pernice@libero.it.
 You can find further details on my web site: simonepernice.freehostia.com
\end_layout

\begin_layout Standard
List of versions of this document:
\end_layout

\begin_layout Itemize
Version 1.0, Turin 14th December 2008, initial draft
\end_layout

\begin_layout Section
Preface
\end_layout

\begin_layout Standard
I am an engineer, I worked on hardware and software fields.
 To design an electrical circuit is quite complex because the characteristics
 of the components involved have huge tolerance some about 5%, while others
 80%.
 The engineer has the target to have the circuit working in the worst case
 of the components and of the environment.
 That involves to compute several time the same equation putting inside
 the worst or best case values.
 Some time ago I was doing the usual design when I though, what if I use
 intervals instead of numbers: I may get the results in just one step! Then
 I went on the Internet looking for Interval Mathematics: I discovered it
 was invented in the '50s.
 Eventually I looked for a open source calculator able to manage intervals
 instead of Numbers.
 Unfortunately I was not able to find anything.
 There are just some libraries for C++ language and packages for proprietary
 software.
 I was thinking to develop a calculator on my own, but I was not that happy
 because it would have required a lot of effort.
 Then I discovered Octave.
 After a loot at its tutorial I decided to write a package to work on intervals
 in Octave.
 It was the right choice, because it tooks just three days while to make
 a new program from scratch would have taken weeks.
 The package extends the basic function to single interval mathematics,
 it is called SIMP.
 Unfortunately it is not possible to overload Octave operators, therefore
 new functions working on matrix were added for that purpose.
\end_layout

\begin_layout Standard
\begin_inset LatexCommand prettyref
reference "sec:Introduction"

\end_inset

 shows why numbers are not the best tool when computing real world measures.
 
\begin_inset LatexCommand prettyref
reference "sec:Intervals"

\end_inset

 explains what is an interval and how a function can be extended to work
 on intervals.
 
\begin_inset LatexCommand prettyref
reference "sec:Issues-with-interval"

\end_inset

 explains some issues to be aware when making interval calculations, which
 are not present in the number computation.
 
\begin_inset LatexCommand prettyref
reference "sec:Single-Interval-Mathematics"

\end_inset

 shows some examples to explain how the SIMP package can be used.
 Eventually the 
\begin_inset LatexCommand prettyref
reference "sec:Functions"

\end_inset

 provides the detailed list of functions available.
\end_layout

\begin_layout Section
Introduction
\begin_inset LatexCommand label
name "sec:Introduction"

\end_inset

 
\end_layout

\begin_layout Standard
Every day we need to compute the result of a lot of simple mathematical
 equations.
 For example the cost of the apples bought at the supermarket is given by
 the apple cost per kilo times the number of kilos bought: 
\begin_inset Formula $applePrice=appleCostPerKilo\times kilosOfAppleBought$
\end_inset

.
\end_layout

\begin_layout Standard
When we need the result of those mathematical expressions, we put the values
 on the right side of the equation and we got its result on the left side.
 Well, we usually put wrong numbers on the right side and therefore no doubt
 we get wrong results.
 There are a lot of reason why we put wrong values, below some of them follows:
 
\end_layout

\begin_layout Enumerate
Most of the values are measured, therefore they are known within a given
 tolerance (looking for accuracy and precision on Wikipedia will provide
 interesting information); 
\end_layout

\begin_layout Enumerate
Some values have an infinite number of digits after the decimal point, like
 for 
\begin_inset Formula $\pi$
\end_inset

 (the ratio between a circumference and its diameter); 
\end_layout

\begin_layout Enumerate
Some values change with time or samples or whatever, like the weight of
 a person (which can change of 5% during a day) or the current gain of a
 BJT (which can change of 50% from the samples of the same series); 
\end_layout

\begin_layout Enumerate
Some value are estimation or guess: something like between a minimum and
 a maximum.
 
\end_layout

\begin_layout Standard
For example if a pipe brakes and you want to buy a new one you need its
 diameter.
 If you do not have a caliber, you may measure its circumference and divide
 it by 
\begin_inset Formula $\pi$
\end_inset

 (3.1415...):
\begin_inset Formula $diameter=\frac{circumference}{\pi}$
\end_inset

.
\end_layout

\begin_layout Standard
Here there are two errors: the circumference is knows with the tolerance
 given by your meter, moreover 
\begin_inset Formula $\pi$
\end_inset

 has an infinite number of digits while only few of them can be used in
 the operation.
 You may think the error is negligible, the result is enough accurate to
 buy a new pipe in a hardware shop.
 However the not infinite accuracy of those operation avoid the use of computers
 as automatic theorem demonstration tools and so on...
\end_layout

\begin_layout Standard
This kind of issue is quite common on engineer design.
 What engineers do is to be sure their design will work in the worst case
 or in most of the cases (usually more than 99.9%).
 Here a simple example.
 Let us say you want to repaint the walls of your living room completely
 messed up by your children.
 You need to compute how many paint cans you need to buy.
 The equation is quite simple:
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
paintCans=\frac{2\times\left(roomWidth+roomLength\right)\times roomHeight}{paintLitersPerCan\times paintEfficiency}\label{eq:paintCans}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
where paintEfficiency is how may square meter of surface can be painted
 with a liter of paint.
 The problem here is that usually we do not have a meter long enough to
 measure the room width and length, it is much simpler to count the number
 of steps to go through it (1 step is about 1m, let us say from 0.9 to 1.1m).
 Moreover the paint provider usually declare a paint efficiency range.
 Let us put below the data: 
\end_layout

\begin_layout Itemize
roomWidth = 6 
\end_layout

\begin_layout Itemize
steps roomLength = 4 
\end_layout

\begin_layout Itemize
steps roomHeight = 3 
\end_layout

\begin_layout Itemize
meters paintEfficiency = from 0.7 to 1.3 square meters per liter (1 liter
 per square meter in average) 
\end_layout

\begin_layout Itemize
paintLitersPerCan = 40 
\end_layout

\begin_layout Standard
To compute the average result just put average values in 
\begin_inset LatexCommand eqref
reference "eq:paintCans"

\end_inset

.
 We get: 
\begin_inset Formula $paintCans=\frac{2\times\left(6+4\right)\times3}{40\times1}=1.5$
\end_inset


\end_layout

\begin_layout Standard
paint cans, which means two unless you are able to buy just half of a can.
 
\end_layout

\begin_layout Standard
Are you satisfied with that result? I am not.
 What if I have underestimated something? As every good engineer I would
 check what would happen in the worst case, which means 1.1m step and efficiency
 of just 0.8.
 Again just substituting those values in 
\begin_inset LatexCommand eqref
reference "eq:paintCans"

\end_inset

, we get: 
\begin_inset Formula $paintCans=\frac{2\times\left(6.6+4.4\right)\times3}{40\times0.7}=2.36$
\end_inset

.
 That is really interesting: in the worst case I would miss 0.36 cans, it
 makes sense to buy three cans to avoid to go back to the hardware shop
 to buy one more (in the worst case).
 
\end_layout

\begin_layout Standard
More happy with the result now? I am not completely satisfied, I am asking
 myself: what if in the best case I need just 1 can? In that case probably
 I need more accurate data because the result range would be too wide.
 Eventually from 
\begin_inset LatexCommand eqref
reference "eq:paintCans"

\end_inset

 we get: 
\begin_inset Formula $paintCans=\frac{2\times\left(5.4+3.6\right)\times3}{40\times1.3}=1.04$
\end_inset

.
 Which means two cans.
 I am satisfied, I have to buy at least two cans, but probably I may need
 one more.
 In the next paragraph you will see how to do all this stuff in one step
 using Octave and SIMP.
 
\end_layout

\begin_layout Section
Intervals
\begin_inset LatexCommand label
name "sec:Intervals"

\end_inset

 
\end_layout

\begin_layout Standard
As you can see in the example above a lot of computations are required to
 get an idea of the result.
 To get the worst (and sometime is required also best) case, you need also
 to think carefully at the equation because some time you need to put the
 higher value (for steps) while other times the smallest (for efficiency)
 to get the worst case and vice versa for the best.
 There is a much simpler way to work with that issue.
 You can use intervals instead of number.
 An interval is:
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
[a1,a2]=\left\{ \forall x\in\mathbb{R\mid\mathit{a1}\leqslant\mathit{x}\leqslant\mathit{a2}}\right\} ;a1,a2\in\mathbb{R\cup\left\{ -\infty,+\infty\right\} ;\mathit{a1}\leqslant\mathit{a2};}\label{eq:interval}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
In few words, [a, b] is the set of real numbers among a and b.
 Please note that intervals suit perfectly in all the cases where numbers
 do not fit (some were showed in the 
\begin_inset LatexCommand prettyref
reference "sec:Introduction"

\end_inset

).
 Moreover if it is correct to use a number, it is possible to use a degenerate
 interval like [a, a].
 It is possible also to define functions that work on interval instead of
 numbers:
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
f\left([a1,a2],[b1,b2],...\right)=\left\{ \forall f(a,b,...)\in\mathbb{R}\mid\exists a\in[a1,a2],b\in[b1,b2],...\right\} \label{eq:functionOnInterval}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Please note, with that definition it is possible to extend every function
 (like addition, multiplication, square, square root, ...) to work on intervals.
 
\end_layout

\begin_layout Standard
Note also sometime a function may generate several intervals as result,
 but in this package we will concentrate on single interval function.
 I will give you an example: 
\begin_inset Formula $[4,4]/[-2,2]=[-\infty,-2]\cup[2,+\infty]$
\end_inset

.
 However the result is a double interval, for that reason if you try to
 divide for a interval containing 0 in SIMP, you will get an error.
\end_layout

\begin_layout Standard
Eventually note that the usually compute the interval result of a function
 applied to intervals is computationally a long task.
 In those case we are satisfied by a bigger interval containing the correct
 interval.
 However the target is always to get the smaller interval containing the
 solution.
 In the example above you would have:
\end_layout

\begin_layout Itemize
roomWidth = [5.4, 6.6] meters 
\end_layout

\begin_layout Itemize
roomLength = [3.6, 4.4] meters 
\end_layout

\begin_layout Itemize
roomHeight = 3 = [3, 3] meters
\end_layout

\begin_layout Itemize
paintEfficiency = [0.7, 1.3] square meters per liter 
\end_layout

\begin_layout Itemize
paintLitersPerCan = 40 = [40, 40] liters per can
\end_layout

\begin_layout Standard
Now you have just to compute the equation once with extended function to
 get [1.04, 2.36] cans.
 SIMP, the Octave package I developed, extends all the basic mathematical
 functions and it provides functions to extend all other available Octave
 functions.
 
\end_layout

\begin_layout Section
Issues with interval computation
\begin_inset LatexCommand label
name "sec:Issues-with-interval"

\end_inset

 
\end_layout

\begin_layout Standard
There are few issues you need to know about interval computations.
 
\end_layout

\begin_layout Subsection
Variables independence 
\end_layout

\begin_layout Standard
All the variables you use to make a computation are independent from each
 other, although they are the same instance of variable for you.
 For example the perimeter of a rectangle (which was also used in a piece
 of the equation 
\begin_inset LatexCommand ref
reference "eq:paintCans"

\end_inset

) can be written in several different ways.
 If the dimensions of the rectangle are a end b we can write:
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
perimeter=2(a+b)\label{eq:perimetersmall}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
perimeter=a+a+b+b\label{eq:perimeterbig}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
In standard mathematics they are the same, while in interval mathematics
 we have the interval 
\begin_inset Formula $equation(\ref{eq:perimetersmall})\subseteqq equation(\ref{eq:perimeterbig})$
\end_inset

.
 The reason is that every interval that appears in the equation is not dependent
 from each other, therefore in equation 
\begin_inset LatexCommand ref
reference "eq:perimeterbig"

\end_inset

 is like having four different intervals.
 What is important to remember is that: 
\emph on
Every variable should appear just once in the equation if possible in order
 to get the smallest interval possible as result.
\end_layout

\begin_layout Subsection
Hyper-cube Overlapping
\end_layout

\begin_layout Standard
The result of a set of equation involving intervals is an Hyper-cube.
 For example if we have just two equations in the unknowns x and y the result
 will be a couple of intervals which draw a rectangle on the Cartesian plane.
 However in general the solution will be smaller, for example just a segment.
 In that case the rectangle will contain the solution.
 There is no way to solve that, just remember the solution is usually a
 super set of the actual one.
\end_layout

\begin_layout Section
Introduction on how the package works 
\begin_inset LatexCommand label
name "sec:Single-Interval-Mathematics"

\end_inset


\end_layout

\begin_layout Subsection
Installation
\end_layout

\begin_layout Standard
First of all you have to install the SIMP package in Octave, so that Octave
 will automatically load the new functions at every start.
 To do that just run Octave from the directory where was downloaded the
 package and execute the following command:
\end_layout

\begin_layout Itemize
pkg install simp.tar.gz
\end_layout

\begin_layout Subsection
Some example
\end_layout

\begin_layout Standard
SIMP works on matrix, interpreted as intervals.
 The basic interval is: [min, max], which in Octave is a row vector made
 by two elements.
 The added functions work on those matrix.
 For example to add the intervals [5.4, 6.6] and [3.6, 4.4] it is possible to
 write:
\end_layout

\begin_layout Itemize
addInt ([5.4, 6.6], [3.6, 4.4])
\end_layout

\begin_layout Description
> ans = [9, 11]
\end_layout

\begin_layout Standard
addInt stands for add intervals.
 It is possible to use scalar number instead of intervals.
 Every scalar is computed like: 
\begin_inset Formula $s=[s,s]$
\end_inset

.
 Therefore the following computations give the same result:
\end_layout

\begin_layout Itemize
addInt ([5.4, 6.6], 3.6)
\end_layout

\begin_layout Description
> ans = [9, 10.2]
\end_layout

\begin_layout Itemize
addInt ([5.4, 6.6], [3.6, 3.6])
\end_layout

\begin_layout Description
> ans = [9, 10.2]
\end_layout

\begin_layout Standard
Octave supports variable declaration, therefore it is possible to write:
\end_layout

\begin_layout Itemize
roomWidth = [5.4, 6.6];
\end_layout

\begin_layout Itemize
roomLength =[3.6, 4.4];
\end_layout

\begin_layout Itemize
addInt (roomWidth, roomLength)
\end_layout

\begin_layout Description
> ans = [9, 11]
\end_layout

\begin_layout Standard
Now we know enough from Octave to compute the equation 
\begin_inset LatexCommand ref
reference "eq:paintCans"

\end_inset

:
\end_layout

\begin_layout Itemize
roomHeight = 3;
\end_layout

\begin_layout Itemize
paintEfficiency = [0.7, 1.3]; 
\end_layout

\begin_layout Itemize
paintLitersPerCan = 40; 
\end_layout

\begin_layout Itemize
divInt(mulInt(2, addInt (roomWidth, roomLength), roomHeight), mulInt(paintLiters
PerCan, paintEfficiency)) 
\end_layout

\begin_layout Description
> ans = [1.0385, 2.3571]
\end_layout

\begin_layout Standard
Sometime the intervals are expressed in terms of tolerance.
 The electronic resistors are sold in several tolerances: 1%, 2%, 5%.
 There is a function to easily make an interval from a tolerance.
 For example a resistor of 10KOhms with 5% of tolerance can be converted
 in an interval:
\end_layout

\begin_layout Itemize
tollToInt (10000, 5)
\end_layout

\begin_layout Description
> ans = [9500, 10500]
\end_layout

\begin_layout Standard
If the tolerance is not symmetric, for example +5% and -10%:
\end_layout

\begin_layout Itemize
tollToInt (10000, 5, -10)
\end_layout

\begin_layout Description
> ans = [9000, 10500]
\end_layout

\begin_layout Standard
All the computations are done among intervals, therefore if a result with
 tolerance is required it is possible to get back the value and tolerance
 of an interval in the hypothesis that the tolerance is symmetrical:
\end_layout

\begin_layout Itemize
engFormInt([9500, 10500])
\end_layout

\begin_layout Description
> 10K+-5%
\end_layout

\begin_layout Standard
Eventually those functions work on vectors of intervals which may be useful
 to compute functions.
 It is possible to compute operation on vectors of the same size (element
 by element) or scalar by vector.
 In that case the scalar is expanded in a vector of the sime size of the
 others.
 That is really useful for the functions where a x vector can be used to
 compute a y in just one time.
\end_layout

\begin_layout Standard
As you can see SMIP can be used just like a calculator.
 The basic operations are applied on intervals instead of scalar.
 That makes really simple to evaluate equations where some data is uncertain.
\end_layout

\begin_layout Section
Functions
\begin_inset LatexCommand label
name "sec:Functions"

\end_inset


\end_layout

\begin_layout Standard
This section describe the functions provided in the package.
\end_layout

\begin_layout Subsection
Intervals
\end_layout

\begin_layout Standard
An interval is described by a matrix with two columns and a row.
 The matrix is composed by real numbers.
 The first value is the interval minimum, the second is the interval maximum.
 A real number is interpreted like an interval with the same maximum and
 minimum.
 It is also possible to write a vector of intervals: it is a matrix with
 two columns and n rows, where every row is an interval.
\end_layout

\begin_layout Subsection
addInt (a, b, c, ...) 
\end_layout

\begin_layout Standard
addInt adds the given vector of intervals.
 It returns 
\begin_inset Formula $a+b+c+\ldots$
\end_inset

 .
 They must have the same number of rows or be scalars.
 At least two vectors are required.
\end_layout

\begin_layout Subsection
negateInt (a)
\end_layout

\begin_layout Standard
negateInt negates the given vector of intervals.
 It returns 
\begin_inset Formula $-a$
\end_inset

.
\end_layout

\begin_layout Subsection
subInt (a, b, c, ...)
\end_layout

\begin_layout Standard
subInt subtracts the given vector of intervals.
 It returns 
\begin_inset Formula $a-b-c-\ldots$
\end_inset

 .
 They must have the same number of rows or be scalar.
 At least two vectors are required.
\end_layout

\begin_layout Subsection
mulInt (a, b, c, ...)
\end_layout

\begin_layout Standard
mulInt multiplies the given vector of intervals.
 It returns 
\begin_inset Formula $a\cdot b\cdot c\cdot\ldots$
\end_inset

 .
 They must have the same number of rows or be scalar.
 At least two vectors are required.
\end_layout

\begin_layout Subsection
invertInt (a)
\end_layout

\begin_layout Standard
invertInt inverts the given vector of intervals.
 It returns 
\begin_inset Formula $\frac{1}{a}$
\end_inset

.
\end_layout

\begin_layout Subsection
invertAddInt (a, b, c, ...)
\end_layout

\begin_layout Standard
invertAddInt adds the inverse of the given vector of intervals and then
 inverts again the result.
 It returns 
\begin_inset Formula $\frac{1}{\frac{1}{a}+\frac{1}{b}+\frac{1}{c+\ldots}}$
\end_inset

.
 They must have the same number of rows or be scalar.
 At least two vectors are required.
\end_layout

\begin_layout Subsection
divInt (a, b, c, ...)
\end_layout

\begin_layout Standard
divInt divides the given vector of intervals.
 It returns 
\begin_inset Formula $\frac{\frac{a}{b}}{c}\ldots$
\end_inset

 .
 They must have the same number of rows or be scalar.
 At least two vectors are required.
\end_layout

\begin_layout Subsection
powerInt (a, n)
\end_layout

\begin_layout Standard
powerInt rise the given vector of intervals to the power of n.
 It returns 
\begin_inset Formula $a^{n}$
\end_inset

.
\end_layout

\begin_layout Subsection
sqrInt (a)
\end_layout

\begin_layout Standard
sqrInt squares the given vector of intervals.
 It returns 
\begin_inset Formula $a^{2}$
\end_inset

.
\end_layout

\begin_layout Subsection
sqrtInt (a)
\end_layout

\begin_layout Standard
sqrtInt square roots the given vector of intervals.
 It returns 
\begin_inset Formula $\sqrt{a}$
\end_inset

.
\end_layout

\begin_layout Subsection
sqrAddInt (a, b, c, ...)
\end_layout

\begin_layout Standard
addSqrInt adds the square of the given vector of intervals and then it squares
 root the result.
 It returns 
\begin_inset Formula $\sqrt{a^{2}+b^{2}+c^{2}+\ldots}$
\end_inset

.
 They must have the same number of rows or be scalar.
 At least two vectors are required.
\end_layout

\begin_layout Subsection
engFormInt (a)
\end_layout

\begin_layout Standard
engFormInt prints the intervals in the vector a in engineer format.
 It prints the average between minimum and maximum expressed with engineer
 notation and add the tolerance in percentage.
\end_layout

\begin_layout Subsection
dB10ToLinInt (a)
\end_layout

\begin_layout Standard
db10ToLinInt rises 10 to the power of a tens.
 It returns 
\begin_inset Formula $10^{\frac{a}{10}}$
\end_inset

.
\end_layout

\begin_layout Subsection
linToDB10Int (a)
\end_layout

\begin_layout Standard
linToDB10Int produces 10 times the logarithm of a.
 It returns 
\begin_inset Formula $10log_{10}(a)$
\end_inset

.
\end_layout

\begin_layout Subsection
dB20ToLinInt (a)
\end_layout

\begin_layout Standard
db10ToLinInt rises 10 to the power of a twenties.
 It returns 
\begin_inset Formula $10^{\frac{a}{20}}$
\end_inset

.
\end_layout

\begin_layout Subsection
linToDB20Int (a)
\end_layout

\begin_layout Standard
linToDB10Int produces 20 times the logarithm of a.
 It returns 
\begin_inset Formula $20log_{10}(a)$
\end_inset

.
\end_layout

\begin_layout Subsection
valtol100ToInt (v, ptol, ntol)
\end_layout

\begin_layout Standard
valtol100ToInt produces an interval with center value given by the scalar
 v, and positive and negative tolerance express in percentage given by ptol
 and ntol.
 ntol is optional, if not present it is assumed equal to ptol.
 It returns 
\begin_inset Formula $[v(1+\frac{100}{ntol}),v(1+\frac{100}{ptol})]$
\end_inset


\end_layout

\begin_layout Subsection
intToTol (a)
\end_layout

\begin_layout Standard
intToTol produces the tolerance of the vector of interval a, in the hypothesis
 that the actual value is in the average point.
 It returns 
\begin_inset Formula $2\frac{a_{max}-a_{min}}{a_{max}+a_{min}}$
\end_inset

.
\end_layout

\begin_layout Subsection
intToTol100 (a)
\end_layout

\begin_layout Standard
intToTol100 produces the tolerance (expressed in percentage) of the vector
 of interval a, in the hypothesis that the actual value is in the average
 point.
 It returns 
\begin_inset Formula $200\frac{a_{max}-a_{min}}{a_{max}+a_{min}}$
\end_inset

.
\end_layout

\begin_layout Subsection
intToVal (a)
\end_layout

\begin_layout Standard
intToVal produces the central value of the vector of intervals a, in the
 hypothesis that the actual value is in the average point.
 It returns 
\begin_inset Formula $\frac{a_{max}-a_{min}}{2}$
\end_inset

.
\end_layout

\begin_layout Subsection
linSpaceTol100Int (begin, end, numberOfIntervals, tolerance)
\end_layout

\begin_layout Standard
linSpaceTol100Int produces a vector of numberOfIntervals intervals equally
 spaced between begin and end, with the given tolerance.
\end_layout

\begin_layout Subsection
logSpaceTol100Int (begin, end, numberOfIntervals, tolerance)
\end_layout

\begin_layout Standard
linSpaceTol100Int produces a vector of numberOfIntervals intervals equally
 spaced between 
\begin_inset Formula $10^{begin}$
\end_inset

 and 
\begin_inset Formula $10^{end}$
\end_inset

, with the given tolerance.
\end_layout

\begin_layout Subsection
monotonicFunctionInt (f, x)
\end_layout

\begin_layout Standard
monotonicFunctionInt produces the y interval obtained applying the monotonic
 function f to the interval x.
 If f is not monotonic, y may be wrong.
 It returns 
\begin_inset Formula $[min(f(x_{min}),f(x_{max})),max(f(x_{min}),f(x_{max}))]$
\end_inset

.
\end_layout

\begin_layout Subsection
functionInt (f, x, nOfPoint)
\end_layout

\begin_layout Standard
functionInt try to produces the y interval obtained applying the function
 f to the interval x.
 The function is checked for monotonicity on the given number of point.
 nOfPoint is optional, default is 10.
\end_layout

\begin_layout Subsection
plotInt (x, y)
\end_layout

\begin_layout Standard
plotInt plots two curves.
 Those curves, for every x interval center point, goes through ymin and
 ymax.
 x and y must have the same rows.
\end_layout

\begin_layout Subsection
errorBarInt (x, y)
\end_layout

\begin_layout Standard
For every x center point, plots the y tolerance.
\end_layout

\begin_layout Section
Biography
\end_layout

\begin_layout Enumerate
http://en.wikipedia.org/wiki/Interval_arithmetic
\end_layout

\begin_layout Enumerate
http://www.cs.utep.edu/interval-comp/hayes.pdf
\end_layout

\begin_layout Enumerate
http://www.gnu.org/software/octave/docs.html
\end_layout

\end_body
\end_document
