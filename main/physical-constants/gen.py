#! /usr/bin/python
##
## (C) 2007 Muthiah Annamalai
##
## Code is released under GNU GPL.
## should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, write to the Free
## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
## 02110-1301, USA.
##
##
## This is the code generator that works on the NIST file.
## 
##
import string
import time
import sys
from curses.ascii import *

def make_oct_func(name,Description,Val,Units,Uncertainity,path):
    sys.stdout=open(path + string.upper(name)+".m","w");
    print "## Copyright (C) 2007 Python Code Generator "
    print "##"
    print "## -- WARNING -- Autogenerated  - DONOT EDIT -"
    print "##"
    print "## This code is released under GPL"
    print """## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, write to the Free
## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
## 02110-1301, USA."""
    print ""
    print "## -*- texinfo -*-"
    print "## @deftypefn {Function File} [@var{Val},@var{unit},@var{uncertanity}] {} "+ \
          string.upper(name) + "() "
    
    Description = "Returns the "+Description;
    while len(Description) > 0:
        print "## %s"%(Description[:80]);
        Description=Description[81:];
    print "## . Val="+Val + "  Units="+Units+" Uncertanity="+Uncertainity+". "
    print """## @var{Val} is actual value of the constant.
## @var{Unit} is a Units string.
## @var{uncertanity} is +/- value to constant."""    
    print "##"
    print "## Autogenerated on "+str(time.ctime())
    print "## from NIST database at  http://physics.nist.gov/constants "
    print "## @end deftypefn"
    print ""
    print """## Fundamental Physical Constants --- Complete Listing
## From:  http://physics.nist.gov/constants
## Source: Peter J. Mohr and Barry N. Taylor, CODATA Recommended Values of the 
## Fundamental Physical Constants: 2002, published in Rev. Mod. Phys.
## vol. 77(1) 1-107 (2005).
## Taken from: physics.nist.gov/cuu/Constants/Table/allascii.txt
##
    """
    print "function [Val,Unit,Uncertanity]=%s()"%(string.upper(name))
    print "\t Val = %s; "%(Val)
    print "\t Units = \"%s\";"%(Units)
    print "\t Uncertanity = %s;"%(Uncertainity)
    print "endfunction"
    print "%"
    print "%%!assert(%s,%s,eps)"%(string.upper(name),Val)
    print "%"
    sys.stdout.close()
    return

def make_physconst_func(func_metadata,PATH):
    ostd=sys.stdout;
    sys.stdout=open(PATH+'/physical_constant.m','w');
    print "## Copyright (C) 2007 Muthiah Annamalai "
    print "##"
    print "## --parts of code AUTOGENERATED. DONOT EDIT--"
    print "## --DONOT EDIT--"
    print "##"
    print "## This code is released under GPL"
    print """## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, write to the Free
## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
## 02110-1301, USA."""
    print ""
    print "## -*- texinfo -*-"
    print "## @deftypefn {Function File} [@var{Val},@var{unit},@var{uncertanity},@var{desc},@var{name}] {} =physical_constant(@var{arg})"
    print "## @var{arg} is the name of the physical constant to retrieve."
    print "## The output arguments are the attributes which you need. "
    print "## By default, the return value is the constant value."
    print "## if no arguments are passed, depending on the output arguments the entire units structure is returned"
    print """## @var{Val} is actual value of the constant.
## @var{Unit} is a Units string.
## @var{uncertanity} is +/- value to constant."""    
    print "##"
    print "## Autogenerated on "+str(time.ctime())
    print "## from NIST database at  http://physics.nist.gov/constants "
    print "## @end deftypefn"
    print ""
    print """## Fundamental Physical Constants --- Complete Listing
## From:  http://physics.nist.gov/constants
## Source: Peter J. Mohr and Barry N. Taylor, CODATA Recommended Values of the 
## Fundamental Physical Constants: 2002, published in Rev. Mod. Phys.
## vol. 77(1) 1-107 (2005).
## Taken from: physics.nist.gov/cuu/Constants/Table/allascii.txt
##
    """
    
    print "function  [rval,unit,uncert,desc,name]=physical_constant(arg)"
    print ""
    print " persistent unit_data;"
    print " if isstruct(unit_data) == 0 "
    print "   unit_data=struct();"; ## can we use persist smartly here?
    
    #func-name#'es => [Desc, Val,Units, Uncertanity]
    k=1;
    key_sorted=func_metadata.keys();
    key_sorted.sort();
    for key in key_sorted:
        v=func_metadata[key]; #sort by name
        print "   unit_data( %d ).name=\"%s\";"%(k,key);
        print "   unit_data( %d ).description=\"%s\";"%(k,v[0]);
        print "   unit_data( %d ).value=%s;"%(k,v[1]);
        print "   unit_data( %d ).units=\"%s\";"%(k,v[2]);
        print "   unit_data( %d ).uncertanity=%s;"%(k,v[3]);
        k=k+1;
        print ""
    print " end"

    print ""
    print " if nargin < 1 "
    print "    rval=unit_data;"
    print "    return;"
    print " end"
    
    #print " if nargin < 1"
    #print "    if (nargout <= 1)"
    #print "       rval=unit_data;"
    #print "    else"
    #print "       rval=unit_data.value;"
    #print "    end"
    #print "    if (nargout >= 2)"
    #print "       unit=unit_data.units"
    #print "    end"
    #print "    if (nargout >= 3)"
    #print "       uncert=unit_data.uncertanity;"
    #print "    end"
    #print "    if (nargout >= 4)"
    #print "       desc=unit_data.description;"
    #print "    end"
    #print "    if (nargout >= 5)"
    #print "       name=unit_data.name;"
    #print "    end"
    #print "    return;"
    #print " end"
    
    print ""
    print " matches=[]; pmatches=[];"
    print " LN=length(arg);"
    print " arg=toupper(arg);"
    #print " for idx = 1:length(unit_data) %replace to binary search"
    #print "    if ( strcmp(arg,unit_data( idx ).name) == 1 )"
    #print "        matches=[matches, idx];"
    #print "    end"
    #print " end"
    print " %binary search"
    print " low=1;high=length(unit_data);"
    print " while ( low <= high ) "
    print "   idx=low+floor((high-low)/2);"
    print "   val=cstrcmp(unit_data( idx ).name,arg);"
    print "   if val == 0"
    print "      matches=[matches, idx];"
    print "      break;"
    print "   elseif val==-1"
    print "      low=idx+1;"
    print "   else %val ==+1";
    print "      high=idx;"
    print "   end"
    print "   if ( idx == (low + high)/2 )"
    print "       warning(\"Cannot find a perfect-match for %s\",arg)"
    print "       break;"
    print "   end"    
    print " end"
    print " if (length(matches) == 0) %search only when we dont have matches"
    print "   for idx = 1:length(unit_data)"
    print "     if ( strncmp(arg,unit_data( idx ).name,LN) == 1 )"
    print "        pmatches=[pmatches, idx];"
    print "     end"
    print "   end"
    print " end"
    print ""
    print " matches = [matches, pmatches]; "
    print " if (length(matches) >= 1)"
    print "       if (length(matches) == length(pmatches)) %Only partial matches exist"
    print "            warning(\" Includes partial matches. Picking first %s (1'st) match with units %s..."
    print " by default for %s.\",unit_data(matches(1)).name,unit_data(matches(1)).units,arg)"
    print "        end"
    print "    match=unit_data(matches(1));"
    print "    rval=match.value;"
    print "    if (nargout >= 2)"
    print "       unit=match.units;"
    print "    end"
    print "    if (nargout >= 3)"
    print "       uncert=match.uncertanity;"
    print "    end"
    print "    if (nargout >= 4)"
    print "       desc=match.description;"
    print "    end"
    print "    if (nargout >= 5)"
    print "       name=match.name;"
    print "    end"    
    print " else"
    print "    error(\" No matches found\")";
    print " end"
    print " return;"
    print "end"
    print ""
    print "function v=cstrcmp(s1,s2)"
    print " L2=length(s2);"
    print " L1=length(s1);"
    print " L=min(L1,L2);"
    print " for idx=1:L"
    print """   p=s1(idx);
    q=s2(idx);
    if ( p ~= q )
     v=sign(p-q);
     return
   end"""
#    print "   if s1(idx)!=s2(idx)"
#    print "     if ( s1(idx)>s2(idx) )"
#    print "        v=+1;"
#    print "     else"
#    print "        v=-1;"
#    print "     end"
#    print "    return"
#    print "   end"
    print " end"
    print " v=sign(L1-L2);"
    print " return;"
    print "end"

    ## tests
    for key in key_sorted:
        v=func_metadata[key];
        print "%%!assert( physical_constant( \"%s\" ),%s,eps);"%(key,v[1])
    
    sys.stdout.close()
    return


if __name__ == "__main__":
    y=file("nist-allascii.txt");
    x=y.readlines()[14:]; ## skip first 14 lines.
    y.close();
    
    replace_dict={',':'_',
                  '/':'_per_',
                  '-':'_',
                  ' ':'_',
                  '.':'',
                  '_over_':'_by_',
                  '_relationship':''};
    uncert_dict={'(exact)':'0.0'};
    val_dict={' ':'',
              '.':''}
    
    PATH="./" #default path.
    ostd=sys.stdout;
    if len(sys.argv) > 1:
        PATH=sys.argv[1]+"/";
    func_metadata={}; ## this is Python
    for l in x:
        ## serves like a comment.
        Description=l[0:55].strip();

        ## function name
        name=Description;

        ## discard anything that dont have alphabets in beginning.
        idx=0;
        NLEN=len(name);
        while ( idx < NLEN) and (not isalpha(name[idx])) :
            idx=idx+1;
        name=name[idx:]
            
        ## value 
        Val=l[55:77];
            
        ## Uncertanity field
        Uncertainity=l[77:77+22].strip().replace(" ","")
            
        ## create units.
        Units=l[99:-1].strip()
        
        ## replace names.
        if name.find("(") >= 0:
            name=name.split('(')[0].strip()
        for k,v in replace_dict.items():
            name=name.replace(k,v);
        name=string.upper(name);
        
        ## replace uncertanity values
        for k,v in val_dict.items():
            Val=Val.replace(k,v)

        ## replace uncertanity values
        for k,v in uncert_dict.items():
            Uncertainity=Uncertainity.replace(k,v)
        
        ## call function
        ##print "[%s],[%s],[%s],[%s]"%(name, Val, Uncertainity, Units)
        ##make_oct_func(name,Description,Val,Units,Uncertainity,PATH)        
        ##sys.stdout=ostd
        ##print string.upper(name)

        #func-name#'es => [Desc, Val,Units, Uncertanity]
        func_metadata[name]=[Description,Val, Units, Uncertainity];
        
    ##generate main file.
    make_physconst_func(func_metadata,PATH);
    
        


##python ./gen.py > constants.m && octave -q constants.m
##octave -q --eval 'test physical_constant'
