diff -urN -x configure vte-0.17.2/config.h.in vte-0.17.2-new/config.h.in
--- vte-0.17.2/config.h.in	Thu Aug 14 02:03:22 2008
+++ vte-0.17.2-new/config.h.in	Wed Aug 27 14:38:16 2008
@@ -285,3 +285,7 @@
 
 /* Needed to get declarations for msg_control and msg_controllen on Solaris */
 #undef __EXTENSIONS__
+
+typedef int pid_t;
+#define LINE_MAX 8192
+#define USE_PCRE 1
diff -urN -x configure vte-0.17.2/configure.in vte-0.17.2-new/configure.in
--- vte-0.17.2/configure.in	Thu Aug 14 02:01:13 2008
+++ vte-0.17.2-new/configure.in	Wed Aug 27 14:38:16 2008
@@ -36,7 +36,7 @@
 AM_PROG_CC_C_O
 
 AM_PROG_LIBTOOL
-IT_PROG_INTLTOOL([0.35.0])
+#IT_PROG_INTLTOOL([0.35.0])
 
 GETTEXT_PACKAGE=vte
 AC_SUBST(GETTEXT_PACKAGE)
diff -urN -x configure vte-0.17.2/src/Makefile.in vte-0.17.2-new/src/Makefile.in
--- vte-0.17.2/src/Makefile.in	Thu Aug 14 02:02:47 2008
+++ vte-0.17.2-new/src/Makefile.in	Fri Aug 29 10:02:16 2008
@@ -92,9 +92,9 @@
 @BUILD_XFT_TRUE@am__objects_1 = vtexft.lo
 @BUILD_PANGOX_TRUE@am__objects_2 = vtepangox.lo
 am_libvte_la_OBJECTS = buffer.lo caps.lo debug.lo iso2022.lo keymap.lo \
-	marshal.lo matcher.lo pty.lo reaper.lo ring.lo table.lo \
+	marshal.lo matcher.lo pty.lo ptywin.lo reaper.lo ring.lo table.lo \
 	trie.lo vte.lo vteaccess.lo vtebg.lo vteconv.lo vtedraw.lo \
-	vtefc.lo vteft2.lo vtegl.lo vteglyph.lo vtepango.lo vterdb.lo \
+	vtefc.lo vteft2.lo vtegl.lo vteglyph.lo vtepango.lo vtewin.lo vterdb.lo \
 	vteregex.lo vtergb.lo vteseq.lo vteskel.lo vtetc.lo vtetree.lo \
 	vtetypebuiltins.lo $(am__objects_1) $(am__objects_2)
 libvte_la_OBJECTS = $(am_libvte_la_OBJECTS)
@@ -336,6 +336,7 @@
 FT2_CFLAGS = @FT2_CFLAGS@
 FT2_CONFIG = @FT2_CONFIG@
 FT2_LIBS = @FT2_LIBS@
+PCRE_LIBS = -lpcre
 GETTEXT_PACKAGE = @GETTEXT_PACKAGE@
 GLIB_CFLAGS = @GLIB_CFLAGS@
 GLIB_GENMARSHAL = @GLIB_GENMARSHAL@
@@ -505,7 +506,7 @@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
-pkginclude_HEADERS = pty.h reaper.h vte.h vteaccess.h vtetypebuiltins.h vteversion.h
+pkginclude_HEADERS = pty.h reaper.h vte.h vteaccess.h vtetypebuiltins.h vteversion.h ptywin.h
 lib_LTLIBRARIES = libvte.la
 pkglib_SCRIPTS = decset osc window
 EXTRA_DIST = \
@@ -549,7 +550,7 @@
 EXTRA_libvte_la_SOURCES = keysyms.c
 libvte_la_SOURCES = buffer.c buffer.h caps.c caps.h debug.c debug.h \
 	iso2022.c iso2022.h keymap.c keymap.h marshal.c marshal.h \
-	matcher.c matcher.h pty.c pty.h reaper.c reaper.h ring.c \
+	matcher.c matcher.h pty.c pty.h ptywin.c ptywin.h reaper.c reaper.h ring.c \
 	ring.h table.c table.h trie.c trie.h vte.c vte.h vte-private.h \
 	vteaccess.c vteaccess.h vtebg.c vtebg.h vteconv.c vteconv.h \
 	vtedraw.c vtedraw.h vtefc.c vtefc.h vteft2.c vteft2.h vtegl.c \
@@ -561,7 +562,7 @@
 	$(am__append_1) $(am__append_2)
 libvte_la_LDFLAGS = $(LDFLAGS) \
 	-version-info $(LIBVTE_LTVERSION) \
-	-export-symbols-regex "^vte_terminal_.*|^_vte_pty_.*|^vte_reaper_.*|_vte_debug_.*" \
+	-export-symbols-regex "^vte_terminal_.*|^_vte_pty_.*|^_vte_ptywin_.*|^vte_reaper_.*|_vte_debug_.*" \
 	@LIBTOOL_EXPORT_OPTIONS@ @LIBTOOL_FLAGS@
 
 libvte_la_LIBADD = $(LIBS) $(VTE_LIBS) $(X_LIBS) $(PCRE_LIBS) $(FT2_LIBS)
diff -urN -x configure vte-0.17.2/src/keymap.c vte-0.17.2-new/src/keymap.c
--- vte-0.17.2/src/keymap.c	Mon Dec  3 19:22:30 2007
+++ vte-0.17.2-new/src/keymap.c	Wed Aug 27 14:38:16 2008
@@ -199,7 +199,11 @@
 	{cursor_all, keypad_all, fkey_all,
 	 VTE_META_MASK, _VTE_CAP_ESC "\n", 2, X_NULL},
 	{cursor_all, keypad_all, fkey_all, GDK_CONTROL_MASK, "\n", 1, X_NULL},
+#ifndef _MSC_VER
 	{cursor_all, keypad_all, fkey_all, 0, "\r", 1, X_NULL},
+#else
+	{cursor_all, keypad_all, fkey_all, 0, "\n", 1, X_NULL},
+#endif
 	{cursor_all, keypad_all, fkey_all, 0, X_NULL, 0, X_NULL},
 };
 
diff -urN -x configure vte-0.17.2/src/pty.c vte-0.17.2-new/src/pty.c
--- vte-0.17.2/src/pty.c	Tue Aug  5 12:40:13 2008
+++ vte-0.17.2-new/src/pty.c	Wed Aug 27 14:47:21 2008
@@ -18,7 +18,9 @@
 
 #include "../config.h"
 #include <sys/types.h>
+#ifndef _MSC_VER
 #include <sys/ioctl.h>
+#endif
 #ifdef HAVE_SYS_TERMIOS_H
 #include <sys/termios.h>
 #endif
@@ -64,27 +66,63 @@
 static GTree *_vte_pty_helper_map = NULL;
 #endif
 
+#ifdef _MSC_VER
+#include "ptywin.h"
+#endif
+
 /* Reset the handlers for all known signals to their defaults.  The parent
  * (or one of the libraries it links to) may have changed one to be ignored. */
 static void
 _vte_pty_reset_signal_handlers(void)
 {
+#ifdef SIGHUP
 	signal(SIGHUP,  SIG_DFL);
+#endif
+#ifdef SIGINT
 	signal(SIGINT,  SIG_DFL);
+#endif
+#ifdef SIGILL
 	signal(SIGILL,  SIG_DFL);
+#endif
+#ifdef SIGABRT
 	signal(SIGABRT, SIG_DFL);
+#endif
+#ifdef SIGFPE
 	signal(SIGFPE,  SIG_DFL);
+#endif
+#ifdef SIGKILL
 	signal(SIGKILL, SIG_DFL);
+#endif
+#ifdef SIGSEGV
 	signal(SIGSEGV, SIG_DFL);
+#endif
+#ifdef SIGPIPE
 	signal(SIGPIPE, SIG_DFL);
+#endif
+#ifdef SIGALRM
 	signal(SIGALRM, SIG_DFL);
+#endif
+#ifdef SIGTERM
 	signal(SIGTERM, SIG_DFL);
+#endif
+#ifdef SIGCHLD
 	signal(SIGCHLD, SIG_DFL);
+#endif
+#ifdef SIGCONT
 	signal(SIGCONT, SIG_DFL);
+#endif
+#ifdef SIGSTOP
 	signal(SIGSTOP, SIG_DFL);
+#endif
+#ifdef SIGTSTP
 	signal(SIGTSTP, SIG_DFL);
+#endif
+#ifdef SIGTTIN
 	signal(SIGTTIN, SIG_DFL);
+#endif
+#ifdef SIGTTOU
 	signal(SIGTTOU, SIG_DFL);
+#endif
 #ifdef SIGBUS
 	signal(SIGBUS,  SIG_DFL);
 #endif
@@ -157,6 +195,7 @@
 static void
 vte_pty_child_setup (gpointer arg)
 {
+#ifndef _MSC_VER
 	struct vte_pty_child_setup_data *data = arg;
 	int fd = -1;
 	const char *tty = NULL;
@@ -250,6 +289,7 @@
 	/* Reset our signals -- our parent may have done any number of
 	 * weird things to them. */
 	_vte_pty_reset_signal_handlers();
+#endif
 }
 
 /* TODO: clean up the spawning
@@ -340,6 +380,7 @@
 					directory ? directory : "(none)");
 		}
 
+#ifndef _MSC_VER
 		ret = g_spawn_async_with_pipes (directory,
 				arg2, envp2,
 				G_SPAWN_CHILD_INHERITS_STDIN |
@@ -350,6 +391,10 @@
 				pid,
 				NULL, NULL, NULL,
 				&local_error);
+#else
+		ret = _vte_ptywin_spawn(arg2, envp2, directory,
+				(VtePtyWin32*)data->tty.fd, pid);
+#endif
 		if (ret == FALSE) {
 			if (g_error_matches (local_error,
 						G_SPAWN_ERROR,
@@ -463,6 +508,7 @@
 int
 _vte_pty_set_size(int master, int columns, int rows)
 {
+#ifndef _MSC_VER
 	struct winsize size;
 	int ret;
 	memset(&size, 0, sizeof(size));
@@ -478,6 +524,14 @@
 				master, strerror(errno));
 	}
 	return ret;
+#else
+	char buf[16] = {0};
+	_snprintf(buf, 15, "%d", rows);
+	g_setenv("LINES", buf, TRUE);
+	_snprintf(buf, 15, "%d", columns);
+	g_setenv("COLUMNS", buf, TRUE);
+	return 0;
+#endif
 }
 
 /**
@@ -493,6 +547,7 @@
 int
 _vte_pty_get_size(int master, int *columns, int *rows)
 {
+#ifndef _MSC_VER
 	struct winsize size;
 	int ret;
 	memset(&size, 0, sizeof(size));
@@ -513,6 +568,19 @@
 				master);
 	}
 	return ret;
+#else
+	const gchar *renv = g_getenv("LINES");
+	const gchar *cenv = g_getenv("COLUMNS");
+
+	if (renv && cenv)
+	{
+		*rows = atoi(renv);
+		*columns = atoi(cenv);
+		return 0;
+	}
+
+	return -1;
+#endif
 }
 
 static char *
@@ -559,6 +627,7 @@
 static int
 _vte_pty_getpt(void)
 {
+#ifndef _MSC_VER
 	int fd, flags;
 #ifdef HAVE_GETPT
 	/* Call the system's function for allocating a pty. */
@@ -575,6 +644,9 @@
 	flags &= ~(O_NONBLOCK);
 	fcntl(fd, F_SETFL, flags);
 	return fd;
+#else
+	return -1;
+#endif
 }
 
 static int
@@ -595,11 +667,38 @@
 #elif defined(TIOCSPTLCK)
 	int zero = 0;
 	return ioctl(fd, TIOCSPTLCK, &zero);
+#elif defined(_MSC_VER)
+	return (fd != 0 && fd != -1 ? 0 : -1);
 #else
 	return -1;
 #endif
 }
 
+#ifdef _MSC_VER
+static int
+_vte_pty_open_win32(GPid *child, char **env_add,
+		    const char *command, char **argv,
+		    const char *directory, int columns, int rows)
+{
+	VtePtyWin32 *ptyw = _vte_ptywin_new();
+	int fd = (int)ptyw;
+
+	/* Attempt to open the master. */
+	_vte_debug_print(VTE_DEBUG_PTY, "Allocated pty on fd %p.\n", ptyw);
+	if (fd != 0) {
+		if (!_vte_pty_fork_on_pty_fd(fd,
+					     env_add, command,
+					     argv, directory,
+					     columns, rows,
+					     child)) {
+			g_free(ptyw);
+			fd = -1;
+		}
+	}
+	return fd;
+}
+#endif
+
 static int
 _vte_pty_open_unix98(GPid *child, char **env_add,
 		     const char *command, char **argv,
@@ -822,6 +921,7 @@
 static gboolean
 _vte_pty_start_helper(void)
 {
+#ifndef _MSC_VER
 	int i, tmp[2], tunnel;
 	/* Sanity check. */
 	if (access(LIBEXECDIR "/gnome-pty-helper", X_OK) != 0) {
@@ -872,6 +972,9 @@
 	_vte_pty_helper_map = g_tree_new(_vte_direct_compare);
 	atexit(_vte_pty_stop_helper);
 	return TRUE;
+#else
+	return FALSE;
+#endif
 }
 
 static int
@@ -1005,8 +1108,13 @@
 	}
 #endif
 	if (ret == -1) {
+#ifndef _MSC_VER
 		ret = _vte_pty_open_unix98(&child, env_add, command, argv,
 					   directory, columns, rows);
+#else
+		ret = _vte_pty_open_win32(&child, env_add, command, argv,
+					  directory, columns, rows);
+#endif
 	}
 	if (ret != -1) {
 		*child_pid = (pid_t) child;
diff -urN -x configure vte-0.17.2/src/ptywin.c vte-0.17.2-new/src/ptywin.c
--- vte-0.17.2/src/ptywin.c	Thu Jan  1 01:00:00 1970
+++ vte-0.17.2-new/src/ptywin.c	Wed Aug 27 14:38:16 2008
@@ -0,0 +1,509 @@
+/*
+ * Copyright (C) 2008 Michael Goffioul.
+ *
+ * This is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU Library General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include "../config.h"
+#include "ptywin.h"
+#include <fcntl.h>
+#include <errno.h>
+
+#undef DATADIR
+#include <windows.h>
+
+#define LOCK(x) EnterCriticalSection(&(x))
+#define UNLOCK(x) LeaveCriticalSection(&(x))
+
+typedef struct __VtePtyWin32Watch VtePtyWin32Watch;
+typedef struct __VtePtyWin32IOChannel VtePtyWin32IOChannel;
+typedef struct __VtePtyWin32Chunk VtePtyWin32Chunk;
+
+DWORD WINAPI _vte_ptywin_io_read_thread(LPVOID data);
+
+struct __VtePtyWin32 {
+	int read_fd;
+	int write_fd;
+};
+
+struct __VtePtyWin32Watch {
+	GSource source;
+	GPollFD poll;
+	VtePtyWin32IOChannel *pty;
+};
+
+struct __VtePtyWin32Chunk {
+	int len;
+	char *data;
+};
+
+struct __VtePtyWin32IOChannel {
+	GIOChannel channel;
+	int fd;
+	HANDLE read_thread;
+	HANDLE data_event;
+	CRITICAL_SECTION mutex;
+	GQueue *data;
+	guint revents;
+};
+
+static gboolean
+_vte_ptywin_prepare(GSource *source, gint *timeout)
+{
+	VtePtyWin32Watch *pty_watch;
+	gboolean result;
+
+	pty_watch = (VtePtyWin32Watch *)source;
+	*timeout = -1;
+	result = FALSE;
+
+	LOCK(pty_watch->pty->mutex);
+	if (g_queue_is_empty(pty_watch->pty->data)
+	    && !(pty_watch->pty->revents & (G_IO_HUP|G_IO_ERR)))
+		pty_watch->pty->revents = 0;
+	UNLOCK(pty_watch->pty->mutex);
+
+	return result;
+}
+
+static gboolean
+_vte_ptywin_check(GSource *source)
+{
+	VtePtyWin32Watch *pty_watch;
+	gboolean result;
+
+	pty_watch = (VtePtyWin32Watch *)source;
+	result = FALSE;
+
+	LOCK(pty_watch->pty->mutex);
+	result = pty_watch->poll.revents = pty_watch->pty->revents;
+	/*
+	if (!g_queue_is_empty(pty_watch->pty->data))
+		result = TRUE;
+		*/
+	UNLOCK(pty_watch->pty->mutex);
+
+	return result;
+}
+
+static gboolean
+_vte_ptywin_dispatch(GSource *source, GSourceFunc callback, gpointer data)
+{
+	VtePtyWin32Watch *pty_watch;
+	GIOFunc func = (GIOFunc)callback;
+	
+	pty_watch = (VtePtyWin32Watch *)source;
+
+	return (*func)(&pty_watch->pty->channel,
+			pty_watch->poll.revents,
+			data);
+}
+
+static void
+_vte_ptywin_finalize(GSource *source)
+{
+	VtePtyWin32Watch *pty_watch = (VtePtyWin32Watch *)source;
+	g_io_channel_unref(&pty_watch->pty->channel);
+}
+
+static GSourceFuncs _vte_ptywin_funcs = {
+	_vte_ptywin_prepare,
+	_vte_ptywin_check,
+	_vte_ptywin_dispatch,
+	_vte_ptywin_finalize
+};
+
+static GSource*
+_vte_ptywin_io_create_watch(GIOChannel *channel, GIOCondition condition)
+{
+	VtePtyWin32IOChannel *pty_channel = (VtePtyWin32IOChannel *)channel;
+	GSource *source;
+	VtePtyWin32Watch *pty_watch;
+
+	source = g_source_new(&_vte_ptywin_funcs, sizeof(VtePtyWin32Watch));
+	pty_watch = (VtePtyWin32Watch *)source;
+	
+	pty_watch->pty = pty_channel;
+	g_io_channel_ref(channel);
+
+	pty_watch->poll.fd = (int)pty_channel->data_event;
+	pty_watch->poll.events = condition;
+
+	LOCK(pty_channel->mutex);
+
+	if ((condition & G_IO_IN) && (pty_channel->read_thread == NULL))
+	{
+		pty_channel->read_thread = 
+			CreateThread(NULL, 0, _vte_ptywin_io_read_thread,
+					pty_channel, 0, NULL);
+
+		if (pty_channel->read_thread == NULL)
+			g_warning(G_STRLOC ": Error creating read thread (%x)",
+					GetLastError());
+	}
+
+	g_source_add_poll(source, &pty_watch->poll);
+
+	UNLOCK (pty_channel->mutex);
+
+	return source;
+}
+
+static VtePtyWin32Chunk*
+_vte_ptywin_io_chunk_new(char *data, int len)
+{
+	VtePtyWin32Chunk *chunk = g_new(VtePtyWin32Chunk, 1);
+	chunk->len = len;
+	chunk->data = g_memdup(data, len);
+	return chunk;
+}
+
+static void
+_vte_ptywin_io_free_queue_elem(gpointer data, gpointer user_data)
+{
+	VtePtyWin32Chunk *chunk = (VtePtyWin32Chunk *)data;
+	g_free(chunk->data);
+	g_free(data);
+}
+
+static void
+_vte_ptywin_io_free(GIOChannel *channel)
+{
+	VtePtyWin32IOChannel *pty_channel = (VtePtyWin32IOChannel *)channel;
+
+	/* should stop polling */
+
+	LOCK(pty_channel->mutex);
+
+	g_queue_foreach(pty_channel->data,
+			_vte_ptywin_io_free_queue_elem, NULL);
+	g_queue_clear(pty_channel->data);
+	g_queue_free(pty_channel->data);
+
+	UNLOCK(pty_channel->mutex);
+
+	DeleteCriticalSection(&pty_channel->mutex);
+	CloseHandle(pty_channel->data_event);
+}
+
+static GIOFuncs _vte_ptywin_io_funcs = {
+	NULL /* io_read  */,
+	NULL /* io_write */,
+	NULL /* io_seek  */,
+	NULL /* io_close */,
+	_vte_ptywin_io_create_watch,
+	_vte_ptywin_io_free,
+	NULL /* io_set_flags */,
+	NULL /* io_get_flags */
+};
+
+GIOChannel*
+_vte_ptywin_io_new(int fd)
+{
+	VtePtyWin32IOChannel *pty_channel = g_new(VtePtyWin32IOChannel, 1);
+	GIOChannel *channel = (GIOChannel *)pty_channel;
+
+	g_io_channel_init(channel);
+
+	pty_channel->fd = fd;
+	pty_channel->read_thread = NULL;
+	InitializeCriticalSection(&pty_channel->mutex);
+	pty_channel->data_event = CreateEvent(NULL, TRUE, FALSE, NULL);
+	pty_channel->data = g_queue_new();
+
+	channel->funcs = &_vte_ptywin_io_funcs;
+	channel->is_seekable = FALSE;
+	channel->is_readable = TRUE;
+	channel->is_writeable = FALSE;
+
+	return channel;
+}
+
+#define IO_BUF_SIZE 8192
+
+DWORD WINAPI
+_vte_ptywin_io_read_thread(LPVOID data)
+{
+	VtePtyWin32IOChannel *pty_channel;
+	char buffer[IO_BUF_SIZE] = {0};
+	int n;
+
+	pty_channel = (VtePtyWin32IOChannel *)data;
+	g_io_channel_ref(&pty_channel->channel);
+
+	LOCK(pty_channel->mutex);
+
+	while (TRUE)
+	{
+		UNLOCK(pty_channel->mutex);
+
+#if 1
+		n = read(pty_channel->fd, buffer, IO_BUF_SIZE-1);
+#else
+		if (!ReadFile(_get_osfhandle(pty_channel->fd),
+				buffer, IO_BUF_SIZE-1, (LPDWORD)&n, NULL))
+		{
+			DWORD werr = GetLastError();
+		}
+#endif
+
+		LOCK(pty_channel->mutex);
+
+		pty_channel->revents = G_IO_IN;
+
+		if (n > 0)
+		{
+			VtePtyWin32Chunk *chunk = _vte_ptywin_io_chunk_new(buffer, n);
+			g_queue_push_tail(pty_channel->data, chunk);
+			SetEvent(pty_channel->data_event);
+		}
+		else
+		{
+			if (n == 0)
+				pty_channel->revents |= G_IO_HUP;
+			else
+			{
+				int err = errno, derr = _doserrno;
+				pty_channel->revents |= G_IO_ERR;
+			}
+			break;
+		}
+	}
+	
+	SetEvent(pty_channel->data_event);
+
+	UNLOCK(pty_channel->mutex);
+
+	g_io_channel_unref(&pty_channel->channel);
+
+	return 0;
+}
+
+int
+_vte_ptywin_io_read(GIOChannel *channel, guchar *buf, int len)
+{
+	VtePtyWin32IOChannel *pty_channel;
+	VtePtyWin32Chunk *chunk;
+	int result = 0;
+
+	pty_channel = (VtePtyWin32IOChannel *)channel;
+	errno = 0;
+
+	LOCK(pty_channel->mutex);
+
+	if (g_queue_is_empty(pty_channel->data))
+		if (pty_channel->revents & G_IO_HUP)
+			result = 0;
+		else
+		{
+			errno = EAGAIN;
+			result = -1;
+		}
+
+	while ((len > 0) && (!g_queue_is_empty(pty_channel->data)))
+	{
+		chunk = g_queue_pop_head(pty_channel->data);
+		if (chunk->len <= len)
+		{
+			memcpy(buf+result, chunk->data, chunk->len);
+			len -= chunk->len;
+			result += chunk->len;
+		}
+		else
+		{
+			VtePtyWin32Chunk *new_chunk;
+
+			memcpy(buf+result, chunk->data, len);
+			new_chunk = _vte_ptywin_io_chunk_new(chunk->data+len, chunk->len-len);
+			g_queue_push_head(pty_channel->data, new_chunk);
+			result += len;
+			len = 0;
+		}
+		_vte_ptywin_io_free_queue_elem(chunk, NULL);
+	}
+
+	if (g_queue_is_empty(pty_channel->data))
+		ResetEvent(pty_channel->data_event);
+
+	if (result == 0)
+	{
+		int x = result;
+	}
+
+	UNLOCK(pty_channel->mutex);
+
+	return result;
+}
+
+VtePtyWin32*
+_vte_ptywin_new(void)
+{
+	return (VtePtyWin32*)g_malloc0(sizeof(VtePtyWin32));
+}
+
+int
+_vte_ptywin_get_read(int fd)
+{
+	return ((VtePtyWin32*)fd)->read_fd;
+}
+
+int
+_vte_ptywin_get_write(int fd)
+{
+	return ((VtePtyWin32*)fd)->write_fd;
+}
+
+int
+_vte_ptywin_spawn(char **argv, char **envp, const char *directory,
+		  VtePtyWin32 *ptyw, GPid *pid)
+{
+	HANDLE childRd, childWr, parentRd, parentWr;
+	HANDLE hProcess;
+	DWORD pipeMode;
+	PROCESS_INFORMATION pi;
+	STARTUPINFO si;
+	char buf[4096*8] = {0}, *envbuf;
+	int i, len;
+
+	hProcess = GetCurrentProcess();
+	if (CreatePipe(&childRd, &parentWr, 0, 0) == 0 
+	    || DuplicateHandle(hProcess, childRd, hProcess, &childRd, 0, TRUE,
+		    DUPLICATE_SAME_ACCESS|DUPLICATE_CLOSE_SOURCE) == 0)
+	{
+		pipeMode = GetLastError();
+		return -1;
+	}
+	if (CreatePipe(&parentRd, &childWr, 0, 0) == 0 
+	    || DuplicateHandle(hProcess, childWr, hProcess, &childWr, 0, TRUE,
+		    DUPLICATE_SAME_ACCESS|DUPLICATE_CLOSE_SOURCE) == 0)
+	{
+		pipeMode = GetLastError();
+		CloseHandle(parentWr);
+		CloseHandle(childRd);
+		return -1;
+	}
+
+#if 0
+	pipeMode = PIPE_NOWAIT;
+	SetNamedPipeHandleState(parentRd, &pipeMode, 0, 0);
+	SetNamedPipeHandleState(parentWr, &pipeMode, 0, 0);
+#endif
+
+	ptyw->read_fd = _open_osfhandle(parentRd, _O_RDONLY|_O_BINARY);
+	ptyw->write_fd = _open_osfhandle(parentWr, _O_WRONLY|_O_BINARY);
+
+	ZeroMemory(&pi, sizeof(pi));
+	ZeroMemory(&si, sizeof(si));
+	si.cb = sizeof(si);
+	si.dwFlags |= STARTF_USESTDHANDLES;
+	si.hStdInput = childRd;
+	si.hStdOutput = childWr;
+	si.hStdError = childWr;
+
+	for (i=0; argv[i] != NULL; i++)
+	{
+		if (i > 0)
+			strcat(buf, " ");
+		strcat(buf, argv[i]);
+	}
+
+	len = 0;
+	for (i=0; (envp != NULL && envp[i] != NULL); i++)
+		len += (strlen(envp[i]) + 1);
+	if (len > 0)
+	{
+		int idx = 0;
+
+		len++;
+		envbuf = (char*)g_malloc0(len);
+		for (i=0; envp[i] != NULL; i++)
+		{
+			int n = strlen(envp[i]);
+
+			memcpy(envbuf+idx, envp[i], n);
+			idx += (n+1);
+		}
+	}
+	else
+		envbuf = NULL;
+
+	if (CreateProcess(NULL, buf, NULL, NULL, TRUE, 0, envbuf, directory, &si, &pi) != 0)
+	{
+		CloseHandle(childRd);
+		CloseHandle(childWr);
+		CloseHandle(pi.hProcess);
+		CloseHandle(pi.hThread);
+		*pid = pi.dwProcessId;
+
+		if (envbuf)
+			g_free(envbuf);
+
+		return TRUE;
+	}
+
+	pipeMode = GetLastError();
+
+	if (envbuf)
+		g_free(envbuf);
+
+	return FALSE;
+}
+
+void
+_vte_ptywin_close(int fd)
+{
+	VtePtyWin32 *ptyw = (VtePtyWin32*)fd;
+	close(ptyw->write_fd);
+	close(ptyw->read_fd);
+	g_free(ptyw);
+}
+
+int
+_vte_ptywin_openpty(int *fdm, int *fds)
+{
+	VtePtyWin32 *ptywm, *ptyws;
+	DWORD pipeMode;
+	HANDLE childRd, childWr, parentRd, parentWr;
+	HANDLE hProcess;
+
+	hProcess = GetCurrentProcess();
+	if (CreatePipe(&childRd, &parentWr, 0, 0) == 0 
+	    || DuplicateHandle(hProcess, childRd, hProcess, &childRd, 0, TRUE,
+		    DUPLICATE_SAME_ACCESS|DUPLICATE_CLOSE_SOURCE) == 0)
+	{
+		pipeMode = GetLastError();
+		return -1;
+	}
+	if (CreatePipe(&parentRd, &childWr, 0, 0) == 0 
+	    || DuplicateHandle(hProcess, childWr, hProcess, &childWr, 0, TRUE,
+		    DUPLICATE_SAME_ACCESS|DUPLICATE_CLOSE_SOURCE) == 0)
+	{
+		pipeMode = GetLastError();
+		CloseHandle(parentWr);
+		CloseHandle(childRd);
+		return -1;
+	}
+
+	ptywm = g_new(VtePtyWin32, 1);
+	ptyws = g_new(VtePtyWin32, 1);
+
+	ptywm->read_fd = _open_osfhandle(parentRd, _O_RDONLY|_O_BINARY);
+	ptywm->write_fd = _open_osfhandle(parentWr, _O_WRONLY|_O_BINARY);
+	ptyws->read_fd = _open_osfhandle(childRd, _O_RDONLY|_O_BINARY);
+	ptyws->write_fd = _open_osfhandle(childWr, _O_WRONLY|_O_BINARY);
+
+	*fdm = (int)ptywm;
+	*fds = (int)ptyws;
+}
diff -urN -x configure vte-0.17.2/src/ptywin.h vte-0.17.2-new/src/ptywin.h
--- vte-0.17.2/src/ptywin.h	Thu Jan  1 01:00:00 1970
+++ vte-0.17.2-new/src/ptywin.h	Wed Aug 27 14:38:16 2008
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2008 Michael Goffioul.
+ *
+ * This is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU Library General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef vte_ptywin_h_included
+#define vte_ptywin_h_included
+
+#include <glib.h>
+
+G_BEGIN_DECLS
+
+typedef struct __VtePtyWin32 VtePtyWin32;
+
+VtePtyWin32* _vte_ptywin_new(void);
+GIOChannel* _vte_ptywin_io_new(int fd);
+int _vte_ptywin_spawn(char **argv, char **envp, const char *directory,
+		      VtePtyWin32 *ptyw, GPid *pid);
+int _vte_ptywin_get_read(int fd);
+int _vte_ptywin_get_write(int fd);
+void _vte_ptywin_close(int fd);
+int _vte_ptywin_io_read(GIOChannel *channel, guchar *buffer, int len);
+int _vte_ptywin_openpty(int *fdm, int *fds);
+
+G_END_DECLS
+
+#endif
diff -urN -x configure vte-0.17.2/src/reaper.c vte-0.17.2-new/src/reaper.c
--- vte-0.17.2/src/reaper.c	Tue May 27 10:27:06 2008
+++ vte-0.17.2-new/src/reaper.c	Wed Aug 27 14:38:16 2008
@@ -18,7 +18,9 @@
 
 #include "../config.h"
 #include <sys/types.h>
+#ifdef HAVE_SYS_WAIT_H
 #include <sys/wait.h>
+#endif
 #include <signal.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -48,6 +50,7 @@
 static void
 vte_reaper_signal_handler(int signum)
 {
+#ifdef SIGCHLD
 	struct reaper_info info;
 	int status;
 
@@ -68,12 +71,14 @@
 			}
 		}
 	}
+#endif
 }
 
 static gboolean
 vte_reaper_emit_signal(GIOChannel *channel, GIOCondition condition,
 		       gpointer data)
 {
+#ifdef SIGCHLD
 	struct reaper_info info;
 	if (condition != G_IO_IN) {
 		return FALSE;
@@ -87,6 +92,9 @@
 				      info.pid, info.status);
 	}
 	return TRUE;
+#else
+	return FALSE;
+#endif
 }
 
 #if GLIB_CHECK_VERSION(2,4,0)
@@ -114,7 +122,7 @@
 int
 vte_reaper_add_child(GPid pid)
 {
-#if GLIB_CHECK_VERSION(2,4,0)
+#if GLIB_CHECK_VERSION(2,4,0) && ! defined (_MSC_VER)
 	return g_child_watch_add_full(G_PRIORITY_HIGH,
 				      pid,
 				      vte_reaper_child_watch_cb,
@@ -127,6 +135,7 @@
 static void
 vte_reaper_init(VteReaper *reaper)
 {
+#ifdef SIGCHLD
 	struct sigaction action;
 	int ret;
 
@@ -161,6 +170,10 @@
 	sigaction(SIGCHLD, &action, NULL);
 	_vte_debug_print(VTE_DEBUG_SIGNALS,
 			"Hooked SIGCHLD signal in reaper.\n");
+#else
+	_vte_debug_print(VTE_DEBUG_SIGNALS,
+			"SIGCHLD signal not supported.\n");
+#endif
 }
 
 static GObject*
@@ -182,6 +195,7 @@
 static void
 vte_reaper_finalize(GObject *reaper)
 {
+#ifdef SIGCHLD
 	struct sigaction action, old_action;
 
 	/* Reset the signal handler if we still have it hooked. */
@@ -207,6 +221,7 @@
 
 	G_OBJECT_CLASS(vte_reaper_parent_class)->finalize(reaper);
 	singleton_reaper = NULL;
+#endif
 }
 
 static void
diff -urN -x configure vte-0.17.2/src/reaper.h vte-0.17.2-new/src/reaper.h
--- vte-0.17.2/src/reaper.h	Sun Jun 29 18:48:34 2008
+++ vte-0.17.2-new/src/reaper.h	Wed Aug 27 14:38:16 2008
@@ -19,8 +19,9 @@
 #ifndef vte_reaper_h_included
 #define vte_reaper_h_included
 
-
+#ifdef HAVE_SYS_WAIT_H
 #include <sys/wait.h>
+#endif
 #include <signal.h>
 #include <glib.h>
 #include <glib-object.h>
diff -urN -x configure vte-0.17.2/src/trie.c vte-0.17.2-new/src/trie.c
--- vte-0.17.2/src/trie.c	Tue May 27 10:27:06 2008
+++ vte-0.17.2-new/src/trie.c	Wed Aug 27 14:38:16 2008
@@ -47,6 +47,10 @@
 #define TRIE_MAYBE_STATIC
 #endif
 
+#ifdef _MSC_VER
+#define snprintf _snprintf
+#endif
+
 /* Structures and whatnot for tracking character classes. */
 struct char_class_data {
 	gunichar c;			/* A character. */
diff -urN -x configure vte-0.17.2/src/vte-private.h vte-0.17.2-new/src/vte-private.h
--- vte-0.17.2/src/vte-private.h	Thu Aug 14 01:21:04 2008
+++ vte-0.17.2-new/src/vte-private.h	Wed Aug 27 15:18:52 2008
@@ -19,18 +19,26 @@
 #ifndef vte_vte_private_h_included
 #define vte_vte_private_h_included
 
+#ifndef _MSC_VER
 #include <sys/ioctl.h>
+#endif
 #include <sys/types.h>
+#ifndef _MSC_VER
 #include <sys/param.h>
+#endif
 #include <sys/stat.h>
 #ifdef HAVE_SYS_TERMIOS_H
 #include <sys/termios.h>
 #endif
+#ifndef _MSC_VER
 #include <sys/time.h>
+#endif
 #include <errno.h>
 #include <fcntl.h>
 #include <math.h>
+#ifndef _MSC_VER
 #include <pwd.h>
+#endif
 #include <signal.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -201,7 +209,12 @@
 	/* PTY handling data. */
 	const char *shell;		/* shell we started */
 	int pty_master;			/* pty master descriptor */
+#ifndef _MSC_VER
 	GIOChannel *pty_channel;	/* master channel */
+#else
+	GIOChannel *pty_input_channel;
+	GIOChannel *pty_output_channel;
+#endif
 	guint pty_input_source;
 	guint pty_output_source;
 	gboolean pty_input_active;
diff -urN -x configure vte-0.17.2/src/vte.c vte-0.17.2-new/src/vte.c
--- vte-0.17.2/src/vte.c	Thu Aug 14 01:43:48 2008
+++ vte-0.17.2-new/src/vte.c	Wed Aug 27 16:10:43 2008
@@ -62,6 +62,11 @@
 #define howmany(x, y) (((x) + ((y) - 1)) / (y))
 #endif
 
+#ifdef _MSC_VER
+#include "ptywin.h"
+#define close(x) _vte_ptywin_close(x)
+#endif
+
 #if !GTK_CHECK_VERSION(2,2,0)
 #define gdk_keymap_get_for_display(dpy) gdk_keymap_get_default()
 #endif
@@ -3079,6 +3084,7 @@
 vte_terminal_catch_child_exited(VteReaper *reaper, int pid, int status,
 				VteTerminal *terminal)
 {
+#ifndef _MSC_VER
 	if (pid == terminal->pvt->pty_pid) {
 		_VTE_DEBUG_IF (VTE_DEBUG_LIFECYCLE) {
 			g_printerr ("Child[%d] exited with status %d\n",
@@ -3106,6 +3112,7 @@
 		/* Close out the PTY. */
 		_vte_terminal_disconnect_pty_read(terminal);
 		_vte_terminal_disconnect_pty_write(terminal);
+#ifndef _MSC_VER
 		if (terminal->pvt->pty_channel != NULL) {
 			g_io_channel_unref (terminal->pvt->pty_channel);
 			terminal->pvt->pty_channel = NULL;
@@ -3115,6 +3122,20 @@
 			close(terminal->pvt->pty_master);
 			terminal->pvt->pty_master = -1;
 		}
+#else
+		if (terminal->pvt->pty_input_channel != NULL) {
+			g_io_channel_unref (terminal->pvt->pty_input_channel);
+			terminal->pvt->pty_input_channel = NULL;
+		}
+		if (terminal->pvt->pty_output_channel != NULL) {
+			g_io_channel_unref (terminal->pvt->pty_output_channel);
+			terminal->pvt->pty_output_channel = NULL;
+		}
+		if (terminal->pvt->pty_master != -1) {
+			_vte_ptywin_close(terminal->pvt->pty_master);
+			terminal->pvt->pty_master = -1;
+		}
+#endif
 
 		/* Take one last shot at processing whatever data is pending,
 		 * then flush the buffers in case we're about to run a new
@@ -3134,6 +3155,7 @@
 		/* Tell observers what's happened. */
 		vte_terminal_emit_child_exited(terminal);
 	}
+#endif
 }
 
 static void mark_input_source_invalid(VteTerminal *terminal)
@@ -3144,6 +3166,7 @@
 static void
 _vte_terminal_connect_pty_read(VteTerminal *terminal)
 {
+#ifndef _MSC_VER
 	if (terminal->pvt->pty_channel == NULL) {
 		return;
 	}
@@ -3158,6 +3181,22 @@
 					    terminal,
 					    (GDestroyNotify) mark_input_source_invalid);
 	}
+#else
+	if (terminal->pvt->pty_input_channel == NULL) {
+		return;
+	}
+
+	if (terminal->pvt->pty_input_source == VTE_INVALID_SOURCE) {
+		_vte_debug_print (VTE_DEBUG_IO, "polling vte_terminal_io_read\n");
+		terminal->pvt->pty_input_source =
+			g_io_add_watch_full(terminal->pvt->pty_input_channel,
+					    VTE_CHILD_INPUT_PRIORITY,
+					    G_IO_IN | G_IO_HUP,
+					    (GIOFunc) vte_terminal_io_read,
+					    terminal,
+					    (GDestroyNotify) mark_input_source_invalid);
+	}
+#endif
 }
 
 static void mark_output_source_invalid(VteTerminal *terminal)
@@ -3168,6 +3207,7 @@
 static void
 _vte_terminal_connect_pty_write(VteTerminal *terminal)
 {
+#ifndef _MSC_VER
 	if (terminal->pvt->pty_channel == NULL) {
 		return;
 	}
@@ -3187,6 +3227,27 @@
 						    (GDestroyNotify) mark_output_source_invalid);
 		}
 	}
+#else
+	if (terminal->pvt->pty_output_channel == NULL) {
+		return;
+	}
+
+	if (terminal->pvt->pty_output_source == VTE_INVALID_SOURCE) {
+		if (vte_terminal_io_write (terminal->pvt->pty_output_channel,
+					     G_IO_OUT,
+					     terminal))
+		{
+			_vte_debug_print (VTE_DEBUG_IO, "polling vte_terminal_io_write\n");
+			terminal->pvt->pty_output_source =
+				g_io_add_watch_full(terminal->pvt->pty_output_channel,
+						    VTE_CHILD_OUTPUT_PRIORITY,
+						    G_IO_OUT,
+						    (GIOFunc) vte_terminal_io_write,
+						    terminal,
+						    (GDestroyNotify) mark_output_source_invalid);
+		}
+	}
+#endif
 }
 
 static void
@@ -3234,6 +3295,7 @@
 	env_add[i + 1] = NULL;
 
 	/* Close any existing ptys. */
+#ifndef _MSC_VER
 	if (terminal->pvt->pty_channel != NULL) {
 		g_io_channel_unref (terminal->pvt->pty_channel);
 	}
@@ -3241,6 +3303,17 @@
 		_vte_pty_close(terminal->pvt->pty_master);
 		close(terminal->pvt->pty_master);
 	}
+#else
+	if (terminal->pvt->pty_input_channel != NULL) {
+		g_io_channel_unref (terminal->pvt->pty_input_channel);
+	}
+	if (terminal->pvt->pty_output_channel != NULL) {
+		g_io_channel_unref (terminal->pvt->pty_output_channel);
+	}
+	if (terminal->pvt->pty_master != -1) {
+		_vte_ptywin_close(terminal->pvt->pty_master);
+	}
+#endif
 
 	/* Open the new pty. */
 	pid = -1;
@@ -3316,6 +3389,7 @@
 
 	/* Make the user's shell the default command. */
 	if (command == NULL) {
+#ifndef _MSC_VER
 		if (terminal->pvt->shell == NULL) {
 			struct passwd *pwd;
 
@@ -3327,6 +3401,7 @@
 						terminal->pvt->shell);
 			}
 		}
+#endif
 		if (terminal->pvt->shell == NULL) {
 			if (getenv ("SHELL")) {
 				terminal->pvt->shell = getenv ("SHELL");
@@ -3389,6 +3464,7 @@
 
 	_vte_terminal_disconnect_pty_read(terminal);
 	_vte_terminal_disconnect_pty_write(terminal);
+#ifndef _MSC_VER
 	if (terminal->pvt->pty_channel != NULL) {
 		g_io_channel_unref (terminal->pvt->pty_channel);
 		terminal->pvt->pty_channel = NULL;
@@ -3398,6 +3474,20 @@
 		close(terminal->pvt->pty_master);
 		terminal->pvt->pty_master = -1;
 	}
+#else
+	if (terminal->pvt->pty_input_channel != NULL) {
+		g_io_channel_unref (terminal->pvt->pty_input_channel);
+		terminal->pvt->pty_input_channel = NULL;
+	}
+	if (terminal->pvt->pty_output_channel != NULL) {
+		g_io_channel_unref (terminal->pvt->pty_output_channel);
+		terminal->pvt->pty_output_channel = NULL;
+	}
+	if (terminal->pvt->pty_master != -1) {
+		_vte_ptywin_close(terminal->pvt->pty_master);
+		terminal->pvt->pty_master = -1;
+	}
+#endif
 
 	/* Take one last shot at processing whatever data is pending, then
 	 * flush the buffers in case we're about to run a new command,
@@ -3903,6 +3993,7 @@
 static inline void
 _vte_terminal_enable_input_source (VteTerminal *terminal)
 {
+#ifndef _MSC_VER
 	if (terminal->pvt->pty_channel == NULL) {
 		return;
 	}
@@ -3917,6 +4008,22 @@
 					    terminal,
 					    (GDestroyNotify) mark_input_source_invalid);
 	}
+#else
+	if (terminal->pvt->pty_input_channel == NULL) {
+		return;
+	}
+
+	if (terminal->pvt->pty_input_source == VTE_INVALID_SOURCE) {
+		_vte_debug_print (VTE_DEBUG_IO, "polling vte_terminal_io_read\n");
+		terminal->pvt->pty_input_source =
+			g_io_add_watch_full(terminal->pvt->pty_input_channel,
+					    VTE_CHILD_INPUT_PRIORITY,
+					    G_IO_IN | G_IO_HUP,
+					    (GIOFunc) vte_terminal_io_read,
+					    terminal,
+					    (GDestroyNotify) mark_input_source_invalid);
+	}
+#endif
 }
 static void
 _vte_terminal_feed_chunks (VteTerminal *terminal, struct _vte_incoming_chunk *chunks)
@@ -3981,7 +4088,11 @@
 			bp = chunk->data + chunk->len;
 			len = 0;
 			do {
+#ifndef _MSC_VER
 				int ret = read (fd, bp, rem);
+#else
+				int ret = _vte_ptywin_io_read (channel, bp, rem);
+#endif
 				switch (ret){
 					case -1:
 						err = errno;
@@ -4508,7 +4619,9 @@
 	gssize normal_length = 0;
 	int i;
 	const char *special = NULL;
+#ifndef _MSC_VER
 	struct termios tio;
+#endif
 	gboolean scrolled = FALSE, steal = FALSE, modifier = FALSE, handled,
 		 suppress_meta_esc = FALSE;
 	guint keyval = 0;
@@ -4654,12 +4767,14 @@
 			case VTE_ERASE_AUTO:
 			default:
 				if (terminal->pvt->pty_master != -1) {
+#ifndef _MSC_VER
 					if (tcgetattr(terminal->pvt->pty_master,
 						      &tio) != -1) {
 						normal = g_strdup_printf("%c",
 									 tio.c_cc[VERASE]);
 						normal_length = 1;
 					}
+#endif
 				}
 				suppress_meta_esc = FALSE;
 				break;
@@ -6022,7 +6137,10 @@
 	vte_terminal_emit_selection_changed(terminal);
 
 	/* Temporarily stop caring about input from the child. */
+#ifndef _MSC_VER
+	/* TODO: channel should be disabled temporarily */
 	_vte_terminal_disconnect_pty_read(terminal);
+#endif
 }
 
 /* Extend selection to include the given event coordinates. */
@@ -7370,6 +7488,13 @@
 			g_warning(_("Error setting PTY size: %s."),
 				    strerror(errno));
 		}
+#ifdef _MSC_VER
+		{
+			char buf[128] = {0};
+			_snprintf(buf, 127, "\033[X%dx%d", columns, rows);
+			vte_terminal_feed_child_binary(terminal, buf, strlen(buf)+1);
+		}
+#endif
 		/* Read the terminal size, in case something went awry. */
 		vte_terminal_refresh_size(terminal);
 	} else {
@@ -7479,6 +7604,7 @@
 	terminal->pvt->emulation = g_intern_string(emulation);
 	_vte_debug_print(VTE_DEBUG_MISC,
 			"Setting emulation to `%s'...\n", emulation);
+	g_setenv("TERM", emulation, TRUE);
 	/* Find and read the right termcap file. */
 	vte_terminal_set_termcap(terminal, NULL, FALSE);
 
@@ -7586,10 +7712,30 @@
 	char *wpath;
 
 	if (path == NULL) {
+#ifdef G_OS_WIN32
+		char *winpath;
+		
+		winpath = g_win32_get_package_installation_directory(NULL, "libvte-9");
+		wpath = g_strdup_printf("%s/share/" PACKAGE "/termcap/%s",
+					winpath,
+					terminal->pvt->emulation ?
+					terminal->pvt->emulation :
+					vte_terminal_get_default_emulation(terminal));
+		if (g_stat(wpath, &st) != 0) {
+			g_free(wpath);
+			wpath = g_strdup_printf("%s/../../termcaps/%s",
+						winpath,
+						terminal->pvt->emulation ?
+						terminal->pvt->emulation :
+						vte_terminal_get_default_emulation(terminal));
+		}
+		g_free(winpath);
+#else
 		wpath = g_strdup_printf(DATADIR "/" PACKAGE "/termcap/%s",
 					terminal->pvt->emulation ?
 					terminal->pvt->emulation :
 					vte_terminal_get_default_emulation(terminal));
+#endif
 		if (g_stat(wpath, &st) != 0) {
 			g_free(wpath);
 			wpath = g_strdup("/etc/termcap");
@@ -7817,7 +7963,11 @@
 	vte_terminal_set_word_chars(terminal, NULL);
 
 	/* Miscellaneous options. */
+#ifndef _MSC_VER
 	vte_terminal_set_backspace_binding(terminal, VTE_ERASE_AUTO);
+#else
+	vte_terminal_set_backspace_binding(terminal, VTE_ERASE_ASCII_BACKSPACE);
+#endif
 	vte_terminal_set_delete_binding(terminal, VTE_ERASE_AUTO);
 	pvt->meta_sends_escape = TRUE;
 	pvt->audible_bell = TRUE;
@@ -8298,11 +8448,13 @@
 		if (pgrp != -1) {
 			kill(-pgrp, SIGHUP);
 		}
-#endif
+#elif ! defined(_MSC_VER)
 		kill(terminal->pvt->pty_pid, SIGHUP);
+#endif
 	}
 	_vte_terminal_disconnect_pty_read(terminal);
 	_vte_terminal_disconnect_pty_write(terminal);
+#ifndef _MSC_VER
 	if (terminal->pvt->pty_channel != NULL) {
 		g_io_channel_unref (terminal->pvt->pty_channel);
 	}
@@ -8310,6 +8462,17 @@
 		_vte_pty_close(terminal->pvt->pty_master);
 		close(terminal->pvt->pty_master);
 	}
+#else
+	if (terminal->pvt->pty_input_channel != NULL) {
+		g_io_channel_unref (terminal->pvt->pty_input_channel);
+	}
+	if (terminal->pvt->pty_output_channel != NULL) {
+		g_io_channel_unref (terminal->pvt->pty_output_channel);
+	}
+	if (terminal->pvt->pty_master != -1) {
+		_vte_ptywin_close(terminal->pvt->pty_master);
+	}
+#endif
 
 	/* Remove hash tables. */
 	if (terminal->pvt->dec_saved != NULL) {
@@ -12449,6 +12612,7 @@
 	       return;
        }
 
+#ifndef _MSC_VER
        if (terminal->pvt->pty_channel != NULL) {
 	       g_io_channel_unref (terminal->pvt->pty_channel);
        }
@@ -12456,16 +12620,36 @@
                _vte_pty_close(terminal->pvt->pty_master);
                close(terminal->pvt->pty_master);
        }
+#else
+	if (terminal->pvt->pty_input_channel != NULL) {
+		g_io_channel_unref (terminal->pvt->pty_input_channel);
+	}
+	if (terminal->pvt->pty_output_channel != NULL) {
+		g_io_channel_unref (terminal->pvt->pty_output_channel);
+	}
+	if (terminal->pvt->pty_master != -1) {
+		_vte_ptywin_close(terminal->pvt->pty_master);
+	}
+#endif
        terminal->pvt->pty_master = pty_master;
+#ifndef _MSC_VER
        terminal->pvt->pty_channel = g_io_channel_unix_new (pty_master);
        g_io_channel_set_close_on_unref (terminal->pvt->pty_channel, FALSE);
+#else
+       terminal->pvt->pty_input_channel = _vte_ptywin_io_new (_vte_ptywin_get_read (pty_master));
+       terminal->pvt->pty_output_channel = g_io_channel_win32_new_fd(_vte_ptywin_get_write(terminal->pvt->pty_master));
+       g_io_channel_set_close_on_unref (terminal->pvt->pty_input_channel, FALSE);
+       g_io_channel_set_close_on_unref (terminal->pvt->pty_output_channel, FALSE);
+#endif
 
 
        /* Set the pty to be non-blocking. */
+#ifndef _MSC_VER
        i = fcntl(terminal->pvt->pty_master, F_GETFL);
        if ((i & O_NONBLOCK) == 0) {
 	       fcntl(terminal->pvt->pty_master, F_SETFL, i | O_NONBLOCK);
        }
+#endif
 
        vte_terminal_set_size(terminal,
                              terminal->column_count,
@@ -12771,11 +12955,11 @@
 		if (l != active_terminals) {
 			_vte_debug_print (VTE_DEBUG_WORK, "T");
 		}
-		if (terminal->pvt->pty_channel != NULL) {
+		if (terminal->pvt->pty_input_channel != NULL) {
 			if (terminal->pvt->pty_input_active ||
 					terminal->pvt->pty_input_source == VTE_INVALID_SOURCE) {
 				terminal->pvt->pty_input_active = FALSE;
-				vte_terminal_io_read (terminal->pvt->pty_channel,
+				vte_terminal_io_read (terminal->pvt->pty_input_channel,
 						G_IO_IN, terminal);
 			}
 			_vte_terminal_enable_input_source (terminal);
@@ -12895,11 +13079,11 @@
 		if (l != active_terminals) {
 			_vte_debug_print (VTE_DEBUG_WORK, "T");
 		}
-		if (terminal->pvt->pty_channel != NULL) {
+		if (terminal->pvt->pty_input_channel != NULL) {
 			if (terminal->pvt->pty_input_active ||
 					terminal->pvt->pty_input_source == VTE_INVALID_SOURCE) {
 				terminal->pvt->pty_input_active = FALSE;
-				vte_terminal_io_read (terminal->pvt->pty_channel,
+				vte_terminal_io_read (terminal->pvt->pty_input_channel,
 						G_IO_IN, terminal);
 			}
 			_vte_terminal_enable_input_source (terminal);
@@ -12999,11 +13183,11 @@
 		if (l != active_terminals) {
 			_vte_debug_print (VTE_DEBUG_WORK, "T");
 		}
-		if (terminal->pvt->pty_channel != NULL) {
+		if (terminal->pvt->pty_input_channel != NULL) {
 			if (terminal->pvt->pty_input_active ||
 					terminal->pvt->pty_input_source == VTE_INVALID_SOURCE) {
 				terminal->pvt->pty_input_active = FALSE;
-				vte_terminal_io_read (terminal->pvt->pty_channel,
+				vte_terminal_io_read (terminal->pvt->pty_input_channel,
 						G_IO_IN, terminal);
 			}
 			_vte_terminal_enable_input_source (terminal);
diff -urN -x configure vte-0.17.2/src/vteapp.c vte-0.17.2-new/src/vteapp.c
--- vte-0.17.2/src/vteapp.c	Tue May 27 10:27:06 2008
+++ vte-0.17.2-new/src/vteapp.c	Wed Aug 27 14:38:16 2008
@@ -20,7 +20,9 @@
 #include "../config.h"
 
 #include <stdlib.h>
+#ifndef _MSC_VER
 #include <sys/ioctl.h>
+#endif
 #include <sys/stat.h>
 #include <errno.h>
 #include <fcntl.h>
@@ -36,6 +38,12 @@
 #define DINGUS1 "(((news|telnet|nntp|file|http|ftp|https)://)|(www|ftp)[-A-Za-z0-9]*\\.)[-A-Za-z0-9\\.]+(:[0-9]*)?"
 #define DINGUS2 "(((news|telnet|nntp|file|http|ftp|https)://)|(www|ftp)[-A-Za-z0-9]*\\.)[-A-Za-z0-9\\.]+(:[0-9]*)?/[-A-Za-z0-9_\\$\\.\\+\\!\\*\\(\\),;:@&=\\?/~\\#\\%]*[^]'\\.}>\\) ,\\\"]"
 
+#ifdef _MSC_VER
+#undef DATADIR
+#include <windows.h>
+#define sleep(x) Sleep((x)*1000)
+#endif
+
 static void
 window_title_changed(GtkWidget *widget, gpointer win)
 {
@@ -145,6 +153,7 @@
 destroy_and_quit_eof(GtkWidget *widget, gpointer data)
 {
 	_vte_debug_print(VTE_DEBUG_MISC, "Detected EOF.\n");
+	destroy_and_quit(widget, data);
 }
 static void
 destroy_and_quit_exited(GtkWidget *widget, gpointer data)
@@ -737,7 +746,9 @@
 		/* Open a "console" connection. */
 		int consolefd = -1, yes = 1, watch;
 		GIOChannel *channel;
+#ifndef _MSC_VER
 		consolefd = open("/dev/console", O_RDONLY | O_NOCTTY);
+#endif
 		if (consolefd != -1) {
 			/* Assume failure. */
 			console = FALSE;
@@ -780,11 +791,12 @@
 
 	if (!console) {
 		if (shell) {
+			char *argv[] = {"-i", NULL};
 			/* Launch a shell. */
 			_VTE_DEBUG_IF(VTE_DEBUG_MISC)
 				vte_terminal_feed(terminal, message, -1);
 			vte_terminal_fork_command(terminal,
-						  command, NULL, env_add,
+						  command, (command?NULL:argv), env_add,
 						  working_directory,
 						  TRUE, TRUE, TRUE);
 	#ifdef VTE_DEBUG
@@ -844,7 +856,7 @@
 
 
 	gtk_main();
-
+ 
 	g_assert(widget == NULL);
 	g_assert(window == NULL);
 
diff -urN -x configure vte-0.17.2/src/vtedraw.c vte-0.17.2-new/src/vtedraw.c
--- vte-0.17.2/src/vtedraw.c	Fri May 23 21:36:03 2008
+++ vte-0.17.2-new/src/vtedraw.c	Fri Aug 29 09:31:01 2008
@@ -32,11 +32,14 @@
 #include "vtegl.h"
 #include "vtepango.h"
 #include "vtepangox.h"
+#include "vtepangowin.h"
 #include "vteskel.h"
 #include "vtexft.h"
+#include "vtewin.h"
 
 static const struct _vte_draw_impl
 *_vte_draw_impls[] = {
+	&_vte_draw_win,
 #ifndef X_DISPLAY_MISSING
 #ifdef HAVE_XFT2
 	&_vte_draw_xft,
@@ -54,6 +57,9 @@
 	&_vte_draw_pango_x,
 #endif /* HAVE_PANGOX */
 #endif /* !X_DISPLAY_MISSING */
+#ifdef HAVE_PANGOWIN
+	&_vte_draw_pango_win,
+#endif /* HAVE_PANGOWIN */
 };
 
 static gboolean
diff -urN -x configure vte-0.17.2/src/vteft2.c vte-0.17.2-new/src/vteft2.c
--- vte-0.17.2/src/vteft2.c	Wed Nov 28 14:44:48 2007
+++ vte-0.17.2-new/src/vteft2.c	Wed Aug 27 14:38:16 2008
@@ -19,7 +19,9 @@
 
 #include "../config.h"
 
+#ifndef _MSC_VER
 #include <sys/param.h>
+#endif
 #include <string.h>
 #include <gtk/gtk.h>
 #include <glib.h>
diff -urN -x configure vte-0.17.2/src/vteglyph.c vte-0.17.2-new/src/vteglyph.c
--- vte-0.17.2/src/vteglyph.c	Tue May 27 10:27:06 2008
+++ vte-0.17.2-new/src/vteglyph.c	Wed Aug 27 14:38:16 2008
@@ -19,7 +19,9 @@
 
 #include "../config.h"
 
+#ifndef _MSC_VER
 #include <sys/param.h>
+#endif
 #include <math.h>
 #include <gdk/gdk.h>
 #include <glib.h>
@@ -33,6 +35,10 @@
 #define FONT_INDEX_FUDGE 10
 #define CHAR_WIDTH_FUDGE 10
 #define INVALID_GLYPH    GINT_TO_POINTER(-1)
+
+#ifndef howmany
+#define howmany(x, y) (((x) + ((y) - 1)) / (y))
+#endif
 
 static FT_Face _vte_glyph_cache_face_for_char(struct _vte_glyph_cache *cache,
 					      gunichar c);
diff -urN -x configure vte-0.17.2/src/vtepango.c vte-0.17.2-new/src/vtepango.c
--- vte-0.17.2/src/vtepango.c	Tue May 27 10:27:06 2008
+++ vte-0.17.2-new/src/vtepango.c	Wed Aug 27 14:38:16 2008
@@ -19,7 +19,9 @@
 
 #include "../config.h"
 
+#ifndef _MSC_VER
 #include <sys/param.h>
+#endif
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -29,6 +31,10 @@
 #include "vtebg.h"
 #include "vtedraw.h"
 #include "vtepango.h"
+
+#ifndef howmany
+#define howmany(x, y) (((x) + ((y) - 1)) / (y))
+#endif
 
 struct _vte_pango_data
 {
diff -urN -x configure vte-0.17.2/src/vtepangowin.c vte-0.17.2-new/src/vtepangowin.c
--- vte-0.17.2/src/vtepangowin.c	Thu Jan  1 01:00:00 1970
+++ vte-0.17.2-new/src/vtepangowin.c	Thu Aug 28 15:38:27 2008
@@ -0,0 +1,495 @@
+/*
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU Library General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+
+#include "../config.h"
+
+#undef DATADIR
+#include <stdio.h>
+#include <string.h>
+#include <gtk/gtk.h>
+#include <gdk/gdkwin32.h>
+#include <pango/pango.h>
+#include <pango/pangowin32.h>
+#include "debug.h"
+#include "vtebg.h"
+#include "vtedraw.h"
+#include "vtepangowin.h"
+
+#ifndef howmany
+#define howmany(x, y) (((x) + ((y) - 1)) / (y))
+#endif
+
+struct _vte_pango_win_data
+{
+	GdkColor color;
+	GdkPixmap *pixmap;
+	gint pixmapw, pixmaph;
+	gint scrollx, scrolly;
+	PangoContext *ctx;
+	PangoFontDescription *font;
+	PangoLayout *layout;
+	GdkGC *gc;
+	GdkPixmap *buffer;
+	gint bufferw, bufferh;
+};
+
+static gboolean
+_vte_pango_win_check(struct _vte_draw *draw, GtkWidget *widget)
+{
+	/* We can draw onto any widget. */
+	return TRUE;
+}
+
+static void
+_vte_pango_win_create(struct _vte_draw *draw, GtkWidget *widget)
+{
+	struct _vte_pango_win_data *data;
+
+	draw->impl_data = g_slice_new(struct _vte_pango_win_data);
+	data = (struct _vte_pango_win_data*) draw->impl_data;
+
+	data->color.red = 0;
+	data->color.green = 0;
+	data->color.blue = 0;
+	data->pixmap = NULL;
+	data->pixmapw = data->pixmaph = 0;
+	data->scrollx = data->scrolly = 0;
+	data->ctx = pango_win32_get_context();
+	data->font = NULL;
+	data->layout = NULL;
+	data->gc = NULL;
+	data->buffer = NULL;
+	data->bufferw = data->bufferh = 0;
+
+	gtk_widget_set_double_buffered(widget, FALSE);
+	/*draw->requires_clear = TRUE;*/
+}
+
+static void
+_vte_pango_win_destroy(struct _vte_draw *draw)
+{
+	struct _vte_pango_win_data *data = (struct _vte_pango_win_data*) draw->impl_data;
+
+	if (data->pixmap != NULL) {
+		g_object_unref(data->pixmap);
+	}
+	if (data->font != NULL) {
+		pango_font_description_free(data->font);
+	}
+	if (data->layout != NULL) {
+		g_object_unref(data->layout);
+	}
+	if (data->gc != NULL) {
+		g_object_unref(data->gc);
+	}
+	if (data->ctx != NULL) {
+		g_object_unref(data->ctx);
+	}
+
+	g_slice_free(struct _vte_pango_win_data, draw->impl_data);
+}
+
+static GdkVisual *
+_vte_pango_win_get_visual(struct _vte_draw *draw)
+{
+	return gtk_widget_get_visual(draw->widget);
+}
+
+static GdkColormap *
+_vte_pango_win_get_colormap(struct _vte_draw *draw)
+{
+	return gtk_widget_get_colormap(draw->widget);
+}
+
+static void
+_vte_pango_win_start(struct _vte_draw *draw)
+{
+	struct _vte_pango_win_data *data = (struct _vte_pango_win_data*) draw->impl_data;
+	PangoContext *ctx;
+
+	/*ctx = gtk_widget_get_pango_context (draw->widget);*/
+	ctx = data->ctx;
+
+	if (data->layout != NULL) {
+		g_object_unref(data->layout);
+	}
+	data->layout = pango_layout_new(data->ctx);
+	if (data->font != NULL) {
+		pango_layout_set_font_description(data->layout, data->font);
+	}
+
+	if (data->gc != NULL) {
+		g_object_unref(data->gc);
+	}
+	data->gc = gdk_gc_new(draw->widget->window);
+
+	if (data->buffer == NULL) {
+		data->buffer = gdk_pixmap_new(draw->widget->window,
+					      draw->widget->allocation.width,
+					      draw->widget->allocation.height,
+					      -1);
+		data->bufferw = draw->widget->allocation.width;
+		data->bufferh = draw->widget->allocation.height;
+	} else if (data->bufferw != draw->widget->allocation.width ||
+		   data->bufferh != draw->widget->allocation.height) {
+		g_object_unref(data->buffer);
+		data->buffer = gdk_pixmap_new(draw->widget->window,
+					      draw->widget->allocation.width,
+					      draw->widget->allocation.height,
+					      -1);
+	}
+
+	gdk_rgb_find_color(gdk_drawable_get_colormap(draw->widget->window),
+			   &data->color);
+}
+
+static void
+_vte_pango_win_end(struct _vte_draw *draw)
+{
+	struct _vte_pango_win_data *data = (struct _vte_pango_win_data*) draw->impl_data;
+
+	gdk_draw_pixmap(draw->widget->window, data->gc, data->buffer,
+			0, 0, 0, 0, data->bufferw, data->bufferh);
+
+	if (data->gc != NULL) {
+		g_object_unref(data->gc);
+	}
+	data->gc = NULL;
+
+	if (data->layout != NULL) {
+		g_object_unref(data->layout);
+	}
+	data->layout = NULL;
+}
+
+static void
+_vte_pango_win_set_background_color(struct _vte_draw *draw, GdkColor *color, guint16 opacity)
+{
+	struct _vte_pango_win_data *data = (struct _vte_pango_win_data*) draw->impl_data;
+	data->color = *color;
+}
+
+static void
+_vte_pango_win_set_background_image(struct _vte_draw *draw,
+				enum VteBgSourceType type,
+				GdkPixbuf *pixbuf,
+				const char *file,
+				const GdkColor *color,
+				double saturation)
+{
+	struct _vte_pango_win_data *data = (struct _vte_pango_win_data*) draw->impl_data;
+	GdkPixmap *pixmap;
+	GdkScreen *screen;
+
+	screen = gtk_widget_get_screen(draw->widget);
+
+	pixmap = vte_bg_get_pixmap(vte_bg_get_for_screen(screen),
+				   type, pixbuf, file,
+				   color, saturation,
+				   _vte_draw_get_colormap(draw, TRUE));
+	if (data->pixmap != NULL) {
+		g_object_unref(data->pixmap);
+	}
+	draw->requires_clear = FALSE;
+	data->pixmap = NULL;
+	data->pixmapw = data->pixmaph = 0;
+	if (pixmap) {
+		data->pixmap = pixmap;
+		gdk_drawable_get_size(pixmap, &data->pixmapw, &data->pixmaph);
+		draw->requires_clear =
+			data->pixmapw > 0 && data->pixmaph > 0;
+	}
+}
+
+static void
+_vte_pango_win_clip(struct _vte_draw *draw, GdkRegion *region)
+{
+	struct _vte_pango_win_data *data = draw->impl_data;
+	gdk_gc_set_clip_region(data->gc, region);
+}
+
+static void
+_vte_pango_win_clear(struct _vte_draw *draw,
+		 gint x, gint y, gint width, gint height)
+{
+	struct _vte_pango_win_data *data = (struct _vte_pango_win_data*) draw->impl_data;
+	gint i, j, h, w, xstop, ystop;
+
+	if ((data->pixmap == NULL) ||
+	    (data->pixmapw == 0) ||
+	    (data->pixmaph == 0)) {
+		gdk_gc_set_foreground(data->gc, &data->color);
+		gdk_draw_rectangle(data->buffer,
+				   data->gc,
+				   TRUE,
+				   x, y, width, height);
+		return;
+	}
+
+	/* Flood fill. */
+	xstop = x + width;
+	ystop = y + height;
+
+	y = ystop - height;
+	j = (data->scrolly + y) % data->pixmaph;
+	while (y < ystop) {
+		x = xstop - width;
+		i = (data->scrollx + x) % data->pixmapw;
+		h = MIN(data->pixmaph - (j % data->pixmaph), ystop - y);
+		while (x < xstop) {
+			w = MIN(data->pixmapw - (i % data->pixmapw), xstop - x);
+			gdk_draw_drawable(draw->widget->window,
+					  data->gc,
+					  data->pixmap,
+					  i, j,
+					  x, y,
+					  w, h);
+			x += w;
+			i = 0;
+		}
+		y += h;
+		j = 0;
+	}
+}
+
+static void
+_vte_pango_win_set_text_font(struct _vte_draw *draw,
+			 const PangoFontDescription *fontdesc,
+			 VteTerminalAntiAlias antialias)
+{
+	struct _vte_pango_win_data *data = (struct _vte_pango_win_data*) draw->impl_data;
+	PangoContext *ctx;
+	PangoLayout *layout;
+	PangoLayoutIter *iter;
+	PangoRectangle ink, logical;
+	gunichar full_codepoints[] = {VTE_DRAW_DOUBLE_WIDE_IDEOGRAPHS};
+	GString *full_string;
+	gint full_width;
+	guint i;
+
+	/*ctx = gtk_widget_get_pango_context(draw->widget);*/
+	layout = pango_layout_new(data->ctx);
+	if (data->font != NULL) {
+		pango_font_description_free(data->font);
+	}
+	data->font = pango_font_description_copy(fontdesc);
+	pango_layout_set_font_description(layout, data->font);
+
+	/* Estimate for ASCII characters. */
+	pango_layout_set_text(layout,
+			      VTE_DRAW_SINGLE_WIDE_CHARACTERS,
+			      strlen(VTE_DRAW_SINGLE_WIDE_CHARACTERS));
+	pango_layout_get_extents(layout, &ink, &logical);
+	draw->width = logical.width;
+	draw->width = howmany(draw->width,
+			      strlen(VTE_DRAW_SINGLE_WIDE_CHARACTERS));
+	iter = pango_layout_get_iter(layout);
+	draw->height = PANGO_PIXELS(logical.height);
+	draw->ascent = PANGO_PIXELS(pango_layout_iter_get_baseline(iter));
+	pango_layout_iter_free(iter);
+
+	/* Estimate for CJK characters. */
+	full_width = draw->width * 2;
+	full_string = g_string_new(NULL);
+	for (i = 0; i < G_N_ELEMENTS(full_codepoints); i++) {
+		g_string_append_unichar(full_string, full_codepoints[i]);
+	}
+	pango_layout_set_text(layout, full_string->str, full_string->len);
+	pango_layout_get_extents(layout, &ink, &logical);
+	full_width = howmany(logical.width, G_N_ELEMENTS(full_codepoints));
+	g_string_free(full_string, TRUE);
+
+	/* If they're the same, then we have a screwy font. */
+	if (full_width == draw->width) {
+		/* add 1 to round up when dividing by 2 */
+		draw->width = (draw->width + 1) / 2;
+	}
+
+	draw->width = PANGO_PIXELS(draw->width) * 3 / 2;
+	iter = pango_layout_get_iter(layout);
+	if (draw->height == 0) {
+		draw->height = PANGO_PIXELS(logical.height);
+	}
+	if (draw->ascent == 0) {
+		draw->ascent = PANGO_PIXELS(pango_layout_iter_get_baseline(iter));
+	}
+	pango_layout_iter_free(iter);
+
+	_vte_debug_print(VTE_DEBUG_MISC,
+			"VtePangoWin font metrics = %dx%d (%d).\n",
+			draw->width, draw->height, draw->ascent);
+	g_object_unref(layout);
+}
+
+static int
+_vte_pango_win_get_text_width(struct _vte_draw *draw)
+{
+	return draw->width;
+}
+
+static int
+_vte_pango_win_get_text_height(struct _vte_draw *draw)
+{
+	return draw->height;
+}
+
+static int
+_vte_pango_win_get_text_ascent(struct _vte_draw *draw)
+{
+	return draw->ascent;
+}
+
+static int
+_vte_pango_win_get_char_width(struct _vte_draw *draw, gunichar c, int columns)
+{
+	return _vte_pango_win_get_text_width(draw) * columns;
+}
+
+static gboolean
+_vte_pango_win_get_using_fontconfig(struct _vte_draw *draw)
+{
+	return TRUE;
+}
+
+static void
+_vte_pango_win_draw_text(struct _vte_draw *draw,
+		     struct _vte_draw_text_request *requests, gsize n_requests,
+		     GdkColor *color, guchar alpha)
+{
+	HDC hdc;
+	struct _vte_pango_win_data *data = (struct _vte_pango_win_data*) draw->impl_data;
+	char buf[VTE_UTF8_BPC];
+	guint i;
+	gsize length;
+	GdkColor wcolor;
+
+
+	wcolor = *color;
+	gdk_rgb_find_color(gdk_drawable_get_colormap(draw->widget->window),
+			   &wcolor);
+	gdk_gc_set_foreground(data->gc, &wcolor);
+	hdc = gdk_win32_hdc_get(data->buffer, data->gc, GDK_GC_FOREGROUND|GDK_GC_CLIP_MASK|GDK_GC_FONT);
+
+	for (i = 0; i < n_requests; i++) {
+		length = g_unichar_to_utf8(requests[i].c, buf);
+		pango_layout_set_text(data->layout, buf, length);
+		pango_win32_render_layout(hdc,
+				      data->layout,
+				      requests[i].x,
+				      requests[i].y);
+	}
+	
+	gdk_win32_hdc_release(data->buffer, data->gc, GDK_GC_FOREGROUND|GDK_GC_CLIP_MASK|GDK_GC_FONT);
+}
+
+static gboolean
+_vte_pango_win_draw_char(struct _vte_draw *draw,
+		     struct _vte_draw_text_request *request,
+		     GdkColor *color, guchar alpha)
+{
+	_vte_pango_win_draw_text(draw, request, 1, color, alpha);
+	return TRUE;
+}
+
+static gboolean
+_vte_pango_win_draw_has_char(struct _vte_draw *draw, gunichar c)
+{
+#if defined(PANGO_VERSION_CHECK) && PANGO_VERSION_CHECK(1,15,4)
+	struct _vte_pango_win_data *data = (struct _vte_pango_win_data*) draw->impl_data;
+	char buf[VTE_UTF8_BPC];
+	gsize length;
+
+	length = g_unichar_to_utf8(c, buf);
+	pango_layout_set_text(data->layout, buf, length);
+
+	return pango_layout_get_unknown_glyphs_count (data->layout) == 0;
+#else
+	return FALSE;
+#endif
+}
+
+
+static void
+_vte_pango_win_draw_rectangle(struct _vte_draw *draw,
+			  gint x, gint y, gint width, gint height,
+			  GdkColor *color, guchar alpha)
+{
+	struct _vte_pango_win_data *data = (struct _vte_pango_win_data*) draw->impl_data;
+	GdkColor wcolor;
+
+	wcolor = *color;
+	gdk_rgb_find_color(gdk_drawable_get_colormap(draw->widget->window),
+			   &wcolor);
+	gdk_gc_set_foreground(data->gc, &wcolor);
+
+	gdk_draw_rectangle(draw->widget->window, data->gc, FALSE,
+			   x, y, width-1, height-1);
+}
+
+static void
+_vte_pango_win_fill_rectangle(struct _vte_draw *draw,
+			  gint x, gint y, gint width, gint height,
+			  GdkColor *color, guchar alpha)
+{
+	struct _vte_pango_win_data *data = (struct _vte_pango_win_data*) draw->impl_data;
+	GdkColor wcolor;
+
+	wcolor = *color;
+	gdk_rgb_find_color(gdk_drawable_get_colormap(draw->widget->window),
+			   &wcolor);
+	gdk_gc_set_foreground(data->gc, &wcolor);
+	gdk_draw_rectangle(draw->widget->window, data->gc, TRUE,
+			   x, y, width, height);
+}
+
+static void
+_vte_pango_win_set_scroll(struct _vte_draw *draw, gint x, gint y)
+{
+	struct _vte_pango_win_data *data = (struct _vte_pango_win_data*) draw->impl_data;
+	data->scrollx = x;
+	data->scrolly = y;
+}
+
+const struct _vte_draw_impl _vte_draw_pango_win = {
+	"pangowin",
+	_vte_pango_win_check,
+	_vte_pango_win_create,
+	_vte_pango_win_destroy,
+	_vte_pango_win_get_visual,
+	_vte_pango_win_get_colormap,
+	_vte_pango_win_start,
+	_vte_pango_win_end,
+	_vte_pango_win_set_background_color,
+	_vte_pango_win_set_background_image,
+	FALSE,
+	_vte_pango_win_clip,
+	_vte_pango_win_clear,
+	_vte_pango_win_set_text_font,
+	_vte_pango_win_get_text_width,
+	_vte_pango_win_get_text_height,
+	_vte_pango_win_get_text_ascent,
+	_vte_pango_win_get_char_width,
+	_vte_pango_win_get_using_fontconfig,
+	_vte_pango_win_draw_text,
+	_vte_pango_win_draw_char,
+	_vte_pango_win_draw_has_char,
+	_vte_pango_win_draw_rectangle,
+	_vte_pango_win_fill_rectangle,
+	_vte_pango_win_set_scroll,
+};
diff -urN -x configure vte-0.17.2/src/vtepangowin.h vte-0.17.2-new/src/vtepangowin.h
--- vte-0.17.2/src/vtepangowin.h	Thu Jan  1 01:00:00 1970
+++ vte-0.17.2-new/src/vtepangowin.h	Wed Aug 27 14:38:16 2008
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU Library General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef vte_vtepangowin_h_included
+#define vte_vtepangowin_h_included
+
+/* The interfaces in this file are subject to change at any time. */
+
+
+#include "vtedraw.h"
+
+G_BEGIN_DECLS
+
+extern const struct _vte_draw_impl _vte_draw_pango_win;
+
+G_END_DECLS
+
+#endif
diff -urN -x configure vte-0.17.2/src/vterdb.c vte-0.17.2-new/src/vterdb.c
--- vte-0.17.2/src/vterdb.c	Sat Nov 24 02:24:40 2007
+++ vte-0.17.2-new/src/vterdb.c	Wed Aug 27 14:38:16 2008
@@ -27,6 +27,11 @@
 #endif
 #include "vterdb.h"
 
+#ifdef _MSC_VER
+#undef DATADIR
+#include <windows.h>
+#endif
+
 #define DEFAULT_ANTIALIAS	TRUE
 #define DEFAULT_DPI		-1
 #define DEFAULT_RGBA		"none"
@@ -38,11 +43,15 @@
 			 GdkAtom *type, int *size,
 			 char **retval)
 {
+#ifndef _MSC_VER
 	return gdk_property_get(window, atom, GDK_TARGET_STRING,
 				0, INT_MAX - 3,
 				FALSE,
 				type, NULL, size,
 				(guchar**) retval);
+#else
+	return FALSE;
+#endif
 }
 
 static gchar **
@@ -204,7 +213,18 @@
 double
 _vte_rdb_get_dpi(GtkWidget *widget)
 {
+#ifdef _MSC_VER
+	HDC hdc;
+	double ret;
+
+	hdc = CreateDC("DISPLAY", NULL, NULL, NULL);
+	ret = GetDeviceCaps(hdc, LOGPIXELSY);
+	DeleteDC(hdc);
+
+	return ret;
+#else
 	return _vte_rdb_double(widget, "Xft.dpi", DEFAULT_DPI);
+#endif
 }
 
 gboolean
diff -urN -x configure vte-0.17.2/src/vteseq.c vte-0.17.2-new/src/vteseq.c
--- vte-0.17.2/src/vteseq.c	Thu Aug 14 01:58:36 2008
+++ vte-0.17.2-new/src/vteseq.c	Wed Aug 27 14:38:16 2008
@@ -2185,6 +2185,9 @@
 	long start, end;
 	VteScreen *screen;
 
+#ifdef _MSC_VER
+	terminal->pvt->screen->cursor_current.col = 0;
+#endif
 	screen = terminal->pvt->screen;
 
 	if (screen->scrolling_restricted) {
diff -urN -x configure vte-0.17.2/src/vteskel.c vte-0.17.2-new/src/vteskel.c
--- vte-0.17.2/src/vteskel.c	Mon Feb 26 22:05:13 2007
+++ vte-0.17.2-new/src/vteskel.c	Wed Aug 27 14:38:16 2008
@@ -19,7 +19,9 @@
 
 #include "../config.h"
 
+#ifndef _MSC_VER
 #include <sys/param.h>
+#endif
 #include <stdio.h>
 #include <string.h>
 #include <gtk/gtk.h>
diff -urN -x configure vte-0.17.2/src/vtetypebuiltins.c.template vte-0.17.2-new/src/vtetypebuiltins.c.template
--- vte-0.17.2/src/vtetypebuiltins.c.template	Sun Jun 29 18:48:34 2008
+++ vte-0.17.2-new/src/vtetypebuiltins.c.template	Wed Aug 27 15:51:32 2008
@@ -1,4 +1,8 @@
 /*** BEGIN file-header ***/
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
 #include "vte.h"
 
 /*** END file-header ***/
diff -urN -x configure vte-0.17.2/src/vtewin.c vte-0.17.2-new/src/vtewin.c
--- vte-0.17.2/src/vtewin.c	Thu Jan  1 01:00:00 1970
+++ vte-0.17.2-new/src/vtewin.c	Fri Aug 29 09:47:35 2008
@@ -0,0 +1,478 @@
+/*
+ * Copyright (C) 2003 Red Hat, Inc.
+ *
+ * This is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU Library General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+
+#include "../config.h"
+
+#ifndef _MSC_VER
+#include <sys/param.h>
+#endif
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+#include <windowsx.h>
+#include <gdk/gdkwin32.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <gtk/gtk.h>
+#include "debug.h"
+#include "vtebg.h"
+#include "vtedraw.h"
+#include "vtewin.h"
+
+#ifndef howmany
+#define howmany(x, y) (((x) + ((y) - 1)) / (y))
+#endif
+
+struct _vte_win_data
+{
+	GdkColor color;
+	GdkPixmap *pixmap;
+	gint pixmapw, pixmaph;
+	gint scrollx, scrolly;
+	GdkGC *gc;
+	HFONT font;
+	GdkPixmap *buffer;
+	gint bufferw, bufferh;
+};
+
+static gboolean
+_vte_win_check(struct _vte_draw *draw, GtkWidget *widget)
+{
+	/* We can draw onto any widget. */
+	return TRUE;
+}
+
+static void
+_vte_win_create(struct _vte_draw *draw, GtkWidget *widget)
+{
+	struct _vte_win_data *data;
+
+	draw->impl_data = g_slice_new(struct _vte_win_data);
+	data = (struct _vte_win_data*) draw->impl_data;
+
+	data->color.red = 0;
+	data->color.green = 0;
+	data->color.blue = 0;
+	data->pixmap = NULL;
+	data->pixmapw = data->pixmaph = 0;
+	data->scrollx = data->scrolly = 0;
+	data->font = NULL;
+	data->gc = NULL;
+	data->buffer = NULL;
+	data->bufferw = data->bufferh = 0;
+
+	draw->requires_clear = TRUE;
+}
+
+static void
+_vte_win_destroy(struct _vte_draw *draw)
+{
+	struct _vte_win_data *data = (struct _vte_win_data*) draw->impl_data;
+
+	if (data->pixmap != NULL) {
+		g_object_unref(data->pixmap);
+	}
+	if (data->font != NULL) {
+		DeleteObject(data->font);
+	}
+	if (data->gc != NULL) {
+		g_object_unref(data->gc);
+	}
+	if (data->buffer != NULL) {
+		g_object_unref(data->buffer);
+	}
+
+	g_slice_free (struct _vte_win_data, draw->impl_data);
+}
+
+static GdkVisual *
+_vte_win_get_visual(struct _vte_draw *draw)
+{
+	return gtk_widget_get_visual(draw->widget);
+}
+
+static GdkColormap *
+_vte_win_get_colormap(struct _vte_draw *draw)
+{
+	return gtk_widget_get_colormap(draw->widget);
+}
+
+static void
+_vte_win_start(struct _vte_draw *draw)
+{
+	struct _vte_win_data *data = (struct _vte_win_data*) draw->impl_data;
+	HDC hdc;
+
+	if (data->gc != NULL) {
+		g_object_unref(data->gc);
+	}
+	data->gc = gdk_gc_new(draw->widget->window);
+
+	if (data->buffer == NULL || data->bufferw != draw->widget->allocation.width
+	    || data->bufferh != draw->widget->allocation.height) {
+		if (data->buffer != NULL) {
+			g_object_unref(data->buffer);
+		}
+		data->buffer = gdk_pixmap_new(draw->widget->window,
+					      draw->widget->allocation.width,
+					      draw->widget->allocation.height,
+					      -1);
+		data->bufferw = draw->widget->allocation.width;
+		data->bufferh = draw->widget->allocation.height;
+	}
+
+	gdk_rgb_find_color(gdk_drawable_get_colormap(draw->widget->window),
+			   &data->color);
+}
+
+static void
+_vte_win_end(struct _vte_draw *draw)
+{
+	struct _vte_win_data *data = (struct _vte_win_data*) draw->impl_data;
+
+	gdk_draw_pixmap(draw->widget->window, data->gc, data->buffer,
+			0, 0, 0, 0, data->bufferw, data->bufferh);
+
+	if (data->gc != NULL) {
+		g_object_unref(data->gc);
+	}
+	data->gc = NULL;
+}
+
+static void
+_vte_win_set_background_color(struct _vte_draw *draw, GdkColor *color, guint16 opacity)
+{
+	struct _vte_win_data *data = (struct _vte_win_data*) draw->impl_data;
+	data->color = *color;
+}
+
+static void
+_vte_win_set_background_image(struct _vte_draw *draw,
+				enum VteBgSourceType type,
+				GdkPixbuf *pixbuf,
+				const char *file,
+				const GdkColor *color,
+				double saturation)
+{
+	struct _vte_win_data *data = (struct _vte_win_data*) draw->impl_data;
+	GdkPixmap *pixmap;
+	GdkScreen *screen;
+
+	screen = gtk_widget_get_screen(draw->widget);
+
+	pixmap = vte_bg_get_pixmap(vte_bg_get_for_screen(screen),
+				   type, pixbuf, file,
+				   color, saturation,
+				   _vte_draw_get_colormap(draw, TRUE));
+	if (data->pixmap != NULL) {
+		g_object_unref(data->pixmap);
+	}
+	data->pixmap = NULL;
+	data->pixmapw = data->pixmaph = 0;
+	if (pixmap) {
+		data->pixmap = pixmap;
+		gdk_drawable_get_size(pixmap, &data->pixmapw, &data->pixmaph);
+	}
+}
+
+static void
+_vte_win_clip(struct _vte_draw *draw, GdkRegion *region)
+{
+	struct _vte_win_data *data = draw->impl_data;
+	gdk_gc_set_clip_region(data->gc, region);
+}
+
+static void
+_vte_win_clear(struct _vte_draw *draw,
+		 gint x, gint y, gint width, gint height)
+{
+	struct _vte_win_data *data = (struct _vte_win_data*) draw->impl_data;
+	gint i, j, h, w, xstop, ystop;
+
+	if ((data->pixmap == NULL) ||
+	    (data->pixmapw == 0) ||
+	    (data->pixmaph == 0)) {
+		gdk_gc_set_foreground(data->gc, &data->color);
+		gdk_draw_rectangle(data->buffer,
+				   data->gc,
+				   TRUE,
+				   x, y, width, height);
+		return;
+	}
+
+	/* Flood fill. */
+	xstop = x + width;
+	ystop = y + height;
+
+	y = ystop - height;
+	j = (data->scrolly + y) % data->pixmaph;
+	while (y < ystop) {
+		x = xstop - width;
+		i = (data->scrollx + x) % data->pixmapw;
+		h = MIN(data->pixmaph - (j % data->pixmaph), ystop - y);
+		while (x < xstop) {
+			w = MIN(data->pixmapw - (i % data->pixmapw), xstop - x);
+			gdk_draw_drawable(data->buffer,
+					  data->gc,
+					  data->pixmap,
+					  i, j,
+					  x, y,
+					  w, h);
+			x += w;
+			i = 0;
+		}
+		y += h;
+		j = 0;
+	}
+}
+
+static void
+_vte_win_set_text_font(struct _vte_draw *draw,
+			 const PangoFontDescription *fontdesc,
+			 VteTerminalAntiAlias antialias)
+{
+	struct _vte_win_data *data = (struct _vte_win_data*) draw->impl_data;
+	/*
+	gunichar full_codepoints[] = {VTE_DRAW_DOUBLE_WIDE_IDEOGRAPHS};
+	GString *full_string;
+	gint full_width;
+	*/
+	LOGFONT lf;
+	HDC hdc;
+	GdkDrawable *window;
+	GdkGC *gc;
+	TEXTMETRIC tm;
+	SIZE sz;
+
+	if (data->font != NULL) {
+		DeleteObject(data->font);
+	}
+
+	if (draw->widget->window == NULL) {
+		/* Widget is not realized yet. Use desktop window instead */
+		window = gdk_screen_get_root_window(gdk_screen_get_default());
+	} else {
+		window = draw->widget->window;
+	}
+
+	ZeroMemory(&lf, sizeof(lf));
+	lf.lfHeight = PANGO_PIXELS(pango_font_description_get_size(fontdesc));
+	lf.lfPitchAndFamily = FF_MODERN;
+	strncpy(lf.lfFaceName, pango_font_description_get_family(fontdesc), 32);
+	if (pango_font_description_get_weight(fontdesc) == PANGO_WEIGHT_BOLD)
+	  lf.lfWeight = FW_BOLD;
+	if (pango_font_description_get_style(fontdesc) == PANGO_STYLE_ITALIC)
+	  lf.lfItalic = TRUE;
+	data->font = CreateFontIndirect(&lf);
+
+	if (data->gc == NULL) {
+		gc = gdk_gc_new(window);
+	} else {
+		gc = data->gc;
+		g_object_ref (gc);
+	}
+
+	hdc = gdk_win32_hdc_get(window, gc,
+				GDK_GC_FOREGROUND|GDK_GC_CLIP_MASK|GDK_GC_FONT);
+	SelectFont(hdc, data->font);
+	
+	/* Estimate for ASCII characters. */
+	GetTextExtentPoint32(hdc, VTE_DRAW_SINGLE_WIDE_CHARACTERS,
+			     strlen(VTE_DRAW_SINGLE_WIDE_CHARACTERS), &sz);
+	draw->width = sz.cx;
+	draw->width = howmany(draw->width,
+			      strlen(VTE_DRAW_SINGLE_WIDE_CHARACTERS));
+	draw->height = sz.cy;
+	GetTextMetrics(hdc, &tm);
+	draw->ascent = tm.tmAscent;
+
+	/* Estimate for CJK characters. */
+#if 0
+	full_width = draw->width * 2;
+	full_string = g_string_new(NULL);
+	for (i = 0; i < G_N_ELEMENTS(full_codepoints); i++) {
+		g_string_append_unichar(full_string, full_codepoints[i]);
+	}
+	pango_layout_set_text(layout, full_string->str, full_string->len);
+	pango_layout_get_extents(layout, &ink, &logical);
+	full_width = howmany(logical.width, G_N_ELEMENTS(full_codepoints));
+	g_string_free(full_string, TRUE);
+
+
+	/* If they're the same, then we have a screwy font. */
+	if (full_width == draw->width) {
+		/* add 1 to round up when dividing by 2 */
+		draw->width = (draw->width + 1) / 2;
+	}
+#endif
+
+	_vte_debug_print(VTE_DEBUG_MISC,
+			"VteWin font metrics = %dx%d (%d).\n",
+			draw->width, draw->height, draw->ascent);
+
+	gdk_win32_hdc_release(window, gc,
+			      GDK_GC_FOREGROUND|GDK_GC_CLIP_MASK|GDK_GC_FONT);
+
+	g_object_unref(gc);
+}
+
+static int
+_vte_win_get_text_width(struct _vte_draw *draw)
+{
+	return draw->width;
+}
+
+static int
+_vte_win_get_text_height(struct _vte_draw *draw)
+{
+	return draw->height;
+}
+
+static int
+_vte_win_get_text_ascent(struct _vte_draw *draw)
+{
+	return draw->ascent;
+}
+
+static int
+_vte_win_get_char_width(struct _vte_draw *draw, gunichar c, int columns)
+{
+	return _vte_win_get_text_width(draw) * columns;
+}
+
+static gboolean
+_vte_win_get_using_fontconfig(struct _vte_draw *draw)
+{
+	return FALSE;
+}
+
+static void
+_vte_win_draw_text(struct _vte_draw *draw,
+		     struct _vte_draw_text_request *requests, gsize n_requests,
+		     GdkColor *color, guchar alpha)
+{
+	struct _vte_win_data *data = (struct _vte_win_data*) draw->impl_data;
+	char buf[VTE_UTF8_BPC];
+	guint i;
+	gsize length;
+	GdkColor wcolor;
+	HDC hdc;
+
+	wcolor = *color;
+	gdk_rgb_find_color(gdk_drawable_get_colormap(draw->widget->window),
+			   &wcolor);
+	gdk_gc_set_foreground(data->gc, &wcolor);
+
+	hdc = gdk_win32_hdc_get(data->buffer, data->gc,
+				GDK_GC_FOREGROUND|GDK_GC_CLIP_MASK/*|GDK_GC_FONT*/);
+	SelectFont(hdc, data->font);
+	SetBkMode(hdc, TRANSPARENT);
+
+	for (i = 0; i < n_requests; i++) {
+		length = g_unichar_to_utf8(requests[i].c, buf);
+		TextOut(hdc, requests[i].x, requests[i].y, buf, 1);
+	}
+
+	gdk_win32_hdc_release(data->buffer, data->gc,
+			      GDK_GC_FOREGROUND|GDK_GC_CLIP_MASK/*|GDK_GC_FONT*/);
+}
+
+static gboolean
+_vte_win_draw_char(struct _vte_draw *draw,
+		     struct _vte_draw_text_request *request,
+		     GdkColor *color, guchar alpha)
+{
+	_vte_win_draw_text(draw, request, 1, color, alpha);
+	return TRUE;
+}
+
+static gboolean
+_vte_win_draw_has_char(struct _vte_draw *draw, gunichar c)
+{
+	return FALSE;
+}
+
+static void
+_vte_win_draw_rectangle(struct _vte_draw *draw,
+			  gint x, gint y, gint width, gint height,
+			  GdkColor *color, guchar alpha)
+{
+	struct _vte_win_data *data = (struct _vte_win_data*) draw->impl_data;
+	GdkColor wcolor;
+
+	wcolor = *color;
+	gdk_rgb_find_color(gdk_drawable_get_colormap(draw->widget->window),
+			   &wcolor);
+	gdk_gc_set_foreground(data->gc, &wcolor);
+
+	gdk_draw_rectangle(data->buffer, data->gc, FALSE,
+			   x, y, width-1, height-1);
+}
+
+static void
+_vte_win_fill_rectangle(struct _vte_draw *draw,
+			  gint x, gint y, gint width, gint height,
+			  GdkColor *color, guchar alpha)
+{
+	struct _vte_win_data *data = (struct _vte_win_data*) draw->impl_data;
+	GdkColor wcolor;
+
+	wcolor = *color;
+	gdk_rgb_find_color(gdk_drawable_get_colormap(draw->widget->window),
+			   &wcolor);
+	gdk_gc_set_foreground(data->gc, &wcolor);
+	gdk_draw_rectangle(data->buffer, data->gc, TRUE,
+			   x, y, width, height);
+}
+
+static void
+_vte_win_set_scroll(struct _vte_draw *draw, gint x, gint y)
+{
+	struct _vte_win_data *data = (struct _vte_win_data*) draw->impl_data;
+	data->scrollx = x;
+	data->scrolly = y;
+}
+
+const struct _vte_draw_impl _vte_draw_win = {
+	"win",
+	_vte_win_check,
+	_vte_win_create,
+	_vte_win_destroy,
+	_vte_win_get_visual,
+	_vte_win_get_colormap,
+	_vte_win_start,
+	_vte_win_end,
+	_vte_win_set_background_color,
+	_vte_win_set_background_image,
+	FALSE,
+	_vte_win_clip,
+	_vte_win_clear,
+	_vte_win_set_text_font,
+	_vte_win_get_text_width,
+	_vte_win_get_text_height,
+	_vte_win_get_text_ascent,
+	_vte_win_get_char_width,
+	_vte_win_get_using_fontconfig,
+	_vte_win_draw_text,
+	_vte_win_draw_char,
+	_vte_win_draw_has_char,
+	_vte_win_draw_rectangle,
+	_vte_win_fill_rectangle,
+	_vte_win_set_scroll,
+};
diff -urN -x configure vte-0.17.2/src/vtewin.h vte-0.17.2-new/src/vtewin.h
--- vte-0.17.2/src/vtewin.h	Thu Jan  1 01:00:00 1970
+++ vte-0.17.2-new/src/vtewin.h	Thu Aug 28 12:02:49 2008
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2003 Red Hat, Inc.
+ *
+ * This is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU Library General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef vte_vtewin_h_included
+#define vte_vtewin_h_included
+
+/* The interfaces in this file are subject to change at any time. */
+
+
+#include "vtedraw.h"
+
+G_BEGIN_DECLS
+
+extern const struct _vte_draw_impl _vte_draw_win;
+
+G_END_DECLS
+
+#endif
