#!/usr/bin/env perl
#
# Traverse the directory tree and extract author information from .m
# files.  Put author information in the file 'AUTHORS'.
# Understands variations of these entries:
#
#   ## Copyright (C)  year(s)  name1, name2 and name3   <email>
#   ## Author:  name  <email>
#
# Albert Danial Dec 15 2001

use strict;
use File::Find;

my @files = ();       # to contain relative path names of each .m file
find(\&wanted, ".");  # start here & descend recursively; populate @files

my %author_data = ();
extract_authors(\@files,         # in
                \%author_data);  # out, a_data{file}{'name'} = [ names ]
                                 #                  {'year'} = [ years ]
                                 #                  {'mail'} = [ email addrs ]
                                 #                  {'cpyr'} = [ 'C' or ' '  ]

# traverse author_data and extract
#   - files without copyrights
#   - files without authors
#   - files grouped by author
#   - author to email map
my @unattributed_files  = ();
my @uncopyrighted_files = ();
my %email               = ();   # email{ author name } = email address
my %files               = ();   # files{ author name } = [ list of files ]
foreach my $f (sort @files) {
    # each file can have multiple authors, loop over each author
    if (!defined @{$author_data{$f}{name}}) {
        push @unattributed_files, $f;
        next;
    }
    my $copyrighted = 0;
    for (my $i = 0; $i < scalar @{$author_data{$f}{name}}; $i++) {
        if (defined $author_data{$f}{mail}[$i]) {
            $email{ $author_data{$f}{name}[$i] } = $author_data{$f}{mail}[$i];
        }
        $copyrighted = 1 if $author_data{$f}{cpyr}[$i] eq "C";
        push @{$files{ $author_data{$f}{name}[$i] }}, $f;
    }
    push @uncopyrighted_files, $f unless $copyrighted;
}

printf "%3d uncopyrighted files:\n", scalar @uncopyrighted_files;
foreach my $f (sort @uncopyrighted_files) {
    printf "      %s\n", $f;
}

printf "%3d unattributed files:\n", scalar @unattributed_files;
foreach my $f (sort @unattributed_files) {
    printf "      %s\n", $f;
}

my $Auth_file = "AUTHORS";
open(OUT, ">$Auth_file") or die "Cannot write $Auth_file:  $!\n";
printf "%3d authors:\n", scalar keys %files;
foreach my $n (sort by_last_name keys %files) {
    printf     "      %-20s", $n;
    printf OUT       "%-20s", $n;
    print     $email{$n} if defined $email{$n};
    print OUT $email{$n} if defined $email{$n};
    print     "\n";
    print OUT "\n";
    for (my $i = 0; $i < scalar @{$files{$n}}; $i++) {
        printf "       %3d. %s\n", $i+1, $files{$n}[$i];
    }
}
close OUT;

# # # # # # # 

sub by_last_name {  # for sorting on names
    (my $A = $a) =~ s/.*?(\w+)$/$1/;
    (my $B = $b) =~ s/.*?(\w+)$/$1/;
    return lc($A) cmp lc($B);
}

# # # # # # # 

sub extract_authors {
    my ($ra_files,  # in, list of files
        $rhha_data, # out,  data{file}{ name | year | cpyr } = [entries]
       ) = @_;
    warn "Found ", scalar @{$ra_files}, " .m files\n";
    foreach my $f (@{$ra_files}) {
        open(IN, $f) or die "Cannot read $f: $!\n";
        my $found_copyright = 0;
        while (<IN>) {
            # find the copyright line and extract author info from it
            s/all\s+rights\s+reserved\.?//i;
            s/\bby\s+//i;
            s/and sundry contributors//i;
            if (/^\s*[#%]+                #  one or more leading comment markers
                    \s*copyright          #  Copyright
                    \s+(\(c\))?           #  (c)    - optional           $1
                    \s*(\d+([,-]\s*\d+)*) #  Year (or years)             $2, $3
                    \s+(.*?)              #  name                        $4
                    \s*(<.*>)?            #  email  - optional           $5
                    \s*$/ix) {
                $found_copyright = 1;
                my $year  = $2;
                   $year .= $3 if defined $3;
                my $name  = $4;
                   $name  =~ s/\.\s*$//; # strip trailing period
                my $email = "" || $5;
                my @namelist = ();
                $name     =~ s/\s+and\s+/,/g;  # separate authors by commas
                @namelist = split(',', $name);
                foreach my $N (@namelist) {
                    $N   =~ s/^\s+//;  # strip leading  whitespace
                    $N   =~ s/\s+$//;  # strip trailing whitespace
                    push @{$rhha_data->{$f}{name}}, $N;
                    push @{$rhha_data->{$f}{year}}, $year;
                    push @{$rhha_data->{$f}{mail}}, $email;
                    push @{$rhha_data->{$f}{cpyr}}, 'C';
                }
                # don't exit w/last because there could be multiple copyrights
            } elsif
               (!$found_copyright and
                /^\s*[#%]+                #  one or more leading comment markers
                    \s*author:?           #  Copyright
                    \s+(.*?)              #  name                        $1
                    \s*(<.*>)?            #  email  - optional           $2
                    \s*$/ix) {
                my $name  = $1;
                   $name  =~ s/\.\s*$//; # strip trailing period
                my $email = "" || $2;
                push @{$rhha_data->{$f}{name}}, $name;
                push @{$rhha_data->{$f}{year}}, "";
                push @{$rhha_data->{$f}{mail}}, $email;
                if ($found_copyright) {
                    push @{$rhha_data->{$f}{cpyr}}, 'C';
                } else {
                    push @{$rhha_data->{$f}{cpyr}}, "";
                }
            }
        }
        close IN;
    }
}

# # # # # # # 

sub wanted { # populates global array @files
    return unless -f and /\.m$/;  # only want .m files (for now)
    push @files, "$File::Find::dir/$_";
}
