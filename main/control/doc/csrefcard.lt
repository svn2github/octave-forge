@Include { OCSTreport }
@Report
  @Title {
    { clines 0.8vx } @Break { 1.4f @Font {
      Octave Controls Toolbox Reference Card }
      0.8f @Font 0.7vx @Break { The Controls Toolbox was written by
      A. Scottedward Hodel  <A.S.Hodel@Eng.Auburn.EDU> }
    }
  }
  @Author { clines @Break { Kai P. Mueller
    <mueller@ifr.ing.tu-bs.de> }
  }
  @Institution { clines @Break { Technical University of Braunschweig
    Control Department }
  }
  @DateLine { Yes }
  @CoverSheet { No }
  @InitialFont { Schoolbook Base 12p }
  @InitialSpace { tex }
//

@Abstract 
  @Title { }
@Begin
@I {
This document provides an overview of the Controls Toolbox functions
of Octave. It is still under construction, don't rely on details.
}
@End @Abstract

@Section
  @Title { System Analysis }
@Begin
  @BeginSubSections

  @SubSection
    @Title { Properties }
  @Begin
  @PP
  @Tab
    between { single }
    @Fmta { @Col @Heading A !
            @Col @Heading B !
	    @Col @Heading C }
    @Fmtb { @Col 3c @Wide { ragged nohyphen } @Break A !
            @Col 7c @Wide { ragged nohyphen } @Break B !
	    @Col 3c @Wide { ragged nohyphen } @Break C }
  {
    @Rowa above { double } below { double }
      A { name } B { description "/" usage } C { remarks } 
    @Rowb above { yes }
      A { is_controllable }
      B { controllability check
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  [retval,U] = is_controllable(a [, b ,tol])
        }
      }
      C { }
    @Rowb above { yes }
      A { is_detectable }
      B { decetability check (unstable subsystem stabilizable?)
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  [retval,U] = is_detectable(a , c [, tol])
	}
      }
      C { }
    @Rowb above { yes }
      A { is_dgkf }
      B { checks if packed system meets assumptions for the
	  H{ @Sub @Sym infinity } Doyle-Glover-algorithm
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  retval = dgkf(Asys,nu,ny[,tol])
	}
      }
      C { }
    @Rowb above { yes }
      A { is_digital }
      B { returns true if packed system is a sampled system
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  *** no description ***
	}
      }
      C { }
  }

  @DP @PP
  @Tab
    between { single }
    @Fmta { @Col @Heading A !
            @Col @Heading B !
	    @Col @Heading C }
    @Fmtb { @Col 3c @Wide { ragged nohyphen } @Break A !
            @Col 7c @Wide { ragged nohyphen } @Break B !
	    @Col 3c @Wide { ragged nohyphen } @Break C }
  {
    @Rowa above { double } below { double }
      A { name } B { description "/" usage } C { remarks } 
    @Rowb above { yes }
      A { is_observable }
      B { observability check
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  [retval,U] = is_observable(a , c [, tol])
	}
      }
      C { }
    @Rowb above { yes }
      A { is_sample }
      B { returns true if sampling time Ts is a legal (scalar) value
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  *** no description ***
	}
      }
      C { }
    @Rowb above { yes }
      A { is_siso }
      B { returns true if packed system is siso
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  SISO = is_siso(sys)
	}
      }
      C { }
    @Rowb above { yes }
      A { is_stabilizable }
      B { returns true if system stabilizable
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  [retval,U] = is_stabilizable(a [, b ,tol])
	}
      }
      C { }
    @Rowb above { yes }
      A { is_stable }
      B { stability check
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  is_stable(a [,tol,disc])
	}
      }
      C { }
  }
  @End @SubSection

  @SubSection
    @Title { Time Domain }
  @Begin
  @PP
  @Tab
    between { single }
    @Fmta { @Col @Heading A !
            @Col @Heading B !
	    @Col @Heading C }
    @Fmtb { @Col 3c @Wide { ragged nohyphen } @Break A !
            @Col 7c @Wide { ragged nohyphen } @Break B !
	    @Col 3c @Wide { ragged nohyphen } @Break C }
  {
    @Rowa above { double } below { double }
      A { name } B { description "/" usage } C { remarks } 
    @Rowb above { yes }
      A { step }
      B { step response of a system (mimo, discrete, or both)
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  [y, u] = step(sys[, tstop, n, inp])
	}
      }
      C { }
    @Rowb above { yes }
      A { impulse }
      B { impulse response of a system (mimo, discrete, or both)
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  [y, u] = impulse(sys[, tstop, n, inp])
	}
      }
      C { }
    @Rowb above { yes }
      A { stepimp }
      B { common code for step and impulse
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  *** no description ***
	}
      }
      C { internal use }
    @Rowb above { yes }
      A { damp }
      B { display eigenvalues, damping ratios, and naural frequencies of a
	  matrix or poles of a packed system (continuous and discrete)
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  damp(p,[ tsamp])
	}
      }
      C { }
  }

  @DP @PP
  @Tab
    between { single }
    @Fmta { @Col @Heading A !
            @Col @Heading B !
	    @Col @Heading C }
    @Fmtb { @Col 3c @Wide { ragged nohyphen } @Break A !
            @Col 7c @Wide { ragged nohyphen } @Break B !
	    @Col 3c @Wide { ragged nohyphen } @Break C }
  {
    @Rowa above { double } below { double }
      A { name } B { description "/" usage } C { remarks } 
    @Rowb above { yes }
      A { dcgain }
      B { calculate steady state gain of a packed system
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  [gm, ok] = dcgain(sys[, tol])
	}
      }
      C { }
    @Rowb above { yes }
      A { dgram }
      B { discrete controllability grammian
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  *** no description ***
	}
      }
      C { }
    @Rowb above { yes }
      A { gram }
      B { continuous controllabilty grammian
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  *** no description ***
	}
      }
      C { }
    @Rowb above { yes }
      A { h2norm }
      B { continuous system H{ @Sub 2} norm
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  out = h2norm(sys)
	}
      }
      C { }
    @Rowb above { yes }
      A { lsim }
      B { simulation of a linear system with arbitrary input and
          time vector
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  [y,x] = lsim(sys,u,t[,x0])
	}
      }
      C { }
  }
  @End @SubSection

  @SubSection
    @Title { Frequency Domain }
  @Begin
  @PP
  @Tab
    between { single }
    @Fmta { @Col @Heading A !
            @Col @Heading B !
	    @Col @Heading C }
    @Fmtb { @Col 3c @Wide { ragged nohyphen } @Break A !
            @Col 7c @Wide { ragged nohyphen } @Break B !
	    @Col 3c @Wide { ragged nohyphen } @Break C }
  {
    @Rowa above { double } below { double }
      A { name } B { description "/" usage } C { remarks } 
    @Rowb above { yes }
      A { bode }
      B { bode diagram or compute magnitude and phase data
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  [mag,phase,w] = bode(sys[,w,outputs,inputs])
	}
      }
      C { }
    @Rowb above { yes }
      A { bode_bounds }
      B { calculation of frequencies for bode and nyquist
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  *** no description ***
	}
      }
      C { internal use } 
    @Rowb above { yes }
      A { bodquist }
      B { common code for bode und nyquist
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  *** no description ***
	}
      }
      C { internal use }
  }

  @DP @PP
  @Tab
    between { single }
    @Fmta { @Col @Heading A !
            @Col @Heading B !
	    @Col @Heading C }
    @Fmtb { @Col 3c @Wide { ragged nohyphen } @Break A !
            @Col 7c @Wide { ragged nohyphen } @Break B !
	    @Col 3c @Wide { ragged nohyphen } @Break C }
  {
    @Rowa above { double } below { double }
      A { name } B { description "/" usage } C { remarks } 
    @Rowb above { yes }
      A { freqchkw }
      B { check frequency vector, used by freqresp
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  *** no description ***
	}
      }
      C { internal use }
    @Rowb above { yes }
      A { freqresp }
      B { calculation of the mutivariable frequency response of a system, 
          used by bode and nyquist
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  out = freqresp(sys, SISO, DIGITAL, USEW
	  @LLP
	  [, w, SQUARE_NYQUIST])
	}
      }
      C { internal use }
    @Rowb above { yes }
      A { nyquist }
      B { nyquist diagram
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  *** no description ***
	}
      }
      C { }
    @Rowb above { yes }
      A { dcgain }
      B { calculate steady state gain of a packed system
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  [gm, ok] = dcgain(sys[, tol])
	}
      }
      C { }
    @Rowb above { yes }
      A { h2norm }
      B { continuous system H{ @Sub 2} norm
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  out = h2norm(sys)
	}
      }
      C { }
    @Rowb above { yes }
      A { hinfnorm }
      B { continuous system H{ @Sub @Sym infinity} norm
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  [g gmin gmax] = hinfnorm(sys[,tol,gmin,gmax,ptol])
	}
      }
      C { }
    @Rowb above { yes }
      A { ltifr }
      B { siso system frequency response
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  *** no description ***
	}
      }
      C { }
    @Rowb above { yes }
      A { pzmap }
      B { plot of poles and zeros of a system
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  pzmap(sys) or [zer,pol] = pzmap(sys)
	}
      }
      C { }
    @Rowb above { yes }
      A { rlocus }
      B { displays root locus plot
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  rlocus(sys[,inc,mink,maxk])
	}
      }
      C { }
    @Rowb above { yes }
      A { tzero }
      B { transmission zeros of a continuous"/"discrete system
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  [zer,gain] = tzero(A,B,C,D) or
	  @LLP
	  zer = tzero(Asys)
	}
      }
      C { }
  }

  @DP @PP
  @Tab
    between { single }
    @Fmta { @Col @Heading A !
            @Col @Heading B !
	    @Col @Heading C }
    @Fmtb { @Col 3c @Wide { ragged nohyphen } @Break A !
            @Col 7c @Wide { ragged nohyphen } @Break B !
	    @Col 3c @Wide { ragged nohyphen } @Break C }
  {
    @Rowa above { double } below { double }
      A { name } B { description "/" usage } C { remarks } 
    @Rowb above { yes }
      A { tzero2 }
      B { compute the transmission zeros of an a, b, c, d system
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  *** no description ***
	}
      }
      C { }
    @Rowb above { yes }
      A { zgpbal }
      B { used by tzero
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  retsys = zgpbal(Asys) - packed system input
	}
      }
      C { internal use }
    @Rowb above { yes }
      A { zgreduce }
      B { used by tzero
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  *** no description ***
	}
      }
      C { internal use }
    @Rowb above { yes }
      A { zgrownorm }
      B { used by tzero
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  *** no description ***
	}
      }
      C { internal use }
  }
  @End @SubSection
  @EndSubSections
@End @Section

@Section
  @Title { System Building }
@Begin
  @PP
  @Tab
    between { single }
    @Fmta { @Col @Heading A !
            @Col @Heading B !
	    @Col @Heading C }
    @Fmtb { @Col 3c @Wide { ragged nohyphen } @Break A !
            @Col 7c @Wide { ragged nohyphen } @Break B !
	    @Col 3c @Wide { ragged nohyphen } @Break C }
  {
    @Rowa above { double } below { double }
      A { name } B { description "/" usage } C { remarks } 
    @Rowb above { yes }
      A { abcddim }
      B { dimension compatibility check
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  *** no description ***
	}
      }
      C { }
    @Rowb above { yes }
      A { abcddims }
      B { used by abcddim
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  *** no description ***
	}
      }
      C { internal use }
    @Rowb above { yes }
      A { outlist }
      B { prints enumerated list of strings
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  outlist(x[,tabchar,yd,ilist])
	}
      }
      C { internal use }
    @Rowb above { yes }
      A { parallel }
      B { parallel connection of two systems
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  sysp = parallel(Asys,Bsys)
	}
      }
      C { }
    @Rowb above { yes }
      A { sysadd }
      B { addition of two systems
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  [sys] = sysysadd(Gsys,Hsys)
	}
      }
      C { }
    @Rowb above { yes }
      A { sysappend }
      B { append new inputs and outputs to a system
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  retsys = sysappend(sys,b,c[,d,outname,inname,yd])
	}
      }
      C { }
  }

  @DP @PP
  @Tab
    between { single }
    @Fmta { @Col @Heading A !
            @Col @Heading B !
	    @Col @Heading C }
    @Fmtb { @Col 3c @Wide { ragged nohyphen } @Break A !
            @Col 7c @Wide { ragged nohyphen } @Break B !
	    @Col 3c @Wide { ragged nohyphen } @Break C }
  {
    @Rowa above { double } below { double }
      A { name } B { description "/" usage } C { remarks } 
    @Rowb above { yes }
      A { syssetsignals }
      B { change names of system inputs, outputs, or states
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  retsys=syssetsignals(sys,opt,names[,sigidx])
	}
      }
      C { }
    @Rowb above { yes }
      A { syschtsam }
      B { change sampling time of a (sampled) system
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  retsys = syschtsam(sys,tsam)
	}
      }
      C { }
    @Rowb above { yes }
      A { sysconnect }
      B { form a closed loop system
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  retsys = sysconnect(sys, output_list, input_list [, order, tol])
	}
      }
      C { }
    @Rowb above { yes }
      A { syscont }
      B { extract continuous part of a mixed continuous"/"discrete system
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  [csys,Acd,Ccd,Dcd] = syscont(sys)
	}
      }
      C { }
    @Rowb above { yes }
      A { syscont_disc }
      B { extract continuous"/"discrete part
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  *** no description ***
	}
      }
      C { internal use, used by syscont and sysdisc, internal use }
    @Rowb above { yes }
      A { sysdefioname }
      B { create defaut signal names
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  ioname = sysdefioname(n,str[,m])
	}
      }
      C { internal use }
    @Rowb above { yes }
      A { sysdefstname }
      B { create default state names
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  *** no description ***
	}
      }
      C { internal use }
    @Rowb above { yes }
      A { sysdimensions }
      B { get number of states, inputs, and outputs from system
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  [n,nz,m,p] = sysdimensions(sys)
	}
      }
      C { }
    @Rowb above { yes }
      A { sysdisc }
      B { extract purely discrete portion of a mixed
          continuous"/"discrete system
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  [dsys,Adc,Cdc] = sysdisc(sys)
	}
      }
      C { }
  }

  @DP @PP
  @Tab
    between { single }
    @Fmta { @Col @Heading A !
            @Col @Heading B !
	    @Col @Heading C }
    @Fmtb { @Col 3c @Wide { ragged nohyphen } @Break A !
            @Col 7c @Wide { ragged nohyphen } @Break B !
	    @Col 3c @Wide { ragged nohyphen } @Break C }
  {
    @Rowa above { double } below { double }
      A { name } B { description "/" usage } C { remarks } 
    @Rowb above { yes }
      A { sysdup }
      B { duplicate specified input"/"output connections of a system
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  retsys = sysdup(Asys,output_list,input_list)
	}
      }
      C { }
    @Rowb above { yes }
      A { sysgroup }
      B { combines two packed system matrices into a single system
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  sys = sysgroup(Asys,Bsys)
	}
      }
      C { }
    @Rowb above { yes }
      A { sysgroupn }
      B { locate and mark duplicate names (in sysgroup)
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  *** no description ***
	}
      }
      C { internal use }
    @Rowb above { yes }
      A { sysmult }
      B { concatenates two systems
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  [sys] = sysmult(Asys,Bsys)
	}
      }
      C { }
    @Rowb above { yes }
      A { sysprune }
      B { extract specified inputs"/"outputs from a system
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  retsys = sysprune(sys,output_list,input_list)
	}
      }
      C { }
    @Rowb above { yes }
      A { sysreorder }
      B { reorder elements of a vector
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  *** no description ***
	}
      }
      C { used by sysconnect }
    @Rowb above { yes }
      A { sysscale }
      B { input"/"output scaling of a system
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  retsys = sysscale(Asys, output_list, input_list [,inname, outname])
	}
      }
      C { }
    @Rowb above { yes }
      A { syssub }
      B { subtraction of two systems
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  [sys] = syssub(Gsys,Hsys)
	}
      }
      C { }
    @Rowb above { yes }
      A { sysupdate }
      B { update the internal representation of a system
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  newsys = sysupdate(sys,opt)
	}
      }
      C { }
  }
  @NP
@End @Section


@Section
  @Title { Display and Convenience Functions }
@Begin
  @PP
  @Tab
    between { single }
    @Fmta { @Col @Heading A !
            @Col @Heading B !
	    @Col @Heading C }
    @Fmtb { @Col 3c @Wide { ragged nohyphen } @Break A !
            @Col 7c @Wide { ragged nohyphen } @Break B !
	    @Col 3c @Wide { ragged nohyphen } @Break C }
  {
    @Rowa above { double } below { double }
      A { name } B { description "/" usage } C { remarks } 
    @Rowb above { yes }
      A { polyout }
      B { formatted display of polynomials
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  [y = ] polyout(c,[x])
	}
      }
      C { }
    @Rowb above { yes }
      A { prompt }
      B { prompt user to continue
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  prompt([str])
	}
      }
      C { }
    @Rowb above { yes }
      A { sortcom }
      B { sort a complex vector by real, imaginary, or magnitude
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  yy = sortcom(xx[,opt]
	}
      }
      C { }
    @Rowb above { yes }
      A { swap }
      B { exchange two values
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  *** no description ***
	}
      }
      C { }
    @Rowb above { yes }
      A { swapcols }
      B { permute columns of a matrix into reverse order
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  *** no description ***
	}
      }
      C { }
    @Rowb above { yes }
      A {swaprows  }
      B { permute rows of a matrix into reverse order
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  *** no description ***
	}
      }
      C { }
    @Rowb above { yes }
      A { sysout }
      B { print out a packed system in desired format
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  sysout(sys[,opt])
	}
      }
      C { }
    @Rowb above { yes }
      A { tfout }
      B { formatted transfer function num(s)"/"den(s)
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  tfout(num,denom[,x])
	}
      }
      C { }
    @Rowb above { yes }
      A { zpout }
      B { print formatted zero-pole form
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  zpout(zer,pol,k[,x])
	}
      }
      C { }
  }
  @NP
@End @Section

@Section
  @Title { System Representations and Conversions }
@Begin
  @PP
  @Tab
    between { single }
    @Fmta { @Col @Heading A !
            @Col @Heading B !
	    @Col @Heading C }
    @Fmtb { @Col 3c @Wide { ragged nohyphen } @Break A !
            @Col 7c @Wide { ragged nohyphen } @Break B !
	    @Col 3c @Wide { ragged nohyphen } @Break C }
  {
    @Rowa above { double } below { double }
      A { name } B { description "/" usage } C { remarks } 
    @Rowb above { yes }
      A { c2d }
      B { continuous to discrete conversion of a packed system
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  dsys=c2d(sys[,T])
	}
      }
      C { }
    @Rowb above { yes }
      A { fir2sys }
      B { FIR (finite impulse response) to packed system conversion
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  *** no description ***
	}
      }
      C { }
    @Rowb above { yes }
      A { ss2sys }
      B { conversion from state space to system
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  OUTSYS = ss2sys(A, B, C [, D, TSAM, N,
	  NZ, STNAME, INNAME, OUTNAME, OUTLIST])
	}
      }
      C { }
    @Rowb above { yes }
      A { ss2tf }
      B { conversion from state space to transfer function
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  [num,den] = ss2tf(a,b,c,d)
	}
      }
      C { }
    @Rowb above { yes }
      A { ss2zp }
      B { conversion from state space to zero pole representation
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  [zer,pol,k] = ss2zp(a,b,c,d)
	}
      }
      C { }
    @Rowb above { yes }
      A { sys2fir }
      B { extract fir system from packed system form
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  *** no description ***
	}
      }
      C { }
    @Rowb above { yes }
      A { sys2ss }
      B { conversion from packed system to state space form
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  [a, b, c, d, tsam, n, nz, stname, inname, outname] = sys2ss(sys)
	}
      }
      C { }
    @Rowb above { yes }
      A { sys2tf }
      B { conversion from packed system to stransfer function
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  *** no description ***
	}
      }
      C { }
  }

  @DP @PP
  @Tab
    between { single }
    @Fmta { @Col @Heading A !
            @Col @Heading B !
	    @Col @Heading C }
    @Fmtb { @Col 3c @Wide { ragged nohyphen } @Break A !
            @Col 7c @Wide { ragged nohyphen } @Break B !
	    @Col 3c @Wide { ragged nohyphen } @Break C }
  {
    @Rowa above { double } below { double }
      A { name } B { description "/" usage } C { remarks } 
    @Rowb above { yes }
      A { sys2zp }
      B { conversion from packed system to zero pole representation
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  [zer,pol,k] = ss2zp(a,b,c,d)
	}
      }
      C { }
    @Rowb above { yes }
      A { sysdisc }
      B { extract purely discrete portion of a mixed
          continuous"/"discrete system
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  [dsys,Adc,Cdc] = sysdisc(sys)
	}
      }
      C { }
    @Rowb above { yes }
      A { tf2ss }
      B { function to state-space conversion
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  *** no description ***
	}
      }
      C { }
    @Rowb above { yes }
      A { tf2sys }
      B { transfer function to system conversion
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  *** no description ***
	}
      }
      C { }
    @Rowb above { yes }
      A { tf2sysl }
      B { strips leading zero coefficient in polynonials
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  *** no description ***
	}
      }
      C { internal use (used by tf2sys) }
    @Rowb above { yes }
      A { tf2zp }
      B { transfer function to state-space conversion
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  *** no description ***
	}
      }
      C { }
    @Rowb above { yes }
      A { zp2ss }
      B { zero-pole representation to state space form conversion
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  *** no description ***
	}
      }
      C { }
    @Rowb above { yes }
      A { zp2ssg2 }
      B { used by zp2ssg2
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  *** no description ***
	}
      }
      C { internal use }
    @Rowb above { yes }
      A { zp2sys }
      B { zero-pole representation to packed system conversion
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  outsys = zp2sys(zer, pol, k [, tsam, inname, outname])
	}
      }
      C { }
    @Rowb above { yes }
      A { zp2tf }
      B { zero-pole representation to transfer function conversion
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  *** no description ***
	}
      }
      C { }
  }
  @NP
@End @Section

@Section
  @Title { Equation Solvers and Math Functions }
@Begin
  @PP
  @Tab
    between { single }
    @Fmta { @Col @Heading A !
            @Col @Heading B !
	    @Col @Heading C }
    @Fmtb { @Col 3c @Wide { ragged nohyphen } @Break A !
            @Col 7c @Wide { ragged nohyphen } @Break B !
	    @Col 3c @Wide { ragged nohyphen } @Break C }
  {
    @Rowa above { double } below { double }
      A { name } B { description "/" usage } C { remarks } 
    @Rowb above { yes }
      A { are }
      B { algebraic riccati equation solver
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  x = are (a, b, c)
	}
      }
      C { }
    @Rowb above { yes }
      A { dlyap }
      B { discrete Lyapunov equation solver
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  *** no description ***
	}
      }
      C { }
    @Rowb above { yes }
      A { dare }
      B { discrete algebaic riccati equation solver
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  *** no description ***
	}
      }
      C { }
    @Rowb above { yes }
      A { lyap }
      B { Lyapunov"/"Sylvester equation solver
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  lyap (a, b [,c])
	}
      }
      C { }
    @Rowb above { yes }
      A { pinv }
      B { pseudoinverse of a matrix
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  *** no description ***
	}
      }
      C { }
    @Rowb above { yes }
      A { zgfmul }
      B { compute product of zgep incidence matrix f with vector x
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  *** no description ***
	}
      }
      C { used by zgscal }
    @Rowb above { yes }
      A { zgfslv }
      B { solve system of equations for dense zgep problem
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  *** no description ***
	}
      }
      C { }
    @Rowb above { yes }
      A { zginit }
      B { construct right hand side for the zero-computation generalized
	  eigenvalue problem
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  *** no description ***
	}
      }
      C { }
    @Rowb above { yes }
      A { zgscal }
      B { generalized conjugate gradient iteration to solve zero-computation
	  generalized eigenvalue problem balancing equation
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  *** no description ***
	}
      }
      C { }
  }

  @DP @PP
  @Tab
    between { single }
    @Fmta { @Col @Heading A !
            @Col @Heading B !
	    @Col @Heading C }
    @Fmtb { @Col 3c @Wide { ragged nohyphen } @Break A !
            @Col 7c @Wide { ragged nohyphen } @Break B !
	    @Col 3c @Wide { ragged nohyphen } @Break C }
  {
    @Rowa above { double } below { double }
      A { name } B { description "/" usage } C { remarks } 
    @Rowb above { yes }
      A {zgsgiv  }
      B { apply givens rotation c,s to column vector a,b
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  *** no description ***
	}
      }
      C { }
    @Rowb above { yes }
      A { zgshsr }
      B { apply householder vector, used by zgfslv
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  *** no description ***
	}
      }
      C { }
  }
@End @Section

@Section
  @Title { Controller Design }
@Begin
  @BeginSubSections
  @SubSection
    @Title { Classic Methods }
  @Begin
  @PP
  @Tab
    between { single }
    @Fmta { @Col @Heading A !
            @Col @Heading B !
	    @Col @Heading C }
    @Fmtb { @Col 3c @Wide { ragged nohyphen } @Break A !
            @Col 7c @Wide { ragged nohyphen } @Break B !
	    @Col 3c @Wide { ragged nohyphen } @Break C }
  {
    @Rowa above { double } below { double }
      A { name } B { description "/" usage } C { remarks } 
    @Rowb above { yes }
      A { dlqe }
      B { discrete Kalman filter design
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  *** no description ***
	}
      }
      C { }
    @Rowb above { yes }
      A { dlqr }
      B { discrete linear quadratic regulator (Riccati controller) design
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  [k, p, e] = lqr (A, B, Q, R [, Z])
	}
      }
      C { }
    @Rowb above { yes }
      A { lqe }
      B { contiuous time Kalman filter design
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  *** no description ***
	}
      }
      C { }
    @Rowb above { yes }
      A { lqg }
      B { continuous"/"discrete lqg (linear quadratic gaussian) controller
          design
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  *** no description ***
	}
      }
      C { }
    @Rowb above { yes }
      A { lqr }
      B { continuous lqr (Riccati-) controller design
        @DP { Helvetica Base -2p } @Font @CurveBox {
	*** no description ***
      }
      }
      C { }
    @Rowb above { yes }
      A { place }
      B { calculation of feedback gain matrix K, using pole-placement
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  K = place(sys, P)
	}
      }
      C { }
  }
  @NP
  @End @SubSection

  @SubSection
    @Title { Modern Methods }
  @Begin
  @PP
  @Tab
    between { single }
    @Fmta { @Col @Heading A !
            @Col @Heading B !
	    @Col @Heading C }
    @Fmtb { @Col 3c @Wide { ragged nohyphen } @Break A !
            @Col 7c @Wide { ragged nohyphen } @Break B !
	    @Col 3c @Wide { ragged nohyphen } @Break C }
  {
    @Rowa above { double } below { double }
      A { name } B { description "/" usage } C { remarks } 
    @Rowb above { yes }
      A { h2syn }
      B { H{ @Sub 2}-optimal controller design
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  [K, gain, Kc, Kf, Pc, Pf] = h2syn(Asys, nu, ny [, tol])
	}
      }
      C { }
    @Rowb above { yes }
      A { hinfsyn }
      B { continuous system H{ @Sub @Sym infinity}-optimal controller design
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  [K,g, ghi, glo, Pc, Pf] = hinfsyn(Asys, nu, ny, gmax,
	  gmin, gtol [, ptol, tol])
	}
      }
      C { }
    @Rowb above { yes }
      A { hinfsyn_chk }
      B { check of existence of an H{ @Sub @Sym infinity}-optimal
          controller, used internally by hinfsyn
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  *** no description ***
	}
      }
      C { internal use }
  }
  @End @SubSection
  @EndSubSections
  @NP
@End @Section

@Section
  @Title { Miscellanious }
@Begin
  @PP
  @Tab
    between { single }
    @Fmta { @Col @Heading A !
            @Col @Heading B !
	    @Col @Heading C }
    @Fmtb { @Col 3c @Wide { ragged nohyphen } @Break A !
            @Col 7c @Wide { ragged nohyphen } @Break B !
	    @Col 3c @Wide { ragged nohyphen } @Break C }
  {
    @Rowa above { double } below { double }
      A { name } B { description "/" usage } C { remarks } 
    @Rowb above { yes }
      A { analdemo }
      B { state space analysis demo
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  no parameters
	}
      }
      C { use by controldemo }
    @Rowb above { yes }
      A { bddemo }
      B { block diagram manipulations demo
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  no parameters
	}
      }
      C { used by controldemo }
    @Rowb above { yes }
      A { controldemo }
      B { Octave Controls Toolbox demo
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  no parameters
	}
      }
      C { }
    @Rowb above { yes }
      A { frdemo }
      B { menu-based frequency response demo
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  no parameters
	}
      }
      C { used by controldemo }
    @Rowb above { yes }
      A { jet707 }
      B { Boeing 707-321 aircraft mimo example
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  outsys = jet707()
	}
      }
      C { }
    @Rowb above { yes }
      A { ord2 }
      B { second order siso example
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  outsys = ord2(nfreq, damp[, gain])
	}
      }
      C { }
    @Rowb above { yes }
      A { dgkfdemo }
      B { H{ @Sub 2}"/"H{@Sub @Sym infinity} controller design demo
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  no parameters
	}
      }
      C { }
    @Rowb above { yes }
      A { moddemo }
      B { system conversion demo
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  no parameters
	}
      }
      C { used by controldemo }
    @Rowb above { yes }
      A { packedform }
      B { srcipt for sysrepdemo, the system representations demo
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  *** no description ***
	}
      }
      C { used by controldemo }
    @Rowb above { yes }
      A { rldemo }
      B { root locus demo
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  no parameters
	}
      }
      C { used by controldemo }
    @Rowb above { yes }
      A { sysrepdemo }
      B { system representation demo
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  no parameters
	}
      }
      C { used by controldemo }
  }
@End @Section

@Section
  @Title { New Functions (most likely not on your system) }
@Begin
  @PP
  @Tab
    between { single }
    @Fmta { @Col @Heading A !
            @Col @Heading B !
	    @Col @Heading C }
    @Fmtb { @Col 3c @Wide { ragged nohyphen } @Break A !
            @Col 7c @Wide { ragged nohyphen } @Break B !
	    @Col 3c @Wide { ragged nohyphen } @Break C }
  {
    @Rowa above { double } below { double }
      A { name } B { description "/" usage } C { remarks } 
    @Rowb above { yes }
      A { ctrb }
      B { Forms the controllability matrix of a system
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  ctrb(sys [, b])
	}
      }
      C { *not* for controllablity tests, use is_controllable instead
      }
    @Rowb above { yes }
      A { is_abcd }
      B { Returns true if dimensions are compatible, false otherwise.
          Complains about the (first) failing matrix dimension.
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  retval = is_abcd(a [, b, c, d])
	}
      }
      C { In contrast to abcddim() the function is_abcd() accepts
      1 to 4 arguments.
      }
    @Rowb above { yes }
      A { obsv }
      B { Forms the observability matrix of a system
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  obsv(sys [, c])
	}
      }
      C { *not* for observablity tests, use is_observable instead
      }
    @Rowb above { yes }
      A { template }
      B { Starting point for your own function
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  y = template(x[, a])
	}
      }
      C { ridiculous calculation }
  }
@End @Section

@Section
  @Title { Obsolete }
@Begin
  @PP
  @Tab
    between { single }
    @Fmta { @Col @Heading A !
            @Col @Heading B !
	    @Col @Heading C }
    @Fmtb { @Col 3c @Wide { ragged nohyphen } @Break A !
            @Col 7c @Wide { ragged nohyphen } @Break B !
	    @Col 3c @Wide { ragged nohyphen } @Break C }
  {
    @Rowa above { double } below { double }
      A { name } B { description "/" usage } C { remarks } 
    @Rowb above { yes }
      A { DEMOcontrol }
      B { Octave Controls Toolbox demo
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  no parameters
	}
      }
      C { obsolete - use democontrol instead }
    @Rowb above { yes }
      A { dlqg }
      B { discrete linear quadratic gaussian design
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  *** no description ***
	}
      }
      C { obsolete - use lqg instead } 
    @Rowb above { yes }
      A { minfo }
      B { determine type of system matrix
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  *** no description ***
	}
      }
      C { obsolete - use ss2sys, tf2sys, sys2ss, or sys2tf instead }
  }

  @DP @PP
  @Tab
    between { single }
    @Fmta { @Col @Heading A !
            @Col @Heading B !
	    @Col @Heading C }
    @Fmtb { @Col 3c @Wide { ragged nohyphen } @Break A !
            @Col 7c @Wide { ragged nohyphen } @Break B !
	    @Col 3c @Wide { ragged nohyphen } @Break C }
  {
    @Rowa above { double } below { double }
      A { name } B { description "/" usage } C { remarks } 
    @Rowb above { yes }
      A { packsys }
      B { pack A, B, C, D matrices into a system representation
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  *** no description ***
	}
      }
      C { obsolete - use ss2sys instead }
    @Rowb above { yes }
      A { rotg }
      B { givens rotation
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  *** no description ***
	}
      }
      C { obsolete - use givens instead }
    @Rowb above { yes }
      A { series }
      B { connect two systems
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  *** no description ***
	}
      }
      C { obsolete - superseeded by sysmult}
    @Rowb above { yes }
      A { unpacksys }
      B { conversion from packed system (sys) to state space
          @DP { Helvetica Base -2p } @Font @CurveBox {
	  *** no description ***
	}
      }
      C { use sys2ss insted}
  }
@End @Section

@Section
  @Title { Dubious }
@Begin
  @PP
  @Tab
    between { single }
    @Fmta { @Col @Heading A !
            @Col @Heading B !
	    @Col @Heading C }
    @Fmtb { @Col 3c @Wide { ragged nohyphen } @Break A !
            @Col 7c @Wide { ragged nohyphen } @Break B !
	    @Col 3c @Wide { ragged nohyphen } @Break C }
  {
    @Rowa above { double } below { double }
      A { name } B { description "/" usage } C { remarks } 
    @Rowb above { yes }
      A { demomarsyas }
      B { unknown interface demo }
      C { }
    @Rowb above { yes }
      A { mb }
      B { unknown purpose }
      C { }
    @Rowb above { yes }
      A { sysball }
      B { unknown purpose }
      C { }
  }
@End @Section

@Appendix
  @Title { Maintainer }
@Begin
@PP
Mail any comments or suggestions to Kai P. Mueller
<mueller@ifr.ing.tu-bs.de>.
Report m-files problems to A. Scottedward Hodel
<A.S.Hodel@Eng.Auburn.EDU> or to the authors.
@End @Appendix

@Appendix
  @Title { Production Note }
@Begin
@PP
A recent version of this brochure can be copied from
@LLP
ftp:"//"ifr.ing.tu-bs.de"/"pub"/"ControlSW"/"doc
("\""lout"\"" source and PostScript{@Sup @Char registered}).
I am too dump to supply a T{/0.2fo E}X source.
@End @Appendix
