diff -ur SuiteSparse/AMD/Demo/Makefile SuiteSparse-mod/AMD/Demo/Makefile
--- SuiteSparse/AMD/Demo/Makefile	2006-05-02 08:31:06.000000000 +0200
+++ SuiteSparse-mod/AMD/Demo/Makefile	2007-02-12 10:29:18.394295500 +0100
@@ -2,10 +2,10 @@
 # compile the AMD demo (for both GNU make or original make)
 #-----------------------------------------------------------------------------
 
-default: amd_simple amd_demo amd_demo2 amd_l_demo
-
 include ../../UFconfig/UFconfig.mk
 
+default: amd_simple$(EXEEXT) amd_demo$(EXEEXT) amd_demo2$(EXEEXT) amd_l_demo$(EXEEXT)
+
 C = $(CC) $(CFLAGS) $(CONFIG) -I../Include -I../../UFconfig
 
 UFCONFIG = ../../UFconfig/UFconfig.h
@@ -24,54 +24,54 @@
 
 dist:
 
-amd_demo: amd_demo.c library $(INC)
-	$(C) -o amd_demo amd_demo.c ../Lib/libamd.a $(LIB)
+amd_demo$(EXEEXT): amd_demo.c library $(INC)
+	$(C) -o amd_demo$(EXEEXT) amd_demo.c ../Lib/$(LIBPRE)amd.$(LIBEXT) $(CLIB)
 	./amd_demo > my_amd_demo.out
-	- diff amd_demo.out my_amd_demo.out
+	- diff -b amd_demo.out my_amd_demo.out
 
-amd_l_demo: amd_l_demo.c library $(INC)
-	$(C) -o amd_l_demo amd_l_demo.c ../Lib/libamd.a $(LIB)
+amd_l_demo$(EXEEXT): amd_l_demo.c library $(INC)
+	$(C) -o amd_l_demo$(EXEEXT) amd_l_demo.c ../Lib/$(LIBPRE)amd.$(LIBEXT) $(CLIB)
 	./amd_l_demo > my_amd_l_demo.out
-	- diff amd_l_demo.out my_amd_l_demo.out
+	- diff -b amd_l_demo.out my_amd_l_demo.out
 
-amd_demo2: amd_demo2.c library $(INC)
-	$(C) -o amd_demo2 amd_demo2.c ../Lib/libamd.a $(LIB)
+amd_demo2$(EXEEXT): amd_demo2.c library $(INC)
+	$(C) -o amd_demo2$(EXEEXT) amd_demo2.c ../Lib/$(LIBPRE)amd.$(LIBEXT) $(CLIB)
 	./amd_demo2 > my_amd_demo2.out
-	- diff amd_demo2.out my_amd_demo2.out
+	- diff -b amd_demo2.out my_amd_demo2.out
 
-amd_simple: amd_simple.c library $(INC)
-	$(C) -o amd_simple amd_simple.c ../Lib/libamd.a $(LIB)
+amd_simple$(EXEEXT): amd_simple.c library $(INC)
+	$(C) -o amd_simple$(EXEEXT) amd_simple.c ../Lib/$(LIBPRE)amd.$(LIBEXT) $(CLIB)
 	./amd_simple > my_amd_simple.out
-	- diff amd_simple.out my_amd_simple.out
+	- diff -b amd_simple.out my_amd_simple.out
 
 #------------------------------------------------------------------------------
 # compile the Fortran demo
 #------------------------------------------------------------------------------
 
-fortran: amd_f77demo amd_f77simple
+fortran: amd_f77demo$(EXEEXT) amd_f77simple$(EXEEXT)
 
-cross: amd_f77cross
+cross: amd_f77cross$(EXEEXT)
 
-amd_f77demo: amd_f77demo.f f77lib
-	$(F77) $(F77FLAGS) -o amd_f77demo amd_f77demo.f ../Lib/libamdf77.a \
+amd_f77demo$(EXEEXT): amd_f77demo.f f77lib
+	$(F77) $(F77FLAGS) -o amd_f77demo$(EXEEXT) amd_f77demo.f ../Lib/$(LIBPRE)amdf77.$(LIBEXT) \
 	    $(F77LIB)
 	./amd_f77demo > my_amd_f77demo.out
-	- diff amd_f77demo.out my_amd_f77demo.out
+	- diff -b amd_f77demo.out my_amd_f77demo.out
 
-amd_f77simple: amd_f77simple.f f77lib
-	$(F77) $(F77FLAGS) -o amd_f77simple amd_f77simple.f \
-	    ../Lib/libamdf77.a $(F77LIB)
+amd_f77simple$(EXEEXT): amd_f77simple.f f77lib
+	$(F77) $(F77FLAGS) -o amd_f77simple$(EXEEXT) amd_f77simple.f \
+	    ../Lib/$(LIBPRE)amdf77.$(LIBEXT) $(F77LIB)
 	./amd_f77simple > my_amd_f77simple.out
-	- diff amd_f77simple.out my_amd_f77simple.out
+	- diff -b amd_f77simple.out my_amd_f77simple.out
 
 amd_f77wrapper.o: amd_f77wrapper.c
 	$(C) -DDINT -c amd_f77wrapper.c
 
-amd_f77cross:  amd_f77cross.f amd_f77wrapper.o ../Lib/libamd.a
+amd_f77cross:  amd_f77cross.f amd_f77wrapper.o ../Lib/$(LIBPRE)amd.$(LIBEXT)
 	$(F77) $(F77FLAGS) -o amd_f77cross amd_f77cross.f amd_f77wrapper.o \
-	    ../Lib/libamd.a $(F77LIB)
+	    ../Lib/$(LIBPRE)amd.$(LIBEXT) $(F77LIB)
 	./amd_f77cross > my_amd_f77cross.out
-	- diff amd_f77cross.out my_amd_f77cross.out
+	- diff -b amd_f77cross.out my_amd_f77cross.out
 
 #------------------------------------------------------------------------------
 # Remove all but the files in the original distribution
@@ -83,10 +83,10 @@
 purge: distclean
 
 distclean: clean
-	- $(RM) amd_demo my_amd_demo.out
-	- $(RM) amd_l_demo my_amd_l_demo.out
-	- $(RM) amd_demo2 my_amd_demo2.out
-	- $(RM) amd_simple my_amd_simple.out
-	- $(RM) amd_f77demo my_amd_f77demo.out
-	- $(RM) amd_f77simple my_amd_f77simple.out
-	- $(RM) amd_f77cross my_amd_f77cross.out
+	- $(RM) amd_demo$(EXEEXT) my_amd_demo.out
+	- $(RM) amd_l_demo$(EXEEXT) my_amd_l_demo.out
+	- $(RM) amd_demo2$(EXEEXT) my_amd_demo2.out
+	- $(RM) amd_simple$(EXEEXT) my_amd_simple.out
+	- $(RM) amd_f77demo$(EXEEXT) my_amd_f77demo.out
+	- $(RM) amd_f77simple$(EXEEXT) my_amd_f77simple.out
+	- $(RM) amd_f77cross$(EXEEXT) my_amd_f77cross.out
diff -ur SuiteSparse/AMD/Makefile SuiteSparse-mod/AMD/Makefile
--- SuiteSparse/AMD/Makefile	2006-04-29 15:28:14.000000000 +0200
+++ SuiteSparse-mod/AMD/Makefile	2007-02-12 10:29:18.409918900 +0100
@@ -2,13 +2,13 @@
 # AMD Makefile (for GNU Make or original make)
 #------------------------------------------------------------------------------
 
-default: demo
+default: do_demo
 
 include ../UFconfig/UFconfig.mk
 
 # Compile all C code, including the C-callable routine and the mexFunctions.
 # Do not compile the FORTRAN versions, or MATLAB interface.
-demo:
+do_demo:
 	( cd Source ; $(MAKE) )
 	( cd Demo   ; $(MAKE) )
 
diff -ur SuiteSparse/AMD/Source/GNUmakefile SuiteSparse-mod/AMD/Source/GNUmakefile
--- SuiteSparse/AMD/Source/GNUmakefile	2006-05-02 08:12:28.000000000 +0200
+++ SuiteSparse-mod/AMD/Source/GNUmakefile	2007-02-12 10:29:18.441165700 +0100
@@ -2,10 +2,10 @@
 # AMD Makefile for compiling on Unix systems (for GNU make only)
 #-------------------------------------------------------------------------------
 
-default: ../Lib/libamd.a
-
 include ../../UFconfig/UFconfig.mk
 
+default: ../Lib/$(LIBPRE)amd.$(LIBEXT)
+
 C = $(CC) $(CFLAGS) $(CONFIG) -I../Include -I../../UFconfig
 
 #-------------------------------------------------------------------------------
@@ -43,15 +43,15 @@
 # Create the libamd.a library (C versions only)
 #-------------------------------------------------------------------------------
 
-../Lib/libamd.a: amd_global.o $(AMDI) $(AMDL)
-	$(AR) ../Lib/libamd.a $^
-	- $(RANLIB) ../Lib/libamd.a
+../Lib/$(LIBPRE)amd.$(LIBEXT): amd_global.o $(AMDI) $(AMDL)
+	$(AR) ../Lib/$(LIBPRE)amd.$(LIBEXT) $^
+	- $(RANLIB) ../Lib/$(LIBPRE)amd.$(LIBEXT)
 
 #-------------------------------------------------------------------------------
 # compile the Fortran versions and the libamdf77.a library
 #-------------------------------------------------------------------------------
 
-fortran: ../Lib/libamdf77.a
+fortran: ../Lib/$(LIBPRE)amdf77.$(LIBEXT)
 
 AMDF77 = amd.o amdbar.o
 
@@ -61,9 +61,9 @@
 amdbar.o: amdbar.f
 	$(F77) $(F77FLAGS) -c amdbar.f -o amdbar.o
 
-../Lib/libamdf77.a: $(AMDF77)
-	$(AR) ../Lib/libamdf77.a $^
-	- $(RANLIB) ../Lib/libamdf77.a
+../Lib/$(LIBPRE)amdf77.$(LIBEXT): $(AMDF77)
+	$(AR) ../Lib/$(LIBPRE)amdf77.$(LIBEXT) $^
+	- $(RANLIB) ../Lib/$(LIBPRE)amdf77.$(LIBEXT)
 
 #-------------------------------------------------------------------------------
 # Remove all but the files in the original distribution
@@ -75,5 +75,5 @@
 purge: distclean
 
 distclean: clean
-	- $(RM) ../Lib/libamd.a
-	- $(RM) ../Lib/libamdf77.a
+	- $(RM) ../Lib/$(LIBPRE)amd.$(LIBEXT)
+	- $(RM) ../Lib/$(LIBPRE)amdf77.$(LIBEXT)
diff -ur SuiteSparse/BTF/Lib/Makefile SuiteSparse-mod/BTF/Lib/Makefile
--- SuiteSparse/BTF/Lib/Makefile	2006-01-30 11:43:22.000000000 +0100
+++ SuiteSparse-mod/BTF/Lib/Makefile	2007-02-12 10:29:18.456789100 +0100
@@ -15,13 +15,13 @@
 
 all: library
 
-library: libbtf.a
+library: $(LIBPRE)btf.$(LIBEXT)
 
 OBJ = btf_order.o maxtrans.o strongcomp.o
 
-libbtf.a: $(OBJ)
-	$(AR) libbtf.a $(OBJ)
-	$(RANLIB) libbtf.a
+$(LIBPRE)btf.$(LIBEXT): $(OBJ)
+	$(AR) $(LIBPRE)btf.$(LIBEXT) $(OBJ)
+	$(RANLIB) $(LIBPRE)btf.$(LIBEXT)
 
 $(OBJ): $(INC)
 
@@ -41,7 +41,7 @@
 purge: distclean
 
 distclean: clean
-	- $(RM) libbtf.a 
+	- $(RM) $(LIBPRE)btf.$(LIBEXT) 
 
 clean:
 	- $(RM) $(CLEAN)
diff -ur SuiteSparse/CAMD/Demo/Makefile SuiteSparse-mod/CAMD/Demo/Makefile
--- SuiteSparse/CAMD/Demo/Makefile	2006-05-02 08:19:04.000000000 +0200
+++ SuiteSparse-mod/CAMD/Demo/Makefile	2007-02-12 10:29:18.472412500 +0100
@@ -2,10 +2,10 @@
 # compile the CAMD demo (for both GNU make or original make)
 #-----------------------------------------------------------------------------
 
-default: camd_simple camd_demo camd_demo2 camd_l_demo
-
 include ../../UFconfig/UFconfig.mk
 
+default: camd_simple$(EXEEXT) camd_demo$(EXEEXT) camd_demo2$(EXEEXT) camd_l_demo$(EXEEXT)
+
 C = $(CC) $(CFLAGS) $(CONFIG) -I../Include -I../../UFconfig
 
 UFCONFIG = ../../UFconfig/UFconfig.h
@@ -21,25 +21,25 @@
 
 dist:
 
-camd_demo: camd_demo.c library $(INC)
-	$(C) -o camd_demo camd_demo.c ../Lib/libcamd.a $(LIB)
+camd_demo$(EXEEXT): camd_demo.c library $(INC)
+	$(C) -o camd_demo$(EXEEXT) camd_demo.c ../Lib/$(LIBPRE)camd.$(LIBEXT) $(CLIB)
 	./camd_demo > my_camd_demo.out
-	- diff camd_demo.out my_camd_demo.out
+	- diff -b camd_demo.out my_camd_demo.out
 
-camd_l_demo: camd_l_demo.c library $(INC)
-	$(C) -o camd_l_demo camd_l_demo.c ../Lib/libcamd.a $(LIB)
+camd_l_demo$(EXEEXT): camd_l_demo.c library $(INC)
+	$(C) -o camd_l_demo$(EXEEXT) camd_l_demo.c ../Lib/$(LIBPRE)camd.$(LIBEXT) $(CLIB)
 	./camd_l_demo > my_camd_l_demo.out
-	- diff camd_l_demo.out my_camd_l_demo.out
+	- diff -b camd_l_demo.out my_camd_l_demo.out
 
-camd_demo2: camd_demo2.c library $(INC)
-	$(C) -o camd_demo2 camd_demo2.c ../Lib/libcamd.a $(LIB)
+camd_demo2$(EXEEXT): camd_demo2.c library $(INC)
+	$(C) -o camd_demo2$(EXEEXT) camd_demo2.c ../Lib/$(LIBPRE)camd.$(LIBEXT) $(CLIB)
 	./camd_demo2 > my_camd_demo2.out
-	- diff camd_demo2.out my_camd_demo2.out
+	- diff -b camd_demo2.out my_camd_demo2.out
 
-camd_simple: camd_simple.c library $(INC)
-	$(C) -o camd_simple camd_simple.c ../Lib/libcamd.a $(LIB)
+camd_simple$(EXEEXT): camd_simple.c library $(INC)
+	$(C) -o camd_simple$(EXEEXT) camd_simple.c ../Lib/$(LIBPRE)camd.$(LIBEXT) $(CLIB)
 	./camd_simple > my_camd_simple.out
-	- diff camd_simple.out my_camd_simple.out
+	- diff -b camd_simple.out my_camd_simple.out
 
 #------------------------------------------------------------------------------
 # Remove all but the files in the original distribution
@@ -51,7 +51,7 @@
 purge: distclean
 
 distclean: clean
-	- $(RM) camd_demo my_camd_demo.out
-	- $(RM) camd_l_demo my_camd_l_demo.out
-	- $(RM) camd_demo2 my_camd_demo2.out
-	- $(RM) camd_simple my_camd_simple.out
+	- $(RM) camd_demo$(EXEEXT) my_camd_demo.out
+	- $(RM) camd_l_demo$(EXEEXT) my_camd_l_demo.out
+	- $(RM) camd_demo2$(EXEEXT) my_camd_demo2.out
+	- $(RM) camd_simple$(EXEEXT) my_camd_simple.out
diff -ur SuiteSparse/CAMD/Makefile SuiteSparse-mod/CAMD/Makefile
--- SuiteSparse/CAMD/Makefile	2006-04-29 15:28:36.000000000 +0200
+++ SuiteSparse-mod/CAMD/Makefile	2007-02-12 10:29:18.503659300 +0100
@@ -2,13 +2,13 @@
 # CAMD Makefile (for GNU Make or original make)
 #------------------------------------------------------------------------------
 
-default: demo
+default: do_demo
 
 include ../UFconfig/UFconfig.mk
 
 # Compile all C code, including the C-callable routine and the mexFunctions.
 # Do not compile the FORTRAN versions, or MATLAB interface.
-demo:
+do_demo:
 	( cd Source ; $(MAKE) )
 	( cd Demo   ; $(MAKE) )
 
diff -ur SuiteSparse/CAMD/Source/GNUmakefile SuiteSparse-mod/CAMD/Source/GNUmakefile
--- SuiteSparse/CAMD/Source/GNUmakefile	2006-05-02 08:19:44.000000000 +0200
+++ SuiteSparse-mod/CAMD/Source/GNUmakefile	2007-02-12 10:29:18.519282700 +0100
@@ -2,10 +2,10 @@
 # CAMD Makefile for compiling on Unix systems (for GNU make only)
 #-------------------------------------------------------------------------------
 
-default: ../Lib/libcamd.a
-
 include ../../UFconfig/UFconfig.mk
 
+default: ../Lib/$(LIBPRE)camd.$(LIBEXT)
+
 C = $(CC) $(CFLAGS) $(CONFIG) -I../Include -I../../UFconfig
 
 #-------------------------------------------------------------------------------
@@ -43,9 +43,9 @@
 # Create the libcamd.a library (C versions only)
 #-------------------------------------------------------------------------------
 
-../Lib/libcamd.a: camd_global.o $(CAMDI) $(CAMDL)
-	$(AR) ../Lib/libcamd.a $^
-	- $(RANLIB) ../Lib/libcamd.a
+../Lib/$(LIBPRE)camd.$(LIBEXT): camd_global.o $(CAMDI) $(CAMDL)
+	$(AR) ../Lib/$(LIBPRE)camd.$(LIBEXT) $^
+	- $(RANLIB) ../Lib/$(LIBPRE)camd.$(LIBEXT)
 
 #-------------------------------------------------------------------------------
 # Remove all but the files in the original distribution
@@ -57,4 +57,4 @@
 purge: distclean
 
 distclean: clean
-	- $(RM) ../Lib/libcamd.a
+	- $(RM) ../Lib/$(LIBPRE)camd.$(LIBEXT)
diff -ur SuiteSparse/CCOLAMD/Makefile SuiteSparse-mod/CCOLAMD/Makefile
--- SuiteSparse/CCOLAMD/Makefile	2006-08-16 10:16:04.000000000 +0200
+++ SuiteSparse-mod/CCOLAMD/Makefile	2007-02-12 10:29:18.534906100 +0100
@@ -1,51 +1,51 @@
 
-default: ccolamd_example ccolamd_l_example libccolamd.a
-
 include ../UFconfig/UFconfig.mk
 
+default: ccolamd_example$(EXEEXT) ccolamd_l_example$(EXEEXT) $(LIBPRE)ccolamd.$(LIBEXT)
+
 I = -I../UFconfig
 
-ccolamd_example:  ccolamd_example.c libccolamd.a
-	$(CC) $(CFLAGS) $(I) -o ccolamd_example ccolamd_example.c libccolamd.a -lm
+ccolamd_example$(EXEEXT):  ccolamd_example.c $(LIBPRE)ccolamd.$(LIBEXT)
+	$(CC) $(CFLAGS) $(I) -o ccolamd_example$(EXEEXT) ccolamd_example.c $(LIBPRE)ccolamd.$(LIBEXT) $(CLIB)
 	- ./ccolamd_example > my_ccolamd_example.out
-	- diff ccolamd_example.out my_ccolamd_example.out
+	- diff -b ccolamd_example.out my_ccolamd_example.out
 
-ccolamd_l_example:  ccolamd_l_example.c libccolamd.a
-	$(CC) $(CFLAGS) $(I) -o ccolamd_l_example ccolamd_l_example.c libccolamd.a -lm
+ccolamd_l_example$(EXEEXT):  ccolamd_l_example.c $(LIBPRE)ccolamd.$(LIBEXT)
+	$(CC) $(CFLAGS) $(I) -o ccolamd_l_example$(EXEEXT) ccolamd_l_example.c $(LIBPRE)ccolamd.$(LIBEXT) $(CLIB)
 	- ./ccolamd_l_example > my_ccolamd_l_example.out
-	- diff ccolamd_l_example.out my_ccolamd_l_example.out
+	- diff -b ccolamd_l_example.out my_ccolamd_l_example.out
 
 purge: distclean
 
 distclean: clean2
-	- $(RM) libccolamd.a
+	- $(RM) $(LIBPRE)ccolamd.$(LIBEXT)
 
 clean2: clean
-	- $(RM) *.o *.dll ccolamd_example ccolamd_l_example
+	- $(RM) *.o *.dll ccolamd_example$(EXEEXT) ccolamd_l_example$(EXEEXT)
 	- $(RM) ccolamd.mex* csymamd.mex*
 	- $(RM) ccolamdtestmex.mex* csymamdtestmex.mex*
 	- $(RM) my_ccolamd_example.out my_ccolamd_l_example.out
 
 # Compiles the MATLAB-callable routines
-mex: ccolamdmex.c csymamdmex.c libccolamd.a
-	$(MEX) $(I) -output ccolamd ccolamdmex.c libccolamd.a
-	$(MEX) $(I) -output csymamd csymamdmex.c libccolamd.a
+mex: ccolamdmex.c csymamdmex.c $(LIBPRE)ccolamd.$(LIBEXT)
+	$(MEX) $(I) -output ccolamd ccolamdmex.c $(LIBPRE)ccolamd.$(LIBEXT)
+	$(MEX) $(I) -output csymamd csymamdmex.c $(LIBPRE)ccolamd.$(LIBEXT)
 
 # Compiles the extensive test code
-test: mex ccolamdtestmex.c csymamdtestmex.c libccolamd.a
-	$(MEX) $(I) ccolamdtestmex.c libccolamd.a
-	$(MEX) $(I) csymamdtestmex.c libccolamd.a
+test: mex ccolamdtestmex.c csymamdtestmex.c $(LIBPRE)ccolamd.$(LIBEXT)
+	$(MEX) $(I) ccolamdtestmex.c $(LIBPRE)ccolamd.$(LIBEXT)
+	$(MEX) $(I) csymamdtestmex.c $(LIBPRE)ccolamd.$(LIBEXT)
 
 # creates libccolamd.a, a C-callable CCOLAMD library
-libccolamd.a:  ccolamd.c ccolamd_global.c ccolamd.h
+$(LIBPRE)ccolamd.$(LIBEXT):  ccolamd.c ccolamd_global.c ccolamd.h
 	$(CC) $(CFLAGS) $(I) -c ccolamd_global.c
 	$(CC) $(CFLAGS) $(I) -c ccolamd.c
 	$(CC) $(CFLAGS) $(I) -c ccolamd.c -DDLONG -o ccolamd_l.o
-	$(AR) libccolamd.a ccolamd.o ccolamd_l.o ccolamd_global.o
+	$(AR) $(LIBPRE)ccolamd.$(LIBEXT) ccolamd.o ccolamd_l.o ccolamd_global.o
 
-ccode: libccolamd.a
+ccode: $(LIBPRE)ccolamd.$(LIBEXT)
 
-library: libccolamd.a
+library: $(LIBPRE)ccolamd.$(LIBEXT)
 
 clean:
 	- $(RM) $(CLEAN)
diff -ur SuiteSparse/CHOLMOD/Demo/Makefile SuiteSparse-mod/CHOLMOD/Demo/Makefile
--- SuiteSparse/CHOLMOD/Demo/Makefile	2006-08-25 10:41:40.000000000 +0200
+++ SuiteSparse-mod/CHOLMOD/Demo/Makefile	2007-02-12 10:29:18.550529500 +0100
@@ -11,9 +11,9 @@
 
 #-------------------------------------------------------------------------------
 # With METIS, CCOLAMD, CAMD, and the Partition Module:
-LIB2 = ../Lib/libcholmod.a ../../AMD/Lib/libamd.a ../../COLAMD/libcolamd.a \
-	../../CCOLAMD/libccolamd.a ../../CAMD/Lib/libcamd.a \
-	$(METIS) $(LAPACK) $(BLAS) $(XERBLA) $(LIB)
+LIB2 = ../Lib/$(LIBPRE)cholmod.$(LIBEXT) ../../AMD/Lib/$(LIBPRE)amd.$(LIBEXT) ../../COLAMD/$(LIBPRE)colamd.$(LIBEXT) \
+	../../CCOLAMD/$(LIBPRE)ccolamd.$(LIBEXT) ../../CAMD/Lib/$(LIBPRE)camd.$(LIBEXT) \
+	$(METIS) $(LAPACK) $(BLAS) $(XERBLA) $(CLIB)
 # Use this instead, if you compile with -DNPARTITION:
 # LIB2 = ../Lib/libcholmod.a ../../AMD/Lib/libamd.a ../../COLAMD/libcolamd.a \
 	$(LAPACK) $(BLAS) $(XERBLA) $(LIB)
@@ -21,9 +21,9 @@
 
 C = $(CC) $(CFLAGS) $(CHOLMOD_CONFIG)
 
-code: library cholmod_demo cholmod_l_demo cholmod_simple
+code: library cholmod_demo$(EXEEXT) cholmod_l_demo$(EXEEXT) cholmod_simple$(EXEEXT)
 
-fortran: readhb readhb2 reade 
+fortran: readhb$(EXEEXT) readhb2$(EXEEXT) reade$(EXEEXT) 
 
 all: code
 	./cholmod_demo < Matrix/bcsstk01.tri
@@ -41,8 +41,8 @@
 distclean: purge
 
 purge: clean
-	- $(RM) cholmod_demo cholmod_l_demo readhb readhb2 reade
-	- $(RM) cholmod_simple
+	- $(RM) cholmod_demo$(EXEEXT) cholmod_l_demo$(EXEEXT) readhb$(EXEEXT) readhb2$(EXEEXT) reade$(EXEEXT)
+	- $(RM) cholmod_simple$(EXEEXT)
 
 clean:
 	- $(RM) $(CLEAN)
@@ -66,20 +66,20 @@
 
 I = -I../Include -I../../UFconfig
 
-cholmod_demo: library cholmod_demo.c cholmod_demo.h
-	$(C) -o cholmod_demo $(I) cholmod_demo.c $(LIB2)
+cholmod_demo$(EXEEXT): library cholmod_demo.c cholmod_demo.h
+	$(C) -o cholmod_demo$(EXEEXT) $(I) cholmod_demo.c $(LIB2)
 
-cholmod_simple: library cholmod_simple.c
-	$(C) -o cholmod_simple $(I) cholmod_simple.c $(LIB2)
+cholmod_simple$(EXEEXT): library cholmod_simple.c
+	$(C) -o cholmod_simple$(EXEEXT) $(I) cholmod_simple.c $(LIB2)
 
-cholmod_l_demo: library cholmod_l_demo.c cholmod_demo.h
-	$(C) -o cholmod_l_demo $(I) cholmod_l_demo.c $(LIB2)
+cholmod_l_demo$(EXEEXT): library cholmod_l_demo.c cholmod_demo.h
+	$(C) -o cholmod_l_demo$(EXEEXT) $(I) cholmod_l_demo.c $(LIB2)
 
-readhb: readhb.f
-	$(F77) $(FFLAGS) -o readhb readhb.f
+readhb$(EXEEXT): readhb.f
+	$(F77) $(FFLAGS) -o readhb$(EXEEXT) readhb.f
 
-readhb2: readhb2.f
-	$(F77) $(FFLAGS) -O -o readhb2 readhb2.f
+readhb2$(EXEEXT): readhb2.f
+	$(F77) $(FFLAGS) -O -o readhb2$(EXEEXT) readhb2.f
 
-reade: reade.f
-	$(F77) $(FFLAGS) -O -o reade reade.f
+reade$(EXEEXT): reade.f
+	$(F77) $(FFLAGS) -O -o reade$(EXEEXT) reade.f
diff -ur SuiteSparse/CHOLMOD/Include/cholmod_blas.h SuiteSparse-mod/CHOLMOD/Include/cholmod_blas.h
--- SuiteSparse/CHOLMOD/Include/cholmod_blas.h	2006-11-29 10:12:36.000000000 +0100
+++ SuiteSparse-mod/CHOLMOD/Include/cholmod_blas.h	2007-02-12 10:29:18.581776300 +0100
@@ -48,8 +48,10 @@
 #define CHOLMOD_CYGWIN
 #else
 #define CHOLMOD_WINDOWS
+#ifndef BLAS_UNDERSCORE
 #define BLAS_NO_UNDERSCORE
 #endif
+#endif
 #define CHOLMOD_ARCHITECTURE "Microsoft Windows"
 
 #elif defined (__hppa) || defined (__hpux) || defined (MHPUX) || defined (ARCH_HPUX)
diff -ur SuiteSparse/CHOLMOD/Lib/Makefile SuiteSparse-mod/CHOLMOD/Lib/Makefile
--- SuiteSparse/CHOLMOD/Lib/Makefile	2006-10-24 11:09:36.000000000 +0200
+++ SuiteSparse-mod/CHOLMOD/Lib/Makefile	2007-02-12 10:29:18.613023100 +0100
@@ -10,14 +10,14 @@
 
 C = $(CC) $(CFLAGS) $(CHOLMOD_CONFIG)
 
-all: libcholmod.a
+all: $(LIBPRE)cholmod.$(LIBEXT)
 
-library: libcholmod.a
+library: $(LIBPRE)cholmod.$(LIBEXT)
 
 purge: distclean
 
 distclean: clean
-	- $(RM) libcholmod.a
+	- $(RM) $(LIBPRE)cholmod.$(LIBEXT)
 
 clean:
 	- $(RM) $(CLEAN)
@@ -109,9 +109,9 @@
 # to compile just the double/int version, use OBJ = $(DI)
 OBJ = $(DI) $(DL)
 
-libcholmod.a: $(OBJ)
-	$(AR) libcholmod.a $(OBJ)
-	$(RANLIB) libcholmod.a
+$(LIBPRE)cholmod.$(LIBEXT): $(OBJ)
+	$(AR) $(LIBPRE)cholmod.$(LIBEXT) $(OBJ)
+	$(RANLIB) $(LIBPRE)cholmod.$(LIBEXT)
 
 $(OBJ): $(INC)
 
diff -ur SuiteSparse/COLAMD/Makefile SuiteSparse-mod/COLAMD/Makefile
--- SuiteSparse/COLAMD/Makefile	2006-05-02 17:43:46.000000000 +0200
+++ SuiteSparse-mod/COLAMD/Makefile	2007-02-12 10:29:18.628646500 +0100
@@ -1,51 +1,51 @@
 
-default: libcolamd.a colamd_example colamd_l_example
-
 include ../UFconfig/UFconfig.mk
 
+default: $(LIBPRE)colamd.$(LIBEXT) colamd_example$(EXEEXT) colamd_l_example$(EXEEXT)
+
 I = -I../UFconfig
 
-colamd_example: colamd_example.c libcolamd.a
-	$(CC) $(CFLAGS) $(I) -o colamd_example colamd_example.c libcolamd.a -lm
+colamd_example$(EXEEXT): colamd_example.c $(LIBPRE)colamd.$(LIBEXT)
+	$(CC) $(CFLAGS) $(I) -o colamd_example$(EXEEXT) colamd_example.c $(LIBPRE)colamd.$(LIBEXT) $(CLIB)
 	- ./colamd_example > my_colamd_example.out
-	- diff colamd_example.out my_colamd_example.out
+	- diff -b colamd_example.out my_colamd_example.out
 
-colamd_l_example: colamd_l_example.c libcolamd.a
-	$(CC) $(CFLAGS) $(I) -o colamd_l_example colamd_l_example.c libcolamd.a -lm
+colamd_l_example$(EXEEXT): colamd_l_example.c $(LIBPRE)colamd.$(LIBEXT)
+	$(CC) $(CFLAGS) $(I) -o colamd_l_example$(EXEEXT) colamd_l_example.c $(LIBPRE)colamd.$(LIBEXT) $(CLIB)
 	- ./colamd_l_example > my_colamd_l_example.out
-	- diff colamd_example.out my_colamd_example.out
+	- diff -b colamd_example.out my_colamd_example.out
 
 purge: distclean
 
 distclean: clean2
-	- $(RM) libcolamd.a
+	- $(RM) $(LIBPRE)colamd.$(LIBEXT)
 
 clean2: clean
-	- $(RM) *.o *.dll colamd_example colamd_l_example
+	- $(RM) *.o *.dll colamd_example$(EXEEXT) colamd_l_example$(EXEEXT)
 	- $(RM) colamdmex.mex* symamdmex.mex*
 	- $(RM) colamdtestmex.mex* symamdtestmex.mex*
 	- $(RM) my_colamd_example.out my_colamd_l_example.out
 
 # Compiles the MATLAB-callable routines
-mex: colamdmex.c symamdmex.c libcolamd.a
-	$(MEX) $(I) colamdmex.c libcolamd.a
-	$(MEX) $(I) symamdmex.c libcolamd.a
+mex: colamdmex.c symamdmex.c $(LIBPRE)colamd.$(LIBEXT)
+	$(MEX) $(I) colamdmex.c $(LIBPRE)colamd.$(LIBEXT)
+	$(MEX) $(I) symamdmex.c $(LIBPRE)colamd.$(LIBEXT)
 
 # Compiles the extensive test code
-test: mex colamdtestmex.c symamdtestmex.c libcolamd.a
-	$(MEX) $(I) colamdtestmex.c libcolamd.a
-	$(MEX) $(I) symamdtestmex.c libcolamd.a
+test: mex colamdtestmex.c symamdtestmex.c $(LIBPRE)colamd.$(LIBEXT)
+	$(MEX) $(I) colamdtestmex.c $(LIBPRE)colamd.$(LIBEXT)
+	$(MEX) $(I) symamdtestmex.c $(LIBPRE)colamd.$(LIBEXT)
 
 # creates libcolamd.a, a C-callable COLAMD library
-libcolamd.a:  colamd.c colamd_global.c colamd.h
+$(LIBPRE)colamd.$(LIBEXT):  colamd.c colamd_global.c colamd.h
 	$(CC) $(CFLAGS) $(I) -c colamd_global.c
 	$(CC) $(CFLAGS) $(I) -c colamd.c
 	$(CC) $(CFLAGS) $(I) -c colamd.c -DDLONG -o colamd_l.o
-	$(AR) libcolamd.a colamd.o colamd_l.o colamd_global.o
+	$(AR) $(LIBPRE)colamd.$(LIBEXT) colamd.o colamd_l.o colamd_global.o
 
-ccode: libcolamd.a
+ccode: $(LIBPRE)colamd.$(LIBEXT)
 
-library: libcolamd.a
+library: $(LIBPRE)colamd.$(LIBEXT)
 
 clean:
 	- $(RM) $(CLEAN)
diff -ur SuiteSparse/CSparse/Demo/Makefile SuiteSparse-mod/CSparse/Demo/Makefile
--- SuiteSparse/CSparse/Demo/Makefile	2006-11-29 14:42:38.000000000 +0100
+++ SuiteSparse-mod/CSparse/Demo/Makefile	2007-02-12 10:29:18.659893300 +0100
@@ -1,11 +1,13 @@
-CC = cc
-CFLAGS = -O
+# CC = cc
+# CFLAGS = -O
+
+include ../../UFconfig/UFconfig.mk
 
 I = -I../Source
 
-CS = ../Source/libcsparse.a
+CS = ../Source/$(LIBPRE)csparse.$(LIBEXT)
 
-all: lib cs_demo1 cs_demo2 cs_demo3
+all: lib cs_demo1$(EXEEXT) cs_demo2$(EXEEXT) cs_demo3$(EXEEXT)
 	- ./cs_demo1 < ../Matrix/t1
 	- ./cs_demo2 < ../Matrix/t1
 	- ./cs_demo2 < ../Matrix/ash219
@@ -21,14 +23,14 @@
 lib:
 	( cd ../Source ; $(MAKE) )
 
-cs_demo1: lib cs_demo1.c Makefile
-	$(CC) $(CFLAGS) $(I) -o cs_demo1 cs_demo1.c $(CS) -lm
+cs_demo1$(EXEEXT): lib cs_demo1.c Makefile
+	$(CC) $(CFLAGS) $(I) -o cs_demo1$(EXEEXT) cs_demo1.c $(CS) $(CLIB)
 
-cs_demo2: lib cs_demo2.c cs_demo.c cs_demo.h Makefile
-	$(CC) $(CFLAGS) $(I) -o cs_demo2 cs_demo2.c cs_demo.c $(CS) -lm
+cs_demo2$(EXEEXT): lib cs_demo2.c cs_demo.c cs_demo.h Makefile
+	$(CC) $(CFLAGS) $(I) -o cs_demo2$(EXEEXT) cs_demo2.c cs_demo.c $(CS) $(CLIB)
 
-cs_demo3: lib cs_demo3.c cs_demo.c cs_demo.h Makefile
-	$(CC) $(CFLAGS) $(I) -o cs_demo3 cs_demo3.c cs_demo.c $(CS) -lm
+cs_demo3$(EXEEXT): lib cs_demo3.c cs_demo.c cs_demo.h Makefile
+	$(CC) $(CFLAGS) $(I) -o cs_demo3$(EXEEXT) cs_demo3.c cs_demo.c $(CS) $(CLIB)
 
 clean:
 	rm -f *.o
@@ -36,4 +38,4 @@
 purge: distclean
 
 distclean: clean
-	rm -f cs_demo1 cs_demo2 cs_demo3 *.a
+	rm -f cs_demo1$(EXEEXT) cs_demo2$(EXEEXT) cs_demo3$(EXEEXT) *.$(LIBEXT)
diff -ur SuiteSparse/CSparse/Demo/cs_demo.c SuiteSparse-mod/CSparse/Demo/cs_demo.c
--- SuiteSparse/CSparse/Demo/cs_demo.c	2006-06-02 16:26:46.000000000 +0200
+++ SuiteSparse-mod/CSparse/Demo/cs_demo.c	2007-02-09 16:43:03.472349500 +0100
@@ -81,7 +81,7 @@
     cs *T, *A, *C ;
     int sym, m, n, mn, nz1, nz2 ;
     problem *Prob ;
-    Prob = cs_calloc (1, sizeof (problem)) ;
+    Prob = (problem*)cs_calloc (1, sizeof (problem)) ;
     if (!Prob) return (NULL) ;
     T = cs_load (f) ;			/* load triplet matrix T from a file */
     Prob->A = A = cs_compress (T) ;	/* A = compressed-column form of T */
@@ -100,9 +100,9 @@
 	    m, n, A->p [n], sym, sym ? C->p [n] : 0, cs_norm (C)) ;
     if (nz1 != nz2) printf ("zero entries dropped: %d\n", nz1 - nz2) ;
     if (nz2 != A->p [n]) printf ("tiny entries dropped: %d\n", nz2 - A->p [n]) ;
-    Prob->b = cs_malloc (mn, sizeof (double)) ;
-    Prob->x = cs_malloc (mn, sizeof (double)) ;
-    Prob->resid = cs_malloc (mn, sizeof (double)) ;
+    Prob->b = (double*)cs_malloc (mn, sizeof (double)) ;
+    Prob->x = (double*)cs_malloc (mn, sizeof (double)) ;
+    Prob->resid = (double*)cs_malloc (mn, sizeof (double)) ;
     return ((!Prob->b || !Prob->x || !Prob->resid) ? free_problem (Prob) : Prob) ;
 }
 
@@ -115,7 +115,7 @@
     cs_free (Prob->b) ;
     cs_free (Prob->x) ;
     cs_free (Prob->resid) ;
-    return (cs_free (Prob)) ;
+    return (problem*)(cs_free (Prob)) ;
 }
 
 /* solve a linear system using Cholesky, LU, and QR, with various orderings */
@@ -204,7 +204,7 @@
     rhs (x, b, n) ;				/* compute right-hand side */
     printf ("\nchol then update/downdate ") ;
     print_order (1) ;
-    y = cs_malloc (n, sizeof (double)) ;
+    y = (double*)cs_malloc (n, sizeof (double)) ;
     t = tic () ;
     S = cs_schol (1, C) ;			/* symbolic Chol, amd(A+A') */
     printf ("\nsymbolic chol time %8.2f\n", toc (t)) ;
@@ -234,7 +234,7 @@
     {
 	p2 = p1 - Lp [k] ;
 	Wi [p2] = Li [p1] ;
-	Wx [p2] = s * rand () / ((double) RAND_MAX) ;
+	Wx [p2] = s * (rand () / ((double) RAND_MAX)) ;
     }
     t = tic () ;
     ok = cs_updown (N->L, +1, W, S->parent) ;	/* update: L*L'+W*W' */
diff -ur SuiteSparse/CSparse/Source/Makefile SuiteSparse-mod/CSparse/Source/Makefile
--- SuiteSparse/CSparse/Source/Makefile	2006-04-12 11:15:34.000000000 +0200
+++ SuiteSparse-mod/CSparse/Source/Makefile	2007-02-12 10:29:18.675516700 +0100
@@ -1,11 +1,13 @@
 # Modify the "-O" optimization option for best performance (-O3 on Linux):
-CC = cc
-CFLAGS = -O
+# CC = cc
+# CFLAGS = -O
 
-AR = ar cr
-RANLIB = ranlib
+# AR = ar cr
+# RANLIB = ranlib
 
-all: libcsparse.a
+include ../../UFconfig/UFconfig.mk
+
+all: $(LIBPRE)csparse.$(LIBEXT)
 
 CS = cs_add.o cs_amd.o cs_chol.o cs_cholsol.o cs_counts.o cs_cumsum.o \
 	cs_droptol.o cs_dropzeros.o cs_dupl.o cs_entry.o \
@@ -19,9 +21,9 @@
 
 $(CS): cs.h Makefile
 
-libcsparse.a: $(CS)
-	$(AR) libcsparse.a $(CS)
-	$(RANLIB) libcsparse.a
+$(LIBPRE)csparse.$(LIBEXT): $(CS)
+	$(AR) $(LIBPRE)csparse.$(LIBEXT) $(CS)
+	$(RANLIB) $(LIBPRE)csparse.$(LIBEXT)
 
 clean:
 	rm -f *.o
@@ -29,4 +31,4 @@
 purge: distclean
 
 distclean: clean
-	rm -f *.a
+	rm -f *.$(LIBEXT)
diff -ur SuiteSparse/CSparse/Source/cs_add.c SuiteSparse-mod/CSparse/Source/cs_add.c
--- SuiteSparse/CSparse/Source/cs_add.c	2006-04-04 08:22:12.000000000 +0200
+++ SuiteSparse-mod/CSparse/Source/cs_add.c	2007-02-09 15:06:59.770326100 +0100
@@ -8,9 +8,9 @@
     if (!CS_CSC (A) || !CS_CSC (B)) return (NULL) ;	    /* check inputs */
     m = A->m ; anz = A->p [A->n] ;
     n = B->n ; Bp = B->p ; Bx = B->x ; bnz = Bp [n] ;
-    w = cs_calloc (m, sizeof (int)) ;			    /* get workspace */
+    w = (int*)cs_calloc (m, sizeof (int)) ;			    /* get workspace */
     values = (A->x != NULL) && (Bx != NULL) ;
-    x = values ? cs_malloc (m, sizeof (double)) : NULL ;    /* get workspace */
+    x = values ? (double*)cs_malloc (m, sizeof (double)) : NULL ;    /* get workspace */
     C = cs_spalloc (m, n, anz + bnz, values, 0) ;	    /* allocate result*/
     if (!C || !w || (values && !x)) return (cs_done (C, w, x, 0)) ;
     Cp = C->p ; Ci = C->i ; Cx = C->x ;
diff -ur SuiteSparse/CSparse/Source/cs_amd.c SuiteSparse-mod/CSparse/Source/cs_amd.c
--- SuiteSparse/CSparse/Source/cs_amd.c	2006-06-24 18:19:12.000000000 +0200
+++ SuiteSparse-mod/CSparse/Source/cs_amd.c	2007-02-09 15:09:02.225802200 +0100
@@ -59,8 +59,8 @@
     cs_fkeep (C, &cs_diag, NULL) ;	    /* drop diagonal entries */
     Cp = C->p ;
     cnz = Cp [n] ;
-    P = cs_malloc (n+1, sizeof (int)) ;	    /* allocate result */
-    W = cs_malloc (8*(n+1), sizeof (int)) ; /* get workspace */
+    P = (int*)cs_malloc (n+1, sizeof (int)) ;	    /* allocate result */
+    W = (int*)cs_malloc (8*(n+1), sizeof (int)) ; /* get workspace */
     t = cnz + cnz/5 + 2*n ;		    /* add elbow room to C */
     if (!P || !W || !cs_sprealloc (C, t)) return (cs_idone (P, C, W, 0)) ;
     len  = W           ; nv     = W +   (n+1) ; next   = W + 2*(n+1) ;
diff -ur SuiteSparse/CSparse/Source/cs_chol.c SuiteSparse-mod/CSparse/Source/cs_chol.c
--- SuiteSparse/CSparse/Source/cs_chol.c	2006-04-07 23:07:36.000000000 +0200
+++ SuiteSparse-mod/CSparse/Source/cs_chol.c	2007-02-09 15:09:50.742358700 +0100
@@ -8,9 +8,9 @@
     csn *N ;
     if (!CS_CSC (A) || !S || !S->cp || !S->parent) return (NULL) ;
     n = A->n ;
-    N = cs_calloc (1, sizeof (csn)) ;	    /* allocate result */
-    c = cs_malloc (2*n, sizeof (int)) ;	    /* get int workspace */
-    x = cs_malloc (n, sizeof (double)) ;    /* get double workspace */
+    N = (csn*)cs_calloc (1, sizeof (csn)) ;	    /* allocate result */
+    c = (int*)cs_malloc (2*n, sizeof (int)) ;	    /* get int workspace */
+    x = (double*)cs_malloc (n, sizeof (double)) ;    /* get double workspace */
     cp = S->cp ; pinv = S->pinv ; parent = S->parent ;
     C = pinv ? cs_symperm (A, pinv, 1) : ((cs *) A) ;
     E = pinv ? C : NULL ;	    /* E is alias for A, or a copy E=A(p,p) */
diff -ur SuiteSparse/CSparse/Source/cs_cholsol.c SuiteSparse-mod/CSparse/Source/cs_cholsol.c
--- SuiteSparse/CSparse/Source/cs_cholsol.c	2006-04-10 08:41:40.000000000 +0200
+++ SuiteSparse-mod/CSparse/Source/cs_cholsol.c	2007-02-09 15:10:19.024151700 +0100
@@ -10,7 +10,7 @@
     n = A->n ;
     S = cs_schol (order, A) ;		    /* ordering and symbolic analysis */
     N = cs_chol (A, S) ;		    /* numeric Cholesky factorization */
-    x = cs_malloc (n, sizeof (double)) ;    /* get workspace */
+    x = (double*)cs_malloc (n, sizeof (double)) ;    /* get workspace */
     ok = (S && N && x) ;
     if (ok)
     {
diff -ur SuiteSparse/CSparse/Source/cs_compress.c SuiteSparse-mod/CSparse/Source/cs_compress.c
--- SuiteSparse/CSparse/Source/cs_compress.c	2006-05-27 15:08:36.000000000 +0200
+++ SuiteSparse-mod/CSparse/Source/cs_compress.c	2007-02-09 15:10:34.524449300 +0100
@@ -8,7 +8,7 @@
     if (!CS_TRIPLET (T)) return (NULL) ;		/* check inputs */
     m = T->m ; n = T->n ; Ti = T->i ; Tj = T->p ; Tx = T->x ; nz = T->nz ;
     C = cs_spalloc (m, n, nz, Tx != NULL, 0) ;		/* allocate result */
-    w = cs_calloc (n, sizeof (int)) ;			/* get workspace */
+    w = (int*)cs_calloc (n, sizeof (int)) ;			/* get workspace */
     if (!C || !w) return (cs_done (C, w, NULL, 0)) ;	/* out of memory */
     Cp = C->p ; Ci = C->i ; Cx = C->x ;
     for (k = 0 ; k < nz ; k++) w [Tj [k]]++ ;		/* column counts */
diff -ur SuiteSparse/CSparse/Source/cs_counts.c SuiteSparse-mod/CSparse/Source/cs_counts.c
--- SuiteSparse/CSparse/Source/cs_counts.c	2006-04-04 08:24:20.000000000 +0200
+++ SuiteSparse-mod/CSparse/Source/cs_counts.c	2007-02-09 15:10:50.040372200 +0100
@@ -22,8 +22,8 @@
     if (!CS_CSC (A) || !parent || !post) return (NULL) ;    /* check inputs */
     m = A->m ; n = A->n ;
     s = 4*n + (ata ? (n+m+1) : 0) ;
-    delta = colcount = cs_malloc (n, sizeof (int)) ;	/* allocate result */
-    w = cs_malloc (s, sizeof (int)) ;			/* get workspace */
+    delta = colcount = (int*)cs_malloc (n, sizeof (int)) ;	/* allocate result */
+    w = (int*)cs_malloc (s, sizeof (int)) ;			/* get workspace */
     AT = cs_transpose (A, 0) ;				/* AT = A' */
     if (!AT || !colcount || !w) return (cs_idone (colcount, AT, w, 0)) ;
     ancestor = w ; maxfirst = w+n ; prevleaf = w+2*n ; first = w+3*n ;
diff -ur SuiteSparse/CSparse/Source/cs_dropzeros.c SuiteSparse-mod/CSparse/Source/cs_dropzeros.c
--- SuiteSparse/CSparse/Source/cs_dropzeros.c	2006-04-05 11:47:22.000000000 +0200
+++ SuiteSparse-mod/CSparse/Source/cs_dropzeros.c	2007-02-09 15:34:55.989880700 +0100
@@ -1,7 +1,7 @@
 #include "cs.h"
 static int cs_nonzero (int i, int j, double aij, void *other)
 {
-    return (aij != 0) ;
+    return (aij != 0.) ;
 }
 int cs_dropzeros (cs *A)
 {
diff -ur SuiteSparse/CSparse/Source/cs_dupl.c SuiteSparse-mod/CSparse/Source/cs_dupl.c
--- SuiteSparse/CSparse/Source/cs_dupl.c	2006-04-03 21:18:24.000000000 +0200
+++ SuiteSparse-mod/CSparse/Source/cs_dupl.c	2007-02-09 15:12:04.760556800 +0100
@@ -6,7 +6,7 @@
     double *Ax ;
     if (!CS_CSC (A)) return (0) ;		/* check inputs */
     m = A->m ; n = A->n ; Ap = A->p ; Ai = A->i ; Ax = A->x ;
-    w = cs_malloc (m, sizeof (int)) ;		/* get workspace */
+    w = (int*)cs_malloc (m, sizeof (int)) ;		/* get workspace */
     if (!w) return (0) ;			/* out of memory */
     for (i = 0 ; i < m ; i++) w [i] = -1 ;	/* row i not yet seen */
     for (j = 0 ; j < n ; j++)
diff -ur SuiteSparse/CSparse/Source/cs_etree.c SuiteSparse-mod/CSparse/Source/cs_etree.c
--- SuiteSparse/CSparse/Source/cs_etree.c	2006-04-04 08:10:20.000000000 +0200
+++ SuiteSparse-mod/CSparse/Source/cs_etree.c	2007-02-09 15:12:22.432771100 +0100
@@ -5,8 +5,8 @@
     int i, k, p, m, n, inext, *Ap, *Ai, *w, *parent, *ancestor, *prev ;
     if (!CS_CSC (A)) return (NULL) ;	    /* check inputs */
     m = A->m ; n = A->n ; Ap = A->p ; Ai = A->i ;
-    parent = cs_malloc (n, sizeof (int)) ;		/* allocate result */
-    w = cs_malloc (n + (ata ? m : 0), sizeof (int)) ;	/* get workspace */
+    parent = (int*)cs_malloc (n, sizeof (int)) ;		/* allocate result */
+    w = (int*)cs_malloc (n + (ata ? m : 0), sizeof (int)) ;	/* get workspace */
     if (!w || !parent) return (cs_idone (parent, NULL, w, 0)) ;
     ancestor = w ; prev = w + n ;
     if (ata) for (i = 0 ; i < m ; i++) prev [i] = -1 ;
diff -ur SuiteSparse/CSparse/Source/cs_lu.c SuiteSparse-mod/CSparse/Source/cs_lu.c
--- SuiteSparse/CSparse/Source/cs_lu.c	2006-04-04 18:32:52.000000000 +0200
+++ SuiteSparse-mod/CSparse/Source/cs_lu.c	2007-02-09 15:13:50.168830600 +0100
@@ -9,13 +9,13 @@
     if (!CS_CSC (A) || !S) return (NULL) ;	    /* check inputs */
     n = A->n ;
     q = S->q ; lnz = S->lnz ; unz = S->unz ;
-    x = cs_malloc (n, sizeof (double)) ;	    /* get double workspace */
-    xi = cs_malloc (2*n, sizeof (int)) ;	    /* get int workspace */
-    N = cs_calloc (1, sizeof (csn)) ;		    /* allocate result */
+    x = (double*)cs_malloc (n, sizeof (double)) ;	    /* get double workspace */
+    xi = (int*)cs_malloc (2*n, sizeof (int)) ;	    /* get int workspace */
+    N = (csn*)cs_calloc (1, sizeof (csn)) ;		    /* allocate result */
     if (!x || !xi || !N) return (cs_ndone (N, NULL, xi, x, 0)) ;
     N->L = L = cs_spalloc (n, n, lnz, 1, 0) ;	    /* allocate result L */
     N->U = U = cs_spalloc (n, n, unz, 1, 0) ;	    /* allocate result U */
-    N->pinv = pinv = cs_malloc (n, sizeof (int)) ;  /* allocate result pinv */
+    N->pinv = pinv = (int*)cs_malloc (n, sizeof (int)) ;  /* allocate result pinv */
     if (!L || !U || !pinv) return (cs_ndone (N, NULL, xi, x, 0)) ;
     Lp = L->p ; Up = U->p ;
     for (i = 0 ; i < n ; i++) x [i] = 0 ;	    /* clear workspace */
diff -ur SuiteSparse/CSparse/Source/cs_lusol.c SuiteSparse-mod/CSparse/Source/cs_lusol.c
--- SuiteSparse/CSparse/Source/cs_lusol.c	2006-04-10 08:41:52.000000000 +0200
+++ SuiteSparse-mod/CSparse/Source/cs_lusol.c	2007-02-09 15:14:25.419507400 +0100
@@ -10,7 +10,7 @@
     n = A->n ;
     S = cs_sqr (order, A, 0) ;		    /* ordering and symbolic analysis */
     N = cs_lu (A, S, tol) ;		    /* numeric LU factorization */
-    x = cs_malloc (n, sizeof (double)) ;    /* get workspace */
+    x = (double*)cs_malloc (n, sizeof (double)) ;    /* get workspace */
     ok = (S && N && x) ;
     if (ok)
     {
diff -ur SuiteSparse/CSparse/Source/cs_maxtrans.c SuiteSparse-mod/CSparse/Source/cs_maxtrans.c
--- SuiteSparse/CSparse/Source/cs_maxtrans.c	2006-06-24 18:19:26.000000000 +0200
+++ SuiteSparse-mod/CSparse/Source/cs_maxtrans.c	2007-02-09 15:14:41.326062800 +0100
@@ -48,7 +48,7 @@
     cs *C ;
     if (!CS_CSC (A)) return (NULL) ;		    /* check inputs */
     n = A->n ; m = A->m ; Ap = A->p ; Ai = A->i ;
-    w = jimatch = cs_calloc (m+n, sizeof (int)) ;   /* allocate result */
+    w = jimatch = (int*)cs_calloc (m+n, sizeof (int)) ;   /* allocate result */
     if (!jimatch) return (NULL) ;
     for (k = 0, j = 0 ; j < n ; j++)	/* count nonempty rows and columns */
     {
@@ -74,7 +74,7 @@
     n = C->n ; m = C->m ; Cp = C->p ;
     jmatch = (m2 < n2) ? jimatch + n : jimatch ;
     imatch = (m2 < n2) ? jimatch : jimatch + m ;
-    w = cs_malloc (5*n, sizeof (int)) ;		    /* get workspace */
+    w = (int*)cs_malloc (5*n, sizeof (int)) ;		    /* get workspace */
     if (!w) return (cs_idone (jimatch, (m2 < n2) ? C : NULL, w, 0)) ;
     cheap = w + n ; js = w + 2*n ; is = w + 3*n ; ps = w + 4*n ;
     for (j = 0 ; j < n ; j++) cheap [j] = Cp [j] ;  /* for cheap assignment */
diff -ur SuiteSparse/CSparse/Source/cs_multiply.c SuiteSparse-mod/CSparse/Source/cs_multiply.c
--- SuiteSparse/CSparse/Source/cs_multiply.c	2006-04-04 08:27:12.000000000 +0200
+++ SuiteSparse-mod/CSparse/Source/cs_multiply.c	2007-02-09 15:14:56.060720700 +0100
@@ -8,9 +8,9 @@
     if (!CS_CSC (A) || !CS_CSC (B)) return (NULL) ;	 /* check inputs */
     m = A->m ; anz = A->p [A->n] ;
     n = B->n ; Bp = B->p ; Bi = B->i ; Bx = B->x ; bnz = Bp [n] ;
-    w = cs_calloc (m, sizeof (int)) ;			 /* get workspace */
+    w = (int*)cs_calloc (m, sizeof (int)) ;			 /* get workspace */
     values = (A->x != NULL) && (Bx != NULL) ;
-    x = values ? cs_malloc (m, sizeof (double)) : NULL ; /* get workspace */
+    x = values ? (double*)cs_malloc (m, sizeof (double)) : NULL ; /* get workspace */
     C = cs_spalloc (m, n, anz + bnz, values, 0) ;	 /* allocate result */
     if (!C || !w || (values && !x)) return (cs_done (C, w, x, 0)) ;
     Cp = C->p ;
diff -ur SuiteSparse/CSparse/Source/cs_pinv.c SuiteSparse-mod/CSparse/Source/cs_pinv.c
--- SuiteSparse/CSparse/Source/cs_pinv.c	2006-04-04 08:27:38.000000000 +0200
+++ SuiteSparse-mod/CSparse/Source/cs_pinv.c	2007-02-09 15:15:14.154818100 +0100
@@ -4,7 +4,7 @@
 {
     int k, *pinv ;
     if (!p) return (NULL) ;			/* p = NULL denotes identity */
-    pinv = cs_malloc (n, sizeof (int)) ;	/* allocate result */
+    pinv = (int*)cs_malloc (n, sizeof (int)) ;	/* allocate result */
     if (!pinv) return (NULL) ;			/* out of memory */
     for (k = 0 ; k < n ; k++) pinv [p [k]] = k ;/* invert the permutation */
     return (pinv) ;				/* return result */
diff -ur SuiteSparse/CSparse/Source/cs_post.c SuiteSparse-mod/CSparse/Source/cs_post.c
--- SuiteSparse/CSparse/Source/cs_post.c	2006-04-07 12:56:12.000000000 +0200
+++ SuiteSparse-mod/CSparse/Source/cs_post.c	2007-02-09 15:15:24.639394400 +0100
@@ -4,8 +4,8 @@
 {
     int j, k = 0, *post, *w, *head, *next, *stack ;
     if (!parent) return (NULL) ;			/* check inputs */
-    post = cs_malloc (n, sizeof (int)) ;		/* allocate result */
-    w = cs_malloc (3*n, sizeof (int)) ;			/* get workspace */
+    post = (int*)cs_malloc (n, sizeof (int)) ;		/* allocate result */
+    w = (int*)cs_malloc (3*n, sizeof (int)) ;			/* get workspace */
     if (!w || !post) return (cs_idone (post, NULL, w, 0)) ;
     head = w ; next = w + n ; stack = w + 2*n ;
     for (j = 0 ; j < n ; j++) head [j] = -1 ;		/* empty linked lists */
diff -ur SuiteSparse/CSparse/Source/cs_qr.c SuiteSparse-mod/CSparse/Source/cs_qr.c
--- SuiteSparse/CSparse/Source/cs_qr.c	2006-04-05 19:26:26.000000000 +0200
+++ SuiteSparse-mod/CSparse/Source/cs_qr.c	2007-02-09 15:15:52.343051300 +0100
@@ -11,15 +11,15 @@
     m = A->m ; n = A->n ; Ap = A->p ; Ai = A->i ; Ax = A->x ;
     q = S->q ; parent = S->parent ; pinv = S->pinv ; m2 = S->m2 ;
     vnz = S->lnz ; rnz = S->unz ; leftmost = S->leftmost ;
-    w = cs_malloc (m2+n, sizeof (int)) ;	    /* get int workspace */
-    x = cs_malloc (m2, sizeof (double)) ;	    /* get double workspace */
-    N = cs_calloc (1, sizeof (csn)) ;		    /* allocate result */
+    w = (int*)cs_malloc (m2+n, sizeof (int)) ;	    /* get int workspace */
+    x = (double*)cs_malloc (m2, sizeof (double)) ;	    /* get double workspace */
+    N = (csn*)cs_calloc (1, sizeof (csn)) ;		    /* allocate result */
     if (!w || !x || !N) return (cs_ndone (N, NULL, w, x, 0)) ;
     s = w + m2 ;				    /* s is size n */
     for (k = 0 ; k < m2 ; k++) x [k] = 0 ;	    /* clear workspace x */
     N->L = V = cs_spalloc (m2, n, vnz, 1, 0) ;	    /* allocate result V */
     N->U = R = cs_spalloc (m2, n, rnz, 1, 0) ;	    /* allocate result R */
-    N->B = Beta = cs_malloc (n, sizeof (double)) ;  /* allocate result Beta */
+    N->B = Beta = (double*)cs_malloc (n, sizeof (double)) ;  /* allocate result Beta */
     if (!R || !V || !Beta) return (cs_ndone (N, NULL, w, x, 0)) ;
     Rp = R->p ; Ri = R->i ; Rx = R->x ;
     Vp = V->p ; Vi = V->i ; Vx = V->x ;
diff -ur SuiteSparse/CSparse/Source/cs_qrsol.c SuiteSparse-mod/CSparse/Source/cs_qrsol.c
--- SuiteSparse/CSparse/Source/cs_qrsol.c	2006-04-10 08:42:06.000000000 +0200
+++ SuiteSparse-mod/CSparse/Source/cs_qrsol.c	2007-02-09 15:19:48.535086100 +0100
@@ -14,7 +14,7 @@
     {
 	S = cs_sqr (order, A, 1) ;	    /* ordering and symbolic analysis */
 	N = cs_qr (A, S) ;		    /* numeric QR factorization */
-	x = cs_calloc (S ? S->m2 : 1, sizeof (double)) ;    /* get workspace */
+	x = (double*)cs_calloc (S ? S->m2 : 1, sizeof (double)) ;    /* get workspace */
 	ok = (S && N && x) ;
 	if (ok)
 	{
@@ -32,7 +32,7 @@
 	AT = cs_transpose (A, 1) ;	    /* Ax=b is underdetermined */
 	S = cs_sqr (order, AT, 1) ;	    /* ordering and symbolic analysis */
 	N = cs_qr (AT, S) ;		    /* numeric QR factorization of A' */
-	x = cs_calloc (S ? S->m2 : 1, sizeof (double)) ;    /* get workspace */
+	x = (double*)cs_calloc (S ? S->m2 : 1, sizeof (double)) ;    /* get workspace */
 	ok = (AT && S && N && x) ;
 	if (ok)
 	{
diff -ur SuiteSparse/CSparse/Source/cs_randperm.c SuiteSparse-mod/CSparse/Source/cs_randperm.c
--- SuiteSparse/CSparse/Source/cs_randperm.c	2006-04-12 15:42:46.000000000 +0200
+++ SuiteSparse-mod/CSparse/Source/cs_randperm.c	2007-02-09 15:19:58.504027500 +0100
@@ -6,7 +6,7 @@
 {
     int *p, k, j, t ;
     if (seed == 0) return (NULL) ;	/* return p = NULL (identity) */
-    p = cs_malloc (n, sizeof (int)) ;	/* allocate result */
+    p = (int*)cs_malloc (n, sizeof (int)) ;	/* allocate result */
     if (!p) return (NULL) ;		/* out of memory */
     for (k = 0 ; k < n ; k++) p [k] = n-k-1 ;
     if (seed == -1) return (p) ;	/* return reverse permutation */
diff -ur SuiteSparse/CSparse/Source/cs_scc.c SuiteSparse-mod/CSparse/Source/cs_scc.c
--- SuiteSparse/CSparse/Source/cs_scc.c	2006-04-04 08:16:06.000000000 +0200
+++ SuiteSparse-mod/CSparse/Source/cs_scc.c	2007-02-09 15:20:14.332456400 +0100
@@ -9,7 +9,7 @@
     n = A->n ; Ap = A->p ;
     D = cs_dalloc (n, 0) ;			    /* allocate result */
     AT = cs_transpose (A, 0) ;			    /* AT = A' */
-    xi = cs_malloc (2*n+1, sizeof (int)) ;	    /* get workspace */
+    xi = (int*)cs_malloc (2*n+1, sizeof (int)) ;	    /* get workspace */
     if (!D || !AT || !xi) return (cs_ddone (D, AT, xi, 0)) ;
     Blk = xi ; rcopy = pstack = xi + n ;
     p = D->p ; r = D->r ; ATp = AT->p ;
diff -ur SuiteSparse/CSparse/Source/cs_schol.c SuiteSparse-mod/CSparse/Source/cs_schol.c
--- SuiteSparse/CSparse/Source/cs_schol.c	2006-04-10 08:57:42.000000000 +0200
+++ SuiteSparse-mod/CSparse/Source/cs_schol.c	2007-02-09 15:20:26.160808500 +0100
@@ -7,7 +7,7 @@
     css *S ;
     if (!CS_CSC (A)) return (NULL) ;	    /* check inputs */
     n = A->n ;
-    S = cs_calloc (1, sizeof (css)) ;	    /* allocate result S */
+    S = (css*)cs_calloc (1, sizeof (css)) ;	    /* allocate result S */
     if (!S) return (NULL) ;		    /* out of memory */
     P = cs_amd (order, A) ;		    /* P = amd(A+A'), or natural */
     S->pinv = cs_pinv (P, n) ;		    /* find inverse permutation */
@@ -19,7 +19,7 @@
     c = cs_counts (C, S->parent, post, 0) ; /* find column counts of chol(C) */
     cs_free (post) ;
     cs_spfree (C) ;
-    S->cp = cs_malloc (n+1, sizeof (int)) ; /* allocate result S->cp */
+    S->cp = (int*)cs_malloc (n+1, sizeof (int)) ; /* allocate result S->cp */
     S->unz = S->lnz = cs_cumsum (S->cp, c, n) ; /* find column pointers for L */
     cs_free (c) ;
     return ((S->lnz >= 0) ? S : cs_sfree (S)) ;
diff -ur SuiteSparse/CSparse/Source/cs_sqr.c SuiteSparse-mod/CSparse/Source/cs_sqr.c
--- SuiteSparse/CSparse/Source/cs_sqr.c	2006-04-10 08:42:42.000000000 +0200
+++ SuiteSparse-mod/CSparse/Source/cs_sqr.c	2007-02-09 15:20:51.958178800 +0100
@@ -4,9 +4,9 @@
 {
     int i, k, p, pa, n = A->n, m = A->m, *Ap = A->p, *Ai = A->i, *next, *head,
 	*tail, *nque, *pinv, *leftmost, *w, *parent = S->parent ;
-    S->pinv = pinv = cs_malloc (m+n, sizeof (int)) ;	    /* allocate pinv, */
-    S->leftmost = leftmost = cs_malloc (m, sizeof (int)) ;  /* and leftmost */
-    w = cs_malloc (m+3*n, sizeof (int)) ;   /* get workspace */
+    S->pinv = pinv = (int*)cs_malloc (m+n, sizeof (int)) ;	    /* allocate pinv, */
+    S->leftmost = leftmost = (int*)cs_malloc (m, sizeof (int)) ;  /* and leftmost */
+    w = (int*)cs_malloc (m+3*n, sizeof (int)) ;   /* get workspace */
     if (!pinv || !w || !leftmost)
     {
 	cs_free (w) ;			    /* pinv and leftmost freed later */
@@ -63,7 +63,7 @@
     css *S ;
     if (!CS_CSC (A)) return (NULL) ;	    /* check inputs */
     n = A->n ;
-    S = cs_calloc (1, sizeof (css)) ;	    /* allocate result S */
+    S = (css*)cs_calloc (1, sizeof (css)) ;	    /* allocate result S */
     if (!S) return (NULL) ;		    /* out of memory */
     S->q = cs_amd (order, A) ;		    /* fill-reducing ordering */
     if (order && !S->q) return (cs_sfree (S)) ;
diff -ur SuiteSparse/CSparse/Source/cs_symperm.c SuiteSparse-mod/CSparse/Source/cs_symperm.c
--- SuiteSparse/CSparse/Source/cs_symperm.c	2006-04-04 08:30:22.000000000 +0200
+++ SuiteSparse-mod/CSparse/Source/cs_symperm.c	2007-02-09 15:21:37.130921100 +0100
@@ -8,7 +8,7 @@
     if (!CS_CSC (A)) return (NULL) ;			/* check inputs */
     n = A->n ; Ap = A->p ; Ai = A->i ; Ax = A->x ;
     C = cs_spalloc (n, n, Ap [n], values && (Ax != NULL), 0) ; /* alloc result*/
-    w = cs_calloc (n, sizeof (int)) ;			/* get workspace */
+    w = (int*)cs_calloc (n, sizeof (int)) ;			/* get workspace */
     if (!C || !w) return (cs_done (C, w, NULL, 0)) ;	/* out of memory */
     Cp = C->p ; Ci = C->i ; Cx = C->x ;
     for (j = 0 ; j < n ; j++)		/* count entries in each column of C */
diff -ur SuiteSparse/CSparse/Source/cs_transpose.c SuiteSparse-mod/CSparse/Source/cs_transpose.c
--- SuiteSparse/CSparse/Source/cs_transpose.c	2006-04-04 08:20:14.000000000 +0200
+++ SuiteSparse-mod/CSparse/Source/cs_transpose.c	2007-02-09 15:21:48.740519000 +0100
@@ -8,7 +8,7 @@
     if (!CS_CSC (A)) return (NULL) ;	/* check inputs */
     m = A->m ; n = A->n ; Ap = A->p ; Ai = A->i ; Ax = A->x ;
     C = cs_spalloc (n, m, Ap [n], values && Ax, 0) ;	   /* allocate result */
-    w = cs_calloc (m, sizeof (int)) ;			   /* get workspace */
+    w = (int*)cs_calloc (m, sizeof (int)) ;			   /* get workspace */
     if (!C || !w) return (cs_done (C, w, NULL, 0)) ;	   /* out of memory */
     Cp = C->p ; Ci = C->i ; Cx = C->x ;
     for (p = 0 ; p < Ap [n] ; p++) w [Ai [p]]++ ;	   /* row counts */
diff -ur SuiteSparse/CSparse/Source/cs_updown.c SuiteSparse-mod/CSparse/Source/cs_updown.c
--- SuiteSparse/CSparse/Source/cs_updown.c	2006-10-13 13:50:20.000000000 +0200
+++ SuiteSparse-mod/CSparse/Source/cs_updown.c	2007-02-09 15:43:03.779689700 +0100
@@ -8,7 +8,7 @@
     Lp = L->p ; Li = L->i ; Lx = L->x ; n = L->n ;
     Cp = C->p ; Ci = C->i ; Cx = C->x ;
     if ((p = Cp [0]) >= Cp [1]) return (1) ;	    /* return if C empty */
-    w = cs_malloc (n, sizeof (double)) ;	    /* get workspace */
+    w = (double*)cs_malloc (n, sizeof (double)) ;	    /* get workspace */
     if (!w) return (0) ;			    /* out of memory */
     f = Ci [p] ;
     for ( ; p < Cp [1] ; p++) f = CS_MIN (f, Ci [p]) ;	/* f = min (find (C)) */
diff -ur SuiteSparse/CSparse/Source/cs_util.c SuiteSparse-mod/CSparse/Source/cs_util.c
--- SuiteSparse/CSparse/Source/cs_util.c	2006-05-27 10:10:48.000000000 +0200
+++ SuiteSparse-mod/CSparse/Source/cs_util.c	2007-02-09 15:19:03.127964300 +0100
@@ -2,15 +2,15 @@
 /* allocate a sparse matrix (triplet form or compressed-column form) */
 cs *cs_spalloc (int m, int n, int nzmax, int values, int triplet)
 {
-    cs *A = cs_calloc (1, sizeof (cs)) ;    /* allocate the cs struct */
+    cs *A = (cs*)cs_calloc (1, sizeof (cs)) ;    /* allocate the cs struct */
     if (!A) return (NULL) ;		    /* out of memory */
     A->m = m ;				    /* define dimensions and nzmax */
     A->n = n ;
     A->nzmax = nzmax = CS_MAX (nzmax, 1) ;
     A->nz = triplet ? 0 : -1 ;		    /* allocate triplet or comp.col */
-    A->p = cs_malloc (triplet ? nzmax : n+1, sizeof (int)) ;
-    A->i = cs_malloc (nzmax, sizeof (int)) ;
-    A->x = values ? cs_malloc (nzmax, sizeof (double)) : NULL ;
+    A->p = (int*)cs_malloc (triplet ? nzmax : n+1, sizeof (int)) ;
+    A->i = (int*)cs_malloc (nzmax, sizeof (int)) ;
+    A->x = values ? (double*)cs_malloc (nzmax, sizeof (double)) : NULL ;
     return ((!A->p || !A->i || (values && !A->x)) ? cs_spfree (A) : A) ;
 }
 
@@ -20,9 +20,9 @@
     int ok, oki, okj = 1, okx = 1 ;
     if (!A) return (0) ;
     if (nzmax <= 0) nzmax = (CS_CSC (A)) ? (A->p [A->n]) : A->nz ;
-    A->i = cs_realloc (A->i, nzmax, sizeof (int), &oki) ;
-    if (CS_TRIPLET (A)) A->p = cs_realloc (A->p, nzmax, sizeof (int), &okj) ;
-    if (A->x) A->x = cs_realloc (A->x, nzmax, sizeof (double), &okx) ;
+    A->i = (int*)cs_realloc (A->i, nzmax, sizeof (int), &oki) ;
+    if (CS_TRIPLET (A)) A->p = (int*)cs_realloc (A->p, nzmax, sizeof (int), &okj) ;
+    if (A->x) A->x = (double*)cs_realloc (A->x, nzmax, sizeof (double), &okx) ;
     ok = (oki && okj && okx) ;
     if (ok) A->nzmax = nzmax ;
     return (ok) ;
@@ -35,7 +35,7 @@
     cs_free (A->p) ;
     cs_free (A->i) ;
     cs_free (A->x) ;
-    return (cs_free (A)) ;	/* free the cs struct and return NULL */
+    return (cs*)(cs_free (A)) ;	/* free the cs struct and return NULL */
 }
 
 /* free a numeric factorization */
@@ -46,7 +46,7 @@
     cs_spfree (N->U) ;
     cs_free (N->pinv) ;
     cs_free (N->B) ;
-    return (cs_free (N)) ;	/* free the csn struct and return NULL */
+    return (csn*)(cs_free (N)) ;	/* free the csn struct and return NULL */
 }
 
 /* free a symbolic factorization */
@@ -58,19 +58,19 @@
     cs_free (S->parent) ;
     cs_free (S->cp) ;
     cs_free (S->leftmost) ;
-    return (cs_free (S)) ;	/* free the css struct and return NULL */
+    return (css*)(cs_free (S)) ;	/* free the css struct and return NULL */
 }
 
 /* allocate a cs_dmperm or cs_scc result */
 csd *cs_dalloc (int m, int n)
 {
     csd *D ;
-    D = cs_calloc (1, sizeof (csd)) ;
+    D = (csd*)cs_calloc (1, sizeof (csd)) ;
     if (!D) return (NULL) ;
-    D->p = cs_malloc (m, sizeof (int)) ;
-    D->r = cs_malloc (m+6, sizeof (int)) ;
-    D->q = cs_malloc (n, sizeof (int)) ;
-    D->s = cs_malloc (n+6, sizeof (int)) ;
+    D->p = (int*)cs_malloc (m, sizeof (int)) ;
+    D->r = (int*)cs_malloc (m+6, sizeof (int)) ;
+    D->q = (int*)cs_malloc (n, sizeof (int)) ;
+    D->s = (int*)cs_malloc (n+6, sizeof (int)) ;
     return ((!D->p || !D->r || !D->q || !D->s) ? cs_dfree (D) : D) ;
 }
 
@@ -82,7 +82,7 @@
     cs_free (D->q) ;
     cs_free (D->r) ;
     cs_free (D->s) ;
-    return (cs_free (D)) ;
+    return (csd*)(cs_free (D)) ;
 }
 
 /* free workspace and return a sparse matrix result */
@@ -98,7 +98,7 @@
 {
     cs_spfree (C) ;			/* free temporary matrix */
     cs_free (w) ;			/* free workspace */
-    return (ok ? p : cs_free (p)) ;	/* return result if OK, else free it */
+    return (ok ? p : (int*)cs_free (p)) ;	/* return result if OK, else free it */
 }
 
 /* free workspace and return a numeric factorization (Cholesky, LU, or QR) */
diff -ur SuiteSparse/CSparse_to_CXSparse SuiteSparse-mod/CSparse_to_CXSparse
--- SuiteSparse/CSparse_to_CXSparse	2006-08-24 21:45:12.000000000 +0200
+++ SuiteSparse-mod/CSparse_to_CXSparse	2007-02-09 16:32:40.509448600 +0100
@@ -109,20 +109,20 @@
 		s/cs_ci\.h/cs.h/ ;
 		# fabs becomes cabs
 		s/fabs/cabs/g;
-		# change double to double _Complex
-		s/\bdouble\b/double _Complex/g;
+		# change double to cs_complex_t
+		s/\bdouble\b/cs_complex_t/g;
 		# (double) typecasts stay double
-		s/\(double _Complex\) /(double) /g;
-		# tic, toc, tol, and norm are double, not double _Complex
-		s/double _Complex norm/double norm/;
-		s/double _Complex tic/double tic/;
-		s/double _Complex toc \(double _Complex/double toc (double/;
-		s/double _Complex s = tic/double s = tic/;
-		s/double _Complex tol/double tol/;
+		s/\(cs_complex_t\) /(double) /g;
+		# tic, toc, tol, and norm are double, not cs_complex_t
+		s/cs_complex_t norm/double norm/;
+		s/cs_complex_t tic/double tic/;
+		s/cs_complex_t toc \(cs_complex_t/double toc (double/;
+		s/cs_complex_t s = tic/double s = tic/;
+		s/cs_complex_t tol/double tol/;
 		# cumsum, S->lnz, S->unz are double
-		s/double _Complex lnz/double lnz/;
-		s/double _Complex unz/double unz/;
-		s/double _Complex cs_cumsum/double cs_cumsum/;
+		s/cs_complex_t lnz/double lnz/;
+		s/cs_complex_t unz/double unz/;
+		s/cs_complex_t cs_cumsum/double cs_cumsum/;
 		# local variable declarations that stay double
 		s/,  / ;\n    double / ;
 		print OUT $_;
@@ -150,20 +150,20 @@
 		s/\%d/\%ld/g;
 		# fabs becomes cabs
 		s/fabs/cabs/g;
-		# change double to double _Complex
-		s/\bdouble\b/double _Complex/g;
+		# change double to cs_complex_t
+		s/\bdouble\b/cs_complex_t/g;
 		# (double) typecasts stay double
-		s/\(double _Complex\) /(double) /g;
-		# tic, toc, tol, and norm are double, not double _Complex
-		s/double _Complex norm/double norm/;
-		s/double _Complex tic/double tic/;
-		s/double _Complex toc \(double _Complex/double toc (double/;
-		s/double _Complex s = tic/double s = tic/;
-		s/double _Complex tol/double tol/;
+		s/\(cs_complex_t\) /(double) /g;
+		# tic, toc, tol, and norm are double, not cs_complex_t
+		s/cs_complex_t norm/double norm/;
+		s/cs_complex_t tic/double tic/;
+		s/cs_complex_t toc \(cs_complex_t/double toc (double/;
+		s/cs_complex_t s = tic/double s = tic/;
+		s/cs_complex_t tol/double tol/;
 		# cumsum, S->lnz, S->unz are double
-		s/double _Complex lnz/double lnz/;
-		s/double _Complex unz/double unz/;
-		s/double _Complex cs_cumsum/double cs_cumsum/;
+		s/cs_complex_t lnz/double lnz/;
+		s/cs_complex_t unz/double unz/;
+		s/cs_complex_t cs_cumsum/double cs_cumsum/;
 		# local variable declarations that stay double
 		s/,  / ;\n    double / ;
 		print OUT $_;
@@ -252,6 +252,7 @@
 		if ($fbase =~ /cs_cumsum/)
 		{
 		    s/^CS_ENTRY cs_cumsum/double cs_cumsum/;
+		    s/CS_ENTRY nz2 = 0/double nz2 = 0/;
 		}
 
 		# cs_transpose
@@ -265,6 +266,8 @@
 		{
 		    s/beta\*beta/beta*CS_CONJ(beta)/ ;
 		    s/alpha\*alpha/alpha*CS_CONJ(alpha)/ ;
+		    s/sigma ?\* ?alpha/((CS_ENTRY)sigma)*alpha/ ;
+		    s/beta2 = (beta.*) ;/beta2 = CS_REAL(\1) ;/ ;
 		}
 
 		# cs_qrsol
diff -ur SuiteSparse/CXSparse/Demo/Makefile SuiteSparse-mod/CXSparse/Demo/Makefile
--- SuiteSparse/CXSparse/Demo/Makefile	2006-11-29 14:43:00.000000000 +0100
+++ SuiteSparse-mod/CXSparse/Demo/Makefile	2007-02-12 10:42:31.998948900 +0100
@@ -1,20 +1,24 @@
-CC = cc
-CFLAGS = -O
+# CC = cc-msvc
+# CFLAGS = -O2 -EHs -MD -TP
 
-I = -I../Source -I../../UFconfig
+include ../../UFconfig/UFconfig.mk
 
-CS = ../Source/libcxsparse.a
+I = -I../Source -I../../UFconfig -EHs -TP
 
-all: $(CS) cs_demo1 cs_demo2 cs_demo3 \
-	cs_di_demo1 cs_di_demo2 cs_di_demo3 \
-	cs_dl_demo1 cs_dl_demo2 cs_dl_demo3 \
-	cs_ci_demo1 cs_ci_demo2 cs_ci_demo3 \
-	cs_cl_demo1 cs_cl_demo2 cs_cl_demo3  \
-	tests cs_idemo
+CXXFLAGS = $(CFLAGS) -EHs
+
+CS = ../Source/$(LIBPRE)cxsparse.$(LIBEXT)
+
+all: $(CS) cs_demo1$(EXEEXT) cs_demo2$(EXEEXT) cs_demo3$(EXEEXT) \
+	cs_di_demo1$(EXEEXT) cs_di_demo2$(EXEEXT) cs_di_demo3$(EXEEXT) \
+	cs_dl_demo1$(EXEEXT) cs_dl_demo2$(EXEEXT) cs_dl_demo3$(EXEEXT) \
+	cs_ci_demo1$(EXEEXT) cs_ci_demo2$(EXEEXT) cs_ci_demo3$(EXEEXT) \
+	cs_cl_demo1$(EXEEXT) cs_cl_demo2$(EXEEXT) cs_cl_demo3$(EXEEXT)  \
+	tests cs_idemo$(EXEEXT)
 
 tests: test_convert test test_di test_dl test_ci test_cl
 
-test: cs_demo1 cs_demo2 cs_demo3
+test: cs_demo1$(EXEEXT) cs_demo2$(EXEEXT) cs_demo3$(EXEEXT)
 	- ./cs_demo1 < ../Matrix/t1
 	- ./cs_demo2 < ../Matrix/t1
 	- ./cs_demo2 < ../Matrix/fs_183_1
@@ -27,7 +31,7 @@
 	- ./cs_demo2 < ../Matrix/bcsstk16
 	- ./cs_demo3 < ../Matrix/bcsstk16
 
-test_di: cs_di_demo1 cs_di_demo2 cs_di_demo3
+test_di: cs_di_demo1$(EXEEXT) cs_di_demo2$(EXEEXT) cs_di_demo3$(EXEEXT)
 	- ./cs_di_demo1 < ../Matrix/t1
 	- ./cs_di_demo2 < ../Matrix/t1
 	- ./cs_di_demo2 < ../Matrix/fs_183_1
@@ -40,7 +44,7 @@
 	- ./cs_di_demo2 < ../Matrix/bcsstk16
 	- ./cs_di_demo3 < ../Matrix/bcsstk16
 
-test_dl: cs_dl_demo1 cs_dl_demo2 cs_dl_demo3
+test_dl: cs_dl_demo1$(EXEEXT) cs_dl_demo2$(EXEEXT) cs_dl_demo3$(EXEEXT)
 	- ./cs_dl_demo1 < ../Matrix/t1
 	- ./cs_dl_demo2 < ../Matrix/t1
 	- ./cs_dl_demo2 < ../Matrix/fs_183_1
@@ -53,7 +57,7 @@
 	- ./cs_dl_demo2 < ../Matrix/bcsstk16
 	- ./cs_dl_demo3 < ../Matrix/bcsstk16
 
-test_ci: cs_ci_demo1 cs_ci_demo2 cs_ci_demo3
+test_ci: cs_ci_demo1$(EXEEXT) cs_ci_demo2$(EXEEXT) cs_ci_demo3$(EXEEXT)
 	- ./cs_ci_demo1 < ../Matrix/t2
 	- ./cs_ci_demo2 < ../Matrix/t2
 	- ./cs_ci_demo2 < ../Matrix/t3
@@ -66,7 +70,7 @@
 	- ./cs_ci_demo2 < ../Matrix/mhd1280b
 	- ./cs_ci_demo3 < ../Matrix/mhd1280b
 
-test_cl: cs_cl_demo1 cs_cl_demo2 cs_cl_demo3
+test_cl: cs_cl_demo1$(EXEEXT) cs_cl_demo2$(EXEEXT) cs_cl_demo3$(EXEEXT)
 	- ./cs_cl_demo1 < ../Matrix/t2
 	- ./cs_cl_demo2 < ../Matrix/t2
 	- ./cs_cl_demo2 < ../Matrix/t3
@@ -79,86 +83,86 @@
 	- ./cs_cl_demo2 < ../Matrix/mhd1280b
 	- ./cs_cl_demo3 < ../Matrix/mhd1280b
 
-test_convert: cs_idemo cs_ldemo
+test_convert: cs_idemo$(EXEEXT) cs_ldemo$(EXEEXT)
 	- ./cs_idemo < ../Matrix/t2
 	- ./cs_ldemo < ../Matrix/t2
 
 $(CS):
 	( cd ../Source ; $(MAKE) )
 
-cs_demo1: $(CS) cs_demo1.c Makefile $(CS)
-	$(CC) $(I) -o cs_demo1 cs_demo1.c $(CS) -lm
+cs_demo1$(EXEEXT): $(CS) cs_demo1.c Makefile $(CS)
+	$(CC) $(CFLAGS) $(I) -o cs_demo1$(EXEEXT) cs_demo1.c $(CS) $(CLIB)
 
-cs_demo2: $(CS) cs_demo2.c cs_demo.c cs_demo.h Makefile $(CS)
-	$(CC) $(I) -o cs_demo2 cs_demo2.c cs_demo.c $(CS) -lm
+cs_demo2$(EXEEXT): $(CS) cs_demo2.c cs_demo.c cs_demo.h Makefile $(CS)
+	$(CC) $(CFLAGS) $(I) -o cs_demo2$(EXEEXT) cs_demo2.c cs_demo.c $(CS) $(CLIB)
 
-cs_demo3: $(CS) cs_demo3.c cs_demo.c cs_demo.h Makefile $(CS)
-	$(CC) $(I) -o cs_demo3 cs_demo3.c cs_demo.c $(CS) -lm
+cs_demo3$(EXEEXT): $(CS) cs_demo3.c cs_demo.c cs_demo.h Makefile $(CS)
+	$(CC) $(CFLAGS) $(I) -o cs_demo3$(EXEEXT) cs_demo3.c cs_demo.c $(CS) $(CLIB)
 
 
 
 
-cs_di_demo1: $(CS) cs_di_demo1.c Makefile $(CS)
-	$(CC) $(I) -o cs_di_demo1 cs_di_demo1.c $(CS) -lm
+cs_di_demo1$(EXEEXT): $(CS) cs_di_demo1.c Makefile $(CS)
+	$(CC) $(CFLAGS) $(I) -o cs_di_demo1$(EXEEXT) cs_di_demo1.c $(CS) $(CLIB)
 
-cs_di_demo2: $(CS) cs_di_demo2.c cs_di_demo.c cs_di_demo.h Makefile $(CS)
-	$(CC) $(I) -o cs_di_demo2 cs_di_demo2.c cs_di_demo.c $(CS) -lm
+cs_di_demo2$(EXEEXT): $(CS) cs_di_demo2.c cs_di_demo.c cs_di_demo.h Makefile $(CS)
+	$(CC) $(CFLAGS) $(I) -o cs_di_demo2$(EXEEXT) cs_di_demo2.c cs_di_demo.c $(CS) $(CLIB)
 
-cs_di_demo3: $(CS) cs_di_demo3.c cs_di_demo.c cs_di_demo.h Makefile $(CS)
-	$(CC) $(I) -o cs_di_demo3 cs_di_demo3.c cs_di_demo.c $(CS) -lm
+cs_di_demo3$(EXEEXT): $(CS) cs_di_demo3.c cs_di_demo.c cs_di_demo.h Makefile $(CS)
+	$(CC) $(CFLAGS) $(I) -o cs_di_demo3$(EXEEXT) cs_di_demo3.c cs_di_demo.c $(CS) $(CLIB)
 
 
 
 
-cs_ci_demo1: $(CS) cs_ci_demo1.c Makefile $(CS)
-	$(CC) $(I) -o cs_ci_demo1 cs_ci_demo1.c $(CS) -lm
+cs_ci_demo1$(EXEEXT): $(CS) cs_ci_demo1.c Makefile $(CS)
+	$(CC) $(CFLAGS) $(I) -o cs_ci_demo1$(EXEEXT) cs_ci_demo1.c $(CS) $(CLIB)
 
-cs_ci_demo2: $(CS) cs_ci_demo2.c cs_ci_demo.c cs_ci_demo.h Makefile $(CS)
-	$(CC) $(I) -o cs_ci_demo2 cs_ci_demo2.c cs_ci_demo.c $(CS) -lm
+cs_ci_demo2$(EXEEXT): $(CS) cs_ci_demo2.c cs_ci_demo.c cs_ci_demo.h Makefile $(CS)
+	$(CC) $(CFLAGS) $(I) -o cs_ci_demo2$(EXEEXT) cs_ci_demo2.c cs_ci_demo.c $(CS) $(CLIB)
 
-cs_ci_demo3: $(CS) cs_ci_demo3.c cs_ci_demo.c cs_ci_demo.h Makefile $(CS)
-	$(CC) $(I) -o cs_ci_demo3 cs_ci_demo3.c cs_ci_demo.c $(CS) -lm
+cs_ci_demo3$(EXEEXT): $(CS) cs_ci_demo3.c cs_ci_demo.c cs_ci_demo.h Makefile $(CS)
+	$(CC) $(CFLAGS) $(I) -o cs_ci_demo3$(EXEEXT) cs_ci_demo3.c cs_ci_demo.c $(CS) $(CLIB)
 
 
 
-cs_dl_demo1: $(CS) cs_dl_demo1.c Makefile $(CS)
-	$(CC) $(I) -o cs_dl_demo1 cs_dl_demo1.c $(CS) -lm
+cs_dl_demo1$(EXEEXT): $(CS) cs_dl_demo1.c Makefile $(CS)
+	$(CC) $(CFLAGS) $(I) -o cs_dl_demo1$(EXEEXT) cs_dl_demo1.c $(CS) $(CLIB)
 
-cs_dl_demo2: $(CS) cs_dl_demo2.c cs_dl_demo.c cs_dl_demo.h Makefile $(CS)
-	$(CC) $(I) -o cs_dl_demo2 cs_dl_demo2.c cs_dl_demo.c $(CS) -lm
+cs_dl_demo2$(EXEEXT): $(CS) cs_dl_demo2.c cs_dl_demo.c cs_dl_demo.h Makefile $(CS)
+	$(CC) $(CFLAGS) $(I) -o cs_dl_demo2$(EXEEXT) cs_dl_demo2.c cs_dl_demo.c $(CS) $(CLIB)
 
-cs_dl_demo3: $(CS) cs_dl_demo3.c cs_dl_demo.c cs_dl_demo.h Makefile $(CS)
-	$(CC) $(I) -o cs_dl_demo3 cs_dl_demo3.c cs_dl_demo.c $(CS) -lm
+cs_dl_demo3$(EXEEXT): $(CS) cs_dl_demo3.c cs_dl_demo.c cs_dl_demo.h Makefile $(CS)
+	$(CC) $(CFLAGS) $(I) -o cs_dl_demo3$(EXEEXT) cs_dl_demo3.c cs_dl_demo.c $(CS) $(CLIB)
 
 
-cs_cl_demo1: $(CS) cs_cl_demo1.c Makefile $(CS)
-	$(CC) $(I) -o cs_cl_demo1 cs_cl_demo1.c $(CS) -lm
+cs_cl_demo1$(EXEEXT): $(CS) cs_cl_demo1.c Makefile $(CS)
+	$(CC) $(CFLAGS) $(I) -o cs_cl_demo1$(EXEEXT) cs_cl_demo1.c $(CS) $(CLIB)
 
-cs_cl_demo2: $(CS) cs_cl_demo2.c cs_cl_demo.c cs_cl_demo.h Makefile $(CS)
-	$(CC) $(I) -o cs_cl_demo2 cs_cl_demo2.c cs_cl_demo.c $(CS) -lm
+cs_cl_demo2$(EXEEXT): $(CS) cs_cl_demo2.c cs_cl_demo.c cs_cl_demo.h Makefile $(CS)
+	$(CC) $(CFLAGS) $(I) -o cs_cl_demo2$(EXEEXT) cs_cl_demo2.c cs_cl_demo.c $(CS) $(CLIB)
 
-cs_cl_demo3: $(CS) cs_cl_demo3.c cs_cl_demo.c cs_cl_demo.h Makefile $(CS)
-	$(CC) $(I) -o cs_cl_demo3 cs_cl_demo3.c cs_cl_demo.c $(CS) -lm
+cs_cl_demo3$(EXEEXT): $(CS) cs_cl_demo3.c cs_cl_demo.c cs_cl_demo.h Makefile $(CS)
+	$(CC) $(CFLAGS) $(I) -o cs_cl_demo3$(EXEEXT) cs_cl_demo3.c cs_cl_demo.c $(CS) $(CLIB)
 
 
 
 
-cs_idemo: $(CS) cs_idemo.c Makefile $(CS)
-	$(CC) $(I) -o cs_idemo cs_idemo.c $(CS) -lm
+cs_idemo$(EXEEXT): $(CS) cs_idemo.c Makefile $(CS)
+	$(CC) $(CFLAGS) $(I) -o cs_idemo$(EXEEXT) cs_idemo.c $(CS) $(CLIB)
 
-cs_ldemo: $(CS) cs_ldemo.c Makefile $(CS)
-	$(CC) $(I) -o cs_ldemo cs_ldemo.c $(CS) -lm
+cs_ldemo$(EXEEXT): $(CS) cs_ldemo.c Makefile $(CS)
+	$(CC) $(CFLAGS) $(I) -o cs_ldemo$(EXEEXT) cs_ldemo.c $(CS) $(CLIB)
 
 
 clean:
-	rm -f *.o
+	rm -f *.o *.obj
 
 purge: distclean
 
 distclean: clean
-	rm -f cs_demo1 cs_demo2 cs_demo3 *.a
-	rm -f cs_di_demo1 cs_di_demo2 cs_di_demo3
-	rm -f cs_dl_demo1 cs_dl_demo2 cs_dl_demo3
-	rm -f cs_ci_demo1 cs_ci_demo2 cs_ci_demo3
-	rm -f cs_cl_demo1 cs_cl_demo2 cs_cl_demo3
-	rm -f cs_idemo cs_ldemo
+	rm -f cs_demo1$(EXEEXT) cs_demo2$(EXEEXT) cs_demo3$(EXEEXT) *.$(LIBEXT)
+	rm -f cs_di_demo1$(EXEEXT) cs_di_demo2$(EXEEXT) cs_di_demo3$(EXEEXT)
+	rm -f cs_dl_demo1$(EXEEXT) cs_dl_demo2$(EXEEXT) cs_dl_demo3$(EXEEXT)
+	rm -f cs_ci_demo1$(EXEEXT) cs_ci_demo2$(EXEEXT) cs_ci_demo3$(EXEEXT)
+	rm -f cs_cl_demo1$(EXEEXT) cs_cl_demo2$(EXEEXT) cs_cl_demo3$(EXEEXT)
+	rm -f cs_idemo$(EXEEXT) cs_ldemo$(EXEEXT)
diff -ur SuiteSparse/CXSparse/Demo/cs_ci_demo.c SuiteSparse-mod/CXSparse/Demo/cs_ci_demo.c
--- SuiteSparse/CXSparse/Demo/cs_ci_demo.c	2006-12-07 06:52:28.000000000 +0100
+++ SuiteSparse-mod/CXSparse/Demo/cs_ci_demo.c	2007-02-12 09:58:07.575124900 +0100
@@ -19,7 +19,7 @@
 }
 
 /* true for off-diagonal entries */
-static int dropdiag (int i, int j, double _Complex aij, void *other) { return (i != j) ;}
+static int dropdiag (int i, int j, cs_complex_t aij, void *other) { return (i != j) ;}
 
 /* C = A + triu(A,1)' */
 static cs_ci *make_sym (cs_ci *A)
@@ -33,7 +33,7 @@
 }
 
 /* create a right-hand side */
-static void rhs (double _Complex *x, double _Complex *b, int m)
+static void rhs (cs_complex_t *x, cs_complex_t *b, int m)
 {
     int i ;
     for (i = 0 ; i < m ; i++) b [i] = 1 + ((double) i) / m ;
@@ -41,7 +41,7 @@
 }
 
 /* infinity-norm of x */
-static double norm (double _Complex *x, int n)
+static double norm (cs_complex_t *x, int n)
 {
     int i ;
     double normx = 0 ;
@@ -50,7 +50,7 @@
 }
 
 /* compute residual, norm(A*x-b,inf) / (norm(A,1)*norm(x,inf) + norm(b,inf)) */
-static void print_resid (int ok, cs_ci *A, double _Complex *x, double _Complex *b, double _Complex *resid)
+static void print_resid (int ok, cs_ci *A, cs_complex_t *x, cs_complex_t *b, cs_complex_t *resid)
 {
     int i, m, n ;
     if (!ok) { printf ("    (failed)\n") ; return ; }
@@ -81,7 +81,7 @@
     cs_ci *T, *A, *C ;
     int sym, m, n, mn, nz1, nz2 ;
     problem *Prob ;
-    Prob = cs_ci_calloc (1, sizeof (problem)) ;
+    Prob = (problem*)cs_ci_calloc (1, sizeof (problem)) ;
     if (!Prob) return (NULL) ;
     T = cs_ci_load (f) ;			/* load triplet matrix T from a file */
     Prob->A = A = cs_ci_compress (T) ;	/* A = compressed-column form of T */
@@ -100,9 +100,9 @@
 	    m, n, A->p [n], sym, sym ? C->p [n] : 0, cs_ci_norm (C)) ;
     if (nz1 != nz2) printf ("zero entries dropped: %d\n", nz1 - nz2) ;
     if (nz2 != A->p [n]) printf ("tiny entries dropped: %d\n", nz2 - A->p [n]) ;
-    Prob->b = cs_ci_malloc (mn, sizeof (double _Complex)) ;
-    Prob->x = cs_ci_malloc (mn, sizeof (double _Complex)) ;
-    Prob->resid = cs_ci_malloc (mn, sizeof (double _Complex)) ;
+    Prob->b = (cs_complex_t*)cs_ci_malloc (mn, sizeof (cs_complex_t)) ;
+    Prob->x = (cs_complex_t*)cs_ci_malloc (mn, sizeof (cs_complex_t)) ;
+    Prob->resid = (cs_complex_t*)cs_ci_malloc (mn, sizeof (cs_complex_t)) ;
     return ((!Prob->b || !Prob->x || !Prob->resid) ? free_problem (Prob) : Prob) ;
 }
 
@@ -115,14 +115,14 @@
     cs_ci_free (Prob->b) ;
     cs_ci_free (Prob->x) ;
     cs_ci_free (Prob->resid) ;
-    return (cs_ci_free (Prob)) ;
+    return (problem*)(cs_ci_free (Prob)) ;
 }
 
 /* solve a linear system using Cholesky, LU, and QR, with various orderings */
 int demo2 (problem *Prob)
 {
     cs_ci *A, *C ;
-    double _Complex *b, *x, *resid ;
+    cs_complex_t *b, *x, *resid ;
     double t, tol ;
     int k, m, n, ok, order, nb, ns, *r, *s, *rr, sprank ;
     cs_cid *D ;
@@ -179,7 +179,7 @@
 } 
 
 /* free workspace for demo3 */
-static int done3 (int ok, cs_cis *S, cs_cin *N, double _Complex *y, cs_ci *W, cs_ci *E, int *p)
+static int done3 (int ok, cs_cis *S, cs_cin *N, cs_complex_t *y, cs_ci *W, cs_ci *E, int *p)
 {
     cs_ci_sfree (S) ;
     cs_ci_nfree (N) ;
@@ -195,7 +195,7 @@
 {
     cs_ci *A, *C, *W = NULL, *WW, *WT, *E = NULL, *W2 ;
     int n, k, *Li, *Lp, *Wi, *Wp, p1, p2, *p = NULL, ok ;
-    double _Complex *b, *x, *resid, *y = NULL, *Lx, *Wx, s ;
+    cs_complex_t *b, *x, *resid, *y = NULL, *Lx, *Wx, s ;
     double t, t1 ;
     cs_cis *S = NULL ;
     cs_cin *N = NULL ;
@@ -206,7 +206,7 @@
     rhs (x, b, n) ;				/* compute right-hand side */
     printf ("\nchol then update/downdate ") ;
     print_order (1) ;
-    y = cs_ci_malloc (n, sizeof (double _Complex)) ;
+    y = (cs_complex_t*)cs_ci_malloc (n, sizeof (cs_complex_t)) ;
     t = tic () ;
     S = cs_ci_schol (1, C) ;			/* symbolic Chol, amd(A+A') */
     printf ("\nsymbolic chol time %8.2f\n", toc (t)) ;
@@ -236,7 +236,7 @@
     {
 	p2 = p1 - Lp [k] ;
 	Wi [p2] = Li [p1] ;
-	Wx [p2] = s * rand () / ((double) RAND_MAX) ;
+	Wx [p2] = s * (rand () / ((double) RAND_MAX)) ;
     }
     t = tic () ;
     ok = cs_ci_updown (N->L, +1, W, S->parent) ;	/* update: L*L'+W*W' */
diff -ur SuiteSparse/CXSparse/Demo/cs_ci_demo.h SuiteSparse-mod/CXSparse/Demo/cs_ci_demo.h
--- SuiteSparse/CXSparse/Demo/cs_ci_demo.h	2006-12-07 06:52:28.000000000 +0100
+++ SuiteSparse-mod/CXSparse/Demo/cs_ci_demo.h	2007-02-12 09:58:07.606376500 +0100
@@ -4,9 +4,9 @@
     cs_ci *A ;
     cs_ci *C ;
     int sym ;
-    double _Complex *x ;
-    double _Complex *b ;
-    double _Complex *resid ;
+    cs_complex_t *x ;
+    cs_complex_t *b ;
+    cs_complex_t *resid ;
 } problem ;
 
 problem *get_problem (FILE *f, double tol) ;
diff -ur SuiteSparse/CXSparse/Demo/cs_cl_demo.c SuiteSparse-mod/CXSparse/Demo/cs_cl_demo.c
--- SuiteSparse/CXSparse/Demo/cs_cl_demo.c	2006-12-07 06:52:28.000000000 +0100
+++ SuiteSparse-mod/CXSparse/Demo/cs_cl_demo.c	2007-02-12 09:58:07.590750700 +0100
@@ -19,7 +19,7 @@
 }
 
 /* true for off-diagonal entries */
-static UF_long dropdiag (UF_long i, UF_long j, double _Complex aij, void *other) { return (i != j) ;}
+static UF_long dropdiag (UF_long i, UF_long j, cs_complex_t aij, void *other) { return (i != j) ;}
 
 /* C = A + triu(A,1)' */
 static cs_cl *make_sym (cs_cl *A)
@@ -33,7 +33,7 @@
 }
 
 /* create a right-hand side */
-static void rhs (double _Complex *x, double _Complex *b, UF_long m)
+static void rhs (cs_complex_t *x, cs_complex_t *b, UF_long m)
 {
     UF_long i ;
     for (i = 0 ; i < m ; i++) b [i] = 1 + ((double) i) / m ;
@@ -41,7 +41,7 @@
 }
 
 /* infinity-norm of x */
-static double norm (double _Complex *x, UF_long n)
+static double norm (cs_complex_t *x, UF_long n)
 {
     UF_long i ;
     double normx = 0 ;
@@ -50,7 +50,7 @@
 }
 
 /* compute residual, norm(A*x-b,inf) / (norm(A,1)*norm(x,inf) + norm(b,inf)) */
-static void print_resid (UF_long ok, cs_cl *A, double _Complex *x, double _Complex *b, double _Complex *resid)
+static void print_resid (UF_long ok, cs_cl *A, cs_complex_t *x, cs_complex_t *b, cs_complex_t *resid)
 {
     UF_long i, m, n ;
     if (!ok) { printf ("    (failed)\n") ; return ; }
@@ -81,7 +81,7 @@
     cs_cl *T, *A, *C ;
     UF_long sym, m, n, mn, nz1, nz2 ;
     problem *Prob ;
-    Prob = cs_cl_calloc (1, sizeof (problem)) ;
+    Prob = (problem*)cs_cl_calloc (1, sizeof (problem)) ;
     if (!Prob) return (NULL) ;
     T = cs_cl_load (f) ;			/* load triplet matrix T from a file */
     Prob->A = A = cs_cl_compress (T) ;	/* A = compressed-column form of T */
@@ -100,9 +100,9 @@
 	    m, n, A->p [n], sym, sym ? C->p [n] : 0, cs_cl_norm (C)) ;
     if (nz1 != nz2) printf ("zero entries dropped: %ld\n", nz1 - nz2) ;
     if (nz2 != A->p [n]) printf ("tiny entries dropped: %ld\n", nz2 - A->p [n]) ;
-    Prob->b = cs_cl_malloc (mn, sizeof (double _Complex)) ;
-    Prob->x = cs_cl_malloc (mn, sizeof (double _Complex)) ;
-    Prob->resid = cs_cl_malloc (mn, sizeof (double _Complex)) ;
+    Prob->b = (cs_complex_t*)cs_cl_malloc (mn, sizeof (cs_complex_t)) ;
+    Prob->x = (cs_complex_t*)cs_cl_malloc (mn, sizeof (cs_complex_t)) ;
+    Prob->resid = (cs_complex_t*)cs_cl_malloc (mn, sizeof (cs_complex_t)) ;
     return ((!Prob->b || !Prob->x || !Prob->resid) ? free_problem (Prob) : Prob) ;
 }
 
@@ -115,14 +115,14 @@
     cs_cl_free (Prob->b) ;
     cs_cl_free (Prob->x) ;
     cs_cl_free (Prob->resid) ;
-    return (cs_cl_free (Prob)) ;
+    return (problem*)(cs_cl_free (Prob)) ;
 }
 
 /* solve a linear system using Cholesky, LU, and QR, with various orderings */
 UF_long demo2 (problem *Prob)
 {
     cs_cl *A, *C ;
-    double _Complex *b, *x, *resid ;
+    cs_complex_t *b, *x, *resid ;
     double t, tol ;
     UF_long k, m, n, ok, order, nb, ns, *r, *s, *rr, sprank ;
     cs_cld *D ;
@@ -179,7 +179,7 @@
 } 
 
 /* free workspace for demo3 */
-static UF_long done3 (UF_long ok, cs_cls *S, cs_cln *N, double _Complex *y, cs_cl *W, cs_cl *E, UF_long *p)
+static UF_long done3 (UF_long ok, cs_cls *S, cs_cln *N, cs_complex_t *y, cs_cl *W, cs_cl *E, UF_long *p)
 {
     cs_cl_sfree (S) ;
     cs_cl_nfree (N) ;
@@ -195,7 +195,7 @@
 {
     cs_cl *A, *C, *W = NULL, *WW, *WT, *E = NULL, *W2 ;
     UF_long n, k, *Li, *Lp, *Wi, *Wp, p1, p2, *p = NULL, ok ;
-    double _Complex *b, *x, *resid, *y = NULL, *Lx, *Wx, s ;
+    cs_complex_t *b, *x, *resid, *y = NULL, *Lx, *Wx, s ;
     double t, t1 ;
     cs_cls *S = NULL ;
     cs_cln *N = NULL ;
@@ -206,7 +206,7 @@
     rhs (x, b, n) ;				/* compute right-hand side */
     printf ("\nchol then update/downdate ") ;
     print_order (1) ;
-    y = cs_cl_malloc (n, sizeof (double _Complex)) ;
+    y = (cs_complex_t*)cs_cl_malloc (n, sizeof (cs_complex_t)) ;
     t = tic () ;
     S = cs_cl_schol (1, C) ;			/* symbolic Chol, amd(A+A') */
     printf ("\nsymbolic chol time %8.2f\n", toc (t)) ;
@@ -236,7 +236,7 @@
     {
 	p2 = p1 - Lp [k] ;
 	Wi [p2] = Li [p1] ;
-	Wx [p2] = s * rand () / ((double) RAND_MAX) ;
+	Wx [p2] = s * (rand () / ((double) RAND_MAX)) ;
     }
     t = tic () ;
     ok = cs_cl_updown (N->L, +1, W, S->parent) ;	/* update: L*L'+W*W' */
diff -ur SuiteSparse/CXSparse/Demo/cs_cl_demo.h SuiteSparse-mod/CXSparse/Demo/cs_cl_demo.h
--- SuiteSparse/CXSparse/Demo/cs_cl_demo.h	2006-12-07 06:52:30.000000000 +0100
+++ SuiteSparse-mod/CXSparse/Demo/cs_cl_demo.h	2007-02-12 09:58:07.622002300 +0100
@@ -4,9 +4,9 @@
     cs_cl *A ;
     cs_cl *C ;
     UF_long sym ;
-    double _Complex *x ;
-    double _Complex *b ;
-    double _Complex *resid ;
+    cs_complex_t *x ;
+    cs_complex_t *b ;
+    cs_complex_t *resid ;
 } problem ;
 
 problem *get_problem (FILE *f, double tol) ;
diff -ur SuiteSparse/CXSparse/Demo/cs_demo.c SuiteSparse-mod/CXSparse/Demo/cs_demo.c
--- SuiteSparse/CXSparse/Demo/cs_demo.c	2006-06-02 16:26:46.000000000 +0200
+++ SuiteSparse-mod/CXSparse/Demo/cs_demo.c	2007-02-09 16:43:03.000000000 +0100
@@ -81,7 +81,7 @@
     cs *T, *A, *C ;
     int sym, m, n, mn, nz1, nz2 ;
     problem *Prob ;
-    Prob = cs_calloc (1, sizeof (problem)) ;
+    Prob = (problem*)cs_calloc (1, sizeof (problem)) ;
     if (!Prob) return (NULL) ;
     T = cs_load (f) ;			/* load triplet matrix T from a file */
     Prob->A = A = cs_compress (T) ;	/* A = compressed-column form of T */
@@ -100,9 +100,9 @@
 	    m, n, A->p [n], sym, sym ? C->p [n] : 0, cs_norm (C)) ;
     if (nz1 != nz2) printf ("zero entries dropped: %d\n", nz1 - nz2) ;
     if (nz2 != A->p [n]) printf ("tiny entries dropped: %d\n", nz2 - A->p [n]) ;
-    Prob->b = cs_malloc (mn, sizeof (double)) ;
-    Prob->x = cs_malloc (mn, sizeof (double)) ;
-    Prob->resid = cs_malloc (mn, sizeof (double)) ;
+    Prob->b = (double*)cs_malloc (mn, sizeof (double)) ;
+    Prob->x = (double*)cs_malloc (mn, sizeof (double)) ;
+    Prob->resid = (double*)cs_malloc (mn, sizeof (double)) ;
     return ((!Prob->b || !Prob->x || !Prob->resid) ? free_problem (Prob) : Prob) ;
 }
 
@@ -115,7 +115,7 @@
     cs_free (Prob->b) ;
     cs_free (Prob->x) ;
     cs_free (Prob->resid) ;
-    return (cs_free (Prob)) ;
+    return (problem*)(cs_free (Prob)) ;
 }
 
 /* solve a linear system using Cholesky, LU, and QR, with various orderings */
@@ -204,7 +204,7 @@
     rhs (x, b, n) ;				/* compute right-hand side */
     printf ("\nchol then update/downdate ") ;
     print_order (1) ;
-    y = cs_malloc (n, sizeof (double)) ;
+    y = (double*)cs_malloc (n, sizeof (double)) ;
     t = tic () ;
     S = cs_schol (1, C) ;			/* symbolic Chol, amd(A+A') */
     printf ("\nsymbolic chol time %8.2f\n", toc (t)) ;
@@ -234,7 +234,7 @@
     {
 	p2 = p1 - Lp [k] ;
 	Wi [p2] = Li [p1] ;
-	Wx [p2] = s * rand () / ((double) RAND_MAX) ;
+	Wx [p2] = s * (rand () / ((double) RAND_MAX)) ;
     }
     t = tic () ;
     ok = cs_updown (N->L, +1, W, S->parent) ;	/* update: L*L'+W*W' */
diff -ur SuiteSparse/CXSparse/Demo/cs_demo.out SuiteSparse-mod/CXSparse/Demo/cs_demo.out
--- SuiteSparse/CXSparse/Demo/cs_demo.out	2006-12-07 06:55:22.000000000 +0100
+++ SuiteSparse-mod/CXSparse/Demo/cs_demo.out	2006-12-07 06:42:34.000000000 +0100
@@ -1,313 +1,6 @@
-make[1]: Entering directory `/amd/netapp3/vol/research0a/research18/sparse/SuiteSparse/CXSparse/Demo'
-./cs_idemo < ../Matrix/t2
-
---- cs_idemo
-
-T:
-CXSparse Version 2.0.6, Dec 7, 2006.  Copyright (c) Timothy A. Davis, 2006
-triplet: 4-by-4, nzmax: 16 nnz: 10
-    2 2 : (3, 3.14159)
-    1 0 : (3.1, 42)
-    3 3 : (1, 7)
-    0 2 : (3.2, 0.1)
-    1 1 : (2.9, 1.3)
-    3 0 : (3.5, 0)
-    3 1 : (0.4, 2.71828)
-    1 3 : (0.9, 99)
-    0 0 : (4.5, 6)
-    2 1 : (1.7, 1)
-
-Treal:
-CXSparse Version 2.0.6, Dec 7, 2006.  Copyright (c) Timothy A. Davis, 2006
-triplet: 4-by-4, nzmax: 16 nnz: 10
-    2 2 : 3
-    1 0 : 3.1
-    3 3 : 1
-    0 2 : 3.2
-    1 1 : 2.9
-    3 0 : 3.5
-    3 1 : 0.4
-    1 3 : 0.9
-    0 0 : 4.5
-    2 1 : 1.7
-
-Timag:
-CXSparse Version 2.0.6, Dec 7, 2006.  Copyright (c) Timothy A. Davis, 2006
-triplet: 4-by-4, nzmax: 16 nnz: 10
-    2 2 : 3.14159
-    1 0 : 42
-    3 3 : 7
-    0 2 : 0.1
-    1 1 : 1.3
-    3 0 : 0
-    3 1 : 2.71828
-    1 3 : 99
-    0 0 : 6
-    2 1 : 1
-
-A:
-CXSparse Version 2.0.6, Dec 7, 2006.  Copyright (c) Timothy A. Davis, 2006
-4-by-4, nzmax: 10 nnz: 10, 1-norm: 106.075
-    col 0 : locations 0 to 2
-      1 : (3.1, 42)
-      3 : (3.5, 0)
-      0 : (4.5, 6)
-    col 1 : locations 3 to 5
-      1 : (2.9, 1.3)
-      3 : (0.4, 2.71828)
-      2 : (1.7, 1)
-    col 2 : locations 6 to 7
-      2 : (3, 3.14159)
-      0 : (3.2, 0.1)
-    col 3 : locations 8 to 9
-      3 : (1, 7)
-      1 : (0.9, 99)
-
-C1 = real(A):
-CXSparse Version 2.0.6, Dec 7, 2006.  Copyright (c) Timothy A. Davis, 2006
-4-by-4, nzmax: 10 nnz: 10, 1-norm: 11.1
-    col 0 : locations 0 to 2
-      1 : 3.1
-      3 : 3.5
-      0 : 4.5
-    col 1 : locations 3 to 5
-      1 : 2.9
-      3 : 0.4
-      2 : 1.7
-    col 2 : locations 6 to 7
-      2 : 3
-      0 : 3.2
-    col 3 : locations 8 to 9
-      3 : 1
-      1 : 0.9
-
-C2 = imag(A):
-CXSparse Version 2.0.6, Dec 7, 2006.  Copyright (c) Timothy A. Davis, 2006
-4-by-4, nzmax: 10 nnz: 10, 1-norm: 106
-    col 0 : locations 0 to 2
-      1 : 42
-      3 : 0
-      0 : 6
-    col 1 : locations 3 to 5
-      1 : 1.3
-      3 : 2.71828
-      2 : 1
-    col 2 : locations 6 to 7
-      2 : 3.14159
-      0 : 0.1
-    col 3 : locations 8 to 9
-      3 : 7
-      1 : 99
-
-A1:
-CXSparse Version 2.0.6, Dec 7, 2006.  Copyright (c) Timothy A. Davis, 2006
-4-by-4, nzmax: 10 nnz: 10, 1-norm: 11.1
-    col 0 : locations 0 to 2
-      1 : (3.1, 0)
-      3 : (3.5, 0)
-      0 : (4.5, 0)
-    col 1 : locations 3 to 5
-      1 : (2.9, 0)
-      3 : (0.4, 0)
-      2 : (1.7, 0)
-    col 2 : locations 6 to 7
-      2 : (3, 0)
-      0 : (3.2, 0)
-    col 3 : locations 8 to 9
-      3 : (1, 0)
-      1 : (0.9, 0)
-
-A2:
-CXSparse Version 2.0.6, Dec 7, 2006.  Copyright (c) Timothy A. Davis, 2006
-4-by-4, nzmax: 10 nnz: 10, 1-norm: 106
-    col 0 : locations 0 to 2
-      1 : (0, 42)
-      3 : (0, 0)
-      0 : (0, 6)
-    col 1 : locations 3 to 5
-      1 : (0, 1.3)
-      3 : (0, 2.71828)
-      2 : (0, 1)
-    col 2 : locations 6 to 7
-      2 : (0, 3.14159)
-      0 : (0, 0.1)
-    col 3 : locations 8 to 9
-      3 : (0, 7)
-      1 : (0, 99)
-
-B = conj(A):
-CXSparse Version 2.0.6, Dec 7, 2006.  Copyright (c) Timothy A. Davis, 2006
-4-by-4, nzmax: 10 nnz: 10, 1-norm: 106.075
-    col 0 : locations 0 to 2
-      1 : (3.1, -42)
-      3 : (3.5, 0)
-      0 : (4.5, -6)
-    col 1 : locations 3 to 5
-      1 : (2.9, -1.3)
-      3 : (0.4, -2.71828)
-      2 : (1.7, -1)
-    col 2 : locations 6 to 7
-      2 : (3, -3.14159)
-      0 : (3.2, -0.1)
-    col 3 : locations 8 to 9
-      3 : (1, -7)
-      1 : (0.9, -99)
-./cs_ldemo < ../Matrix/t2
-
---- cs_ldemo
-
-T:
-CXSparse Version 2.0.6, Dec 7, 2006.  Copyright (c) Timothy A. Davis, 2006
-triplet: 4-by-4, nzmax: 16 nnz: 10
-    2 2 : (3, 3.14159)
-    1 0 : (3.1, 42)
-    3 3 : (1, 7)
-    0 2 : (3.2, 0.1)
-    1 1 : (2.9, 1.3)
-    3 0 : (3.5, 0)
-    3 1 : (0.4, 2.71828)
-    1 3 : (0.9, 99)
-    0 0 : (4.5, 6)
-    2 1 : (1.7, 1)
-
-Treal:
-CXSparse Version 2.0.6, Dec 7, 2006.  Copyright (c) Timothy A. Davis, 2006
-triplet: 4-by-4, nzmax: 16 nnz: 10
-    2 2 : 3
-    1 0 : 3.1
-    3 3 : 1
-    0 2 : 3.2
-    1 1 : 2.9
-    3 0 : 3.5
-    3 1 : 0.4
-    1 3 : 0.9
-    0 0 : 4.5
-    2 1 : 1.7
-
-Timag:
-CXSparse Version 2.0.6, Dec 7, 2006.  Copyright (c) Timothy A. Davis, 2006
-triplet: 4-by-4, nzmax: 16 nnz: 10
-    2 2 : 3.14159
-    1 0 : 42
-    3 3 : 7
-    0 2 : 0.1
-    1 1 : 1.3
-    3 0 : 0
-    3 1 : 2.71828
-    1 3 : 99
-    0 0 : 6
-    2 1 : 1
-
-A:
-CXSparse Version 2.0.6, Dec 7, 2006.  Copyright (c) Timothy A. Davis, 2006
-4-by-4, nzmax: 10 nnz: 10, 1-norm: 106.075
-    col 0 : locations 0 to 2
-      1 : (3.1, 42)
-      3 : (3.5, 0)
-      0 : (4.5, 6)
-    col 1 : locations 3 to 5
-      1 : (2.9, 1.3)
-      3 : (0.4, 2.71828)
-      2 : (1.7, 1)
-    col 2 : locations 6 to 7
-      2 : (3, 3.14159)
-      0 : (3.2, 0.1)
-    col 3 : locations 8 to 9
-      3 : (1, 7)
-      1 : (0.9, 99)
-
-C1 = real(A):
-CXSparse Version 2.0.6, Dec 7, 2006.  Copyright (c) Timothy A. Davis, 2006
-4-by-4, nzmax: 10 nnz: 10, 1-norm: 11.1
-    col 0 : locations 0 to 2
-      1 : 3.1
-      3 : 3.5
-      0 : 4.5
-    col 1 : locations 3 to 5
-      1 : 2.9
-      3 : 0.4
-      2 : 1.7
-    col 2 : locations 6 to 7
-      2 : 3
-      0 : 3.2
-    col 3 : locations 8 to 9
-      3 : 1
-      1 : 0.9
-
-C2 = imag(A):
-CXSparse Version 2.0.6, Dec 7, 2006.  Copyright (c) Timothy A. Davis, 2006
-4-by-4, nzmax: 10 nnz: 10, 1-norm: 106
-    col 0 : locations 0 to 2
-      1 : 42
-      3 : 0
-      0 : 6
-    col 1 : locations 3 to 5
-      1 : 1.3
-      3 : 2.71828
-      2 : 1
-    col 2 : locations 6 to 7
-      2 : 3.14159
-      0 : 0.1
-    col 3 : locations 8 to 9
-      3 : 7
-      1 : 99
-
-A1:
-CXSparse Version 2.0.6, Dec 7, 2006.  Copyright (c) Timothy A. Davis, 2006
-4-by-4, nzmax: 10 nnz: 10, 1-norm: 11.1
-    col 0 : locations 0 to 2
-      1 : (3.1, 0)
-      3 : (3.5, 0)
-      0 : (4.5, 0)
-    col 1 : locations 3 to 5
-      1 : (2.9, 0)
-      3 : (0.4, 0)
-      2 : (1.7, 0)
-    col 2 : locations 6 to 7
-      2 : (3, 0)
-      0 : (3.2, 0)
-    col 3 : locations 8 to 9
-      3 : (1, 0)
-      1 : (0.9, 0)
-
-A2:
-CXSparse Version 2.0.6, Dec 7, 2006.  Copyright (c) Timothy A. Davis, 2006
-4-by-4, nzmax: 10 nnz: 10, 1-norm: 106
-    col 0 : locations 0 to 2
-      1 : (0, 42)
-      3 : (0, 0)
-      0 : (0, 6)
-    col 1 : locations 3 to 5
-      1 : (0, 1.3)
-      3 : (0, 2.71828)
-      2 : (0, 1)
-    col 2 : locations 6 to 7
-      2 : (0, 3.14159)
-      0 : (0, 0.1)
-    col 3 : locations 8 to 9
-      3 : (0, 7)
-      1 : (0, 99)
-
-B = conj(A):
-CXSparse Version 2.0.6, Dec 7, 2006.  Copyright (c) Timothy A. Davis, 2006
-4-by-4, nzmax: 10 nnz: 10, 1-norm: 106.075
-    col 0 : locations 0 to 2
-      1 : (3.1, -42)
-      3 : (3.5, 0)
-      0 : (4.5, -6)
-    col 1 : locations 3 to 5
-      1 : (2.9, -1.3)
-      3 : (0.4, -2.71828)
-      2 : (1.7, -1)
-    col 2 : locations 6 to 7
-      2 : (3, -3.14159)
-      0 : (3.2, -0.1)
-    col 3 : locations 8 to 9
-      3 : (1, -7)
-      1 : (0.9, -99)
 ./cs_demo1 < ../Matrix/t1
 T:
-CXSparse Version 2.0.6, Dec 7, 2006.  Copyright (c) Timothy A. Davis, 2006
+CSparse Version 2.0.6, Dec 7, 2006.  Copyright (c) Timothy A. Davis, 2006
 triplet: 4-by-4, nzmax: 16 nnz: 10
     2 2 : 3
     1 0 : 3.1
@@ -320,7 +13,7 @@
     0 0 : 4.5
     2 1 : 1.7
 A:
-CXSparse Version 2.0.6, Dec 7, 2006.  Copyright (c) Timothy A. Davis, 2006
+CSparse Version 2.0.6, Dec 7, 2006.  Copyright (c) Timothy A. Davis, 2006
 4-by-4, nzmax: 10 nnz: 10, 1-norm: 11.1
     col 0 : locations 0 to 2
       1 : 3.1
@@ -337,7 +30,7 @@
       3 : 1
       1 : 0.9
 AT:
-CXSparse Version 2.0.6, Dec 7, 2006.  Copyright (c) Timothy A. Davis, 2006
+CSparse Version 2.0.6, Dec 7, 2006.  Copyright (c) Timothy A. Davis, 2006
 4-by-4, nzmax: 10 nnz: 10, 1-norm: 7.7
     col 0 : locations 0 to 1
       0 : 4.5
@@ -354,7 +47,7 @@
       1 : 0.4
       3 : 1
 D:
-CXSparse Version 2.0.6, Dec 7, 2006.  Copyright (c) Timothy A. Davis, 2006
+CSparse Version 2.0.6, Dec 7, 2006.  Copyright (c) Timothy A. Davis, 2006
 4-by-4, nzmax: 16 nnz: 16, 1-norm: 139.58
     col 0 : locations 0 to 3
       1 : 13.95
@@ -380,405 +73,74 @@
 
 --- Matrix: 4-by-4, nnz: 10 (sym: 0: nnz 0), norm: 1.11e+01
 blocks: 1 singletons: 0 structural rank: 4
-QR   natural    time:     0.00 resid: 1.04e-17
-QR   amd(A'*A)  time:     0.00 resid: 2.03e-17
+QR   natural    time:     0.00 resid: 1.53e-17
+QR   amd(A'*A)  time:     0.00 resid: 1.53e-17
 LU   natural    time:     0.00 resid: 1.04e-17
 LU   amd(A+A')  time:     0.00 resid: 4.94e-18
 LU   amd(S'*S)  time:     0.00 resid: 4.94e-18
 LU   amd(A'*A)  time:     0.00 resid: 4.94e-18
-./cs_demo2 < ../Matrix/fs_183_1
-
---- Matrix: 183-by-183, nnz: 988 (sym: 0: nnz 0), norm: 1.70e+09
-zero entries dropped: 71
-tiny entries dropped: 10
-blocks: 38 singletons: 37 structural rank: 183
-QR   natural    time:     0.01 resid: 3.15e-28
-QR   amd(A'*A)  time:     0.00 resid: 2.60e-28
-LU   natural    time:     0.01 resid: 3.08e-28
-LU   amd(A+A')  time:     0.00 resid: 1.42e-27
-LU   amd(S'*S)  time:     0.00 resid: 7.11e-28
-LU   amd(A'*A)  time:     0.00 resid: 7.11e-28
-./cs_demo2 < ../Matrix/west0067
-
---- Matrix: 67-by-67, nnz: 294 (sym: 0: nnz 0), norm: 6.14e+00
-blocks: 2 singletons: 1 structural rank: 67
-QR   natural    time:     0.00 resid: 2.81e-17
-QR   amd(A'*A)  time:     0.00 resid: 1.30e-17
-LU   natural    time:     0.00 resid: 3.85e-17
-LU   amd(A+A')  time:     0.00 resid: 1.95e-17
-LU   amd(S'*S)  time:     0.00 resid: 2.60e-17
-LU   amd(A'*A)  time:     0.00 resid: 2.60e-17
-./cs_demo2 < ../Matrix/lp_afiro
-
---- Matrix: 27-by-51, nnz: 102 (sym: 0: nnz 0), norm: 3.43e+00
-blocks: 1 singletons: 0 structural rank: 27
-QR   natural    time:     0.00 resid: 4.30e-16
-QR   amd(A'*A)  time:     0.00 resid: 1.92e-16
 ./cs_demo2 < ../Matrix/ash219
 
 --- Matrix: 219-by-85, nnz: 438 (sym: 0: nnz 0), norm: 9.00e+00
 blocks: 1 singletons: 0 structural rank: 85
 QR   natural    time:     0.00 resid: 1.61e-02
 QR   amd(A'*A)  time:     0.00 resid: 1.61e-02
-./cs_demo2 < ../Matrix/mbeacxc
-
---- Matrix: 492-by-490, nnz: 49920 (sym: 0: nnz 0), norm: 9.29e-01
-blocks: 10 singletons: 8 structural rank: 448
-QR   natural    time:     0.26 resid:      nan
-QR   amd(A'*A)  time:     0.31 resid:      nan
 ./cs_demo2 < ../Matrix/bcsstk01
 
 --- Matrix: 48-by-48, nnz: 224 (sym: -1: nnz 400), norm: 3.57e+09
 blocks: 1 singletons: 0 structural rank: 48
-QR   natural    time:     0.00 resid: 3.97e-19
-QR   amd(A'*A)  time:     0.00 resid: 2.36e-19
+QR   natural    time:     0.00 resid: 2.83e-19
+QR   amd(A'*A)  time:     0.00 resid: 5.19e-19
 LU   natural    time:     0.00 resid: 2.63e-19
 LU   amd(A+A')  time:     0.00 resid: 8.63e-20
 LU   amd(S'*S)  time:     0.00 resid: 2.04e-19
 LU   amd(A'*A)  time:     0.00 resid: 2.04e-19
 Chol natural    time:     0.00 resid: 1.90e-19
 Chol amd(A+A')  time:     0.00 resid: 2.01e-19
-./cs_demo3 < ../Matrix/bcsstk01
-
---- Matrix: 48-by-48, nnz: 224 (sym: -1: nnz 400), norm: 3.57e+09
-
-chol then update/downdate amd(A+A')  
-symbolic chol time     0.00
-numeric  chol time     0.00
-solve    chol time     0.00
-original: resid: 2.01e-19
-update:   time:     0.00
-update:   time:     0.00 (incl solve) resid: 8.39e-19
-rechol:   time:     0.00 (incl solve) resid: 1.20e-18
-downdate: time:     0.00
-downdate: time:     0.00 (incl solve) resid: 3.30e-17
-./cs_demo2 < ../Matrix/bcsstk16
-
---- Matrix: 4884-by-4884, nnz: 147631 (sym: -1: nnz 290378), norm: 7.01e+09
-blocks: 75 singletons: 74 structural rank: 4884
-QR   amd(A'*A)  time:     2.44 resid: 1.28e-22
-LU   amd(A+A')  time:     1.46 resid: 1.06e-22
-LU   amd(S'*S)  time:     1.41 resid: 1.21e-22
-LU   amd(A'*A)  time:     1.48 resid: 1.70e-22
-Chol amd(A+A')  time:     0.65 resid: 9.28e-23
-./cs_demo3 < ../Matrix/bcsstk16
-
---- Matrix: 4884-by-4884, nnz: 147631 (sym: -1: nnz 290378), norm: 7.01e+09
-
-chol then update/downdate amd(A+A')  
-symbolic chol time     0.03
-numeric  chol time     0.62
-solve    chol time     0.01
-original: resid: 9.28e-23
-update:   time:     0.00
-update:   time:     0.01 (incl solve) resid: 8.62e-24
-rechol:   time:     0.63 (incl solve) resid: 8.72e-24
-downdate: time:     0.00
-downdate: time:     0.01 (incl solve) resid: 3.60e-22
-./cs_di_demo1 < ../Matrix/t1
-T:
-CXSparse Version 2.0.6, Dec 7, 2006.  Copyright (c) Timothy A. Davis, 2006
-triplet: 4-by-4, nzmax: 16 nnz: 10
-    2 2 : 3
-    1 0 : 3.1
-    3 3 : 1
-    0 2 : 3.2
-    1 1 : 2.9
-    3 0 : 3.5
-    3 1 : 0.4
-    1 3 : 0.9
-    0 0 : 4.5
-    2 1 : 1.7
-A:
-CXSparse Version 2.0.6, Dec 7, 2006.  Copyright (c) Timothy A. Davis, 2006
-4-by-4, nzmax: 10 nnz: 10, 1-norm: 11.1
-    col 0 : locations 0 to 2
-      1 : 3.1
-      3 : 3.5
-      0 : 4.5
-    col 1 : locations 3 to 5
-      1 : 2.9
-      3 : 0.4
-      2 : 1.7
-    col 2 : locations 6 to 7
-      2 : 3
-      0 : 3.2
-    col 3 : locations 8 to 9
-      3 : 1
-      1 : 0.9
-AT:
-CXSparse Version 2.0.6, Dec 7, 2006.  Copyright (c) Timothy A. Davis, 2006
-4-by-4, nzmax: 10 nnz: 10, 1-norm: 7.7
-    col 0 : locations 0 to 1
-      0 : 4.5
-      2 : 3.2
-    col 1 : locations 2 to 4
-      0 : 3.1
-      1 : 2.9
-      3 : 0.9
-    col 2 : locations 5 to 6
-      1 : 1.7
-      2 : 3
-    col 3 : locations 7 to 9
-      0 : 3.5
-      1 : 0.4
-      3 : 1
-D:
-CXSparse Version 2.0.6, Dec 7, 2006.  Copyright (c) Timothy A. Davis, 2006
-4-by-4, nzmax: 16 nnz: 16, 1-norm: 139.58
-    col 0 : locations 0 to 3
-      1 : 13.95
-      3 : 15.75
-      0 : 100.28
-      2 : 9.6
-    col 1 : locations 4 to 7
-      1 : 88.62
-      3 : 12.91
-      0 : 13.95
-      2 : 4.93
-    col 2 : locations 8 to 11
-      1 : 4.93
-      3 : 0.68
-      2 : 81.68
-      0 : 9.6
-    col 3 : locations 12 to 15
-      1 : 12.91
-      3 : 83.2
-      0 : 15.75
-      2 : 0.68
-./cs_di_demo2 < ../Matrix/t1
-
---- Matrix: 4-by-4, nnz: 10 (sym: 0: nnz 0), norm: 1.11e+01
-blocks: 1 singletons: 0 structural rank: 4
-QR   natural    time:     0.00 resid: 1.04e-17
-QR   amd(A'*A)  time:     0.00 resid: 2.03e-17
-LU   natural    time:     0.00 resid: 1.04e-17
-LU   amd(A+A')  time:     0.00 resid: 4.94e-18
-LU   amd(S'*S)  time:     0.00 resid: 4.94e-18
-LU   amd(A'*A)  time:     0.00 resid: 4.94e-18
-./cs_di_demo2 < ../Matrix/fs_183_1
+./cs_demo2 < ../Matrix/fs_183_1
 
 --- Matrix: 183-by-183, nnz: 988 (sym: 0: nnz 0), norm: 1.70e+09
 zero entries dropped: 71
 tiny entries dropped: 10
 blocks: 38 singletons: 37 structural rank: 183
-QR   natural    time:     0.00 resid: 3.15e-28
-QR   amd(A'*A)  time:     0.01 resid: 2.60e-28
+QR   natural    time:     0.00 resid: 1.09e-27
+QR   amd(A'*A)  time:     0.01 resid: 5.34e-28
 LU   natural    time:     0.00 resid: 3.08e-28
-LU   amd(A+A')  time:     0.01 resid: 1.42e-27
+LU   amd(A+A')  time:     0.00 resid: 1.42e-27
 LU   amd(S'*S)  time:     0.00 resid: 7.11e-28
-LU   amd(A'*A)  time:     0.00 resid: 7.11e-28
-./cs_di_demo2 < ../Matrix/west0067
-
---- Matrix: 67-by-67, nnz: 294 (sym: 0: nnz 0), norm: 6.14e+00
-blocks: 2 singletons: 1 structural rank: 67
-QR   natural    time:     0.00 resid: 2.81e-17
-QR   amd(A'*A)  time:     0.00 resid: 1.30e-17
-LU   natural    time:     0.00 resid: 3.85e-17
-LU   amd(A+A')  time:     0.00 resid: 1.95e-17
-LU   amd(S'*S)  time:     0.00 resid: 2.60e-17
-LU   amd(A'*A)  time:     0.00 resid: 2.60e-17
-./cs_di_demo2 < ../Matrix/lp_afiro
-
---- Matrix: 27-by-51, nnz: 102 (sym: 0: nnz 0), norm: 3.43e+00
-blocks: 1 singletons: 0 structural rank: 27
-QR   natural    time:     0.00 resid: 4.30e-16
-QR   amd(A'*A)  time:     0.00 resid: 1.92e-16
-./cs_di_demo2 < ../Matrix/ash219
-
---- Matrix: 219-by-85, nnz: 438 (sym: 0: nnz 0), norm: 9.00e+00
-blocks: 1 singletons: 0 structural rank: 85
-QR   natural    time:     0.00 resid: 1.61e-02
-QR   amd(A'*A)  time:     0.00 resid: 1.61e-02
-./cs_di_demo2 < ../Matrix/mbeacxc
+LU   amd(A'*A)  time:     0.01 resid: 7.11e-28
+./cs_demo2 < ../Matrix/mbeacxc
 
 --- Matrix: 492-by-490, nnz: 49920 (sym: 0: nnz 0), norm: 9.29e-01
 blocks: 10 singletons: 8 structural rank: 448
-QR   natural    time:     0.24 resid:      nan
-QR   amd(A'*A)  time:     0.31 resid:      nan
-./cs_di_demo2 < ../Matrix/bcsstk01
-
---- Matrix: 48-by-48, nnz: 224 (sym: -1: nnz 400), norm: 3.57e+09
-blocks: 1 singletons: 0 structural rank: 48
-QR   natural    time:     0.00 resid: 3.97e-19
-QR   amd(A'*A)  time:     0.00 resid: 2.36e-19
-LU   natural    time:     0.00 resid: 2.63e-19
-LU   amd(A+A')  time:     0.00 resid: 8.63e-20
-LU   amd(S'*S)  time:     0.00 resid: 2.04e-19
-LU   amd(A'*A)  time:     0.00 resid: 2.04e-19
-Chol natural    time:     0.00 resid: 1.90e-19
-Chol amd(A+A')  time:     0.00 resid: 2.01e-19
-./cs_di_demo3 < ../Matrix/bcsstk01
-
---- Matrix: 48-by-48, nnz: 224 (sym: -1: nnz 400), norm: 3.57e+09
-
-chol then update/downdate amd(A+A')  
-symbolic chol time     0.00
-numeric  chol time     0.00
-solve    chol time     0.00
-original: resid: 2.01e-19
-update:   time:     0.00
-update:   time:     0.00 (incl solve) resid: 8.39e-19
-rechol:   time:     0.00 (incl solve) resid: 1.20e-18
-downdate: time:     0.00
-downdate: time:     0.00 (incl solve) resid: 3.30e-17
-./cs_di_demo2 < ../Matrix/bcsstk16
-
---- Matrix: 4884-by-4884, nnz: 147631 (sym: -1: nnz 290378), norm: 7.01e+09
-blocks: 75 singletons: 74 structural rank: 4884
-QR   amd(A'*A)  time:     2.41 resid: 1.28e-22
-LU   amd(A+A')  time:     1.49 resid: 1.06e-22
-LU   amd(S'*S)  time:     1.40 resid: 1.21e-22
-LU   amd(A'*A)  time:     1.48 resid: 1.70e-22
-Chol amd(A+A')  time:     0.69 resid: 9.28e-23
-./cs_di_demo3 < ../Matrix/bcsstk16
-
---- Matrix: 4884-by-4884, nnz: 147631 (sym: -1: nnz 290378), norm: 7.01e+09
-
-chol then update/downdate amd(A+A')  
-symbolic chol time     0.03
-numeric  chol time     0.61
-solve    chol time     0.01
-original: resid: 9.28e-23
-update:   time:     0.00
-update:   time:     0.01 (incl solve) resid: 8.62e-24
-rechol:   time:     0.62 (incl solve) resid: 8.72e-24
-downdate: time:     0.00
-downdate: time:     0.01 (incl solve) resid: 3.60e-22
-./cs_dl_demo1 < ../Matrix/t1
-T:
-CXSparse Version 2.0.6, Dec 7, 2006.  Copyright (c) Timothy A. Davis, 2006
-triplet: 4-by-4, nzmax: 16 nnz: 10
-    2 2 : 3
-    1 0 : 3.1
-    3 3 : 1
-    0 2 : 3.2
-    1 1 : 2.9
-    3 0 : 3.5
-    3 1 : 0.4
-    1 3 : 0.9
-    0 0 : 4.5
-    2 1 : 1.7
-A:
-CXSparse Version 2.0.6, Dec 7, 2006.  Copyright (c) Timothy A. Davis, 2006
-4-by-4, nzmax: 10 nnz: 10, 1-norm: 11.1
-    col 0 : locations 0 to 2
-      1 : 3.1
-      3 : 3.5
-      0 : 4.5
-    col 1 : locations 3 to 5
-      1 : 2.9
-      3 : 0.4
-      2 : 1.7
-    col 2 : locations 6 to 7
-      2 : 3
-      0 : 3.2
-    col 3 : locations 8 to 9
-      3 : 1
-      1 : 0.9
-AT:
-CXSparse Version 2.0.6, Dec 7, 2006.  Copyright (c) Timothy A. Davis, 2006
-4-by-4, nzmax: 10 nnz: 10, 1-norm: 7.7
-    col 0 : locations 0 to 1
-      0 : 4.5
-      2 : 3.2
-    col 1 : locations 2 to 4
-      0 : 3.1
-      1 : 2.9
-      3 : 0.9
-    col 2 : locations 5 to 6
-      1 : 1.7
-      2 : 3
-    col 3 : locations 7 to 9
-      0 : 3.5
-      1 : 0.4
-      3 : 1
-D:
-CXSparse Version 2.0.6, Dec 7, 2006.  Copyright (c) Timothy A. Davis, 2006
-4-by-4, nzmax: 16 nnz: 16, 1-norm: 139.58
-    col 0 : locations 0 to 3
-      1 : 13.95
-      3 : 15.75
-      0 : 100.28
-      2 : 9.6
-    col 1 : locations 4 to 7
-      1 : 88.62
-      3 : 12.91
-      0 : 13.95
-      2 : 4.93
-    col 2 : locations 8 to 11
-      1 : 4.93
-      3 : 0.68
-      2 : 81.68
-      0 : 9.6
-    col 3 : locations 12 to 15
-      1 : 12.91
-      3 : 83.2
-      0 : 15.75
-      2 : 0.68
-./cs_dl_demo2 < ../Matrix/t1
-
---- Matrix: 4-by-4, nnz: 10 (sym: 0: nnz 0), norm: 1.11e+01
-blocks: 1 singletons: 0 structural rank: 4
-QR   natural    time:     0.00 resid: 1.04e-17
-QR   amd(A'*A)  time:     0.00 resid: 2.03e-17
-LU   natural    time:     0.00 resid: 1.04e-17
-LU   amd(A+A')  time:     0.00 resid: 4.94e-18
-LU   amd(S'*S)  time:     0.00 resid: 4.94e-18
-LU   amd(A'*A)  time:     0.00 resid: 4.94e-18
-./cs_dl_demo2 < ../Matrix/fs_183_1
-
---- Matrix: 183-by-183, nnz: 988 (sym: 0: nnz 0), norm: 1.70e+09
-zero entries dropped: 71
-tiny entries dropped: 10
-blocks: 38 singletons: 37 structural rank: 183
-QR   natural    time:     0.00 resid: 3.15e-28
-QR   amd(A'*A)  time:     0.01 resid: 2.60e-28
-LU   natural    time:     0.00 resid: 3.08e-28
-LU   amd(A+A')  time:     0.00 resid: 1.42e-27
-LU   amd(S'*S)  time:     0.00 resid: 7.11e-28
-LU   amd(A'*A)  time:     0.00 resid: 7.11e-28
-./cs_dl_demo2 < ../Matrix/west0067
+QR   natural    time:     0.25 resid:      nan
+QR   amd(A'*A)  time:     0.30 resid:      nan
+./cs_demo2 < ../Matrix/west0067
 
 --- Matrix: 67-by-67, nnz: 294 (sym: 0: nnz 0), norm: 6.14e+00
 blocks: 2 singletons: 1 structural rank: 67
-QR   natural    time:     0.00 resid: 2.81e-17
-QR   amd(A'*A)  time:     0.00 resid: 1.30e-17
+QR   natural    time:     0.00 resid: 3.42e-17
+QR   amd(A'*A)  time:     0.00 resid: 1.95e-17
 LU   natural    time:     0.00 resid: 3.85e-17
 LU   amd(A+A')  time:     0.00 resid: 1.95e-17
 LU   amd(S'*S)  time:     0.00 resid: 2.60e-17
 LU   amd(A'*A)  time:     0.00 resid: 2.60e-17
-./cs_dl_demo2 < ../Matrix/lp_afiro
+./cs_demo2 < ../Matrix/lp_afiro
 
 --- Matrix: 27-by-51, nnz: 102 (sym: 0: nnz 0), norm: 3.43e+00
 blocks: 1 singletons: 0 structural rank: 27
-QR   natural    time:     0.00 resid: 4.30e-16
-QR   amd(A'*A)  time:     0.00 resid: 1.92e-16
-./cs_dl_demo2 < ../Matrix/ash219
-
---- Matrix: 219-by-85, nnz: 438 (sym: 0: nnz 0), norm: 9.00e+00
-blocks: 1 singletons: 0 structural rank: 85
-QR   natural    time:     0.00 resid: 1.61e-02
-QR   amd(A'*A)  time:     0.00 resid: 1.61e-02
-./cs_dl_demo2 < ../Matrix/mbeacxc
-
---- Matrix: 492-by-490, nnz: 49920 (sym: 0: nnz 0), norm: 9.29e-01
-blocks: 10 singletons: 8 structural rank: 448
-QR   natural    time:     0.26 resid:      nan
-QR   amd(A'*A)  time:     0.33 resid:      nan
-./cs_dl_demo2 < ../Matrix/bcsstk01
+QR   natural    time:     0.00 resid: 9.54e-17
+QR   amd(A'*A)  time:     0.00 resid: 1.89e-16
+./cs_demo2 < ../Matrix/bcsstk16
 
---- Matrix: 48-by-48, nnz: 224 (sym: -1: nnz 400), norm: 3.57e+09
-blocks: 1 singletons: 0 structural rank: 48
-QR   natural    time:     0.00 resid: 3.97e-19
-QR   amd(A'*A)  time:     0.00 resid: 2.36e-19
-LU   natural    time:     0.00 resid: 2.63e-19
-LU   amd(A+A')  time:     0.00 resid: 8.63e-20
-LU   amd(S'*S)  time:     0.00 resid: 2.04e-19
-LU   amd(A'*A)  time:     0.00 resid: 2.04e-19
-Chol natural    time:     0.00 resid: 1.90e-19
-Chol amd(A+A')  time:     0.00 resid: 2.01e-19
-./cs_dl_demo3 < ../Matrix/bcsstk01
+--- Matrix: 4884-by-4884, nnz: 147631 (sym: -1: nnz 290378), norm: 7.01e+09
+blocks: 75 singletons: 74 structural rank: 4884
+QR   amd(A'*A)  time:     2.42 resid: 2.02e-22
+LU   amd(A+A')  time:     1.44 resid: 1.06e-22
+LU   amd(S'*S)  time:     1.39 resid: 1.21e-22
+LU   amd(A'*A)  time:     1.48 resid: 1.70e-22
+Chol amd(A+A')  time:     0.65 resid: 9.28e-23
+./cs_demo3 < ../Matrix/bcsstk01
 
 --- Matrix: 48-by-48, nnz: 224 (sym: -1: nnz 400), norm: 3.57e+09
 
@@ -792,361 +154,17 @@
 rechol:   time:     0.00 (incl solve) resid: 1.20e-18
 downdate: time:     0.00
 downdate: time:     0.00 (incl solve) resid: 3.30e-17
-./cs_dl_demo2 < ../Matrix/bcsstk16
-
---- Matrix: 4884-by-4884, nnz: 147631 (sym: -1: nnz 290378), norm: 7.01e+09
-blocks: 75 singletons: 74 structural rank: 4884
-QR   amd(A'*A)  time:     2.42 resid: 1.28e-22
-LU   amd(A+A')  time:     1.39 resid: 1.06e-22
-LU   amd(S'*S)  time:     1.37 resid: 1.21e-22
-LU   amd(A'*A)  time:     1.41 resid: 1.70e-22
-Chol amd(A+A')  time:     0.65 resid: 9.28e-23
-./cs_dl_demo3 < ../Matrix/bcsstk16
+./cs_demo3 < ../Matrix/bcsstk16
 
 --- Matrix: 4884-by-4884, nnz: 147631 (sym: -1: nnz 290378), norm: 7.01e+09
 
 chol then update/downdate amd(A+A')  
-symbolic chol time     0.03
-numeric  chol time     0.61
-solve    chol time     0.01
+symbolic chol time     0.04
+numeric  chol time     0.60
+solve    chol time     0.02
 original: resid: 9.28e-23
 update:   time:     0.00
-update:   time:     0.02 (incl solve) resid: 8.62e-24
-rechol:   time:     0.63 (incl solve) resid: 8.72e-24
-downdate: time:     0.00
-downdate: time:     0.01 (incl solve) resid: 3.60e-22
-./cs_ci_demo1 < ../Matrix/t2
-T:
-CXSparse Version 2.0.6, Dec 7, 2006.  Copyright (c) Timothy A. Davis, 2006
-triplet: 4-by-4, nzmax: 16 nnz: 10
-    2 2 : (3, 3.14159)
-    1 0 : (3.1, 42)
-    3 3 : (1, 7)
-    0 2 : (3.2, 0.1)
-    1 1 : (2.9, 1.3)
-    3 0 : (3.5, 0)
-    3 1 : (0.4, 2.71828)
-    1 3 : (0.9, 99)
-    0 0 : (4.5, 6)
-    2 1 : (1.7, 1)
-A:
-CXSparse Version 2.0.6, Dec 7, 2006.  Copyright (c) Timothy A. Davis, 2006
-4-by-4, nzmax: 10 nnz: 10, 1-norm: 106.075
-    col 0 : locations 0 to 2
-      1 : (3.1, 42)
-      3 : (3.5, 0)
-      0 : (4.5, 6)
-    col 1 : locations 3 to 5
-      1 : (2.9, 1.3)
-      3 : (0.4, 2.71828)
-      2 : (1.7, 1)
-    col 2 : locations 6 to 7
-      2 : (3, 3.14159)
-      0 : (3.2, 0.1)
-    col 3 : locations 8 to 9
-      3 : (1, 7)
-      1 : (0.9, 99)
-AT:
-CXSparse Version 2.0.6, Dec 7, 2006.  Copyright (c) Timothy A. Davis, 2006
-4-by-4, nzmax: 10 nnz: 10, 1-norm: 144.296
-    col 0 : locations 0 to 1
-      0 : (4.5, -6)
-      2 : (3.2, -0.1)
-    col 1 : locations 2 to 4
-      0 : (3.1, -42)
-      1 : (2.9, -1.3)
-      3 : (0.9, -99)
-    col 2 : locations 5 to 6
-      1 : (1.7, -1)
-      2 : (3, -3.14159)
-    col 3 : locations 7 to 9
-      0 : (3.5, -0)
-      1 : (0.4, -2.71828)
-      3 : (1, -7)
-D:
-CXSparse Version 2.0.6, Dec 7, 2006.  Copyright (c) Timothy A. Davis, 2006
-4-by-4, nzmax: 16 nnz: 16, 1-norm: 25308.3
-    col 0 : locations 0 to 3
-      1 : (265.95, 170.4)
-      3 : (15.75, -21)
-      0 : (12720.7, 0)
-      2 : (9.91416, 9.7531)
-    col 1 : locations 4 to 7
-      1 : (24239.7, 0)
-      3 : (709.444, -232.337)
-      0 : (265.95, -170.4)
-      2 : (6.23, 0.69)
-    col 2 : locations 8 to 11
-      1 : (6.23, -0.69)
-      3 : (3.39828, 4.22108)
-      2 : (12676.9, 0)
-      0 : (9.91416, -9.7531)
-    col 3 : locations 12 to 15
-      1 : (709.444, 232.337)
-      3 : (12724, 0)
-      0 : (15.75, 21)
-      2 : (3.39828, -4.22108)
-./cs_ci_demo2 < ../Matrix/t2
-
---- Matrix: 4-by-4, nnz: 10 (sym: 0: nnz 0), norm: 1.06e+02
-blocks: 1 singletons: 0 structural rank: 4
-QR   natural    time:     0.00 resid: 1.07e-17
-QR   amd(A'*A)  time:     0.00 resid: 3.09e-18
-LU   natural    time:     0.00 resid: 2.67e-18
-LU   amd(A+A')  time:     0.00 resid: 2.12e-18
-LU   amd(S'*S)  time:     0.00 resid: 2.93e-18
-LU   amd(A'*A)  time:     0.00 resid: 2.12e-18
-./cs_ci_demo2 < ../Matrix/t3
-
---- Matrix: 3-by-4, nnz: 12 (sym: 0: nnz 0), norm: 3.06e+00
-blocks: 1 singletons: 0 structural rank: 3
-QR   natural    time:     0.00 resid: 1.21e-16
-QR   amd(A'*A)  time:     0.00 resid: 1.21e-16
-./cs_ci_demo2 < ../Matrix/t4
-
---- Matrix: 2-by-2, nnz: 3 (sym: 1: nnz 4), norm: 2.83e+00
-blocks: 1 singletons: 0 structural rank: 2
-QR   natural    time:     0.00 resid: 2.74e-17
-QR   amd(A'*A)  time:     0.00 resid: 2.74e-17
-LU   natural    time:     0.00 resid: 0.00e+00
-LU   amd(A+A')  time:     0.00 resid: 0.00e+00
-LU   amd(S'*S)  time:     0.00 resid: 0.00e+00
-LU   amd(A'*A)  time:     0.00 resid: 0.00e+00
-Chol natural    time:     0.00     (failed)
-Chol amd(A+A')  time:     0.00     (failed)
-./cs_ci_demo2 < ../Matrix/c_west0067
-
---- Matrix: 67-by-67, nnz: 294 (sym: 0: nnz 0), norm: 6.17e+00
-blocks: 2 singletons: 1 structural rank: 67
-QR   natural    time:     0.00 resid: 3.47e-17
-QR   amd(A'*A)  time:     0.00 resid: 6.79e-17
-LU   natural    time:     0.00 resid: 5.08e-17
-LU   amd(A+A')  time:     0.00 resid: 7.10e-17
-LU   amd(S'*S)  time:     0.00 resid: 3.28e-17
-LU   amd(A'*A)  time:     0.00 resid: 4.32e-17
-./cs_ci_demo2 < ../Matrix/c_mbeacxc
-
---- Matrix: 492-by-490, nnz: 49920 (sym: 0: nnz 0), norm: 9.29e-01
-blocks: 10 singletons: 8 structural rank: 448
-QR   natural    time:     0.62 resid:      nan
-QR   amd(A'*A)  time:     0.68 resid:      nan
-./cs_ci_demo2 < ../Matrix/young1c
-
---- Matrix: 841-by-841, nnz: 4089 (sym: 0: nnz 0), norm: 7.30e+02
-blocks: 1 singletons: 0 structural rank: 841
-QR   natural    time:     0.02 resid: 9.10e-17
-QR   amd(A'*A)  time:     0.02 resid: 8.11e-17
-LU   natural    time:     0.01 resid: 1.27e-16
-LU   amd(A+A')  time:     0.02 resid: 3.45e-16
-LU   amd(S'*S)  time:     0.02 resid: 2.31e-16
-LU   amd(A'*A)  time:     0.01 resid: 2.31e-16
-./cs_ci_demo2 < ../Matrix/qc324
-
---- Matrix: 324-by-324, nnz: 26730 (sym: 0: nnz 0), norm: 1.71e+00
-blocks: 1 singletons: 0 structural rank: 324
-QR   natural    time:     0.04 resid: 3.27e-17
-QR   amd(A'*A)  time:     0.06 resid: 3.70e-17
-LU   natural    time:     0.03 resid: 4.19e-17
-LU   amd(A+A')  time:     0.04 resid: 3.73e-17
-LU   amd(S'*S)  time:     0.03 resid: 4.19e-17
-LU   amd(A'*A)  time:     0.04 resid: 4.19e-17
-./cs_ci_demo2 < ../Matrix/neumann
-
---- Matrix: 1600-by-1600, nnz: 7840 (sym: 0: nnz 0), norm: 1.41e+01
-blocks: 1 singletons: 0 structural rank: 1600
-QR   amd(A'*A)  time:     0.03 resid: 4.89e-16
-LU   amd(A+A')  time:     0.02 resid: 4.32e-16
-LU   amd(S'*S)  time:     0.02 resid: 4.63e-16
-LU   amd(A'*A)  time:     0.02 resid: 4.63e-16
-./cs_ci_demo2 < ../Matrix/mhd1280b
-
---- Matrix: 1280-by-1280, nnz: 11963 (sym: -1: nnz 22646), norm: 8.00e+01
-tiny entries dropped: 66
-blocks: 20 singletons: 14 structural rank: 1280
-QR   amd(A'*A)  time:     0.01 resid: 1.98e-25
-LU   amd(A+A')  time:     0.00 resid: 2.07e-25
-LU   amd(S'*S)  time:     0.01 resid: 1.53e-25
-LU   amd(A'*A)  time:     0.02 resid: 1.53e-25
-Chol amd(A+A')  time:     0.01 resid: 3.63e-16
-./cs_ci_demo3 < ../Matrix/mhd1280b
-
---- Matrix: 1280-by-1280, nnz: 12029 (sym: -1: nnz 22778), norm: 8.00e+01
-
-chol then update/downdate amd(A+A')  
-symbolic chol time     0.01
-numeric  chol time     0.00
-solve    chol time     0.00
-original: resid: 3.64e-16
-update:   time:     0.00
-update:   time:     0.00 (incl solve) resid: 3.64e-16
-rechol:   time:     0.01 (incl solve) resid: 3.64e-16
-downdate: time:     0.00
-downdate: time:     0.00 (incl solve) resid: 1.89e-15
-./cs_cl_demo1 < ../Matrix/t2
-T:
-CXSparse Version 2.0.6, Dec 7, 2006.  Copyright (c) Timothy A. Davis, 2006
-triplet: 4-by-4, nzmax: 16 nnz: 10
-    2 2 : (3, 3.14159)
-    1 0 : (3.1, 42)
-    3 3 : (1, 7)
-    0 2 : (3.2, 0.1)
-    1 1 : (2.9, 1.3)
-    3 0 : (3.5, 0)
-    3 1 : (0.4, 2.71828)
-    1 3 : (0.9, 99)
-    0 0 : (4.5, 6)
-    2 1 : (1.7, 1)
-A:
-CXSparse Version 2.0.6, Dec 7, 2006.  Copyright (c) Timothy A. Davis, 2006
-4-by-4, nzmax: 10 nnz: 10, 1-norm: 106.075
-    col 0 : locations 0 to 2
-      1 : (3.1, 42)
-      3 : (3.5, 0)
-      0 : (4.5, 6)
-    col 1 : locations 3 to 5
-      1 : (2.9, 1.3)
-      3 : (0.4, 2.71828)
-      2 : (1.7, 1)
-    col 2 : locations 6 to 7
-      2 : (3, 3.14159)
-      0 : (3.2, 0.1)
-    col 3 : locations 8 to 9
-      3 : (1, 7)
-      1 : (0.9, 99)
-AT:
-CXSparse Version 2.0.6, Dec 7, 2006.  Copyright (c) Timothy A. Davis, 2006
-4-by-4, nzmax: 10 nnz: 10, 1-norm: 144.296
-    col 0 : locations 0 to 1
-      0 : (4.5, -6)
-      2 : (3.2, -0.1)
-    col 1 : locations 2 to 4
-      0 : (3.1, -42)
-      1 : (2.9, -1.3)
-      3 : (0.9, -99)
-    col 2 : locations 5 to 6
-      1 : (1.7, -1)
-      2 : (3, -3.14159)
-    col 3 : locations 7 to 9
-      0 : (3.5, -0)
-      1 : (0.4, -2.71828)
-      3 : (1, -7)
-D:
-CXSparse Version 2.0.6, Dec 7, 2006.  Copyright (c) Timothy A. Davis, 2006
-4-by-4, nzmax: 16 nnz: 16, 1-norm: 25308.3
-    col 0 : locations 0 to 3
-      1 : (265.95, 170.4)
-      3 : (15.75, -21)
-      0 : (12720.7, 0)
-      2 : (9.91416, 9.7531)
-    col 1 : locations 4 to 7
-      1 : (24239.7, 0)
-      3 : (709.444, -232.337)
-      0 : (265.95, -170.4)
-      2 : (6.23, 0.69)
-    col 2 : locations 8 to 11
-      1 : (6.23, -0.69)
-      3 : (3.39828, 4.22108)
-      2 : (12676.9, 0)
-      0 : (9.91416, -9.7531)
-    col 3 : locations 12 to 15
-      1 : (709.444, 232.337)
-      3 : (12724, 0)
-      0 : (15.75, 21)
-      2 : (3.39828, -4.22108)
-./cs_cl_demo2 < ../Matrix/t2
-
---- Matrix: 4-by-4, nnz: 10 (sym: 0: nnz 0), norm: 1.06e+02
-blocks: 1 singletons: 0 structural rank: 4
-QR   natural    time:     0.00 resid: 1.07e-17
-QR   amd(A'*A)  time:     0.00 resid: 3.09e-18
-LU   natural    time:     0.00 resid: 2.67e-18
-LU   amd(A+A')  time:     0.00 resid: 2.12e-18
-LU   amd(S'*S)  time:     0.00 resid: 2.93e-18
-LU   amd(A'*A)  time:     0.00 resid: 2.12e-18
-./cs_cl_demo2 < ../Matrix/t3
-
---- Matrix: 3-by-4, nnz: 12 (sym: 0: nnz 0), norm: 3.06e+00
-blocks: 1 singletons: 0 structural rank: 3
-QR   natural    time:     0.00 resid: 1.21e-16
-QR   amd(A'*A)  time:     0.00 resid: 1.21e-16
-./cs_cl_demo2 < ../Matrix/t4
-
---- Matrix: 2-by-2, nnz: 3 (sym: 1: nnz 4), norm: 2.83e+00
-blocks: 1 singletons: 0 structural rank: 2
-QR   natural    time:     0.00 resid: 2.74e-17
-QR   amd(A'*A)  time:     0.00 resid: 2.74e-17
-LU   natural    time:     0.00 resid: 0.00e+00
-LU   amd(A+A')  time:     0.00 resid: 0.00e+00
-LU   amd(S'*S)  time:     0.00 resid: 0.00e+00
-LU   amd(A'*A)  time:     0.00 resid: 0.00e+00
-Chol natural    time:     0.00     (failed)
-Chol amd(A+A')  time:     0.00     (failed)
-./cs_cl_demo2 < ../Matrix/c_west0067
-
---- Matrix: 67-by-67, nnz: 294 (sym: 0: nnz 0), norm: 6.17e+00
-blocks: 2 singletons: 1 structural rank: 67
-QR   natural    time:     0.00 resid: 3.47e-17
-QR   amd(A'*A)  time:     0.00 resid: 6.79e-17
-LU   natural    time:     0.00 resid: 5.08e-17
-LU   amd(A+A')  time:     0.00 resid: 7.10e-17
-LU   amd(S'*S)  time:     0.00 resid: 3.28e-17
-LU   amd(A'*A)  time:     0.00 resid: 4.32e-17
-./cs_cl_demo2 < ../Matrix/c_mbeacxc
-
---- Matrix: 492-by-490, nnz: 49920 (sym: 0: nnz 0), norm: 9.29e-01
-blocks: 10 singletons: 8 structural rank: 448
-QR   natural    time:     0.63 resid:      nan
-QR   amd(A'*A)  time:     0.67 resid:      nan
-./cs_cl_demo2 < ../Matrix/young1c
-
---- Matrix: 841-by-841, nnz: 4089 (sym: 0: nnz 0), norm: 7.30e+02
-blocks: 1 singletons: 0 structural rank: 841
-QR   natural    time:     0.03 resid: 9.10e-17
-QR   amd(A'*A)  time:     0.01 resid: 8.11e-17
-LU   natural    time:     0.02 resid: 1.27e-16
-LU   amd(A+A')  time:     0.02 resid: 3.45e-16
-LU   amd(S'*S)  time:     0.01 resid: 2.31e-16
-LU   amd(A'*A)  time:     0.01 resid: 2.31e-16
-./cs_cl_demo2 < ../Matrix/qc324
-
---- Matrix: 324-by-324, nnz: 26730 (sym: 0: nnz 0), norm: 1.71e+00
-blocks: 1 singletons: 0 structural rank: 324
-QR   natural    time:     0.04 resid: 3.27e-17
-QR   amd(A'*A)  time:     0.06 resid: 3.70e-17
-LU   natural    time:     0.03 resid: 4.19e-17
-LU   amd(A+A')  time:     0.03 resid: 3.73e-17
-LU   amd(S'*S)  time:     0.04 resid: 4.19e-17
-LU   amd(A'*A)  time:     0.03 resid: 4.19e-17
-./cs_cl_demo2 < ../Matrix/neumann
-
---- Matrix: 1600-by-1600, nnz: 7840 (sym: 0: nnz 0), norm: 1.41e+01
-blocks: 1 singletons: 0 structural rank: 1600
-QR   amd(A'*A)  time:     0.03 resid: 4.89e-16
-LU   amd(A+A')  time:     0.02 resid: 4.32e-16
-LU   amd(S'*S)  time:     0.02 resid: 4.63e-16
-LU   amd(A'*A)  time:     0.03 resid: 4.63e-16
-./cs_cl_demo2 < ../Matrix/mhd1280b
-
---- Matrix: 1280-by-1280, nnz: 11963 (sym: -1: nnz 22646), norm: 8.00e+01
-tiny entries dropped: 66
-blocks: 20 singletons: 14 structural rank: 1280
-QR   amd(A'*A)  time:     0.01 resid: 1.98e-25
-LU   amd(A+A')  time:     0.01 resid: 2.07e-25
-LU   amd(S'*S)  time:     0.01 resid: 1.53e-25
-LU   amd(A'*A)  time:     0.00 resid: 1.53e-25
-Chol amd(A+A')  time:     0.01 resid: 3.63e-16
-./cs_cl_demo3 < ../Matrix/mhd1280b
-
---- Matrix: 1280-by-1280, nnz: 12029 (sym: -1: nnz 22778), norm: 8.00e+01
-
-chol then update/downdate amd(A+A')  
-symbolic chol time     0.01
-numeric  chol time     0.00
-solve    chol time     0.00
-original: resid: 3.64e-16
-update:   time:     0.00
-update:   time:     0.00 (incl solve) resid: 3.64e-16
-rechol:   time:     0.00 (incl solve) resid: 3.64e-16
+update:   time:     0.01 (incl solve) resid: 8.62e-24
+rechol:   time:     0.62 (incl solve) resid: 8.72e-24
 downdate: time:     0.00
-downdate: time:     0.00 (incl solve) resid: 1.89e-15
-make[1]: Leaving directory `/amd/netapp3/vol/research0a/research18/sparse/SuiteSparse/CXSparse/Demo'
+downdate: time:     0.02 (incl solve) resid: 3.60e-22
diff -ur SuiteSparse/CXSparse/Demo/cs_di_demo.c SuiteSparse-mod/CXSparse/Demo/cs_di_demo.c
--- SuiteSparse/CXSparse/Demo/cs_di_demo.c	2006-12-07 06:52:28.000000000 +0100
+++ SuiteSparse-mod/CXSparse/Demo/cs_di_demo.c	2007-02-12 09:58:07.559499100 +0100
@@ -81,7 +81,7 @@
     cs_di *T, *A, *C ;
     int sym, m, n, mn, nz1, nz2 ;
     problem *Prob ;
-    Prob = cs_di_calloc (1, sizeof (problem)) ;
+    Prob = (problem*)cs_di_calloc (1, sizeof (problem)) ;
     if (!Prob) return (NULL) ;
     T = cs_di_load (f) ;			/* load triplet matrix T from a file */
     Prob->A = A = cs_di_compress (T) ;	/* A = compressed-column form of T */
@@ -100,9 +100,9 @@
 	    m, n, A->p [n], sym, sym ? C->p [n] : 0, cs_di_norm (C)) ;
     if (nz1 != nz2) printf ("zero entries dropped: %d\n", nz1 - nz2) ;
     if (nz2 != A->p [n]) printf ("tiny entries dropped: %d\n", nz2 - A->p [n]) ;
-    Prob->b = cs_di_malloc (mn, sizeof (double)) ;
-    Prob->x = cs_di_malloc (mn, sizeof (double)) ;
-    Prob->resid = cs_di_malloc (mn, sizeof (double)) ;
+    Prob->b = (double*)cs_di_malloc (mn, sizeof (double)) ;
+    Prob->x = (double*)cs_di_malloc (mn, sizeof (double)) ;
+    Prob->resid = (double*)cs_di_malloc (mn, sizeof (double)) ;
     return ((!Prob->b || !Prob->x || !Prob->resid) ? free_problem (Prob) : Prob) ;
 }
 
@@ -115,7 +115,7 @@
     cs_di_free (Prob->b) ;
     cs_di_free (Prob->x) ;
     cs_di_free (Prob->resid) ;
-    return (cs_di_free (Prob)) ;
+    return (problem*)(cs_di_free (Prob)) ;
 }
 
 /* solve a linear system using Cholesky, LU, and QR, with various orderings */
@@ -204,7 +204,7 @@
     rhs (x, b, n) ;				/* compute right-hand side */
     printf ("\nchol then update/downdate ") ;
     print_order (1) ;
-    y = cs_di_malloc (n, sizeof (double)) ;
+    y = (double*)cs_di_malloc (n, sizeof (double)) ;
     t = tic () ;
     S = cs_di_schol (1, C) ;			/* symbolic Chol, amd(A+A') */
     printf ("\nsymbolic chol time %8.2f\n", toc (t)) ;
@@ -234,7 +234,7 @@
     {
 	p2 = p1 - Lp [k] ;
 	Wi [p2] = Li [p1] ;
-	Wx [p2] = s * rand () / ((double) RAND_MAX) ;
+	Wx [p2] = s * (rand () / ((double) RAND_MAX)) ;
     }
     t = tic () ;
     ok = cs_di_updown (N->L, +1, W, S->parent) ;	/* update: L*L'+W*W' */
diff -ur SuiteSparse/CXSparse/Demo/cs_dl_demo.c SuiteSparse-mod/CXSparse/Demo/cs_dl_demo.c
--- SuiteSparse/CXSparse/Demo/cs_dl_demo.c	2006-12-07 06:52:28.000000000 +0100
+++ SuiteSparse-mod/CXSparse/Demo/cs_dl_demo.c	2007-02-12 09:58:07.575124900 +0100
@@ -81,7 +81,7 @@
     cs_dl *T, *A, *C ;
     UF_long sym, m, n, mn, nz1, nz2 ;
     problem *Prob ;
-    Prob = cs_dl_calloc (1, sizeof (problem)) ;
+    Prob = (problem*)cs_dl_calloc (1, sizeof (problem)) ;
     if (!Prob) return (NULL) ;
     T = cs_dl_load (f) ;			/* load triplet matrix T from a file */
     Prob->A = A = cs_dl_compress (T) ;	/* A = compressed-column form of T */
@@ -100,9 +100,9 @@
 	    m, n, A->p [n], sym, sym ? C->p [n] : 0, cs_dl_norm (C)) ;
     if (nz1 != nz2) printf ("zero entries dropped: %ld\n", nz1 - nz2) ;
     if (nz2 != A->p [n]) printf ("tiny entries dropped: %ld\n", nz2 - A->p [n]) ;
-    Prob->b = cs_dl_malloc (mn, sizeof (double)) ;
-    Prob->x = cs_dl_malloc (mn, sizeof (double)) ;
-    Prob->resid = cs_dl_malloc (mn, sizeof (double)) ;
+    Prob->b = (double*)cs_dl_malloc (mn, sizeof (double)) ;
+    Prob->x = (double*)cs_dl_malloc (mn, sizeof (double)) ;
+    Prob->resid = (double*)cs_dl_malloc (mn, sizeof (double)) ;
     return ((!Prob->b || !Prob->x || !Prob->resid) ? free_problem (Prob) : Prob) ;
 }
 
@@ -115,7 +115,7 @@
     cs_dl_free (Prob->b) ;
     cs_dl_free (Prob->x) ;
     cs_dl_free (Prob->resid) ;
-    return (cs_dl_free (Prob)) ;
+    return (problem*)(cs_dl_free (Prob)) ;
 }
 
 /* solve a linear system using Cholesky, LU, and QR, with various orderings */
@@ -204,7 +204,7 @@
     rhs (x, b, n) ;				/* compute right-hand side */
     printf ("\nchol then update/downdate ") ;
     print_order (1) ;
-    y = cs_dl_malloc (n, sizeof (double)) ;
+    y = (double*)cs_dl_malloc (n, sizeof (double)) ;
     t = tic () ;
     S = cs_dl_schol (1, C) ;			/* symbolic Chol, amd(A+A') */
     printf ("\nsymbolic chol time %8.2f\n", toc (t)) ;
@@ -234,7 +234,7 @@
     {
 	p2 = p1 - Lp [k] ;
 	Wi [p2] = Li [p1] ;
-	Wx [p2] = s * rand () / ((double) RAND_MAX) ;
+	Wx [p2] = s * (rand () / ((double) RAND_MAX)) ;
     }
     t = tic () ;
     ok = cs_dl_updown (N->L, +1, W, S->parent) ;	/* update: L*L'+W*W' */
diff -ur SuiteSparse/CXSparse/Source/Makefile SuiteSparse-mod/CXSparse/Source/Makefile
--- SuiteSparse/CXSparse/Source/Makefile	2006-05-02 09:06:20.000000000 +0200
+++ SuiteSparse-mod/CXSparse/Source/Makefile	2007-02-12 10:33:32.359339900 +0100
@@ -1,12 +1,15 @@
 # Modify the "-O" optimization option for best performance (-O3 on Linux):
-CC = cc
-CFLAGS = -O
-I = -I../../UFconfig
+# CC = cc-msvc
+# CFLAGS = -EHs -O2 -MD -TP
 
-AR = ar cr
-RANLIB = ranlib
+include ../../UFconfig/UFconfig.mk
 
-all: libcxsparse.a
+I = -I../../UFconfig -EHs -TP
+
+# AR = ar-msvc cr
+# RANLIB = ranlib-msvc
+
+all: $(LIBPRE)cxsparse.$(LIBEXT)
 
 CS_SOURCE = cs_add.c cs_amd.c cs_chol.c cs_cholsol.c cs_counts.c cs_cumsum.c \
 	cs_droptol.c cs_dropzeros.c cs_dupl.c cs_entry.c \
@@ -85,9 +88,9 @@
 %_cl.o : %.c
 	$(CC) $(CFLAGS) $(I) -DCS_LONG -DCS_COMPLEX -c $< -o $@
 
-libcxsparse.a: $(CS)
-	$(AR) libcxsparse.a $(CS)
-	$(RANLIB) libcxsparse.a
+$(LIBPRE)cxsparse.$(LIBEXT): $(CS)
+	$(AR) $(LIBPRE)cxsparse.$(LIBEXT) $(CS)
+	$(RANLIB) $(LIBPRE)cxsparse.$(LIBEXT)
 
 clean:
 	rm -f *.o
@@ -95,4 +98,4 @@
 purge: distclean
 
 distclean: clean
-	rm -f *.a
+	rm -f *.$(LIBEXT)
diff -ur SuiteSparse/CXSparse/Source/cs.h SuiteSparse-mod/CXSparse/Source/cs.h
--- SuiteSparse/CXSparse/Source/cs.h	2006-12-07 06:47:10.000000000 +0100
+++ SuiteSparse-mod/CXSparse/Source/cs.h	2007-02-12 09:57:20.000000000 +0100
@@ -9,9 +9,19 @@
 #endif
 
 #ifdef __cplusplus
+#include <complex>
+typedef std::complex<double> cs_complex_t;
+#define creal(x) ((x).real())
+#define cimag(x) ((x).imag())
+#define cabs(x) abs(x)
+#define I cs_complex_t(0., 1.)
+#ifdef _MSC_VER
+#pragma warning (disable: 4003)
+#endif
 extern "C" {
 #else
 #include <complex.h>
+#define cs_complex_t double _Complex;
 #endif
 
 #define CS_VER 2		    /* CXSparse Version 2.0.6 */
@@ -308,19 +318,19 @@
     int n ;	    /* number of columns */
     int *p ;	    /* column pointers (size n+1) or col indices (size nzmax) */
     int *i ;	    /* row indices, size nzmax */
-    double _Complex *x ;    /* numerical values, size nzmax */
+    cs_complex_t *x ;    /* numerical values, size nzmax */
     int nz ;	    /* # of entries in triplet matrix, -1 for compressed-col */
 } cs_ci ;
 
-cs_ci *cs_ci_add (const cs_ci *A, const cs_ci *B, double _Complex alpha,
-    double _Complex beta) ;
-int cs_ci_cholsol (int order, const cs_ci *A, double _Complex *b) ;
+cs_ci *cs_ci_add (const cs_ci *A, const cs_ci *B, cs_complex_t alpha,
+    cs_complex_t beta) ;
+int cs_ci_cholsol (int order, const cs_ci *A, cs_complex_t *b) ;
 int cs_ci_dupl (cs_ci *A) ;
-int cs_ci_entry (cs_ci *T, int i, int j, double _Complex x) ;
-int cs_ci_lusol (int order, const cs_ci *A, double _Complex *b, double tol) ;
-int cs_ci_gaxpy (const cs_ci *A, const double _Complex *x, double _Complex *y) ;
+int cs_ci_entry (cs_ci *T, int i, int j, cs_complex_t x) ;
+int cs_ci_lusol (int order, const cs_ci *A, cs_complex_t *b, double tol) ;
+int cs_ci_gaxpy (const cs_ci *A, const cs_complex_t *x, cs_complex_t *y) ;
 cs_ci *cs_ci_multiply (const cs_ci *A, const cs_ci *B) ;
-int cs_ci_qrsol (int order, const cs_ci *A, double _Complex *b) ;
+int cs_ci_qrsol (int order, const cs_ci *A, cs_complex_t *b) ;
 cs_ci *cs_ci_transpose (const cs_ci *A, int values) ;
 cs_ci *cs_ci_compress (const cs_ci *T) ;
 double cs_ci_norm (const cs_ci *A) ;
@@ -355,7 +365,7 @@
     cs_ci *L ;	    /* L for LU and Cholesky, V for QR */
     cs_ci *U ;	    /* U for LU, r for QR, not used for Cholesky */
     int *pinv ;	    /* partial pivoting for LU */
-    double _Complex *B ;	    /* beta [0..n-1] for QR */
+    cs_complex_t *B ;	    /* beta [0..n-1] for QR */
 } cs_cin ;
 
 typedef struct cs_ci_dmperm_results    /* cs_ci_dmperm or cs_ci_scc output */
@@ -374,23 +384,23 @@
 cs_cid *cs_ci_dmperm (const cs_ci *A, int seed) ;
 int cs_ci_droptol (cs_ci *A, double tol) ;
 int cs_ci_dropzeros (cs_ci *A) ;
-int cs_ci_happly (const cs_ci *V, int i, double _Complex beta,
-    double _Complex *x) ;
-int cs_ci_ipvec (const int *p, const double _Complex *b,
-    double _Complex *x, int n) ;
-int cs_ci_lsolve (const cs_ci *L, double _Complex *x) ;
-int cs_ci_ltsolve (const cs_ci *L, double _Complex *x) ;
+int cs_ci_happly (const cs_ci *V, int i, cs_complex_t beta,
+    cs_complex_t *x) ;
+int cs_ci_ipvec (const int *p, const cs_complex_t *b,
+    cs_complex_t *x, int n) ;
+int cs_ci_lsolve (const cs_ci *L, cs_complex_t *x) ;
+int cs_ci_ltsolve (const cs_ci *L, cs_complex_t *x) ;
 cs_cin *cs_ci_lu (const cs_ci *A, const cs_cis *S, double tol) ;
 cs_ci *cs_ci_permute (const cs_ci *A, const int *p, const int *q, int values) ;
 int *cs_ci_pinv (const int *p, int n) ;
-int cs_ci_pvec (const int *p, const double _Complex *b,
-    double _Complex *x, int n) ;
+int cs_ci_pvec (const int *p, const cs_complex_t *b,
+    cs_complex_t *x, int n) ;
 cs_cin *cs_ci_qr (const cs_ci *A, const cs_cis *S) ;
 cs_cis *cs_ci_schol (int order, const cs_ci *A) ;
 cs_cis *cs_ci_sqr (int order, const cs_ci *A, int qr) ;
 cs_ci *cs_ci_symperm (const cs_ci *A, const int *pinv, int values) ;
-int cs_ci_usolve (const cs_ci *U, double _Complex *x) ;
-int cs_ci_utsolve (const cs_ci *U, double _Complex *x) ;
+int cs_ci_usolve (const cs_ci *U, cs_complex_t *x) ;
+int cs_ci_utsolve (const cs_ci *U, cs_complex_t *x) ;
 int cs_ci_updown (cs_ci *L, int sigma, const cs_ci *C, const int *parent) ;
 
 /* utilities */
@@ -406,21 +416,20 @@
 int cs_ci_dfs (int j, cs_ci *G, int top, int *xi, int *pstack,
     const int *pinv) ;
 int *cs_ci_etree (const cs_ci *A, int ata) ;
-int cs_ci_fkeep (cs_ci *A, int (*fkeep) (int, int, double _Complex, void *),
+int cs_ci_fkeep (cs_ci *A, int (*fkeep) (int, int, cs_complex_t, void *),
     void *other) ;
-double _Complex cs_ci_house (double _Complex *x, double _Complex *beta, int n) ;
 int *cs_ci_maxtrans (const cs_ci *A, int seed) ;
 int *cs_ci_post (const int *parent, int n) ;
 cs_cid *cs_ci_scc (cs_ci *A) ;
-int cs_ci_scatter (const cs_ci *A, int j, double _Complex beta, int *w, 
-    double _Complex *x, int mark,cs_ci *C, int nz) ;
+int cs_ci_scatter (const cs_ci *A, int j, cs_complex_t beta, int *w, 
+    cs_complex_t *x, int mark,cs_ci *C, int nz) ;
 int cs_ci_tdfs (int j, int k, int *head, const int *next, int *post,
     int *stack) ;
 int cs_ci_leaf (int i, int j, const int *first, int *maxfirst, int *prevleaf,
     int *ancestor, int *jleaf) ;
 int cs_ci_reach (cs_ci *G, const cs_ci *B, int k, int *xi, const int *pinv) ;
 int cs_ci_spsolve (cs_ci *L, const cs_ci *B, int k, int *xi, 
-    double _Complex *x, const int *pinv, int lo) ;
+    cs_complex_t *x, const int *pinv, int lo) ;
 int cs_ci_ereach (const cs_ci *A, int k, const int *parent, int *s, int *w) ;
 int *cs_ci_randperm (int n, int seed) ;
 
@@ -445,21 +454,21 @@
     UF_long n ;	    /* number of columns */
     UF_long *p ;    /* column pointers (size n+1) or col indlces (size nzmax) */
     UF_long *i ;    /* row indices, size nzmax */
-    double _Complex *x ;    /* numerical values, size nzmax */
+    cs_complex_t *x ;    /* numerical values, size nzmax */
     UF_long nz ;    /* # of entries in triplet matrix, -1 for compressed-col */
 } cs_cl ;
 
-cs_cl *cs_cl_add (const cs_cl *A, const cs_cl *B, double _Complex alpha,
-    double _Complex beta) ;
-UF_long cs_cl_cholsol (UF_long order, const cs_cl *A, double _Complex *b) ;
+cs_cl *cs_cl_add (const cs_cl *A, const cs_cl *B, cs_complex_t alpha,
+    cs_complex_t beta) ;
+UF_long cs_cl_cholsol (UF_long order, const cs_cl *A, cs_complex_t *b) ;
 UF_long cs_cl_dupl (cs_cl *A) ;
-UF_long cs_cl_entry (cs_cl *T, UF_long i, UF_long j, double _Complex x) ;
-UF_long cs_cl_lusol (UF_long order, const cs_cl *A, double _Complex *b,
+UF_long cs_cl_entry (cs_cl *T, UF_long i, UF_long j, cs_complex_t x) ;
+UF_long cs_cl_lusol (UF_long order, const cs_cl *A, cs_complex_t *b,
     double tol) ;
-UF_long cs_cl_gaxpy (const cs_cl *A, const double _Complex *x,
-    double _Complex *y) ;
+UF_long cs_cl_gaxpy (const cs_cl *A, const cs_complex_t *x,
+    cs_complex_t *y) ;
 cs_cl *cs_cl_multiply (const cs_cl *A, const cs_cl *B) ;
-UF_long cs_cl_qrsol (UF_long order, const cs_cl *A, double _Complex *b) ;
+UF_long cs_cl_qrsol (UF_long order, const cs_cl *A, cs_complex_t *b) ;
 cs_cl *cs_cl_transpose (const cs_cl *A, UF_long values) ;
 cs_cl *cs_cl_compress (const cs_cl *T) ;
 double cs_cl_norm (const cs_cl *A) ;
@@ -495,7 +504,7 @@
     cs_cl *L ;		/* L for LU and Cholesky, V for QR */
     cs_cl *U ;		/* U for LU, r for QR, not used for Cholesky */
     UF_long *pinv ;	/* partial pivoting for LU */
-    double _Complex *B ;	    /* beta [0..n-1] for QR */
+    cs_complex_t *B ;	    /* beta [0..n-1] for QR */
 } cs_cln ;
 
 typedef struct cs_cl_dmperm_results    /* cs_cl_dmperm or cs_cl_scc output */
@@ -514,24 +523,24 @@
 cs_cld *cs_cl_dmperm (const cs_cl *A, UF_long seed) ;
 UF_long cs_cl_droptol (cs_cl *A, double tol) ;
 UF_long cs_cl_dropzeros (cs_cl *A) ;
-UF_long cs_cl_happly (const cs_cl *V, UF_long i, double _Complex beta,
-    double _Complex *x) ;
-UF_long cs_cl_ipvec (const UF_long *p, const double _Complex *b,
-    double _Complex *x, UF_long n) ;
-UF_long cs_cl_lsolve (const cs_cl *L, double _Complex *x) ;
-UF_long cs_cl_ltsolve (const cs_cl *L, double _Complex *x) ;
+UF_long cs_cl_happly (const cs_cl *V, UF_long i, cs_complex_t beta,
+    cs_complex_t *x) ;
+UF_long cs_cl_ipvec (const UF_long *p, const cs_complex_t *b,
+    cs_complex_t *x, UF_long n) ;
+UF_long cs_cl_lsolve (const cs_cl *L, cs_complex_t *x) ;
+UF_long cs_cl_ltsolve (const cs_cl *L, cs_complex_t *x) ;
 cs_cln *cs_cl_lu (const cs_cl *A, const cs_cls *S, double tol) ;
 cs_cl *cs_cl_permute (const cs_cl *A, const UF_long *p, const UF_long *q,
     UF_long values) ;
 UF_long *cs_cl_pinv (const UF_long *p, UF_long n) ;
-UF_long cs_cl_pvec (const UF_long *p, const double _Complex *b,
-    double _Complex *x, UF_long n) ;
+UF_long cs_cl_pvec (const UF_long *p, const cs_complex_t *b,
+    cs_complex_t *x, UF_long n) ;
 cs_cln *cs_cl_qr (const cs_cl *A, const cs_cls *S) ;
 cs_cls *cs_cl_schol (UF_long order, const cs_cl *A) ;
 cs_cls *cs_cl_sqr (UF_long order, const cs_cl *A, UF_long qr) ;
 cs_cl *cs_cl_symperm (const cs_cl *A, const UF_long *pinv, UF_long values) ;
-UF_long cs_cl_usolve (const cs_cl *U, double _Complex *x) ;
-UF_long cs_cl_utsolve (const cs_cl *U, double _Complex *x) ;
+UF_long cs_cl_usolve (const cs_cl *U, cs_complex_t *x) ;
+UF_long cs_cl_utsolve (const cs_cl *U, cs_complex_t *x) ;
 UF_long cs_cl_updown (cs_cl *L, UF_long sigma, const cs_cl *C,
     const UF_long *parent) ;
 
@@ -549,14 +558,12 @@
     UF_long *pstack, const UF_long *pinv) ;
 UF_long *cs_cl_etree (const cs_cl *A, UF_long ata) ;
 UF_long cs_cl_fkeep (cs_cl *A,
-    UF_long (*fkeep) (UF_long, UF_long, double _Complex, void *), void *other) ;
-double _Complex cs_cl_house (double _Complex *x, double _Complex *beta,
-    UF_long n) ;
+    UF_long (*fkeep) (UF_long, UF_long, cs_complex_t, void *), void *other) ;
 UF_long *cs_cl_maxtrans (const cs_cl *A, UF_long seed) ;
 UF_long *cs_cl_post (const UF_long *parent, UF_long n) ;
 cs_cld *cs_cl_scc (cs_cl *A) ;
-UF_long cs_cl_scatter (const cs_cl *A, UF_long j, double _Complex beta,
-    UF_long *w, double _Complex *x, UF_long mark,cs_cl *C, UF_long nz) ;
+UF_long cs_cl_scatter (const cs_cl *A, UF_long j, cs_complex_t beta,
+    UF_long *w, cs_complex_t *x, UF_long mark,cs_cl *C, UF_long nz) ;
 UF_long cs_cl_tdfs (UF_long j, UF_long k, UF_long *head, const UF_long *next,
     UF_long *post, UF_long *stack) ;
 UF_long cs_cl_leaf (UF_long i, UF_long j, const UF_long *first,
@@ -564,7 +571,7 @@
 UF_long cs_cl_reach (cs_cl *G, const cs_cl *B, UF_long k, UF_long *xi,
     const UF_long *pinv) ;
 UF_long cs_cl_spsolve (cs_cl *L, const cs_cl *B, UF_long k, UF_long *xi, 
-    double _Complex *x, const UF_long *pinv, UF_long lo) ;
+    cs_complex_t *x, const UF_long *pinv, UF_long lo) ;
 UF_long cs_cl_ereach (const cs_cl *A, UF_long k, const UF_long *parent,
     UF_long *s, UF_long *w) ;
 UF_long *cs_cl_randperm (UF_long n, UF_long seed) ;
@@ -586,7 +593,7 @@
 #define CS_INT_MAX UF_long_max
 #define CS_ID UF_long_id
 #ifdef CS_COMPLEX
-#define CS_ENTRY double _Complex
+#define CS_ENTRY cs_complex_t
 #define CS_NAME(nm) cs_cl ## nm
 #else
 #define CS_ENTRY double
@@ -597,7 +604,7 @@
 #define CS_INT_MAX INT_MAX
 #define CS_ID "%d"
 #ifdef CS_COMPLEX
-#define CS_ENTRY double _Complex
+#define CS_ENTRY cs_complex_t
 #define CS_NAME(nm) cs_ci ## nm
 #else
 #define CS_ENTRY double
@@ -722,4 +729,9 @@
 #ifdef __cplusplus
 }
 #endif
+
+cs_complex_t cs_ci_house (cs_complex_t *x, cs_complex_t *beta, int n) ;
+cs_complex_t cs_cl_house (cs_complex_t *x, cs_complex_t *beta,
+    UF_long n) ;
+
 #endif
diff -ur SuiteSparse/CXSparse/Source/cs_add.c SuiteSparse-mod/CXSparse/Source/cs_add.c
--- SuiteSparse/CXSparse/Source/cs_add.c	2006-12-07 06:52:30.000000000 +0100
+++ SuiteSparse-mod/CXSparse/Source/cs_add.c	2007-02-12 09:58:07.622002300 +0100
@@ -8,9 +8,9 @@
     if (!CS_CSC (A) || !CS_CSC (B)) return (NULL) ;	    /* check inputs */
     m = A->m ; anz = A->p [A->n] ;
     n = B->n ; Bp = B->p ; Bx = B->x ; bnz = Bp [n] ;
-    w = cs_calloc (m, sizeof (CS_INT)) ;			    /* get workspace */
+    w = (CS_INT*)cs_calloc (m, sizeof (CS_INT)) ;			    /* get workspace */
     values = (A->x != NULL) && (Bx != NULL) ;
-    x = values ? cs_malloc (m, sizeof (CS_ENTRY)) : NULL ;    /* get workspace */
+    x = values ? (CS_ENTRY*)cs_malloc (m, sizeof (CS_ENTRY)) : NULL ;    /* get workspace */
     C = cs_spalloc (m, n, anz + bnz, values, 0) ;	    /* allocate result*/
     if (!C || !w || (values && !x)) return (cs_done (C, w, x, 0)) ;
     Cp = C->p ; Ci = C->i ; Cx = C->x ;
diff -ur SuiteSparse/CXSparse/Source/cs_amd.c SuiteSparse-mod/CXSparse/Source/cs_amd.c
--- SuiteSparse/CXSparse/Source/cs_amd.c	2006-12-07 06:52:30.000000000 +0100
+++ SuiteSparse-mod/CXSparse/Source/cs_amd.c	2007-02-12 09:58:07.622002300 +0100
@@ -59,8 +59,8 @@
     cs_fkeep (C, &cs_diag, NULL) ;	    /* drop diagonal entries */
     Cp = C->p ;
     cnz = Cp [n] ;
-    P = cs_malloc (n+1, sizeof (CS_INT)) ;	    /* allocate result */
-    W = cs_malloc (8*(n+1), sizeof (CS_INT)) ; /* get workspace */
+    P = (CS_INT*)cs_malloc (n+1, sizeof (CS_INT)) ;	    /* allocate result */
+    W = (CS_INT*)cs_malloc (8*(n+1), sizeof (CS_INT)) ; /* get workspace */
     t = cnz + cnz/5 + 2*n ;		    /* add elbow room to C */
     if (!P || !W || !cs_sprealloc (C, t)) return (cs_idone (P, C, W, 0)) ;
     len  = W           ; nv     = W +   (n+1) ; next   = W + 2*(n+1) ;
diff -ur SuiteSparse/CXSparse/Source/cs_chol.c SuiteSparse-mod/CXSparse/Source/cs_chol.c
--- SuiteSparse/CXSparse/Source/cs_chol.c	2006-12-07 06:52:30.000000000 +0100
+++ SuiteSparse-mod/CXSparse/Source/cs_chol.c	2007-02-12 09:58:07.637628100 +0100
@@ -8,9 +8,9 @@
     csn *N ;
     if (!CS_CSC (A) || !S || !S->cp || !S->parent) return (NULL) ;
     n = A->n ;
-    N = cs_calloc (1, sizeof (csn)) ;	    /* allocate result */
-    c = cs_malloc (2*n, sizeof (CS_INT)) ;	    /* get CS_INT workspace */
-    x = cs_malloc (n, sizeof (CS_ENTRY)) ;    /* get CS_ENTRY workspace */
+    N = (csn*)cs_calloc (1, sizeof (csn)) ;	    /* allocate result */
+    c = (CS_INT*)cs_malloc (2*n, sizeof (CS_INT)) ;	    /* get CS_INT workspace */
+    x = (CS_ENTRY*)cs_malloc (n, sizeof (CS_ENTRY)) ;    /* get CS_ENTRY workspace */
     cp = S->cp ; pinv = S->pinv ; parent = S->parent ;
     C = pinv ? cs_symperm (A, pinv, 1) : ((cs *) A) ;
     E = pinv ? C : NULL ;	    /* E is alias for A, or a copy E=A(p,p) */
diff -ur SuiteSparse/CXSparse/Source/cs_cholsol.c SuiteSparse-mod/CXSparse/Source/cs_cholsol.c
--- SuiteSparse/CXSparse/Source/cs_cholsol.c	2006-12-07 06:52:30.000000000 +0100
+++ SuiteSparse-mod/CXSparse/Source/cs_cholsol.c	2007-02-12 09:58:07.637628100 +0100
@@ -10,7 +10,7 @@
     n = A->n ;
     S = cs_schol (order, A) ;		    /* ordering and symbolic analysis */
     N = cs_chol (A, S) ;		    /* numeric Cholesky factorization */
-    x = cs_malloc (n, sizeof (CS_ENTRY)) ;    /* get workspace */
+    x = (CS_ENTRY*)cs_malloc (n, sizeof (CS_ENTRY)) ;    /* get workspace */
     ok = (S && N && x) ;
     if (ok)
     {
diff -ur SuiteSparse/CXSparse/Source/cs_compress.c SuiteSparse-mod/CXSparse/Source/cs_compress.c
--- SuiteSparse/CXSparse/Source/cs_compress.c	2006-12-07 06:52:30.000000000 +0100
+++ SuiteSparse-mod/CXSparse/Source/cs_compress.c	2007-02-12 09:58:07.856389300 +0100
@@ -8,7 +8,7 @@
     if (!CS_TRIPLET (T)) return (NULL) ;		/* check inputs */
     m = T->m ; n = T->n ; Ti = T->i ; Tj = T->p ; Tx = T->x ; nz = T->nz ;
     C = cs_spalloc (m, n, nz, Tx != NULL, 0) ;		/* allocate result */
-    w = cs_calloc (n, sizeof (CS_INT)) ;			/* get workspace */
+    w = (CS_INT*)cs_calloc (n, sizeof (CS_INT)) ;			/* get workspace */
     if (!C || !w) return (cs_done (C, w, NULL, 0)) ;	/* out of memory */
     Cp = C->p ; Ci = C->i ; Cx = C->x ;
     for (k = 0 ; k < nz ; k++) w [Tj [k]]++ ;		/* column counts */
diff -ur SuiteSparse/CXSparse/Source/cs_convert.c SuiteSparse-mod/CXSparse/Source/cs_convert.c
--- SuiteSparse/CXSparse/Source/cs_convert.c	2006-05-02 08:59:14.000000000 +0200
+++ SuiteSparse-mod/CXSparse/Source/cs_convert.c	2007-02-09 14:40:04.000000000 +0100
@@ -6,7 +6,7 @@
 {
     cs_di *C ;
     int n, triplet, nn, p, nz, *Ap, *Ai, *Cp, *Ci ;
-    double _Complex *Ax ;
+    cs_complex_t *Ax ;
     double *Cx ;
     if (!A || !A->x) return (NULL) ;	/* return if A NULL or pattern-only */
     n = A->n ; Ap = A->p ; Ai = A->i ; Ax = A->x ;
@@ -30,7 +30,7 @@
     cs_ci *C ;
     int n, triplet, nn, p, nz, *Ap, *Ai, *Cp, *Ci ;
     double *Ax ;
-    double _Complex *Cx ;
+    cs_complex_t *Cx ;
     if (!A || !A->x) return (NULL) ;	/* return if A NULL or pattern-only */
     n = A->n ; Ap = A->p ; Ai = A->i ; Ax = A->x ;
     triplet = (A->nz >= 0) ;		/* true if A is a triplet matrix */
@@ -52,7 +52,7 @@
 {
     cs_dl *C ;
     UF_long n, triplet, nn, p, nz, *Ap, *Ai, *Cp, *Ci ;
-    double _Complex *Ax ;
+    cs_complex_t *Ax ;
     double *Cx ;
     if (!A || !A->x) return (NULL) ;	/* return if A NULL or pattern-only */
     n = A->n ; Ap = A->p ; Ai = A->i ; Ax = A->x ;
@@ -76,7 +76,7 @@
     cs_cl *C ;
     UF_long n, triplet, nn, p, nz, *Ap, *Ai, *Cp, *Ci ;
     double *Ax ;
-    double _Complex *Cx ;
+    cs_complex_t *Cx ;
     if (!A || !A->x) return (NULL) ;	/* return if A NULL or pattern-only */
     n = A->n ; Ap = A->p ; Ai = A->i ; Ax = A->x ;
     triplet = (A->nz >= 0) ;		/* true if A is a triplet matrix */
diff -ur SuiteSparse/CXSparse/Source/cs_counts.c SuiteSparse-mod/CXSparse/Source/cs_counts.c
--- SuiteSparse/CXSparse/Source/cs_counts.c	2006-12-07 06:52:30.000000000 +0100
+++ SuiteSparse-mod/CXSparse/Source/cs_counts.c	2007-02-12 09:58:07.653253900 +0100
@@ -22,8 +22,8 @@
     if (!CS_CSC (A) || !parent || !post) return (NULL) ;    /* check inputs */
     m = A->m ; n = A->n ;
     s = 4*n + (ata ? (n+m+1) : 0) ;
-    delta = colcount = cs_malloc (n, sizeof (CS_INT)) ;	/* allocate result */
-    w = cs_malloc (s, sizeof (CS_INT)) ;			/* get workspace */
+    delta = colcount = (CS_INT*)cs_malloc (n, sizeof (CS_INT)) ;	/* allocate result */
+    w = (CS_INT*)cs_malloc (s, sizeof (CS_INT)) ;			/* get workspace */
     AT = cs_transpose (A, 0) ;				/* AT = A' */
     if (!AT || !colcount || !w) return (cs_idone (colcount, AT, w, 0)) ;
     ancestor = w ; maxfirst = w+n ; prevleaf = w+2*n ; first = w+3*n ;
diff -ur SuiteSparse/CXSparse/Source/cs_cumsum.c SuiteSparse-mod/CXSparse/Source/cs_cumsum.c
--- SuiteSparse/CXSparse/Source/cs_cumsum.c	2006-12-07 06:52:30.000000000 +0100
+++ SuiteSparse-mod/CXSparse/Source/cs_cumsum.c	2007-02-12 09:58:07.653253900 +0100
@@ -3,7 +3,7 @@
 double cs_cumsum (CS_INT *p, CS_INT *c, CS_INT n)
 {
     CS_INT i, nz = 0 ;
-    CS_ENTRY nz2 = 0 ;
+    double nz2 = 0 ;
     if (!p || !c) return (-1) ;	    /* check inputs */
     for (i = 0 ; i < n ; i++)
     {
diff -ur SuiteSparse/CXSparse/Source/cs_dropzeros.c SuiteSparse-mod/CXSparse/Source/cs_dropzeros.c
--- SuiteSparse/CXSparse/Source/cs_dropzeros.c	2006-12-07 06:52:30.000000000 +0100
+++ SuiteSparse-mod/CXSparse/Source/cs_dropzeros.c	2007-02-12 09:58:07.684505500 +0100
@@ -1,7 +1,7 @@
 #include "cs.h"
 static CS_INT cs_nonzero (CS_INT i, CS_INT j, CS_ENTRY aij, void *other)
 {
-    return (aij != 0) ;
+    return (aij != 0.) ;
 }
 CS_INT cs_dropzeros (cs *A)
 {
diff -ur SuiteSparse/CXSparse/Source/cs_dupl.c SuiteSparse-mod/CXSparse/Source/cs_dupl.c
--- SuiteSparse/CXSparse/Source/cs_dupl.c	2006-12-07 06:52:30.000000000 +0100
+++ SuiteSparse-mod/CXSparse/Source/cs_dupl.c	2007-02-12 09:58:07.684505500 +0100
@@ -6,7 +6,7 @@
     CS_ENTRY *Ax ;
     if (!CS_CSC (A)) return (0) ;		/* check inputs */
     m = A->m ; n = A->n ; Ap = A->p ; Ai = A->i ; Ax = A->x ;
-    w = cs_malloc (m, sizeof (CS_INT)) ;		/* get workspace */
+    w = (CS_INT*)cs_malloc (m, sizeof (CS_INT)) ;		/* get workspace */
     if (!w) return (0) ;			/* out of memory */
     for (i = 0 ; i < m ; i++) w [i] = -1 ;	/* row i not yet seen */
     for (j = 0 ; j < n ; j++)
diff -ur SuiteSparse/CXSparse/Source/cs_etree.c SuiteSparse-mod/CXSparse/Source/cs_etree.c
--- SuiteSparse/CXSparse/Source/cs_etree.c	2006-12-07 06:52:30.000000000 +0100
+++ SuiteSparse-mod/CXSparse/Source/cs_etree.c	2007-02-12 09:58:07.700131300 +0100
@@ -5,8 +5,8 @@
     CS_INT i, k, p, m, n, inext, *Ap, *Ai, *w, *parent, *ancestor, *prev ;
     if (!CS_CSC (A)) return (NULL) ;	    /* check inputs */
     m = A->m ; n = A->n ; Ap = A->p ; Ai = A->i ;
-    parent = cs_malloc (n, sizeof (CS_INT)) ;		/* allocate result */
-    w = cs_malloc (n + (ata ? m : 0), sizeof (CS_INT)) ;	/* get workspace */
+    parent = (CS_INT*)cs_malloc (n, sizeof (CS_INT)) ;		/* allocate result */
+    w = (CS_INT*)cs_malloc (n + (ata ? m : 0), sizeof (CS_INT)) ;	/* get workspace */
     if (!w || !parent) return (cs_idone (parent, NULL, w, 0)) ;
     ancestor = w ; prev = w + n ;
     if (ata) for (i = 0 ; i < m ; i++) prev [i] = -1 ;
diff -ur SuiteSparse/CXSparse/Source/cs_house.c SuiteSparse-mod/CXSparse/Source/cs_house.c
--- SuiteSparse/CXSparse/Source/cs_house.c	2006-02-18 07:04:52.000000000 +0100
+++ SuiteSparse-mod/CXSparse/Source/cs_house.c	2007-02-09 15:38:18.000000000 +0100
@@ -9,14 +9,14 @@
     if (!x || !beta) return (-1) ;	    /* check inputs */
     for (i = 0 ; i < n ; i++) s += x [i] * CS_CONJ (x [i]) ;
     s = sqrt (s) ;
-    if (s == 0)
+    if (s == 0.)
     {
 	(*beta) = 0 ;
 	x [0] = 1 ;
     }
     else
     {
-	if (x [0] != 0)
+	if (x [0] != 0.)
 	{
 	    s *= x [0] / CS_ABS (x [0]) ;
 	}
diff -ur SuiteSparse/CXSparse/Source/cs_lu.c SuiteSparse-mod/CXSparse/Source/cs_lu.c
--- SuiteSparse/CXSparse/Source/cs_lu.c	2006-12-07 06:52:30.000000000 +0100
+++ SuiteSparse-mod/CXSparse/Source/cs_lu.c	2007-02-12 09:58:07.731382900 +0100
@@ -10,13 +10,13 @@
     if (!CS_CSC (A) || !S) return (NULL) ;	    /* check inputs */
     n = A->n ;
     q = S->q ; lnz = S->lnz ; unz = S->unz ;
-    x = cs_malloc (n, sizeof (CS_ENTRY)) ;	    /* get CS_ENTRY workspace */
-    xi = cs_malloc (2*n, sizeof (CS_INT)) ;	    /* get CS_INT workspace */
-    N = cs_calloc (1, sizeof (csn)) ;		    /* allocate result */
+    x = (CS_ENTRY*)cs_malloc (n, sizeof (CS_ENTRY)) ;	    /* get CS_ENTRY workspace */
+    xi = (CS_INT*)cs_malloc (2*n, sizeof (CS_INT)) ;	    /* get CS_INT workspace */
+    N = (csn*)cs_calloc (1, sizeof (csn)) ;		    /* allocate result */
     if (!x || !xi || !N) return (cs_ndone (N, NULL, xi, x, 0)) ;
     N->L = L = cs_spalloc (n, n, lnz, 1, 0) ;	    /* allocate result L */
     N->U = U = cs_spalloc (n, n, unz, 1, 0) ;	    /* allocate result U */
-    N->pinv = pinv = cs_malloc (n, sizeof (CS_INT)) ;  /* allocate result pinv */
+    N->pinv = pinv = (CS_INT*)cs_malloc (n, sizeof (CS_INT)) ;  /* allocate result pinv */
     if (!L || !U || !pinv) return (cs_ndone (N, NULL, xi, x, 0)) ;
     Lp = L->p ; Up = U->p ;
     for (i = 0 ; i < n ; i++) x [i] = 0 ;	    /* clear workspace */
diff -ur SuiteSparse/CXSparse/Source/cs_lusol.c SuiteSparse-mod/CXSparse/Source/cs_lusol.c
--- SuiteSparse/CXSparse/Source/cs_lusol.c	2006-12-07 06:52:30.000000000 +0100
+++ SuiteSparse-mod/CXSparse/Source/cs_lusol.c	2007-02-12 09:58:07.747008700 +0100
@@ -10,7 +10,7 @@
     n = A->n ;
     S = cs_sqr (order, A, 0) ;		    /* ordering and symbolic analysis */
     N = cs_lu (A, S, tol) ;		    /* numeric LU factorization */
-    x = cs_malloc (n, sizeof (CS_ENTRY)) ;    /* get workspace */
+    x = (CS_ENTRY*)cs_malloc (n, sizeof (CS_ENTRY)) ;    /* get workspace */
     ok = (S && N && x) ;
     if (ok)
     {
diff -ur SuiteSparse/CXSparse/Source/cs_maxtrans.c SuiteSparse-mod/CXSparse/Source/cs_maxtrans.c
--- SuiteSparse/CXSparse/Source/cs_maxtrans.c	2006-12-07 06:52:30.000000000 +0100
+++ SuiteSparse-mod/CXSparse/Source/cs_maxtrans.c	2007-02-12 09:58:07.747008700 +0100
@@ -48,7 +48,7 @@
     cs *C ;
     if (!CS_CSC (A)) return (NULL) ;		    /* check inputs */
     n = A->n ; m = A->m ; Ap = A->p ; Ai = A->i ;
-    w = jimatch = cs_calloc (m+n, sizeof (CS_INT)) ;   /* allocate result */
+    w = jimatch = (CS_INT*)cs_calloc (m+n, sizeof (CS_INT)) ;   /* allocate result */
     if (!jimatch) return (NULL) ;
     for (k = 0, j = 0 ; j < n ; j++)	/* count nonempty rows and columns */
     {
@@ -74,7 +74,7 @@
     n = C->n ; m = C->m ; Cp = C->p ;
     jmatch = (m2 < n2) ? jimatch + n : jimatch ;
     imatch = (m2 < n2) ? jimatch : jimatch + m ;
-    w = cs_malloc (5*n, sizeof (CS_INT)) ;		    /* get workspace */
+    w = (CS_INT*)cs_malloc (5*n, sizeof (CS_INT)) ;		    /* get workspace */
     if (!w) return (cs_idone (jimatch, (m2 < n2) ? C : NULL, w, 0)) ;
     cheap = w + n ; js = w + 2*n ; is = w + 3*n ; ps = w + 4*n ;
     for (j = 0 ; j < n ; j++) cheap [j] = Cp [j] ;  /* for cheap assignment */
diff -ur SuiteSparse/CXSparse/Source/cs_multiply.c SuiteSparse-mod/CXSparse/Source/cs_multiply.c
--- SuiteSparse/CXSparse/Source/cs_multiply.c	2006-12-07 06:52:30.000000000 +0100
+++ SuiteSparse-mod/CXSparse/Source/cs_multiply.c	2007-02-12 09:58:07.762634500 +0100
@@ -8,9 +8,9 @@
     if (!CS_CSC (A) || !CS_CSC (B)) return (NULL) ;	 /* check inputs */
     m = A->m ; anz = A->p [A->n] ;
     n = B->n ; Bp = B->p ; Bi = B->i ; Bx = B->x ; bnz = Bp [n] ;
-    w = cs_calloc (m, sizeof (CS_INT)) ;			 /* get workspace */
+    w = (CS_INT*)cs_calloc (m, sizeof (CS_INT)) ;			 /* get workspace */
     values = (A->x != NULL) && (Bx != NULL) ;
-    x = values ? cs_malloc (m, sizeof (CS_ENTRY)) : NULL ; /* get workspace */
+    x = values ? (CS_ENTRY*)cs_malloc (m, sizeof (CS_ENTRY)) : NULL ; /* get workspace */
     C = cs_spalloc (m, n, anz + bnz, values, 0) ;	 /* allocate result */
     if (!C || !w || (values && !x)) return (cs_done (C, w, x, 0)) ;
     Cp = C->p ;
diff -ur SuiteSparse/CXSparse/Source/cs_pinv.c SuiteSparse-mod/CXSparse/Source/cs_pinv.c
--- SuiteSparse/CXSparse/Source/cs_pinv.c	2006-12-07 06:52:30.000000000 +0100
+++ SuiteSparse-mod/CXSparse/Source/cs_pinv.c	2007-02-12 09:58:07.778260300 +0100
@@ -4,7 +4,7 @@
 {
     CS_INT k, *pinv ;
     if (!p) return (NULL) ;			/* p = NULL denotes identity */
-    pinv = cs_malloc (n, sizeof (CS_INT)) ;	/* allocate result */
+    pinv = (CS_INT*)cs_malloc (n, sizeof (CS_INT)) ;	/* allocate result */
     if (!pinv) return (NULL) ;			/* out of memory */
     for (k = 0 ; k < n ; k++) pinv [p [k]] = k ;/* invert the permutation */
     return (pinv) ;				/* return result */
diff -ur SuiteSparse/CXSparse/Source/cs_post.c SuiteSparse-mod/CXSparse/Source/cs_post.c
--- SuiteSparse/CXSparse/Source/cs_post.c	2006-12-07 06:52:30.000000000 +0100
+++ SuiteSparse-mod/CXSparse/Source/cs_post.c	2007-02-12 09:58:07.778260300 +0100
@@ -4,8 +4,8 @@
 {
     CS_INT j, k = 0, *post, *w, *head, *next, *stack ;
     if (!parent) return (NULL) ;			/* check inputs */
-    post = cs_malloc (n, sizeof (CS_INT)) ;		/* allocate result */
-    w = cs_malloc (3*n, sizeof (CS_INT)) ;			/* get workspace */
+    post = (CS_INT*)cs_malloc (n, sizeof (CS_INT)) ;		/* allocate result */
+    w = (CS_INT*)cs_malloc (3*n, sizeof (CS_INT)) ;			/* get workspace */
     if (!w || !post) return (cs_idone (post, NULL, w, 0)) ;
     head = w ; next = w + n ; stack = w + 2*n ;
     for (j = 0 ; j < n ; j++) head [j] = -1 ;		/* empty linked lists */
diff -ur SuiteSparse/CXSparse/Source/cs_qr.c SuiteSparse-mod/CXSparse/Source/cs_qr.c
--- SuiteSparse/CXSparse/Source/cs_qr.c	2006-12-07 06:52:30.000000000 +0100
+++ SuiteSparse-mod/CXSparse/Source/cs_qr.c	2007-02-12 09:58:07.793886100 +0100
@@ -11,15 +11,15 @@
     m = A->m ; n = A->n ; Ap = A->p ; Ai = A->i ; Ax = A->x ;
     q = S->q ; parent = S->parent ; pinv = S->pinv ; m2 = S->m2 ;
     vnz = S->lnz ; rnz = S->unz ; leftmost = S->leftmost ;
-    w = cs_malloc (m2+n, sizeof (CS_INT)) ;	    /* get CS_INT workspace */
-    x = cs_malloc (m2, sizeof (CS_ENTRY)) ;	    /* get CS_ENTRY workspace */
-    N = cs_calloc (1, sizeof (csn)) ;		    /* allocate result */
+    w = (CS_INT*)cs_malloc (m2+n, sizeof (CS_INT)) ;	    /* get CS_INT workspace */
+    x = (CS_ENTRY*)cs_malloc (m2, sizeof (CS_ENTRY)) ;	    /* get CS_ENTRY workspace */
+    N = (csn*)cs_calloc (1, sizeof (csn)) ;		    /* allocate result */
     if (!w || !x || !N) return (cs_ndone (N, NULL, w, x, 0)) ;
     s = w + m2 ;				    /* s is size n */
     for (k = 0 ; k < m2 ; k++) x [k] = 0 ;	    /* clear workspace x */
     N->L = V = cs_spalloc (m2, n, vnz, 1, 0) ;	    /* allocate result V */
     N->U = R = cs_spalloc (m2, n, rnz, 1, 0) ;	    /* allocate result R */
-    N->B = Beta = cs_malloc (n, sizeof (CS_ENTRY)) ;  /* allocate result Beta */
+    N->B = Beta = (CS_ENTRY*)cs_malloc (n, sizeof (CS_ENTRY)) ;  /* allocate result Beta */
     if (!R || !V || !Beta) return (cs_ndone (N, NULL, w, x, 0)) ;
     Rp = R->p ; Ri = R->i ; Rx = R->x ;
     Vp = V->p ; Vi = V->i ; Vx = V->x ;
diff -ur SuiteSparse/CXSparse/Source/cs_qrsol.c SuiteSparse-mod/CXSparse/Source/cs_qrsol.c
--- SuiteSparse/CXSparse/Source/cs_qrsol.c	2006-12-07 06:52:30.000000000 +0100
+++ SuiteSparse-mod/CXSparse/Source/cs_qrsol.c	2007-02-12 09:58:07.809511900 +0100
@@ -14,7 +14,7 @@
     {
 	S = cs_sqr (order, A, 1) ;	    /* ordering and symbolic analysis */
 	N = cs_qr (A, S) ;		    /* numeric QR factorization */
-	x = cs_calloc (S ? S->m2 : 1, sizeof (CS_ENTRY)) ;    /* get workspace */
+	x = (CS_ENTRY*)cs_calloc (S ? S->m2 : 1, sizeof (CS_ENTRY)) ;    /* get workspace */
 	ok = (S && N && x) ;
 	if (ok)
 	{
@@ -32,7 +32,7 @@
 	AT = cs_transpose (A, 1) ;	    /* Ax=b is underdetermined */
 	S = cs_sqr (order, AT, 1) ;	    /* ordering and symbolic analysis */
 	N = cs_qr (AT, S) ;		    /* numeric QR factorization of A' */
-	x = cs_calloc (S ? S->m2 : 1, sizeof (CS_ENTRY)) ;    /* get workspace */
+	x = (CS_ENTRY*)cs_calloc (S ? S->m2 : 1, sizeof (CS_ENTRY)) ;    /* get workspace */
 	ok = (AT && S && N && x) ;
 	if (ok)
 	{
diff -ur SuiteSparse/CXSparse/Source/cs_randperm.c SuiteSparse-mod/CXSparse/Source/cs_randperm.c
--- SuiteSparse/CXSparse/Source/cs_randperm.c	2006-12-07 06:52:30.000000000 +0100
+++ SuiteSparse-mod/CXSparse/Source/cs_randperm.c	2007-02-12 09:58:07.903266700 +0100
@@ -6,7 +6,7 @@
 {
     CS_INT *p, k, j, t ;
     if (seed == 0) return (NULL) ;	/* return p = NULL (identity) */
-    p = cs_malloc (n, sizeof (CS_INT)) ;	/* allocate result */
+    p = (CS_INT*)cs_malloc (n, sizeof (CS_INT)) ;	/* allocate result */
     if (!p) return (NULL) ;		/* out of memory */
     for (k = 0 ; k < n ; k++) p [k] = n-k-1 ;
     if (seed == -1) return (p) ;	/* return reverse permutation */
diff -ur SuiteSparse/CXSparse/Source/cs_scc.c SuiteSparse-mod/CXSparse/Source/cs_scc.c
--- SuiteSparse/CXSparse/Source/cs_scc.c	2006-12-07 06:52:30.000000000 +0100
+++ SuiteSparse-mod/CXSparse/Source/cs_scc.c	2007-02-12 09:58:07.825137700 +0100
@@ -9,7 +9,7 @@
     n = A->n ; Ap = A->p ;
     D = cs_dalloc (n, 0) ;			    /* allocate result */
     AT = cs_transpose (A, 0) ;			    /* AT = A' */
-    xi = cs_malloc (2*n+1, sizeof (CS_INT)) ;	    /* get workspace */
+    xi = (CS_INT*)cs_malloc (2*n+1, sizeof (CS_INT)) ;	    /* get workspace */
     if (!D || !AT || !xi) return (cs_ddone (D, AT, xi, 0)) ;
     Blk = xi ; rcopy = pstack = xi + n ;
     p = D->p ; r = D->r ; ATp = AT->p ;
diff -ur SuiteSparse/CXSparse/Source/cs_schol.c SuiteSparse-mod/CXSparse/Source/cs_schol.c
--- SuiteSparse/CXSparse/Source/cs_schol.c	2006-12-07 06:52:30.000000000 +0100
+++ SuiteSparse-mod/CXSparse/Source/cs_schol.c	2007-02-12 09:58:07.825137700 +0100
@@ -7,7 +7,7 @@
     css *S ;
     if (!CS_CSC (A)) return (NULL) ;	    /* check inputs */
     n = A->n ;
-    S = cs_calloc (1, sizeof (css)) ;	    /* allocate result S */
+    S = (css*)cs_calloc (1, sizeof (css)) ;	    /* allocate result S */
     if (!S) return (NULL) ;		    /* out of memory */
     P = cs_amd (order, A) ;		    /* P = amd(A+A'), or natural */
     S->pinv = cs_pinv (P, n) ;		    /* find inverse permutation */
@@ -19,7 +19,7 @@
     c = cs_counts (C, S->parent, post, 0) ; /* find column counts of chol(C) */
     cs_free (post) ;
     cs_spfree (C) ;
-    S->cp = cs_malloc (n+1, sizeof (CS_INT)) ; /* allocate result S->cp */
+    S->cp = (CS_INT*)cs_malloc (n+1, sizeof (CS_INT)) ; /* allocate result S->cp */
     S->unz = S->lnz = cs_cumsum (S->cp, c, n) ; /* find column pointers for L */
     cs_free (c) ;
     return ((S->lnz >= 0) ? S : cs_sfree (S)) ;
diff -ur SuiteSparse/CXSparse/Source/cs_sqr.c SuiteSparse-mod/CXSparse/Source/cs_sqr.c
--- SuiteSparse/CXSparse/Source/cs_sqr.c	2006-12-07 06:52:30.000000000 +0100
+++ SuiteSparse-mod/CXSparse/Source/cs_sqr.c	2007-02-12 09:58:07.825137700 +0100
@@ -4,9 +4,9 @@
 {
     CS_INT i, k, p, pa, n = A->n, m = A->m, *Ap = A->p, *Ai = A->i, *next, *head,
 	*tail, *nque, *pinv, *leftmost, *w, *parent = S->parent ;
-    S->pinv = pinv = cs_malloc (m+n, sizeof (CS_INT)) ;	    /* allocate pinv, */
-    S->leftmost = leftmost = cs_malloc (m, sizeof (CS_INT)) ;  /* and leftmost */
-    w = cs_malloc (m+3*n, sizeof (CS_INT)) ;   /* get workspace */
+    S->pinv = pinv = (CS_INT*)cs_malloc (m+n, sizeof (CS_INT)) ;	    /* allocate pinv, */
+    S->leftmost = leftmost = (CS_INT*)cs_malloc (m, sizeof (CS_INT)) ;  /* and leftmost */
+    w = (CS_INT*)cs_malloc (m+3*n, sizeof (CS_INT)) ;   /* get workspace */
     if (!pinv || !w || !leftmost)
     {
 	cs_free (w) ;			    /* pinv and leftmost freed later */
@@ -63,7 +63,7 @@
     css *S ;
     if (!CS_CSC (A)) return (NULL) ;	    /* check inputs */
     n = A->n ;
-    S = cs_calloc (1, sizeof (css)) ;	    /* allocate result S */
+    S = (css*)cs_calloc (1, sizeof (css)) ;	    /* allocate result S */
     if (!S) return (NULL) ;		    /* out of memory */
     S->q = cs_amd (order, A) ;		    /* fill-reducing ordering */
     if (order && !S->q) return (cs_sfree (S)) ;
diff -ur SuiteSparse/CXSparse/Source/cs_symperm.c SuiteSparse-mod/CXSparse/Source/cs_symperm.c
--- SuiteSparse/CXSparse/Source/cs_symperm.c	2006-12-07 06:52:30.000000000 +0100
+++ SuiteSparse-mod/CXSparse/Source/cs_symperm.c	2007-02-12 09:58:07.840763500 +0100
@@ -8,7 +8,7 @@
     if (!CS_CSC (A)) return (NULL) ;			/* check inputs */
     n = A->n ; Ap = A->p ; Ai = A->i ; Ax = A->x ;
     C = cs_spalloc (n, n, Ap [n], values && (Ax != NULL), 0) ; /* alloc result*/
-    w = cs_calloc (n, sizeof (CS_INT)) ;			/* get workspace */
+    w = (CS_INT*)cs_calloc (n, sizeof (CS_INT)) ;			/* get workspace */
     if (!C || !w) return (cs_done (C, w, NULL, 0)) ;	/* out of memory */
     Cp = C->p ; Ci = C->i ; Cx = C->x ;
     for (j = 0 ; j < n ; j++)		/* count entries in each column of C */
diff -ur SuiteSparse/CXSparse/Source/cs_transpose.c SuiteSparse-mod/CXSparse/Source/cs_transpose.c
--- SuiteSparse/CXSparse/Source/cs_transpose.c	2006-12-07 06:52:30.000000000 +0100
+++ SuiteSparse-mod/CXSparse/Source/cs_transpose.c	2007-02-12 09:58:07.840763500 +0100
@@ -8,7 +8,7 @@
     if (!CS_CSC (A)) return (NULL) ;	/* check inputs */
     m = A->m ; n = A->n ; Ap = A->p ; Ai = A->i ; Ax = A->x ;
     C = cs_spalloc (n, m, Ap [n], values && Ax, 0) ;	   /* allocate result */
-    w = cs_calloc (m, sizeof (CS_INT)) ;			   /* get workspace */
+    w = (CS_INT*)cs_calloc (m, sizeof (CS_INT)) ;			   /* get workspace */
     if (!C || !w) return (cs_done (C, w, NULL, 0)) ;	   /* out of memory */
     Cp = C->p ; Ci = C->i ; Cx = C->x ;
     for (p = 0 ; p < Ap [n] ; p++) w [Ai [p]]++ ;	   /* row counts */
diff -ur SuiteSparse/CXSparse/Source/cs_updown.c SuiteSparse-mod/CXSparse/Source/cs_updown.c
--- SuiteSparse/CXSparse/Source/cs_updown.c	2006-12-07 06:52:30.000000000 +0100
+++ SuiteSparse-mod/CXSparse/Source/cs_updown.c	2007-02-12 09:58:07.856389300 +0100
@@ -9,7 +9,7 @@
     Lp = L->p ; Li = L->i ; Lx = L->x ; n = L->n ;
     Cp = C->p ; Ci = C->i ; Cx = C->x ;
     if ((p = Cp [0]) >= Cp [1]) return (1) ;	    /* return if C empty */
-    w = cs_malloc (n, sizeof (CS_ENTRY)) ;	    /* get workspace */
+    w = (CS_ENTRY*)cs_malloc (n, sizeof (CS_ENTRY)) ;	    /* get workspace */
     if (!w) return (0) ;			    /* out of memory */
     f = Ci [p] ;
     for ( ; p < Cp [1] ; p++) f = CS_MIN (f, Ci [p]) ;	/* f = min (find (C)) */
@@ -19,11 +19,11 @@
     {
 	p = Lp [j] ;
 	alpha = w [j] / Lx [p] ;		    /* alpha = w(j) / L(j,j) */
-	beta2 = beta*CS_CONJ(beta) + sigma*alpha*CS_CONJ(alpha) ;
+	beta2 = CS_REAL(beta*CS_CONJ(beta) + ((CS_ENTRY)sigma)*alpha*CS_CONJ(alpha)) ;
 	if (beta2 <= 0) break ;			    /* not positive definite */
 	beta2 = sqrt (beta2) ;
 	delta = (sigma > 0) ? (beta / beta2) : (beta2 / beta) ;
-	gamma = sigma * alpha / (beta2 * beta) ;
+	gamma = ((CS_ENTRY)sigma)*alpha / (beta2 * beta) ;
 	Lx [p] = delta * Lx [p] + ((sigma > 0) ? (gamma * w [j]) : 0) ;
 	beta = beta2 ;
 	for (p++ ; p < Lp [j+1] ; p++)
diff -ur SuiteSparse/CXSparse/Source/cs_util.c SuiteSparse-mod/CXSparse/Source/cs_util.c
--- SuiteSparse/CXSparse/Source/cs_util.c	2006-12-07 06:52:30.000000000 +0100
+++ SuiteSparse-mod/CXSparse/Source/cs_util.c	2007-02-12 09:58:07.872015100 +0100
@@ -2,15 +2,15 @@
 /* allocate a sparse matrix (triplet form or compressed-column form) */
 cs *cs_spalloc (CS_INT m, CS_INT n, CS_INT nzmax, CS_INT values, CS_INT triplet)
 {
-    cs *A = cs_calloc (1, sizeof (cs)) ;    /* allocate the cs struct */
+    cs *A = (cs*)cs_calloc (1, sizeof (cs)) ;    /* allocate the cs struct */
     if (!A) return (NULL) ;		    /* out of memory */
     A->m = m ;				    /* define dimensions and nzmax */
     A->n = n ;
     A->nzmax = nzmax = CS_MAX (nzmax, 1) ;
     A->nz = triplet ? 0 : -1 ;		    /* allocate triplet or comp.col */
-    A->p = cs_malloc (triplet ? nzmax : n+1, sizeof (CS_INT)) ;
-    A->i = cs_malloc (nzmax, sizeof (CS_INT)) ;
-    A->x = values ? cs_malloc (nzmax, sizeof (CS_ENTRY)) : NULL ;
+    A->p = (CS_INT*)cs_malloc (triplet ? nzmax : n+1, sizeof (CS_INT)) ;
+    A->i = (CS_INT*)cs_malloc (nzmax, sizeof (CS_INT)) ;
+    A->x = values ? (CS_ENTRY*)cs_malloc (nzmax, sizeof (CS_ENTRY)) : NULL ;
     return ((!A->p || !A->i || (values && !A->x)) ? cs_spfree (A) : A) ;
 }
 
@@ -20,9 +20,9 @@
     CS_INT ok, oki, okj = 1, okx = 1 ;
     if (!A) return (0) ;
     if (nzmax <= 0) nzmax = (CS_CSC (A)) ? (A->p [A->n]) : A->nz ;
-    A->i = cs_realloc (A->i, nzmax, sizeof (CS_INT), &oki) ;
-    if (CS_TRIPLET (A)) A->p = cs_realloc (A->p, nzmax, sizeof (CS_INT), &okj) ;
-    if (A->x) A->x = cs_realloc (A->x, nzmax, sizeof (CS_ENTRY), &okx) ;
+    A->i = (CS_INT*)cs_realloc (A->i, nzmax, sizeof (CS_INT), &oki) ;
+    if (CS_TRIPLET (A)) A->p = (CS_INT*)cs_realloc (A->p, nzmax, sizeof (CS_INT), &okj) ;
+    if (A->x) A->x = (CS_ENTRY*)cs_realloc (A->x, nzmax, sizeof (CS_ENTRY), &okx) ;
     ok = (oki && okj && okx) ;
     if (ok) A->nzmax = nzmax ;
     return (ok) ;
@@ -35,7 +35,7 @@
     cs_free (A->p) ;
     cs_free (A->i) ;
     cs_free (A->x) ;
-    return (cs_free (A)) ;	/* free the cs struct and return NULL */
+    return (cs*)(cs_free (A)) ;	/* free the cs struct and return NULL */
 }
 
 /* free a numeric factorization */
@@ -46,7 +46,7 @@
     cs_spfree (N->U) ;
     cs_free (N->pinv) ;
     cs_free (N->B) ;
-    return (cs_free (N)) ;	/* free the csn struct and return NULL */
+    return (csn*)(cs_free (N)) ;	/* free the csn struct and return NULL */
 }
 
 /* free a symbolic factorization */
@@ -58,19 +58,19 @@
     cs_free (S->parent) ;
     cs_free (S->cp) ;
     cs_free (S->leftmost) ;
-    return (cs_free (S)) ;	/* free the css struct and return NULL */
+    return (css*)(cs_free (S)) ;	/* free the css struct and return NULL */
 }
 
 /* allocate a cs_dmperm or cs_scc result */
 csd *cs_dalloc (CS_INT m, CS_INT n)
 {
     csd *D ;
-    D = cs_calloc (1, sizeof (csd)) ;
+    D = (csd*)cs_calloc (1, sizeof (csd)) ;
     if (!D) return (NULL) ;
-    D->p = cs_malloc (m, sizeof (CS_INT)) ;
-    D->r = cs_malloc (m+6, sizeof (CS_INT)) ;
-    D->q = cs_malloc (n, sizeof (CS_INT)) ;
-    D->s = cs_malloc (n+6, sizeof (CS_INT)) ;
+    D->p = (CS_INT*)cs_malloc (m, sizeof (CS_INT)) ;
+    D->r = (CS_INT*)cs_malloc (m+6, sizeof (CS_INT)) ;
+    D->q = (CS_INT*)cs_malloc (n, sizeof (CS_INT)) ;
+    D->s = (CS_INT*)cs_malloc (n+6, sizeof (CS_INT)) ;
     return ((!D->p || !D->r || !D->q || !D->s) ? cs_dfree (D) : D) ;
 }
 
@@ -82,7 +82,7 @@
     cs_free (D->q) ;
     cs_free (D->r) ;
     cs_free (D->s) ;
-    return (cs_free (D)) ;
+    return (csd*)(cs_free (D)) ;
 }
 
 /* free workspace and return a sparse matrix result */
@@ -98,7 +98,7 @@
 {
     cs_spfree (C) ;			/* free temporary matrix */
     cs_free (w) ;			/* free workspace */
-    return (ok ? p : cs_free (p)) ;	/* return result if OK, else free it */
+    return (ok ? p : (CS_INT*)cs_free (p)) ;	/* return result if OK, else free it */
 }
 
 /* free workspace and return a numeric factorization (Cholesky, LU, or QR) */
diff -ur SuiteSparse/CXSparse_newfiles/Demo/Makefile SuiteSparse-mod/CXSparse_newfiles/Demo/Makefile
--- SuiteSparse/CXSparse_newfiles/Demo/Makefile	2006-11-29 14:43:00.000000000 +0100
+++ SuiteSparse-mod/CXSparse_newfiles/Demo/Makefile	2007-02-09 16:22:17.856363600 +0100
@@ -1,9 +1,9 @@
-CC = cc
-CFLAGS = -O
+CC = cc-msvc
+CFLAGS = -O2 -TP -EHsc
 
 I = -I../Source -I../../UFconfig
 
-CS = ../Source/libcxsparse.a
+CS = ../Source/cxsparse.lib
 
 all: $(CS) cs_demo1 cs_demo2 cs_demo3 \
 	cs_di_demo1 cs_di_demo2 cs_di_demo3 \
@@ -87,67 +87,67 @@
 	( cd ../Source ; $(MAKE) )
 
 cs_demo1: $(CS) cs_demo1.c Makefile $(CS)
-	$(CC) $(I) -o cs_demo1 cs_demo1.c $(CS) -lm
+	$(CC) $(CFLAGS) $(I) -o cs_demo1 cs_demo1.c $(CS)
 
 cs_demo2: $(CS) cs_demo2.c cs_demo.c cs_demo.h Makefile $(CS)
-	$(CC) $(I) -o cs_demo2 cs_demo2.c cs_demo.c $(CS) -lm
+	$(CC) $(CFLAGS) $(I) -o cs_demo2 cs_demo2.c cs_demo.c $(CS)
 
 cs_demo3: $(CS) cs_demo3.c cs_demo.c cs_demo.h Makefile $(CS)
-	$(CC) $(I) -o cs_demo3 cs_demo3.c cs_demo.c $(CS) -lm
+	$(CC) $(CFLAGS) $(I) -o cs_demo3 cs_demo3.c cs_demo.c $(CS)
 
 
 
 
 cs_di_demo1: $(CS) cs_di_demo1.c Makefile $(CS)
-	$(CC) $(I) -o cs_di_demo1 cs_di_demo1.c $(CS) -lm
+	$(CC) $(CFLAGS) $(I) -o cs_di_demo1 cs_di_demo1.c $(CS)
 
 cs_di_demo2: $(CS) cs_di_demo2.c cs_di_demo.c cs_di_demo.h Makefile $(CS)
-	$(CC) $(I) -o cs_di_demo2 cs_di_demo2.c cs_di_demo.c $(CS) -lm
+	$(CC) $(CFLAGS) $(I) -o cs_di_demo2 cs_di_demo2.c cs_di_demo.c $(CS)
 
 cs_di_demo3: $(CS) cs_di_demo3.c cs_di_demo.c cs_di_demo.h Makefile $(CS)
-	$(CC) $(I) -o cs_di_demo3 cs_di_demo3.c cs_di_demo.c $(CS) -lm
+	$(CC) $(CFLAGS) $(I) -o cs_di_demo3 cs_di_demo3.c cs_di_demo.c $(CS)
 
 
 
 
 cs_ci_demo1: $(CS) cs_ci_demo1.c Makefile $(CS)
-	$(CC) $(I) -o cs_ci_demo1 cs_ci_demo1.c $(CS) -lm
+	$(CC) $(CFLAGS) $(I) -o cs_ci_demo1 cs_ci_demo1.c $(CS)
 
 cs_ci_demo2: $(CS) cs_ci_demo2.c cs_ci_demo.c cs_ci_demo.h Makefile $(CS)
-	$(CC) $(I) -o cs_ci_demo2 cs_ci_demo2.c cs_ci_demo.c $(CS) -lm
+	$(CC) $(CFLAGS) $(I) -o cs_ci_demo2 cs_ci_demo2.c cs_ci_demo.c $(CS)
 
 cs_ci_demo3: $(CS) cs_ci_demo3.c cs_ci_demo.c cs_ci_demo.h Makefile $(CS)
-	$(CC) $(I) -o cs_ci_demo3 cs_ci_demo3.c cs_ci_demo.c $(CS) -lm
+	$(CC) $(CFLAGS) $(I) -o cs_ci_demo3 cs_ci_demo3.c cs_ci_demo.c $(CS)
 
 
 
 cs_dl_demo1: $(CS) cs_dl_demo1.c Makefile $(CS)
-	$(CC) $(I) -o cs_dl_demo1 cs_dl_demo1.c $(CS) -lm
+	$(CC) $(CFLAGS) $(I) -o cs_dl_demo1 cs_dl_demo1.c $(CS)
 
 cs_dl_demo2: $(CS) cs_dl_demo2.c cs_dl_demo.c cs_dl_demo.h Makefile $(CS)
-	$(CC) $(I) -o cs_dl_demo2 cs_dl_demo2.c cs_dl_demo.c $(CS) -lm
+	$(CC) $(CFLAGS) $(I) -o cs_dl_demo2 cs_dl_demo2.c cs_dl_demo.c $(CS)
 
 cs_dl_demo3: $(CS) cs_dl_demo3.c cs_dl_demo.c cs_dl_demo.h Makefile $(CS)
-	$(CC) $(I) -o cs_dl_demo3 cs_dl_demo3.c cs_dl_demo.c $(CS) -lm
+	$(CC) $(CFLAGS) $(I) -o cs_dl_demo3 cs_dl_demo3.c cs_dl_demo.c $(CS)
 
 
 cs_cl_demo1: $(CS) cs_cl_demo1.c Makefile $(CS)
-	$(CC) $(I) -o cs_cl_demo1 cs_cl_demo1.c $(CS) -lm
+	$(CC) $(CFLAGS) $(I) -o cs_cl_demo1 cs_cl_demo1.c $(CS)
 
 cs_cl_demo2: $(CS) cs_cl_demo2.c cs_cl_demo.c cs_cl_demo.h Makefile $(CS)
-	$(CC) $(I) -o cs_cl_demo2 cs_cl_demo2.c cs_cl_demo.c $(CS) -lm
+	$(CC) $(CFLAGS) $(I) -o cs_cl_demo2 cs_cl_demo2.c cs_cl_demo.c $(CS)
 
 cs_cl_demo3: $(CS) cs_cl_demo3.c cs_cl_demo.c cs_cl_demo.h Makefile $(CS)
-	$(CC) $(I) -o cs_cl_demo3 cs_cl_demo3.c cs_cl_demo.c $(CS) -lm
+	$(CC) $(CFLAGS) $(I) -o cs_cl_demo3 cs_cl_demo3.c cs_cl_demo.c $(CS)
 
 
 
 
 cs_idemo: $(CS) cs_idemo.c Makefile $(CS)
-	$(CC) $(I) -o cs_idemo cs_idemo.c $(CS) -lm
+	$(CC) $(CFLAGS) $(I) -o cs_idemo cs_idemo.c $(CS)
 
 cs_ldemo: $(CS) cs_ldemo.c Makefile $(CS)
-	$(CC) $(I) -o cs_ldemo cs_ldemo.c $(CS) -lm
+	$(CC) $(CFLAGS) $(I) -o cs_ldemo cs_ldemo.c $(CS)
 
 
 clean:
diff -ur SuiteSparse/CXSparse_newfiles/Source/Makefile SuiteSparse-mod/CXSparse_newfiles/Source/Makefile
--- SuiteSparse/CXSparse_newfiles/Source/Makefile	2006-05-02 09:06:20.000000000 +0200
+++ SuiteSparse-mod/CXSparse_newfiles/Source/Makefile	2007-02-09 15:30:46.554520400 +0100
@@ -1,12 +1,12 @@
 # Modify the "-O" optimization option for best performance (-O3 on Linux):
-CC = cc
-CFLAGS = -O
+CC = cc-msvc
+CFLAGS = -O2 -TP -EHsc
 I = -I../../UFconfig
 
-AR = ar cr
-RANLIB = ranlib
+AR = ar-msvc cr
+RANLIB = ranlib-msvc
 
-all: libcxsparse.a
+all: cxsparse.lib
 
 CS_SOURCE = cs_add.c cs_amd.c cs_chol.c cs_cholsol.c cs_counts.c cs_cumsum.c \
 	cs_droptol.c cs_dropzeros.c cs_dupl.c cs_entry.c \
@@ -66,7 +66,7 @@
 	cs_norm_cl.o cs_load_cl.o cs_dfs_cl.o cs_reach_cl.o cs_spsolve_cl.o \
 	cs_leaf_cl.o cs_ereach_cl.o cs_randperm_cl.o
 
-CS = cs_convert.o $(CS_DI_OBJ) $(CS_DL_OBJ) $(CS_CI_OBJ) $(CS_CL_OBJ)
+CS = cs_convert.o $(CS_CI_OBJ) $(CS_CL_OBJ) $(CS_DI_OBJ) $(CS_DL_OBJ)
 
 $(CS): cs.h Makefile
 
@@ -85,9 +85,9 @@
 %_cl.o : %.c
 	$(CC) $(CFLAGS) $(I) -DCS_LONG -DCS_COMPLEX -c $< -o $@
 
-libcxsparse.a: $(CS)
-	$(AR) libcxsparse.a $(CS)
-	$(RANLIB) libcxsparse.a
+cxsparse.lib: $(CS)
+	$(AR) cxsparse.lib $(CS)
+	$(RANLIB) cxsparse.lib
 
 clean:
 	rm -f *.o
@@ -95,4 +95,4 @@
 purge: distclean
 
 distclean: clean
-	rm -f *.a
+	rm -f *.lib
diff -ur SuiteSparse/CXSparse_newfiles/Source/cs.h SuiteSparse-mod/CXSparse_newfiles/Source/cs.h
--- SuiteSparse/CXSparse_newfiles/Source/cs.h	2006-12-07 06:47:10.000000000 +0100
+++ SuiteSparse-mod/CXSparse_newfiles/Source/cs.h	2007-02-12 09:57:20.666473300 +0100
@@ -9,9 +9,19 @@
 #endif
 
 #ifdef __cplusplus
+#include <complex>
+typedef std::complex<double> cs_complex_t;
+#define creal(x) ((x).real())
+#define cimag(x) ((x).imag())
+#define cabs(x) abs(x)
+#define I cs_complex_t(0., 1.)
+#ifdef _MSC_VER
+#pragma warning (disable: 4003)
+#endif
 extern "C" {
 #else
 #include <complex.h>
+#define cs_complex_t double _Complex;
 #endif
 
 #define CS_VER 2		    /* CXSparse Version 2.0.6 */
@@ -308,19 +318,19 @@
     int n ;	    /* number of columns */
     int *p ;	    /* column pointers (size n+1) or col indices (size nzmax) */
     int *i ;	    /* row indices, size nzmax */
-    double _Complex *x ;    /* numerical values, size nzmax */
+    cs_complex_t *x ;    /* numerical values, size nzmax */
     int nz ;	    /* # of entries in triplet matrix, -1 for compressed-col */
 } cs_ci ;
 
-cs_ci *cs_ci_add (const cs_ci *A, const cs_ci *B, double _Complex alpha,
-    double _Complex beta) ;
-int cs_ci_cholsol (int order, const cs_ci *A, double _Complex *b) ;
+cs_ci *cs_ci_add (const cs_ci *A, const cs_ci *B, cs_complex_t alpha,
+    cs_complex_t beta) ;
+int cs_ci_cholsol (int order, const cs_ci *A, cs_complex_t *b) ;
 int cs_ci_dupl (cs_ci *A) ;
-int cs_ci_entry (cs_ci *T, int i, int j, double _Complex x) ;
-int cs_ci_lusol (int order, const cs_ci *A, double _Complex *b, double tol) ;
-int cs_ci_gaxpy (const cs_ci *A, const double _Complex *x, double _Complex *y) ;
+int cs_ci_entry (cs_ci *T, int i, int j, cs_complex_t x) ;
+int cs_ci_lusol (int order, const cs_ci *A, cs_complex_t *b, double tol) ;
+int cs_ci_gaxpy (const cs_ci *A, const cs_complex_t *x, cs_complex_t *y) ;
 cs_ci *cs_ci_multiply (const cs_ci *A, const cs_ci *B) ;
-int cs_ci_qrsol (int order, const cs_ci *A, double _Complex *b) ;
+int cs_ci_qrsol (int order, const cs_ci *A, cs_complex_t *b) ;
 cs_ci *cs_ci_transpose (const cs_ci *A, int values) ;
 cs_ci *cs_ci_compress (const cs_ci *T) ;
 double cs_ci_norm (const cs_ci *A) ;
@@ -355,7 +365,7 @@
     cs_ci *L ;	    /* L for LU and Cholesky, V for QR */
     cs_ci *U ;	    /* U for LU, r for QR, not used for Cholesky */
     int *pinv ;	    /* partial pivoting for LU */
-    double _Complex *B ;	    /* beta [0..n-1] for QR */
+    cs_complex_t *B ;	    /* beta [0..n-1] for QR */
 } cs_cin ;
 
 typedef struct cs_ci_dmperm_results    /* cs_ci_dmperm or cs_ci_scc output */
@@ -374,23 +384,23 @@
 cs_cid *cs_ci_dmperm (const cs_ci *A, int seed) ;
 int cs_ci_droptol (cs_ci *A, double tol) ;
 int cs_ci_dropzeros (cs_ci *A) ;
-int cs_ci_happly (const cs_ci *V, int i, double _Complex beta,
-    double _Complex *x) ;
-int cs_ci_ipvec (const int *p, const double _Complex *b,
-    double _Complex *x, int n) ;
-int cs_ci_lsolve (const cs_ci *L, double _Complex *x) ;
-int cs_ci_ltsolve (const cs_ci *L, double _Complex *x) ;
+int cs_ci_happly (const cs_ci *V, int i, cs_complex_t beta,
+    cs_complex_t *x) ;
+int cs_ci_ipvec (const int *p, const cs_complex_t *b,
+    cs_complex_t *x, int n) ;
+int cs_ci_lsolve (const cs_ci *L, cs_complex_t *x) ;
+int cs_ci_ltsolve (const cs_ci *L, cs_complex_t *x) ;
 cs_cin *cs_ci_lu (const cs_ci *A, const cs_cis *S, double tol) ;
 cs_ci *cs_ci_permute (const cs_ci *A, const int *p, const int *q, int values) ;
 int *cs_ci_pinv (const int *p, int n) ;
-int cs_ci_pvec (const int *p, const double _Complex *b,
-    double _Complex *x, int n) ;
+int cs_ci_pvec (const int *p, const cs_complex_t *b,
+    cs_complex_t *x, int n) ;
 cs_cin *cs_ci_qr (const cs_ci *A, const cs_cis *S) ;
 cs_cis *cs_ci_schol (int order, const cs_ci *A) ;
 cs_cis *cs_ci_sqr (int order, const cs_ci *A, int qr) ;
 cs_ci *cs_ci_symperm (const cs_ci *A, const int *pinv, int values) ;
-int cs_ci_usolve (const cs_ci *U, double _Complex *x) ;
-int cs_ci_utsolve (const cs_ci *U, double _Complex *x) ;
+int cs_ci_usolve (const cs_ci *U, cs_complex_t *x) ;
+int cs_ci_utsolve (const cs_ci *U, cs_complex_t *x) ;
 int cs_ci_updown (cs_ci *L, int sigma, const cs_ci *C, const int *parent) ;
 
 /* utilities */
@@ -406,21 +416,20 @@
 int cs_ci_dfs (int j, cs_ci *G, int top, int *xi, int *pstack,
     const int *pinv) ;
 int *cs_ci_etree (const cs_ci *A, int ata) ;
-int cs_ci_fkeep (cs_ci *A, int (*fkeep) (int, int, double _Complex, void *),
+int cs_ci_fkeep (cs_ci *A, int (*fkeep) (int, int, cs_complex_t, void *),
     void *other) ;
-double _Complex cs_ci_house (double _Complex *x, double _Complex *beta, int n) ;
 int *cs_ci_maxtrans (const cs_ci *A, int seed) ;
 int *cs_ci_post (const int *parent, int n) ;
 cs_cid *cs_ci_scc (cs_ci *A) ;
-int cs_ci_scatter (const cs_ci *A, int j, double _Complex beta, int *w, 
-    double _Complex *x, int mark,cs_ci *C, int nz) ;
+int cs_ci_scatter (const cs_ci *A, int j, cs_complex_t beta, int *w, 
+    cs_complex_t *x, int mark,cs_ci *C, int nz) ;
 int cs_ci_tdfs (int j, int k, int *head, const int *next, int *post,
     int *stack) ;
 int cs_ci_leaf (int i, int j, const int *first, int *maxfirst, int *prevleaf,
     int *ancestor, int *jleaf) ;
 int cs_ci_reach (cs_ci *G, const cs_ci *B, int k, int *xi, const int *pinv) ;
 int cs_ci_spsolve (cs_ci *L, const cs_ci *B, int k, int *xi, 
-    double _Complex *x, const int *pinv, int lo) ;
+    cs_complex_t *x, const int *pinv, int lo) ;
 int cs_ci_ereach (const cs_ci *A, int k, const int *parent, int *s, int *w) ;
 int *cs_ci_randperm (int n, int seed) ;
 
@@ -445,21 +454,21 @@
     UF_long n ;	    /* number of columns */
     UF_long *p ;    /* column pointers (size n+1) or col indlces (size nzmax) */
     UF_long *i ;    /* row indices, size nzmax */
-    double _Complex *x ;    /* numerical values, size nzmax */
+    cs_complex_t *x ;    /* numerical values, size nzmax */
     UF_long nz ;    /* # of entries in triplet matrix, -1 for compressed-col */
 } cs_cl ;
 
-cs_cl *cs_cl_add (const cs_cl *A, const cs_cl *B, double _Complex alpha,
-    double _Complex beta) ;
-UF_long cs_cl_cholsol (UF_long order, const cs_cl *A, double _Complex *b) ;
+cs_cl *cs_cl_add (const cs_cl *A, const cs_cl *B, cs_complex_t alpha,
+    cs_complex_t beta) ;
+UF_long cs_cl_cholsol (UF_long order, const cs_cl *A, cs_complex_t *b) ;
 UF_long cs_cl_dupl (cs_cl *A) ;
-UF_long cs_cl_entry (cs_cl *T, UF_long i, UF_long j, double _Complex x) ;
-UF_long cs_cl_lusol (UF_long order, const cs_cl *A, double _Complex *b,
+UF_long cs_cl_entry (cs_cl *T, UF_long i, UF_long j, cs_complex_t x) ;
+UF_long cs_cl_lusol (UF_long order, const cs_cl *A, cs_complex_t *b,
     double tol) ;
-UF_long cs_cl_gaxpy (const cs_cl *A, const double _Complex *x,
-    double _Complex *y) ;
+UF_long cs_cl_gaxpy (const cs_cl *A, const cs_complex_t *x,
+    cs_complex_t *y) ;
 cs_cl *cs_cl_multiply (const cs_cl *A, const cs_cl *B) ;
-UF_long cs_cl_qrsol (UF_long order, const cs_cl *A, double _Complex *b) ;
+UF_long cs_cl_qrsol (UF_long order, const cs_cl *A, cs_complex_t *b) ;
 cs_cl *cs_cl_transpose (const cs_cl *A, UF_long values) ;
 cs_cl *cs_cl_compress (const cs_cl *T) ;
 double cs_cl_norm (const cs_cl *A) ;
@@ -495,7 +504,7 @@
     cs_cl *L ;		/* L for LU and Cholesky, V for QR */
     cs_cl *U ;		/* U for LU, r for QR, not used for Cholesky */
     UF_long *pinv ;	/* partial pivoting for LU */
-    double _Complex *B ;	    /* beta [0..n-1] for QR */
+    cs_complex_t *B ;	    /* beta [0..n-1] for QR */
 } cs_cln ;
 
 typedef struct cs_cl_dmperm_results    /* cs_cl_dmperm or cs_cl_scc output */
@@ -514,24 +523,24 @@
 cs_cld *cs_cl_dmperm (const cs_cl *A, UF_long seed) ;
 UF_long cs_cl_droptol (cs_cl *A, double tol) ;
 UF_long cs_cl_dropzeros (cs_cl *A) ;
-UF_long cs_cl_happly (const cs_cl *V, UF_long i, double _Complex beta,
-    double _Complex *x) ;
-UF_long cs_cl_ipvec (const UF_long *p, const double _Complex *b,
-    double _Complex *x, UF_long n) ;
-UF_long cs_cl_lsolve (const cs_cl *L, double _Complex *x) ;
-UF_long cs_cl_ltsolve (const cs_cl *L, double _Complex *x) ;
+UF_long cs_cl_happly (const cs_cl *V, UF_long i, cs_complex_t beta,
+    cs_complex_t *x) ;
+UF_long cs_cl_ipvec (const UF_long *p, const cs_complex_t *b,
+    cs_complex_t *x, UF_long n) ;
+UF_long cs_cl_lsolve (const cs_cl *L, cs_complex_t *x) ;
+UF_long cs_cl_ltsolve (const cs_cl *L, cs_complex_t *x) ;
 cs_cln *cs_cl_lu (const cs_cl *A, const cs_cls *S, double tol) ;
 cs_cl *cs_cl_permute (const cs_cl *A, const UF_long *p, const UF_long *q,
     UF_long values) ;
 UF_long *cs_cl_pinv (const UF_long *p, UF_long n) ;
-UF_long cs_cl_pvec (const UF_long *p, const double _Complex *b,
-    double _Complex *x, UF_long n) ;
+UF_long cs_cl_pvec (const UF_long *p, const cs_complex_t *b,
+    cs_complex_t *x, UF_long n) ;
 cs_cln *cs_cl_qr (const cs_cl *A, const cs_cls *S) ;
 cs_cls *cs_cl_schol (UF_long order, const cs_cl *A) ;
 cs_cls *cs_cl_sqr (UF_long order, const cs_cl *A, UF_long qr) ;
 cs_cl *cs_cl_symperm (const cs_cl *A, const UF_long *pinv, UF_long values) ;
-UF_long cs_cl_usolve (const cs_cl *U, double _Complex *x) ;
-UF_long cs_cl_utsolve (const cs_cl *U, double _Complex *x) ;
+UF_long cs_cl_usolve (const cs_cl *U, cs_complex_t *x) ;
+UF_long cs_cl_utsolve (const cs_cl *U, cs_complex_t *x) ;
 UF_long cs_cl_updown (cs_cl *L, UF_long sigma, const cs_cl *C,
     const UF_long *parent) ;
 
@@ -549,14 +558,12 @@
     UF_long *pstack, const UF_long *pinv) ;
 UF_long *cs_cl_etree (const cs_cl *A, UF_long ata) ;
 UF_long cs_cl_fkeep (cs_cl *A,
-    UF_long (*fkeep) (UF_long, UF_long, double _Complex, void *), void *other) ;
-double _Complex cs_cl_house (double _Complex *x, double _Complex *beta,
-    UF_long n) ;
+    UF_long (*fkeep) (UF_long, UF_long, cs_complex_t, void *), void *other) ;
 UF_long *cs_cl_maxtrans (const cs_cl *A, UF_long seed) ;
 UF_long *cs_cl_post (const UF_long *parent, UF_long n) ;
 cs_cld *cs_cl_scc (cs_cl *A) ;
-UF_long cs_cl_scatter (const cs_cl *A, UF_long j, double _Complex beta,
-    UF_long *w, double _Complex *x, UF_long mark,cs_cl *C, UF_long nz) ;
+UF_long cs_cl_scatter (const cs_cl *A, UF_long j, cs_complex_t beta,
+    UF_long *w, cs_complex_t *x, UF_long mark,cs_cl *C, UF_long nz) ;
 UF_long cs_cl_tdfs (UF_long j, UF_long k, UF_long *head, const UF_long *next,
     UF_long *post, UF_long *stack) ;
 UF_long cs_cl_leaf (UF_long i, UF_long j, const UF_long *first,
@@ -564,7 +571,7 @@
 UF_long cs_cl_reach (cs_cl *G, const cs_cl *B, UF_long k, UF_long *xi,
     const UF_long *pinv) ;
 UF_long cs_cl_spsolve (cs_cl *L, const cs_cl *B, UF_long k, UF_long *xi, 
-    double _Complex *x, const UF_long *pinv, UF_long lo) ;
+    cs_complex_t *x, const UF_long *pinv, UF_long lo) ;
 UF_long cs_cl_ereach (const cs_cl *A, UF_long k, const UF_long *parent,
     UF_long *s, UF_long *w) ;
 UF_long *cs_cl_randperm (UF_long n, UF_long seed) ;
@@ -586,7 +593,7 @@
 #define CS_INT_MAX UF_long_max
 #define CS_ID UF_long_id
 #ifdef CS_COMPLEX
-#define CS_ENTRY double _Complex
+#define CS_ENTRY cs_complex_t
 #define CS_NAME(nm) cs_cl ## nm
 #else
 #define CS_ENTRY double
@@ -597,7 +604,7 @@
 #define CS_INT_MAX INT_MAX
 #define CS_ID "%d"
 #ifdef CS_COMPLEX
-#define CS_ENTRY double _Complex
+#define CS_ENTRY cs_complex_t
 #define CS_NAME(nm) cs_ci ## nm
 #else
 #define CS_ENTRY double
@@ -722,4 +729,9 @@
 #ifdef __cplusplus
 }
 #endif
+
+cs_complex_t cs_ci_house (cs_complex_t *x, cs_complex_t *beta, int n) ;
+cs_complex_t cs_cl_house (cs_complex_t *x, cs_complex_t *beta,
+    UF_long n) ;
+
 #endif
diff -ur SuiteSparse/CXSparse_newfiles/Source/cs_convert.c SuiteSparse-mod/CXSparse_newfiles/Source/cs_convert.c
--- SuiteSparse/CXSparse_newfiles/Source/cs_convert.c	2006-05-02 08:59:14.000000000 +0200
+++ SuiteSparse-mod/CXSparse_newfiles/Source/cs_convert.c	2007-02-09 14:40:04.753943900 +0100
@@ -6,7 +6,7 @@
 {
     cs_di *C ;
     int n, triplet, nn, p, nz, *Ap, *Ai, *Cp, *Ci ;
-    double _Complex *Ax ;
+    cs_complex_t *Ax ;
     double *Cx ;
     if (!A || !A->x) return (NULL) ;	/* return if A NULL or pattern-only */
     n = A->n ; Ap = A->p ; Ai = A->i ; Ax = A->x ;
@@ -30,7 +30,7 @@
     cs_ci *C ;
     int n, triplet, nn, p, nz, *Ap, *Ai, *Cp, *Ci ;
     double *Ax ;
-    double _Complex *Cx ;
+    cs_complex_t *Cx ;
     if (!A || !A->x) return (NULL) ;	/* return if A NULL or pattern-only */
     n = A->n ; Ap = A->p ; Ai = A->i ; Ax = A->x ;
     triplet = (A->nz >= 0) ;		/* true if A is a triplet matrix */
@@ -52,7 +52,7 @@
 {
     cs_dl *C ;
     UF_long n, triplet, nn, p, nz, *Ap, *Ai, *Cp, *Ci ;
-    double _Complex *Ax ;
+    cs_complex_t *Ax ;
     double *Cx ;
     if (!A || !A->x) return (NULL) ;	/* return if A NULL or pattern-only */
     n = A->n ; Ap = A->p ; Ai = A->i ; Ax = A->x ;
@@ -76,7 +76,7 @@
     cs_cl *C ;
     UF_long n, triplet, nn, p, nz, *Ap, *Ai, *Cp, *Ci ;
     double *Ax ;
-    double _Complex *Cx ;
+    cs_complex_t *Cx ;
     if (!A || !A->x) return (NULL) ;	/* return if A NULL or pattern-only */
     n = A->n ; Ap = A->p ; Ai = A->i ; Ax = A->x ;
     triplet = (A->nz >= 0) ;		/* true if A is a triplet matrix */
diff -ur SuiteSparse/CXSparse_newfiles/Source/cs_house.c SuiteSparse-mod/CXSparse_newfiles/Source/cs_house.c
--- SuiteSparse/CXSparse_newfiles/Source/cs_house.c	2006-02-18 07:04:52.000000000 +0100
+++ SuiteSparse-mod/CXSparse_newfiles/Source/cs_house.c	2007-02-09 15:38:18.769883000 +0100
@@ -9,14 +9,14 @@
     if (!x || !beta) return (-1) ;	    /* check inputs */
     for (i = 0 ; i < n ; i++) s += x [i] * CS_CONJ (x [i]) ;
     s = sqrt (s) ;
-    if (s == 0)
+    if (s == 0.)
     {
 	(*beta) = 0 ;
 	x [0] = 1 ;
     }
     else
     {
-	if (x [0] != 0)
+	if (x [0] != 0.)
 	{
 	    s *= x [0] / CS_ABS (x [0]) ;
 	}
diff -ur SuiteSparse/KLU/Demo/Makefile SuiteSparse-mod/KLU/Demo/Makefile
--- SuiteSparse/KLU/Demo/Makefile	2006-05-11 14:18:22.000000000 +0200
+++ SuiteSparse-mod/KLU/Demo/Makefile	2007-02-12 10:29:20.815922500 +0100
@@ -5,22 +5,22 @@
 
 include ../../UFconfig/UFconfig.mk
 
-all: kludemo
+all: kludemo$(EXEEXT)
 
 I = -I../Include -I../../AMD/Include -I../../COLAMD -I../../BTF/Include \
 	-I../User -I../../CHOLMOD/Include -I$(METIS_PATH) -I../../CCOLAMD \
 	-I../../CAMD -I../../UFconfig
 
-LIBS = ../Lib/libklu.a ../../AMD/Lib/libamd.a ../../COLAMD/libcolamd.a \
-	../../BTF/Lib/libbtf.a ../User/libklu_cholmod.a \
-	../../CHOLMOD/Lib/libcholmod.a ../../CCOLAMD/libccolamd.a \
-	../../CAMD/Lib/libcamd.a $(METIS) $(LIB)
+LIBS = ../Lib/$(LIBPRE)klu.$(LIBEXT) ../../AMD/Lib/$(LIBPRE)amd.$(LIBEXT) ../../COLAMD/$(LIBPRE)colamd.$(LIBEXT) \
+	../../BTF/Lib/$(LIBPRE)btf.$(LIBEXT) ../User/$(LIBPRE)klu_cholmod.$(LIBEXT) \
+	../../CHOLMOD/Lib/$(LIBPRE)cholmod.$(LIBEXT) ../../CCOLAMD/$(LIBPRE)ccolamd.$(LIBEXT) \
+	../../CAMD/Lib/$(LIBPRE)camd.$(LIBEXT) $(METIS) $(CLIB)
 
-kludemo: library kludemo.c
-	$(CC) $(CFLAGS) $(I) kludemo.c dsecnd.c -o kludemo $(LIBS)
+kludemo$(EXEEXT): library kludemo.c
+	$(CC) $(CFLAGS) $(I) kludemo.c dsecnd.c -o kludemo$(EXEEXT) $(LIBS)
 
 purge: clean
-	- $(RM) kludemo
+	- $(RM) kludemo$(EXEEXT)
 
 distclean: purge
 
diff -ur SuiteSparse/KLU/Lib/Makefile SuiteSparse-mod/KLU/Lib/Makefile
--- SuiteSparse/KLU/Lib/Makefile	2006-06-24 23:16:06.000000000 +0200
+++ SuiteSparse-mod/KLU/Lib/Makefile	2007-02-12 10:29:20.831545900 +0100
@@ -16,7 +16,7 @@
 
 all: library
 
-library: libklu.a
+library: $(LIBPRE)klu.$(LIBEXT)
 
 KLU_D = klu_d.o klu_d_kernel.o klu_d_dump.o \
     klu_d_factor.o klu_d_free_numeric.o klu_d_solve.o \
@@ -33,9 +33,9 @@
 
 OBJ = $(COMMON) $(KLU_D) $(KLU_Z)
 
-libklu.a: $(OBJ)
-	$(AR) libklu.a $(OBJ)
-	$(RANLIB) libklu.a
+$(LIBPRE)klu.$(LIBEXT): $(OBJ)
+	$(AR) $(LIBPRE)klu.$(LIBEXT) $(OBJ)
+	$(RANLIB) $(LIBPRE)klu.$(LIBEXT)
 
 $(OBJ): $(INC)
 
@@ -135,7 +135,7 @@
 purge: distclean
 
 distclean: clean
-	- $(RM) libklu.a 
+	- $(RM) $(LIBPRE)klu.$(LIBEXT) 
 
 clean:
 	- $(RM) $(CLEAN)
diff -ur SuiteSparse/KLU/User/Makefile SuiteSparse-mod/KLU/User/Makefile
--- SuiteSparse/KLU/User/Makefile	2006-05-11 14:18:54.000000000 +0200
+++ SuiteSparse-mod/KLU/User/Makefile	2007-02-12 10:29:20.847169300 +0100
@@ -2,19 +2,19 @@
 
 include ../../UFconfig/UFconfig.mk
 
-all: libklu_cholmod.a
+all: $(LIBPRE)klu_cholmod.$(LIBEXT)
 
 I = -I../../CHOLMOD/Include -I../../UFconfig
 
-libklu_cholmod.a:  library klu_cholmod.c klu_cholmod.h
+$(LIBPRE)klu_cholmod.$(LIBEXT):  library klu_cholmod.c klu_cholmod.h
 	$(CC) $(CFLAGS) $(I) -c klu_cholmod.c
-	$(AR) libklu_cholmod.a klu_cholmod.o
-	$(RANLIB) libklu_cholmod.a
+	$(AR) $(LIBPRE)klu_cholmod.$(LIBEXT) klu_cholmod.o
+	$(RANLIB) $(LIBPRE)klu_cholmod.$(LIBEXT)
 
 distclean: purge
 
 purge: clean
-	- $(RM) *.o *.a
+	- $(RM) *.o *.$(LIBEXT)
 
 clean:
 	- $(RM) $(CLEAN)
diff -ur SuiteSparse/LDL/Makefile SuiteSparse-mod/LDL/Makefile
--- SuiteSparse/LDL/Makefile	2006-09-11 13:59:14.000000000 +0200
+++ SuiteSparse-mod/LDL/Makefile	2007-02-12 10:29:20.878416100 +0100
@@ -8,7 +8,7 @@
 
 C = $(CC) $(CFLAGS)
 
-all: intro libldl.a ldlsimple ldlmain ldlamd
+all: intro $(LIBPRE)ldl.$(LIBEXT) ldlsimple$(EXEEXT) ldlmain$(EXEEXT) ldlamd$(EXEEXT)
 
 intro:
 	@echo " "
@@ -24,38 +24,38 @@
 # the ldl library:
 #-------------------------------------------------------------------------------
 
-libldl.a: ldl.c ldl.h
+$(LIBPRE)ldl.$(LIBEXT): ldl.c ldl.h
 	$(C) -c ldl.c -o ldl.o
-	$(AR) libldl.a ldl.o
-	- $(RANLIB) libldl.a
+	$(AR) $(LIBPRE)ldl.$(LIBEXT) ldl.o
+	- $(RANLIB) $(LIBPRE)ldl.$(LIBEXT)
 
 #-------------------------------------------------------------------------------
 # stand-alone C programs:
 #-------------------------------------------------------------------------------
 
-ldlmain:  ldlmain.c libldl.a
-	$(C) ldlmain.c libldl.a -o ldlmain -lm
+ldlmain$(EXEEXT):  ldlmain.c $(LIBPRE)ldl.$(LIBEXT)
+	$(C) ldlmain.c $(LIBPRE)ldl.$(LIBEXT) -o ldlmain$(EXEEXT) $(CLIB)
 	- ./ldlmain > my_ldlmain.out
-	- diff ldlmain.out my_ldlmain.out
+	- diff -b ldlmain.out my_ldlmain.out
 
-ldlsimple:  ldlsimple.c libldl.a
-	$(C) ldlsimple.c libldl.a -o ldlsimple -lm
+ldlsimple$(EXEEXT):  ldlsimple.c $(LIBPRE)ldl.$(LIBEXT)
+	$(C) ldlsimple.c $(LIBPRE)ldl.$(LIBEXT) -o ldlsimple$(EXEEXT) $(CLIB)
 	- ./ldlsimple > my_ldlsimple.out
-	- diff ldlsimple.out my_ldlsimple.out
+	- diff -b ldlsimple.out my_ldlsimple.out
 
-ldlamd:  ldlmain.c libldl.a
+ldlamd$(EXEEXT):  ldlmain.c $(LIBPRE)ldl.$(LIBEXT)
 	- (cd ../AMD ; $(MAKE))
-	- $(C) -I../AMD/Include -I../UFconfig -L../AMD/Lib -DUSE_AMD ldlmain.c -lamd libldl.a -o ldlamd -lm
+	- $(C) -I../AMD/Include -I../UFconfig -L../AMD/Lib -DUSE_AMD ldlmain.c -lamd $(LIBPRE)ldl.$(LIBEXT) -o ldlamd$(EXEEXT) $(CLIB)
 	- ./ldlamd > my_ldlamd.out
-	- diff ldlamd.out my_ldlamd.out
+	- diff -b ldlamd.out my_ldlamd.out
 
 run:
 	- ./ldlamd > my_ldlamd.out
-	- diff ldlamd.out my_ldlamd.out
+	- diff -b ldlamd.out my_ldlamd.out
 	- ./ldlsimple > my_ldlsimple.out
-	- diff ldlsimple.out my_ldlsimple.out
+	- diff -b ldlsimple.out my_ldlsimple.out
 	- ./ldlmain > my_ldlmain.out
-	- diff ldlmain.out my_ldlmain.out
+	- diff -b ldlmain.out my_ldlmain.out
 
 #-------------------------------------------------------------------------------
 # LDL mexFunctions for use in MATLAB:
@@ -74,7 +74,7 @@
 distclean: purge
 
 purge: clean
-	- $(RM) ldlsparse.mex* ldl.dll libldl.a ldlmain ldlamd ldlsimple
+	- $(RM) ldlsparse.mex* ldl.dll $(LIBPRE)ldl.$(LIBEXT) ldlmain$(EXEEXT) ldlamd$(EXEEXT) ldlsimple$(EXEEXT)
 	- $(RM) my_ldlmain.out my_ldlamd.out my_ldlsimple.out
 	- $(RM) ldlmain.mex* ldlamd.mex* ldlmain.dll ldlamd.dll
 	- $(RM) ldlsymbol.mex* ldlsymbol.dll
diff -ur SuiteSparse/Makefile SuiteSparse-mod/Makefile
--- SuiteSparse/Makefile	2006-12-01 17:31:30.000000000 +0100
+++ SuiteSparse-mod/Makefile	2007-02-12 10:30:07.124964900 +0100
@@ -7,7 +7,7 @@
 # Compile the default rules for each package
 default:
 	( cd UFconfig/xerbla ; $(MAKE) )
-	( cd metis-4.0 ; $(MAKE) )
+#	( cd metis-4.0 ; $(MAKE) )
 	( cd AMD ; $(MAKE) )
 	( cd CAMD ; $(MAKE) )
 	( cd COLAMD ; $(MAKE) )
@@ -42,7 +42,7 @@
 # Remove all files not in the original distribution
 purge:
 	( cd UFconfig/xerbla ; $(MAKE) purge )
-	( cd metis-4.0 ; $(MAKE) realclean )
+#	( cd metis-4.0 ; $(MAKE) realclean )
 	( cd AMD ; $(MAKE) purge )
 	( cd CAMD ; $(MAKE) purge )
 	( cd COLAMD ; $(MAKE) purge )
@@ -62,7 +62,7 @@
 # Remove all files not in the original distribution, but keep the libraries
 clean:
 	( cd UFconfig/xerbla ; $(MAKE) clean )
-	( cd metis-4.0 ; $(MAKE) clean )
+#	( cd metis-4.0 ; $(MAKE) clean )
 	( cd AMD ; $(MAKE) clean )
 	( cd CAMD ; $(MAKE) clean )
 	( cd COLAMD ; $(MAKE) clean )
diff -ur SuiteSparse/UFconfig/UFconfig.mk SuiteSparse-mod/UFconfig/UFconfig.mk
--- SuiteSparse/UFconfig/UFconfig.mk	2006-11-29 06:18:52.000000000 +0100
+++ SuiteSparse-mod/UFconfig/UFconfig.mk	2007-02-12 10:29:20.925286300 +0100
@@ -31,12 +31,12 @@
 # C compiler and compiler flags:  These will normally not give you optimal
 # performance.  You should select the optimization parameters that are best
 # for your system.  On Linux, use "CFLAGS = -O3 -fexceptions" for example.
-CC = cc
-CFLAGS = -O
+CC = cc-msvc
+CFLAGS = -MD -O2
 
 # ranlib, and ar, for generating libraries
-RANLIB = ranlib
-AR = ar cr
+RANLIB = ranlib-msvc
+AR = ar-msvc cr
 
 # delete and rename a file
 RM = rm -f
@@ -48,7 +48,7 @@
 F77LIB =
 
 # C and Fortran libraries
-LIB = -lm
+CLIB =
 
 # For compiling MATLAB mexFunctions
 MEX = mex -O
@@ -57,6 +57,10 @@
 # MAKE = make
 # MAKE = gmake
 
+LIBPRE =
+LIBEXT = lib
+EXEEXT = .exe
+
 #------------------------------------------------------------------------------
 # BLAS and LAPACK configuration:
 #------------------------------------------------------------------------------
@@ -73,7 +77,7 @@
 # These settings will probably not work, since there is no fixed convention for
 # naming the BLAS and LAPACK library (*.a or *.so) files.  Assume the Goto
 # BLAS are available.
-BLAS = -lgoto -lgfortran -lgfortranbegin
+BLAS = -lblas
 LAPACK = -llapack
 
 # The BLAS might not contain xerbla, an error-handling routine for LAPACK and
@@ -102,13 +106,13 @@
 # The path is relative to where it is used, in CHOLMOD/Lib, CHOLMOD/MATLAB, etc.
 # You may wish to use an absolute path.  METIS is optional.  Compile
 # CHOLMOD with -DNPARTITION if you do not wish to use METIS.
-METIS_PATH = ../../metis-4.0
-METIS = ../../metis-4.0/libmetis.a
+# METIS_PATH = ../../metis-4.0
+# METIS = ../../metis-4.0/$(LIBPRE)metis.$(LIBEXT)
 
 # If you use CHOLMOD_CONFIG = -DNPARTITION then you must use the following
 # options:
-# METIS_PATH =
-# METIS =
+METIS_PATH =
+METIS =
 
 #------------------------------------------------------------------------------
 # UMFPACK configuration:
@@ -126,7 +130,7 @@
 # -DNRECIPROCAL	do not multiply by the reciprocal
 # -DNO_DIVIDE_BY_ZERO	do not divide by zero
 
-UMFPACK_CONFIG = 
+UMFPACK_CONFIG = -DBLAS_UNDERSCORE
 
 #------------------------------------------------------------------------------
 # CHOLMOD configuration
@@ -164,7 +168,7 @@
 # -DNSUNPERF	    for Solaris only.  If defined, do not use the Sun
 #			Performance Library
 
-CHOLMOD_CONFIG =
+CHOLMOD_CONFIG = -DNPARTITION -DBLAS_UNDERSCORE
 
 #------------------------------------------------------------------------------
 # Linux
@@ -181,7 +185,7 @@
 # CFLAGS = -O3 -fexceptions \
    	-Wall -W -Werror -Wshadow -Wmissing-prototypes -Wstrict-prototypes \
     	-Wredundant-decls -Wnested-externs -Wdisabled-optimization -ansi
-CFLAGS = -O3 -fexceptions
+# CFLAGS = -O3 -fexceptions
 # CFLAGS = -O3
 
 # consider:
@@ -295,4 +299,4 @@
 # remove object files and profile output
 #------------------------------------------------------------------------------
 
-CLEAN = *.o *.obj *.ln *.bb *.bbg *.da *.tcov *.gcov gmon.out *.bak *.d
+CLEAN = *.o *.obj *.ln *.bb *.bbg *.da *.tcov *.gcov gmon.out *.bak *.d *.exe *.lib *.ilk *.exp
diff -ur SuiteSparse/UFconfig/xerbla/Makefile SuiteSparse-mod/UFconfig/xerbla/Makefile
--- SuiteSparse/UFconfig/xerbla/Makefile	2006-01-30 11:50:58.000000000 +0100
+++ SuiteSparse-mod/UFconfig/xerbla/Makefile	2007-02-12 10:29:20.940909700 +0100
@@ -4,22 +4,22 @@
 
 include ../UFconfig.mk
 
-ccode: libcerbla.a
+ccode: $(LIBPRE)cerbla.$(LIBEXT)
 
-fortran: libxerbla.a 
+fortran: $(LIBPRE)xerbla.$(LIBEXT) 
 
-all: libxerbla.a libcerbla.a
+all: $(LIBPRE)xerbla.$(LIBEXT) $(LIBPRE)cerbla.$(LIBEXT)
 
 # Fortran version:
-libxerbla.a: xerbla.f
+$(LIBPRE)xerbla.$(LIBEXT): xerbla.f
 	$(F77) $(F77FLAGS) -c xerbla.f
-	$(AR) libxerbla.a xerbla.o
+	$(AR) $(LIBPRE)xerbla.$(LIBEXT) xerbla.o
 	- $(RM) xerbla.o
 
 # C version:
-libcerbla.a: xerbla.c xerbla.h
+$(LIBPRE)cerbla.$(LIBEXT): xerbla.c xerbla.h
 	$(CC) $(CFLAGS) -c xerbla.c
-	$(AR) libcerbla.a xerbla.o
+	$(AR) $(LIBPRE)cerbla.$(LIBEXT) xerbla.o
 	- $(RM) xerbla.o
 
 distclean: purge
diff -ur SuiteSparse/UMFPACK/Demo/Makefile SuiteSparse-mod/UMFPACK/Demo/Makefile
--- SuiteSparse/UMFPACK/Demo/Makefile	2006-05-02 09:46:22.000000000 +0200
+++ SuiteSparse-mod/UMFPACK/Demo/Makefile	2007-02-12 10:29:20.972156500 +0100
@@ -5,25 +5,25 @@
 # UMFPACK Version 4.4, Copyright (c) 2005 by Timothy A. Davis.
 # All Rights Reserved.  See ../Doc/License for License.
 
-default: libs umfpack_di_demo umfpack_zi_demo umfpack_dl_demo umfpack_zl_demo \
-	umfpack_simple
-
 include ../../UFconfig/UFconfig.mk
 
+default: libs umfpack_di_demo$(EXEEXT) umfpack_zi_demo$(EXEEXT) umfpack_dl_demo$(EXEEXT) umfpack_zl_demo$(EXEEXT) \
+	umfpack_simple$(EXEEXT)
+
 C = $(CC) $(CFLAGS) $(UMFPACK_CONFIG) -I../Include -I../../AMD/Include \
     -I../../UFconfig
 
 INC = ../Include/umfpack.h ../../AMD/Include/amd.h ../../UFconfig/UFconfig.h
 
-LIBS = $(BLAS) $(XERBLA) $(LIB)
+LIBS = $(BLAS) $(XERBLA) $(CLIB)
 
-../Lib/libumfpack.a:
+../Lib/$(LIBPRE)umfpack.$(LIBEXT):
 	( cd ../Source ; $(MAKE) )
 
-../../AMD/Lib/libamd.a:
+../../AMD/Lib/$(LIBPRE)amd.$(LIBEXT):
 	( cd ../../AMD/Source ; $(MAKE) )
 
-UMFPACK = ../Lib/libumfpack.a ../../AMD/Lib/libamd.a
+UMFPACK = ../Lib/$(LIBPRE)umfpack.$(LIBEXT) ../../AMD/Lib/$(LIBPRE)amd.$(LIBEXT)
 
 libs:
 	( cd ../Source ; $(MAKE) )
@@ -35,8 +35,8 @@
 
 dist: umfpack_di_demo.c umfpack_dl_demo.c umfpack_zi_demo.c umfpack_zl_demo.c
 
-umfpack_simple: umfpack_simple.c $(INC) $(UMFPACK)
-	$(C) -o umfpack_simple umfpack_simple.c $(UMFPACK) $(LIBS)
+umfpack_simple$(EXEEXT): umfpack_simple.c $(INC) $(UMFPACK)
+	$(C) -o umfpack_simple$(EXEEXT) umfpack_simple.c $(UMFPACK) $(LIBS)
 	./umfpack_simple
 
 # the GNU rules are simpler:
@@ -53,44 +53,44 @@
 umfpack_di_demo.c: umfpack_xx_demo.c umfpack_di_demo.sed
 	- sed -f umfpack_di_demo.sed < umfpack_xx_demo.c > umfpack_di_demo.c
 
-umfpack_di_demo: umfpack_di_demo.c $(INC) $(UMFPACK)
-	$(C) -o umfpack_di_demo umfpack_di_demo.c $(UMFPACK) $(LIBS)
+umfpack_di_demo$(EXEEXT): umfpack_di_demo.c $(INC) $(UMFPACK)
+	$(C) -o umfpack_di_demo$(EXEEXT) umfpack_di_demo.c $(UMFPACK) $(LIBS)
 	./umfpack_di_demo > my_umfpack_di_demo.out
-	- diff umfpack_di_demo.out my_umfpack_di_demo.out
+	- diff -b umfpack_di_demo.out my_umfpack_di_demo.out
 
 # double-precision, UF_long verion:
 umfpack_dl_demo.c: umfpack_xx_demo.c umfpack_dl_demo.sed
 	- sed -f umfpack_dl_demo.sed < umfpack_xx_demo.c > umfpack_dl_demo.c
 
-umfpack_dl_demo: umfpack_dl_demo.c $(INC) $(UMFPACK)
-	$(C) -o umfpack_dl_demo umfpack_dl_demo.c $(UMFPACK) $(LIBS)
+umfpack_dl_demo$(EXEEXT): umfpack_dl_demo.c $(INC) $(UMFPACK)
+	$(C) -o umfpack_dl_demo$(EXEEXT) umfpack_dl_demo.c $(UMFPACK) $(LIBS)
 	./umfpack_dl_demo > my_umfpack_dl_demo.out
-	- diff umfpack_dl_demo.out my_umfpack_dl_demo.out
+	- diff -b umfpack_dl_demo.out my_umfpack_dl_demo.out
 
 # complex, int verion:
 umfpack_zi_demo.c: umfpack_xx_demo.c umfpack_zi_demo.sed
 	- sed -f umfpack_zi_demo.sed < umfpack_xx_demo.c > umfpack_zi_demo.c
 
-umfpack_zi_demo: umfpack_zi_demo.c $(INC) $(UMFPACK)
-	$(C) -o umfpack_zi_demo umfpack_zi_demo.c $(UMFPACK) $(LIBS)
+umfpack_zi_demo$(EXEEXT): umfpack_zi_demo.c $(INC) $(UMFPACK)
+	$(C) -o umfpack_zi_demo$(EXEEXT) umfpack_zi_demo.c $(UMFPACK) $(LIBS)
 	./umfpack_zi_demo > my_umfpack_zi_demo.out
-	- diff umfpack_zi_demo.out my_umfpack_zi_demo.out
+	- diff -b umfpack_zi_demo.out my_umfpack_zi_demo.out
 
 # complex, UF_long verion:
 umfpack_zl_demo.c: umfpack_xx_demo.c umfpack_zl_demo.sed
 	- sed -f umfpack_zl_demo.sed < umfpack_xx_demo.c > umfpack_zl_demo.c
 
-umfpack_zl_demo: umfpack_zl_demo.c $(INC) $(UMFPACK)
-	$(C) -o umfpack_zl_demo umfpack_zl_demo.c $(UMFPACK) $(LIBS)
+umfpack_zl_demo$(EXEEXT): umfpack_zl_demo.c $(INC) $(UMFPACK)
+	$(C) -o umfpack_zl_demo$(EXEEXT) umfpack_zl_demo.c $(UMFPACK) $(LIBS)
 	./umfpack_zl_demo > my_umfpack_zl_demo.out
-	- diff umfpack_zl_demo.out my_umfpack_zl_demo.out
+	- diff -b umfpack_zl_demo.out my_umfpack_zl_demo.out
 
 #-------------------------------------------------------------------------------
 # create a demo program that reads in Harwell/Boeing matrices, and run it
 #-------------------------------------------------------------------------------
 
 # the output of "make hb" is in the file umf4.out
-hb: $(UMFPACK) umf4 readhb readhb_nozeros readhb_size
+hb: $(UMFPACK) umf4 readhb$(EXEEXT) readhb_nozeros$(EXEEXT) readhb_size$(EXEEXT)
 	- ./readhb_nozeros < HB/can_24.psa > tmp/A
 	- ./readhb_size    < HB/can_24.psa > tmp/Asize
 	- ./umf4
@@ -113,17 +113,17 @@
 	- ./readhb_size    < HB/arc130.rua > tmp/Asize
 	- ./umf4 a 1e-6
 
-umf4: umf4.c $(UMFPACK)
-	$(C) -o umf4 umf4.c $(UMFPACK) $(LIBS)
+umf4$(EXEEXT): umf4.c $(UMFPACK)
+	$(C) -o umf4$(EXEEXT) umf4.c $(UMFPACK) $(LIBS)
 
-readhb:  readhb.f
-	$(F77) $(F77FLAGS) -o readhb readhb.f $(F77LIB)
+readhb$(EXEEXT):  readhb.f
+	$(F77) $(F77FLAGS) -o readhb$(EXEEXT) readhb.f $(F77LIB)
 
-readhb_size:  readhb_size.f
-	$(F77) $(F77FLAGS) -o readhb_size readhb_size.f $(F77LIB)
+readhb_size$(EXEEXT):  readhb_size.f
+	$(F77) $(F77FLAGS) -o readhb_size$(EXEEXT) readhb_size.f $(F77LIB)
 
-readhb_nozeros:  readhb_nozeros.f
-	$(F77) $(F77FLAGS) -o readhb_nozeros readhb_nozeros.f $(F77LIB)
+readhb_nozeros$(EXEEXT):  readhb_nozeros.f
+	$(F77) $(F77FLAGS) -o readhb_nozeros$(EXEEXT) readhb_nozeros.f $(F77LIB)
 
 #-------------------------------------------------------------------------------
 # compile the FORTRAN interface and demo
@@ -162,14 +162,14 @@
 #-------------------------------------------------------------------------------
 
 purge: clean
-	- $(RM) umfpack_simple a.out
-	- $(RM) umfpack_di_demo my_umfpack_di_demo.out
-	- $(RM) umfpack_dl_demo my_umfpack_dl_demo.out
-	- $(RM) umfpack_zi_demo my_umfpack_zi_demo.out
-	- $(RM) umfpack_zl_demo my_umfpack_zl_demo.out
+	- $(RM) umfpack_simple$(EXEEXT) a.out
+	- $(RM) umfpack_di_demo$(EXEEXT) my_umfpack_di_demo.out
+	- $(RM) umfpack_dl_demo$(EXEEXT) my_umfpack_dl_demo.out
+	- $(RM) umfpack_zi_demo$(EXEEXT) my_umfpack_zi_demo.out
+	- $(RM) umfpack_zl_demo$(EXEEXT) my_umfpack_zl_demo.out
 	- $(RM) umf4hb umf4zhb *.umf my_umf4hb.out
 	- $(RM) umf4hb64 my_umf4hb64.out my_umf4zhb.out
-	- $(RM) umf4 readhb readhb_nozeros readhb_size tmp/*
+	- $(RM) umf4$(EXEEXT) readhb$(EXEEXT) readhb_nozeros$(EXEEXT) readhb_size$(EXEEXT) tmp/*
 
 clean:
 	- $(RM) $(CLEAN)
diff -ur SuiteSparse/UMFPACK/Source/GNUmakefile SuiteSparse-mod/UMFPACK/Source/GNUmakefile
--- SuiteSparse/UMFPACK/Source/GNUmakefile	2006-05-02 10:36:46.000000000 +0200
+++ SuiteSparse-mod/UMFPACK/Source/GNUmakefile	2007-02-12 10:29:21.019026700 +0100
@@ -2,10 +2,10 @@
 # UMFPACK Makefile for compiling on Unix systems (for GNU Make)
 #-------------------------------------------------------------------------------
 
-default: ../Lib/libumfpack.a
-
 include ../../UFconfig/UFconfig.mk
 
+default: ../Lib/$(LIBPRE)umfpack.$(LIBEXT)
+
 C = $(CC) $(CFLAGS) $(UMFPACK_CONFIG) \
     -I../Include -I../../AMD/Include -I../../UFconfig
 
@@ -242,16 +242,16 @@
 # Create the libumfpack.a library
 #-------------------------------------------------------------------------------
 
-../Lib/libumfpack.a: $(II) $(LL) $(GN) $(DI) $(DL) $(ZI) $(ZL)
-	$(AR) ../Lib/libumfpack.a $^
-	- $(RANLIB) ../Lib/libumfpack.a
+../Lib/$(LIBPRE)umfpack.$(LIBEXT): $(II) $(LL) $(GN) $(DI) $(DL) $(ZI) $(ZL)
+	$(AR) ../Lib/$(LIBPRE)umfpack.$(LIBEXT) $^
+	- $(RANLIB) ../Lib/$(LIBPRE)umfpack.$(LIBEXT)
 
 #-------------------------------------------------------------------------------
 # Remove all but the files in the original distribution
 #-------------------------------------------------------------------------------
 
 purge: clean
-	- $(RM) ../Lib/libumfpack.a
+	- $(RM) ../Lib/$(LIBPRE)umfpack.$(LIBEXT)
 
 clean:
 	- $(RM) $(CLEAN)
diff -ur SuiteSparse/UMFPACK/Source/cholmod_blas.h SuiteSparse-mod/UMFPACK/Source/cholmod_blas.h
--- SuiteSparse/UMFPACK/Source/cholmod_blas.h	2006-08-27 16:30:22.000000000 +0200
+++ SuiteSparse-mod/UMFPACK/Source/cholmod_blas.h	2007-02-12 10:29:21.050273500 +0100
@@ -48,8 +48,10 @@
 #define CHOLMOD_CYGWIN
 #else
 #define CHOLMOD_WINDOWS
+#ifndef BLAS_UNDERSCORE
 #define BLAS_NO_UNDERSCORE
 #endif
+#endif
 #define CHOLMOD_ARCHITECTURE "Microsoft Windows"
 
 #elif defined (__hppa) || defined (__hpux) || defined (MHPUX) || defined (ARCH_HPUX)
