diff -r 4afd83c6a1ac scintilla/src/Document.cxx
--- a/scintilla/src/Document.cxx	Mon Feb 09 10:11:07 2009 +0100
+++ b/scintilla/src/Document.cxx	Mon Feb 09 10:53:03 2009 +0100
@@ -1282,8 +1282,8 @@
 					}
 					if (found) {
 						if ((!word && !wordStart) ||
-						        word && IsWordAt(pos, pos + lengthFind) ||
-						        wordStart && IsWordStartAt(pos))
+						        (word && IsWordAt(pos, pos + lengthFind)) ||
+						        (wordStart && IsWordStartAt(pos)))
 							return pos;
 					}
 				}
@@ -1372,8 +1372,8 @@
 					}
 					if (found) {
 						if ((!word && !wordStart) ||
-						    word && IsWordAt(pos, pos + lengthFind) ||
-						    wordStart && IsWordStartAt(pos)) {
+						    (word && IsWordAt(pos, pos + lengthFind)) ||
+						    (wordStart && IsWordStartAt(pos))) {
 						        if (ws_upr != NULL) {
 								delete [] ws_upr;
 								ws_upr = NULL;
diff -r 4afd83c6a1ac scintilla/src/Editor.cxx
--- a/scintilla/src/Editor.cxx	Mon Feb 09 10:11:07 2009 +0100
+++ b/scintilla/src/Editor.cxx	Mon Feb 09 10:53:03 2009 +0100
@@ -1876,13 +1876,13 @@
 							ll->positions[charInLine + 1] = ((((startsegx + 2) /
 							        tabWidth) + 1) * tabWidth) - startsegx;
 						} else if (controlCharSymbol < 32) {
-							if (ctrlCharWidth[ll->chars[charInLine]] == 0) {
+							if (ctrlCharWidth[static_cast<int>(ll->chars[charInLine])] == 0) {
 								const char *ctrlChar = ControlCharacterString(ll->chars[charInLine]);
 								// +3 For a blank on front and rounded edge each side:
-								ctrlCharWidth[ll->chars[charInLine]] =
+								ctrlCharWidth[static_cast<int>(ll->chars[charInLine])] =
 								    surface->WidthText(ctrlCharsFont, ctrlChar, istrlen(ctrlChar)) + 3;
 							}
-							ll->positions[charInLine + 1] = ctrlCharWidth[ll->chars[charInLine]];
+							ll->positions[charInLine + 1] = ctrlCharWidth[static_cast<int>(ll->chars[charInLine])];
 						} else {
 							char cc[2] = { static_cast<char>(controlCharSymbol), '\0' };
 							surface->MeasureWidths(ctrlCharsFont, cc, 1,
@@ -2007,7 +2007,7 @@
 		if (inHotspot && vsDraw.hotspotBackgroundSet)
 			return vsDraw.hotspotBackground.allocated;
 		if (overrideBackground && (((styleMain != STYLE_BRACELIGHT) && (styleMain != STYLE_BRACEBAD)) ||
-			(vsDraw.styles[styleMain].back.allocated.AsLong() == vsDraw.styles[ll->bracePreviousStyles[0]].back.allocated.AsLong())))
+			(vsDraw.styles[styleMain].back.allocated.AsLong() == vsDraw.styles[static_cast<int>(ll->bracePreviousStyles[0])].back.allocated.AsLong())))
 			return background;
 	}
 	return vsDraw.styles[styleMain].back.allocated;
diff -r 4afd83c6a1ac scintilla/src/LexAU3.cxx
--- a/scintilla/src/LexAU3.cxx	Mon Feb 09 10:11:07 2009 +0100
+++ b/scintilla/src/LexAU3.cxx	Mon Feb 09 10:53:03 2009 +0100
@@ -253,11 +253,12 @@
 				//Reset at line end
 				if (sc.atLineEnd) {
 					ci=0;
-					if ((strcmp(s, "#ce")== 0 || strcmp(s, "#comments-end")== 0))
+					if ((strcmp(s, "#ce")== 0 || strcmp(s, "#comments-end")== 0)) {
 						if (sc.atLineEnd) 
 							sc.SetState(SCE_AU3_DEFAULT);
 						else	
 							sc.SetState(SCE_AU3_COMMENTBLOCK);
+					}
 					break;
 				}
 				//skip rest of line when a ; is encountered
diff -r 4afd83c6a1ac scintilla/src/LexFortran.cxx
--- a/scintilla/src/LexFortran.cxx	Mon Feb 09 10:11:07 2009 +0100
+++ b/scintilla/src/LexFortran.cxx	Mon Feb 09 10:53:03 2009 +0100
@@ -83,7 +83,7 @@
 		// Handle the fix format generically
 		int toLineStart = sc.currentPos - posLineStart;
 		if (isFixFormat && (toLineStart < 6 || toLineStart > 72)) {
-			if (toLineStart == 0 && (tolower(sc.ch) == 'c' || sc.ch == '*') || sc.ch == '!') {
+			if (toLineStart == 0 && ((tolower(sc.ch) == 'c' || sc.ch == '*') || sc.ch == '!')) {
 				sc.SetState(SCE_F_COMMENT);
 				while (!sc.atLineEnd && sc.More()) sc.Forward(); // Until line end
 			} else if (toLineStart > 72) {
@@ -243,7 +243,7 @@
 				lev = 0;
 			else
 				lev = 1;
-	} else if (strcmp(s, "end") == 0 && chNextNonBlank != '='
+	} else if (strcmp(s, "end") == 0 && (chNextNonBlank != '='
 		|| strcmp(s, "endassociate") == 0 || strcmp(s, "endblock") == 0
 		|| strcmp(s, "endblockdata") == 0 || strcmp(s, "endselect") == 0
 		|| strcmp(s, "enddo") == 0 || strcmp(s, "endenum") ==0
@@ -252,7 +252,7 @@
 		|| strcmp(s, "endmodule") == 0 || strcmp(s, "endprogram") == 0
 		|| strcmp(s, "endsubroutine") == 0 || strcmp(s, "endtype") == 0
 		|| strcmp(s, "endwhere") == 0
-		|| strcmp(s, "procedure") == 0 ) { // Take care of the module procedure statement
+		|| strcmp(s, "procedure") == 0 )) { // Take care of the module procedure statement
 			lev = -1;
 	} else if (strcmp(prevWord, "end") == 0 && strcmp(s, "if") == 0){ // end if
 			lev = 0;
diff -r 4afd83c6a1ac scintilla/src/LexInno.cxx
--- a/scintilla/src/LexInno.cxx	Mon Feb 09 10:11:07 2009 +0100
+++ b/scintilla/src/LexInno.cxx	Mon Feb 09 10:53:03 2009 +0100
@@ -288,7 +288,7 @@
 		lev = SC_FOLDLEVELBASE;
 	}
 	int flagsNext = styler.LevelAt(lineCurrent);
-	styler.SetLevel(lineCurrent, lev | flagsNext & ~SC_FOLDLEVELNUMBERMASK);
+	styler.SetLevel(lineCurrent, lev | (flagsNext & ~SC_FOLDLEVELNUMBERMASK));
 }
 
 LexerModule lmInno(SCLEX_INNOSETUP, ColouriseInnoDoc, "inno", FoldInnoDoc, innoWordListDesc);
diff -r 4afd83c6a1ac scintilla/src/LexProgress.cxx
--- a/scintilla/src/LexProgress.cxx	Mon Feb 09 10:11:07 2009 +0100
+++ b/scintilla/src/LexProgress.cxx	Mon Feb 09 10:53:03 2009 +0100
@@ -97,7 +97,7 @@
 				if (!IsAWordChar(sc.ch) && sc.ch != '-') {
 					char s[1000];
 					sc.GetCurrentLowered(s, sizeof(s));
-					if (((sc.state & 0x10) == 0) && keywords2.InList(s) || keywords3.InList(s)) {
+					if (((sc.state & 0x10) == 0) && (keywords2.InList(s) || keywords3.InList(s))) {
 						sc.ChangeState(SCE_4GL_BLOCK | ResetSentenceStart);
 					}
 					else if (keywords1.InList(s)) {
diff -r 4afd83c6a1ac scintilla/src/LexPython.cxx
--- a/scintilla/src/LexPython.cxx	Mon Feb 09 10:11:07 2009 +0100
+++ b/scintilla/src/LexPython.cxx	Mon Feb 09 10:53:03 2009 +0100
@@ -276,7 +276,7 @@
 					hexadecimal = false;
 				}
 				sc.SetState(SCE_P_NUMBER);
-			} else if (isascii(sc.ch) && isoperator(static_cast<char>(sc.ch)) || sc.ch == '`') {
+			} else if (isascii(sc.ch) && (isoperator(static_cast<char>(sc.ch)) || sc.ch == '`')) {
 				sc.SetState(SCE_P_OPERATOR);
 			} else if (sc.ch == '#') {
 				sc.SetState(sc.chNext == '#' ? SCE_P_COMMENTBLOCK : SCE_P_COMMENTLINE);
diff -r 4afd83c6a1ac scintilla/src/LexRuby.cxx
--- a/scintilla/src/LexRuby.cxx	Mon Feb 09 10:11:07 2009 +0100
+++ b/scintilla/src/LexRuby.cxx	Mon Feb 09 10:53:03 2009 +0100
@@ -784,13 +784,13 @@
 				state = SCE_RB_COMMENTLINE;
 			} else if (ch == '=') {
 				// =begin indicates the start of a comment (doc) block
-                if (i == 0 || isEOLChar(chPrev)
+                if (i == 0 || (isEOLChar(chPrev)
                     && chNext == 'b'
                     && styler.SafeGetCharAt(i + 2) == 'e'
                     && styler.SafeGetCharAt(i + 3) == 'g'
                     && styler.SafeGetCharAt(i + 4) == 'i'
                     && styler.SafeGetCharAt(i + 5) == 'n'
-                    && !isSafeWordcharOrHigh(styler.SafeGetCharAt(i + 6))) {
+                    && !isSafeWordcharOrHigh(styler.SafeGetCharAt(i + 6)))) {
                     styler.ColourTo(i - 1, state);
                     state = SCE_RB_POD;
 				} else {
diff -r 4afd83c6a1ac scintilla/src/RESearch.cxx
--- a/scintilla/src/RESearch.cxx	Mon Feb 09 10:11:07 2009 +0100
+++ b/scintilla/src/RESearch.cxx	Mon Feb 09 10:53:03 2009 +0100
@@ -449,11 +449,12 @@
 	char mask;             /* xor mask -CCL/NCL */
 	int c1, c2, prevChar;
 
-	if (!pat || !length)
+	if (!pat || !length) {
 		if (sta)
 			return 0;
 		else
 			return badpat("No previous regular expression");
+	}
 	sta = NOP;
 
 	const char *p=pat;     /* pattern pointer   */
@@ -867,10 +868,10 @@
 				return NOTFOUND;
 			break;
 		case BOT:
-			bopat[*ap++] = lp;
+			bopat[static_cast<int>(*ap++)] = lp;
 			break;
 		case EOT:
-			eopat[*ap++] = lp;
+			eopat[static_cast<int>(*ap++)] = lp;
 			break;
  		case BOW:
 			if (lp!=bol && iswordc(ci.CharAt(lp-1)) || !iswordc(ci.CharAt(lp)))
diff -r 4afd83c6a1ac scintilla/src/UniConversion.cxx
--- a/scintilla/src/UniConversion.cxx	Mon Feb 09 10:11:07 2009 +0100
+++ b/scintilla/src/UniConversion.cxx	Mon Feb 09 10:53:03 2009 +0100
@@ -48,7 +48,7 @@
 			i++;
 			unsigned int xch = 0x10000 + ((uch & 0x3ff) << 10) + (uptr[i] & 0x3ff);
 			putf[k++] = static_cast<char>(0xF0 | (xch >> 18));
-			putf[k++] = static_cast<char>(0x80 | (xch >> 12) & 0x3f);
+			putf[k++] = static_cast<char>(0x80 | ((xch >> 12) & 0x3f));
 			putf[k++] = static_cast<char>(0x80 | ((xch >> 6) & 0x3f));
 			putf[k++] = static_cast<char>(0x80 | (xch & 0x3f));
 		} else {
diff -r 4afd83c6a1ac scintilla/win32/ScintillaWin.cxx
--- a/scintilla/win32/ScintillaWin.cxx	Mon Feb 09 10:11:07 2009 +0100
+++ b/scintilla/win32/ScintillaWin.cxx	Mon Feb 09 10:53:03 2009 +0100
@@ -2308,7 +2308,8 @@
 bool ScintillaWin::HasCaretSizeChanged() {
 	if (
 		( (0 != vs.caretWidth) && (sysCaretWidth != vs.caretWidth) )
-		|| (0 != vs.lineHeight) && (sysCaretHeight != vs.lineHeight)
+		|| 
+		( (0 != vs.lineHeight) && (sysCaretHeight != vs.lineHeight) )
 		) {
 		return true;
 	}
