@c -*- texinfo -*-

@c Copyright (C) 2008, 2009, 2010, 2011, 2012 Moreno Marzolla
@c
@c This file is part of the queueing toolbox, a Queueing Networks
@c analysis package for GNU Octave.
@c
@c The queueing toolbox is free software; you can redistribute it
@c and/or modify it under the terms of the GNU General Public License
@c as published by the Free Software Foundation; either version 3 of
@c the License, or (at your option) any later version.
@c
@c The queueing toolbox is distributed in the hope that it will be
@c useful, but WITHOUT ANY WARRANTY; without even the implied warranty
@c of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
@c GNU General Public License for more details.
@c
@c You should have received a copy of the GNU General Public License
@c along with the queueing toolbox; see the file COPYING.  If not, see
@c <http://www.gnu.org/licenses/>.

@node Queueing Networks
@chapter Queueing Networks

@menu
* Introduction to QNs::             A brief introduction to Queueing Networks
* Single Class Models::             Queueing Models with a single job class
* Multiple Class Models::           Queueing Models with multiple job classess
* Generic Algorithms::              High-level functions for QN analysis
* Bounds Analysis::                 Computation of asymptotic performance bounds
* QN Analysis Examples::            Queueing Networks Analysis examples
@end menu

@cindex queueing networks

@c
@c INTRODUCTION
@c
@node Introduction to QNs
@section Introduction to QNs

Queueing Networks (QN) are a very simple yet powerful modeling tool
which can be used to analyze many kind of systems. In its simplest
form, a QN is made of @math{K} service centers. Each center @math{k}
has a queue, which is connected to @math{m_k} (generally identical)
@emph{servers}. Arriving customers (requests) join the queue if there
is a slot available. Then, requests are served according to a
(de)queueing policy (e.g., FIFO). After service completes, requests
leave the server and can join another queue or exit from the system.

Service centers for which @math{m_k = \infty} are called @emph{delay
centers} or @emph{infinite servers}. In this kind of centers, every
request always finds one available server, so queueing never occurs.

Requests join the queue according to a @emph{queueing policy}, such as:

@table @strong

@item FCFS
First-Come-First-Served

@item LCFS-PR
Last-Come-First-Served, Preemptive Resume

@item PS
Processor Sharing

@item IS
Infinite Server (for which @math{m_k = \infty}).

@end table

Queueing models can be @emph{open} or @emph{closed}. In open models
there is an infinite population of requests; new customers are
generated outside the system, and eventually leave the system. In
closed systems there is a fixed population of request.

Queueing models can have a single request class (@emph{single class
models}), meaning that all requests behave in the same way (e.g., they
spend the same average time on each particular server). In
@emph{multiple class models} there are multiple request classes, each
one with its own parameters. Furthermore, in multiclass models there
can be open and closed classes of requests within the same system.

A particular class of QN models, @emph{product-form} QNs, is of
particular interest. Product-form networks fulfill the following
assumptions:

@itemize

@item The network can consist of open and closed job classes.

@item The following queueing disciplines are allowed: FCFS, PS, LCFS-PR and IS.

@item Service times for FCFS nodes must be exponentially distributed and
class-independent. Service centers at PS, LCFS-PR and IS nodes can
have any kind of service time distribution with a rational Laplace
transform.  Furthermore, for PS, LCFS-PR and IS nodes, different
classes of customers can have different service times.

@item The service rate of an FCFS node is only allowed to depend on the
number of jobs at this node; in a PS, LCFS-PR and IS node the service
rate for a particular job class can also depend on the number of jobs
of that class at the node.

@item In open networks two kinds of arrival processes are allowed: i) the
arrival process is Poisson, with arrival rate @math{\lambda} which can
depend on the number of jobs in the network. ii) the arrival process
consists of @math{U} independent Poisson arrival streams where the
@math{U} job sources are assigned to the @math{U} chains; the arrival
rate can be load dependent.

@end itemize

Product-form networks are attractive because they be efficiently
analyzed to compute steady-state performance measures.

@c
@c Single Class Models
@c

@node Single Class Models
@section Single Class Models

In single class models, all requests are indistinguishable and belong
to the same class. This means that every request has the same average
service time, and all requests move through the system with the same
routing probabilities.

@noindent @strong{Model Inputs}

@table @math

@item @lambda_k
(Open models only) External arrival rate to service center @math{k}.

@item @lambda
(Open models only) Overall external arrival rate to the system as a whole: @math{\lambda =
\sum_k \lambda_k}.

@item N
(Closed models only) Total number of requests in the system.

@item S_k
Average service time. @math{S_k} is the average service time on service
center @math{k}. In other words, @math{S_k} is the average time from the
instant in which a request is extracted from the queue and starts being
service, and the instant at which service finishes and the request moves
to another queue (or exits the system).

@item P_{i, j}
Routing probability matrix. @math{{\bf P} = [P_{i, j}]} is a @math{K
\times K} matrix such that @math{P_{i, j}} is the probability that a
request completing service at server @math{i} will move directly to
server @math{j}, The probability that a request leaves the system
after service at service center @math{i} is @math{1-\sum_{j=1}^K P_{i,
j}}.

@item V_k
Mean number of visits the center @math{k} (also called @emph{visit
ratio} or @emph{relative arrival rate}).

@end table

@noindent @strong{Model Outputs}

@table @math

@item U_k
Service center utilization. @math{U_k} is the utilization of service
center @math{k}. The utilization is defined as the fraction of time in
which the resource is busy (i.e., the server is processing requests).
If center @math{k} is a single-server or multiserver node, then
@math{0 @leq{} U_k @leq{} 1}. If center @math{k} is an infinite server
node (delay center), then @math{U_k} denotes the @emph{traffic
intensity} and is defined as @math{U_k = X_k S_k}; in this case the
utilization may be greater than one.

@item R_k
Average response time. @math{R_k} is the average response time of
service center @math{k}. The average response time is defined as the
average time between the arrival of a customer in the queue, and the
completion of service.

@item Q_k
Average number of customers. @math{Q_k} is the average number of
requests in service center @math{k}. This includes both the requests in
the queue, and the request being served.

@item X_k
Throughput. @math{X_k} is the throughput of service center @math{k}.
The throughput is defined as the ratio of job completions (i.e., average
number of jobs completed over a fixed interval of time).

@end table

@noindent Given these output parameters, additional performance measures can
be computed as follows:

@table @math

@item X
System throughput, @math{X = X_1 / V_1}

@item R
System response time, @math{R = \sum_{k=1}^K R_k V_k}

@item Q
Average number of requests in the system, @math{Q = \sum_{k=1} Q_k}; for
closed systems, this can be written as @math{Q = N-XZ};

@end table

For open, single class models, the scalar @math{\lambda} denotes the
external arrival rate of requests to the system. The average number of
visits @math{V_j} satisfy the following equation:

@iftex
@tex
$$ V_j = P_{0, j} + \sum_{i=1}^K V_i P_{i, j} \quad j=1, \ldots, K $$
@end tex
@end iftex
@ifnottex
@example
@group
                  K
                 ___
                \
V_j = P_(0, j) + >   V_i P_(i, j)    j=1,...,K
                /___
                 i=1
@end group
@end example
@end ifnottex

@noindent where @math{P_{0, j}} is the probability that an external
arrival goes to service center @math{j}. If @math{\lambda_j} is the
external arrival rate to service center @math{j}, and @math{\lambda =
\sum_j \lambda_j} is the overall external arrival rate, then
@math{P_{0, j} = \lambda_j / \lambda}.

For closed models, the visit ratios satisfy the following equation:

@iftex
@tex
$$\left\{\eqalign{V_j & = \sum_{i=1}^K V_i P_{i, j} \quad j=1, \ldots, K \cr
                  V_r & = 1 \quad \hbox{for a selected reference station $r$}}\right. $$
@end tex
@end iftex
@ifnottex
@example
/
|         K
|        ___
|       \
| V_j =  >   V_i P_(i, j)     j=1,...,K
|       /___
|        i=1
|
| V_r = 1                     for a selected reference station r
\
@end example
@end ifnottex

Note that the set of traffic equations @math{V_j = \sum_{i=1}^K V_i
P_{i, j}} alone can only be solved up to a multiplicative constant; to
get a unique solution we impose an additional constraint @math{V_r =
1}. This constraint is equivalent to defining station @math{r} as the
@emph{reference station}; the default is @math{r=1},
@pxref{doc-qncsvisits}. A job that returns to the reference station is
assumed to have completed its activity cycle. The network throughput
is set to the throughput of the reference station.

@GETHELP{qncsvisits}

@GETHELP{qnosvisits}

@c
@c
@c
@noindent @strong{EXAMPLE}

@float Figure,fig:qn_closed_single
@center @image{qn_closed_single,3in}
@caption{Closed network with a single class of requests}
@end float

@ref{fig:qn_closed_single} shows a closed QN with a single class of
requests. The network has three service centers, labeled @emph{CPU},
@emph{Disk1}, @emph{Disk2}. and represents the so called @emph{central
server} model of a computer system. Requests spend some time at the
CPU, which is represented by a PS (Processor Sharing) node. After
that, requests are routed to node Disk1 with probability @math{0.3},
and to node Disk2 with probability @math{0.7}. Both Disk1 and Disk2
are modeled as FCFS nodes.

If we enumerate the servers as CPU=1, Disk1=2, Disk2=3, we can define
the routing matrix as follows:

@iftex
@tex
$$
P = \pmatrix{ 0 & 0.3 & 0.7 \cr
              1 & 0 & 0 \cr
              1 & 0 & 0 }
$$
@end tex
@end iftex
@ifnottex
@example
    / 0  0.3  0.7 \
P = | 1  0    0   |
    \ 1  0    0   /
@end example
@end ifnottex

The visit ratios @math{V} using station 1 as the reference
station can be computed with:

@example
@GETDEMO{qncsvisits,1}
   @result{} V = 1.00000   0.30000   0.70000
@end example

@noindent @strong{EXAMPLE}

@float Figure,fig:qn_open_single
@center @image{qn_open_single,3in}
@caption{Open Queueing Network with a single class of requests}
@end float

@ref{fig:qn_open_single} shows a open QN with a single class of
requests. The network has the same structure as the one in
@ref{fig:qn_closed_single}, with the difference that here we have a
stream of jobs arriving from outside the system, at a rate
@math{\lambda}. After service completion at the CPU, a job can leave
the system with probability 0.2, or be transferred to other nodes with
the probabilities shown in the figure.

The routing matrix of this network is

@iftex
@tex
$$
P = \pmatrix{ 0 & 0.3 & 0.5 \cr
              1 & 0 & 0 \cr
              1 & 0 & 0 }
$$
@end tex
@end iftex
@ifnottex
@example
    / 0  0.3  0.5 \
P = | 1  0    0   |
    \ 1  0    0   /
@end example
@end ifnottex

If we let @math{\lambda = 1.2}, we can compute the visit ratios
@math{V} as follows:

@example
@GETDEMO{qnosvisits,1}
   @result{} V = 5.0000   1.5000   2.5000
@end example

Function @command{qnosvisits} expects a vector with @math{K} elements
as a second parameter, for open networks only. The vector contains the
arrival rates at each individual node; since in our example external
arrivals exist only for node @math{S_1} with rate @math{\lambda =
1.2}, the second parameter is @code{[1.2, 0, 0]}.

@c
@c Open Networks
@c
@subsection Open Networks

Jackson networks satisfy the following conditions:

@itemize

@item
There is only one job class in the network; the overall number of jobs
in the system is unlimited.

@item
There are @math{N} service centers in the network. Each service center
may have Poisson arrivals from outside the system. A job can leave
the system from any node.

@item
Arrival rates as well as routing probabilities are independent from
the number of nodes in the network.

@item
External arrivals and service times at the service centers are
exponentially distributed, and in general can be load-dependent.

@item
Service discipline at each node is FCFS

@end itemize

We define the @emph{joint probability vector} @math{\pi(k_1, k_2,
\ldots, k_N)} as the steady-state probability that there are @math{k_i}
requests at service center @math{i}, for all @math{i=1, 2, \ldots, N}.
Jackson networks have the property that the joint probability is the
product of the marginal probabilities @math{\pi_i}:

@iftex
@tex
$$ \pi(k_1, k_2, \ldots, k_N) = \prod_{i=1}^N \pi_i(k_i) $$
@end tex
@end iftex
@ifnottex
@example
@var{joint_prob} = prod( @var{pi} )
@end example
@end ifnottex

@noindent where @math{\pi_i(k_i)} is the steady-state probability
that there are @math{k_i} requests at service center @math{i}.

@GETHELP{qnos}

From the results computed by this function, it is possible to derive
other quantities of interest as follows:

@itemize

@item
@strong{System Response Time}: The overall system response time
can be computed as
@iftex
@tex
$R_s = \sum_{i=1}^K V_i R_i$
@end tex
@end iftex
@ifnottex
@code{R_s = dot(V,R);}
@end ifnottex

@item
@strong{Average number of requests}: The average number of requests
in the system can be computed as:
@iftex
@tex
$Q_s = \sum_{i=1}^K Q(i)$
@end tex
@end iftex
@ifnottex
@code{Q_s = sum(Q)}
@end ifnottex

@end itemize

@noindent @strong{EXAMPLE}

@example
@GETDEMO{qnos,1}
@print{} R_s =  1.4062
@print{} N =  4.2186
@end example

@noindent @strong{REFERENCES}

@noindent G. Bolch, S. Greiner, H. de Meer and K. Trivedi, @cite{Queueing
Networks and Markov Chains: Modeling and Performance Evaluation with
Computer Science Applications}, Wiley, 1998.

@auindex Bolch, G.
@auindex Greiner, S.
@auindex de Meer, H.
@auindex Trivedi, K.

@c
@c Closed Networks
@c
@subsection Closed Networks

@GETHELP{qncsmva}

@noindent @strong{REFERENCES}

@noindent M. Reiser and S. S. Lavenberg, @cite{Mean-Value Analysis of Closed
Multichain Queuing Networks}, Journal of the ACM, vol. 27, n. 2, April
1980, pp. 313--322. @uref{http://doi.acm.org/10.1145/322186.322195, 10.1145/322186.322195}

@auindex Reiser, M.
@auindex Lavenberg, S. S.

This implementation is described in R. Jain , @cite{The Art of
Computer Systems Performance Analysis}, Wiley, 1991, p. 577.
Multi-server nodes are treated according to G. Bolch, S. Greiner,
H. de Meer and K. Trivedi, @cite{Queueing Networks and Markov Chains:
Modeling and Performance Evaluation with Computer Science
Applications}, Wiley, 1998, Section 8.2.1, "Single Class Queueing
Networks".

@auindex Jain, R.
@auindex Bolch, G.
@auindex Greiner, S.
@auindex de Meer, H.
@auindex Trivedi, K.

@noindent @strong{EXAMPLE}

@example
@GETDEMO{qncsmva,1}
@end example

@c
@c MVA for single class, closed networks with load dependent servers
@c
@GETHELP{qncsmvald}

@noindent @strong{REFERENCES}

@noindent M. Reiser and S. S. Lavenberg, @cite{Mean-Value Analysis of Closed
Multichain Queuing Networks}, Journal of the ACM, vol. 27, n. 2,
April 1980, pp. 313--322. @uref{http://doi.acm.org/10.1145/322186.322195, 10.1145/322186.322195}

This implementation is described in G. Bolch, S. Greiner, H. de Meer
and K. Trivedi, @cite{Queueing Networks and Markov Chains: Modeling
and Performance Evaluation with Computer Science Applications}, Wiley,
1998, Section 8.2.4.1, ``Networks with Load-Deèpendent Service: Closed
Networks''.

@auindex Bolch, G.
@auindex Greiner, S.
@auindex de Meer, H.
@auindex Trivedi, K.

@c
@c CMVA for single class, closed networks with a single load dependent servers
@c
@GETHELP{qncscmva}

@noindent @strong{REFERENCES}

@noindent G. Casale. @cite{A note on stable flow-equivalent aggregation in
closed networks}. Queueing Syst. Theory Appl., 60:193–-202, December
2008, @uref{http://dx.doi.org/10.1007/s11134-008-9093-6, 10.1007/s11134-008-9093-6}

@auindex Casale, G.

@c
@c Approximate MVA for single class, closed networks
@c

@GETHELP{qncsmvaap}

@noindent @strong{REFERENCES}

This implementation is based on Edward D. Lazowska, John Zahorjan,
G. Scott Graham, and Kenneth C. Sevcik, @cite{Quantitative System
Performance: Computer System Analysis Using Queueing Network Models},
Prentice Hall,
1984. @url{http://www.cs.washington.edu/homes/lazowska/qsp/}. In
particular, see section 6.4.2.2 ("Approximate Solution Techniques").

@auindex Lazowska, E. D.
@auindex Zahorjan, J.
@auindex Graham, G. S.
@auindex Sevcik, K. C.

@c
@c Convolution
@c

According to the BCMP theorem, the state probability of a closed
single class queueing network with @math{K} nodes and @math{N} requests
can be expressed as:

@iftex
@tex
$$ \pi(k_1, k_2, \ldots, k_K) = {1 \over G(N)} \prod_{i=1}^N F_i(k_i) $$
@end tex
@end iftex
@ifnottex
@example
@group
k = [k1, k2, @dots{} kn]; @r{population vector}
p = 1/G(N+1) \prod F(i,k);
@end group
@end example
@end ifnottex

Here @math{\pi(k_1, k_2, \ldots, k_K)} is the joint probability of
having @math{k_i} requests at node @math{i}, for all @math{i=1, 2,
\ldots, K}.

The @emph{convolution algorithms} computes the normalization constants
@math{{\bf G} = \left(G(0), G(1), \ldots, G(N)\right)} for single-class, closed networks
with @math{N} requests.  The normalization constants are returned as
vector @code{@var{G}=[@var{G}(1), @var{G}(2), @dots{} @var{G}(N+1)]} where
@code{@var{G}(i+1)} is the value of @math{G(i)} (remember that Octave
uses 1-base vectors). The normalization constant can be used to
compute all performance measures of interest (utilization, average
response time and so on).

@command{queueing} implements the convolution algorithm, in the function
@command{qncsconv} and @command{qncsconvld}. The first one
supports single-station nodes, multiple-station nodes and IS nodes.
The second one supports networks with general load-dependent service
centers.


@GETHELP{qncsconv}

@noindent @strong{NOTE}

For a network with @math{K} service centers and @math{N} requests,
this implementation of the convolution algorithm has time and space
complexity @math{O(NK)}.

@noindent @strong{REFERENCES}

Jeffrey P. Buzen, @cite{Computational Algorithms for Closed Queueing
Networks with Exponential Servers}, Communications of the ACM, volume
16, number 9, september 1973,
pp. 527--531. @uref{http://doi.acm.org/10.1145/362342.362345, 10.1145/362342.362345}

@auindex Buzen, J. P.

This implementation is based on G. Bolch, S. Greiner, H. de Meer and
K. Trivedi, @cite{Queueing Networks and Markov Chains: Modeling and
Performance Evaluation with Computer Science Applications}, Wiley,
1998, pp. 313--317.

@auindex Bolch, G.
@auindex Greiner, S.
@auindex de Meer, H.
@auindex Trivedi, K.

@noindent @strong{EXAMPLE}

The normalization constant @math{G} can be used to compute the
steady-state probabilities for a closed single class product-form
Queueing Network with @math{K} nodes. Let @code{@var{k}=[@math{k_1,
k_2, @dots{}, k_K}]} be a valid population vector. Then, the
steady-state probability @code{@var{p}(i)} to have @code{@var{k}(i)}
requests at service center @math{i} can be computed as:

@iftex
@tex
$$
p_i(k_i) = {(V_i S_i)^{k_i} \over G(K)} \left(G(K-k_i) - V_i S_i G(K-k_i-1)\right), \quad i=1, 2, \ldots, K
$$
@end tex
@end iftex

@example
@GETDEMO{qncsconv,1}
@print{} k(1)=1 prob=0.17975
@print{} k(2)=2 prob=0.48404
@print{} k(3)=0 prob=0.52779
@end example


@c
@GETHELP{qncsconvld}

@noindent @strong{REFERENCES}

@noindent Herb Schwetman, @cite{Some Computational Aspects of Queueing Network
Models}, Technical Report
@uref{http://www.cs.purdue.edu/research/technical_reports/1980/TR%2080-354.pdf,
CSD-TR-354}, Department of Computer Sciences, Purdue University, feb,
1981 (revised).

@auindex Schwetman, H.

@noindent M. Reiser, H. Kobayashi, @cite{On The Convolution Algorithm for
Separable Queueing Networks}, In Proceedings of the 1976 ACM
SIGMETRICS Conference on Computer Performance Modeling Measurement and
Evaluation (Cambridge, Massachusetts, United States, March 29--31,
1976). SIGMETRICS '76. ACM, New York, NY,
pp. 109--117. @uref{http://doi.acm.org/10.1145/800200.806187, 10.1145/800200.806187}

@auindex Reiser, M.
@auindex Kobayashi, H.

This implementation is based on G. Bolch, S. Greiner, H. de Meer and
K. Trivedi, @cite{Queueing Networks and Markov Chains: Modeling and
Performance Evaluation with Computer Science Applications}, Wiley,
1998, pp. 313--317. Function @command{qncsconvld} is slightly
different from the version described in Bolch et al. because it
supports general load-dependent centers (while the version in the book
does not). The modification is in the definition of function
@code{F()} in @command{qncsconvld} which has been made similar to
function @math{f_i} defined in Schwetman, @cite{Some Computational
Aspects of Queueing Network Models}.

@auindex Bolch, G.
@auindex Greiner, S.
@auindex de Meer, H.
@auindex Trivedi, K.

@c
@c
@c
@subsection Non Product-Form QNs
@anchor{Non Product-Form QNs}
@c
@c MVABLO algorithm for approximate analysis of closed, single class
@c QN with blocking
@c
@GETHELP{qncsmvablo}

@noindent @strong{REFERENCES}

@noindent Ian F. Akyildiz, @cite{Mean Value Analysis for Blocking Queueing
Networks}, IEEE Transactions on Software Engineering, vol. 14, n. 2,
april 1988, pp. 418--428.  @uref{http://dx.doi.org/10.1109/32.4663, 10.1109/32.4663}

@auindex Akyildiz, I. F.

@GETHELP{qnmarkov}

@c
@c
@c
@node Multiple Class Models
@section Multiple Class Models

In multiple class QN models, we assume that there exist @math{C}
different classes of requests. Each request from class @math{c} spends
on average time @math{S_{c, k}} in service at service center
@math{k}. For open models, we denote with @math{{\bf \lambda} =
\lambda_{c, k}} the arrival rates, where @math{\lambda_{c, k}} is the
external arrival rate of class @math{c} customers at service center
@math{k}. For closed models, we denote with @math{{\bf N} = (N_1, N_2,
\ldots, N_C)} the population vector, where @math{N_c} is the number of
class @math{c} requests in the system.

The transition probability matrix for these kind of networks will be a
@math{C \times K \times C \times K} matrix @math{{\bf P} = [P_{r, i, s, j}]}
such that @math{P_{r, i, s, j}} is the probability that a class
@math{r} request which completes service at center @math{i} will join
server @math{j} as a class @math{s} request.

Model input and outputs can be adjusted by adding additional indexes
for the customer classes.

@noindent @strong{Model Inputs}

@table @math

@item @lambdack
(open networks) External arrival rate of class-@math{c} requests to service center @math{k}

@item @lambda
(open networks) Overall external arrival rate to the whole system: @math{\lambda = \sum_c \sum_k \lambda_{c, k}}

@item N_c
(closed networks) Number of class @math{c} requests in the system.

@item S_{c, k}
Average service time. @math{S_{c, k}} is the average service time on
service center @math{k} for class @math{c} requests.

@item P_{r, i, s, j}
Routing probability matrix. @math{{\bf P} = [P_{r, i, s, j}]} is a @math{C
\times K \times C \times K} matrix such that @math{P_{r, i, s, j}} is
the probability that a class @math{r} request which completes service
at server @math{i} will move to server @math{j} as a class @math{s}
request.

@item V_{c, k}
Mean number of visits of class @math{c} requests to center @math{k}.

@end table

@noindent @strong{Model Outputs}

@table @math

@item U_{c, k}
Utilization of service center @math{k} by class @math{c} requests. The
utilization is defined as the fraction of time in which the resource
is busy (i.e., the server is processing requests).  If center @math{k}
is a single-server or multiserver node, then 
@math{0 \leq U_{c, k} \leq 1}. 
If center @math{k} is an infinite server node (delay
center), then @math{U_{c, k}} denotes the @emph{traffic intensity} and
is defined as @math{U_{c, k} = X_{c, k} S_{c, k}}; in this case the
utilization may be greater than one.

@item R_{c, k}
Average response time experienced by class @math{c} requests on service
center @math{k}. The average response time is defined as the average
time between the arrival of a customer in the queue, and the completion
of service.

@item Q_{c, k}
Average number of class @math{c} requests on service center
@math{k}. This includes both the requests in the queue, and the request
being served.

@item X_{c, k}
Throughput of service center @math{k} for class @math{c} requests.  The
throughput is defined as the rate of completion of class @math{c}
requests.

@end table

@noindent It is possible to define aggregate performance measures as follows:

@table @math

@item U_k
Utilization of service center @math{k}:
@iftex
@tex
$U_k = \sum_{c=1}^C U_{c, k}$
@end tex
@end iftex
@ifnottex
@code{Uk = sum(U,k);}
@end ifnottex

@item R_c
System response time for class @math{c} requests:
@iftex
@tex
$R_c = \sum_{k=1}^K R_{c, k} V_{c, k}$
@end tex
@end iftex
@ifnottex
@code{Rc = sum( V.*R, 1 );}
@end ifnottex

@item Q_c
Average number of class @math{c} requests in the system:
@iftex
@tex
$Q_c = \sum_{k=1}^K Q_{c, k}$
@end tex
@end iftex
@ifnottex
@code{Qc = sum( Q, 2 );}
@end ifnottex

@item X_c
Class @math{c} throughput:
@iftex
@tex
$X_c = X_{c, 1} / V_{c, 1}$
@end tex
@end iftex
@ifnottex
@code{Xc = X(:,1) ./ V(:,1);}
@end ifnottex

@end table

For closed networks, we can define the visit ratios @math{V_{s, j}}
for class @math{s} customers at service center @math{j} as follows:

@iftex
@tex
$$\left\{\eqalign{ V_{s, j} & = \sum_{r=1}^C \sum_{i=1}^K V_{r, i} P_{r, i, s, j}, \quad s=1, \ldots, C, j=1, \ldots, K \cr
                   V_{s, r_s} & = 1 \quad s=1, \ldots, C}\right. $$
@end tex
@end iftex
@ifnottex
@group
V_sj = sum_r sum_i V_ri P_risj    s=1,...,C, j=1,...,K
V_s r_s = 1                       s=1,...,C
@end group
@end ifnottex

@noindent where @math{r_s} is the class @math{s}
reference station. Similarly to single class models, the traffic
equation for closed multiclass networks can be solved up to
multiplicative constants unless we choose one reference station for
each closed chain class and set its visit ratio to 1.

For open networks the traffic equations are as follows:

@iftex
@tex
$$V_{s, j} = P_{0, s, j} + \sum_{r=1}^C \sum_{i=1}^K V_{r, i} P_{r, i, s, j} \quad s=1, \ldots, C, j=1, \ldots, K$$
@end tex
@end iftex
@ifnottex
@group
V_sj = P_0sj + sum_r sum_i V_ri P_risj  s=1,...,C, j=1,...,K
@end group
@end ifnottex

@noindent where @math{P_{0, s, j}} is the probability that an external
arrival goes to service center @math{j} as a class-@math{s} request.
If @math{\lambda_{s, j}} is the external arrival rate of class
@math{s} requests to service center @math{j}, and @math{\lambda =
\sum_s \sum_j \lambda_{s, j}} is the overall external arrival rate,
then @math{P_{0, s, j} = \lambda_{s, j} / \lambda}.

@GETHELP{qncmvisits}

@GETHELP{qnomvisits}

@c
@c Open Networks
@c
@subsection Open Networks

@c
@c Open network with multiple classes
@c
@GETHELP{qnom}

@noindent @strong{REFERENCES}

@noindent Edward D. Lazowska, John Zahorjan, G. Scott Graham, and Kenneth C.
Sevcik, @cite{Quantitative System Performance: Computer System
Analysis Using Queueing Network Models}, Prentice Hall,
1984. @url{http://www.cs.washington.edu/homes/lazowska/qsp/}. In
particular, see section 7.4.1 ("Open Model Solution Techniques").

@auindex Lazowska, E. D.
@auindex Zahorjan, J.
@auindex Graham, G. S.
@auindex Sevcik, K. C.


@subsection Closed Networks

@c
@GETHELP{qncmpopmix}

@noindent @strong{REFERENCES}

@noindent Herb Schwetman, @cite{Implementing the Mean Value Algorithm for the
Solution of Queueing Network Models}, Technical Report
@uref{http://www.cs.purdue.edu/research/technical_reports/1980/TR
80-355.pdf, CSD-TR-355},
Department of Computer Sciences, Purdue University, feb 15, 1982,

Note that the slightly different problem of generating all tuples
@math{k_1, k_2, \ldots, k_N} such that @math{\sum_i k_i = k} and
@math{k_i} are nonnegative integers, for some fixed integer @math{k
@geq{} 0} has been described in S. Santini, @cite{Computing the
Indices for a Complex Summation}, unpublished report, available at
@url{http://arantxa.ii.uam.es/~ssantini/writing/notes/s668_summation.pdf}

@auindex Schwetman, H.
@auindex Santini, S.

@c
@GETHELP{qncmnpop}

@noindent @strong{REFERENCES}

@noindent Zahorjan, J. and Wong, E. @cite{The solution of separable queueing
network models using mean value analysis}. SIGMETRICS
Perform. Eval. Rev. 10, 3 (Sep. 1981), 80-85. DOI
@uref{http://doi.acm.org/10.1145/1010629.805477, 10.1145/1010629.805477}

@auindex Zahorjan, J.
@auindex Wong, E.

@c
@c MVA for multiple class, closed networks
@c
@GETHELP{qncmmva}

@noindent @strong{NOTE}

Given a network with @math{K} service centers, @math{C} job classes
and population vector @math{{\bf N}=(N_1, N_2, \ldots, N_C)}, the MVA
algorithm requires space @math{O(C \prod_i (N_i + 1))}. The time
complexity is @math{O(CK\prod_i (N_i + 1))}. This implementation is
slightly more space-efficient (see details in the code). While the
space requirement can be mitigated by using some optimizations, the
time complexity can not. If you need to analyze large closed networks
you should consider the @command{qncmmvaap} function, which implements
the approximate MVA algorithm. Note however that @command{qncmmvaap}
will only provide approximate results.


@noindent @strong{REFERENCES}

@noindent M. Reiser and S. S. Lavenberg, @cite{Mean-Value Analysis of Closed
Multichain Queuing Networks}, Journal of the ACM, vol. 27, n. 2, April
1980, pp. 313--322. @uref{http://doi.acm.org/10.1145/322186.322195, 10.1145/322186.322195}

@auindex Reiser, M.
@auindex Lavenberg, S. S.

This implementation is based on G. Bolch, S. Greiner, H. de Meer and
K. Trivedi, @cite{Queueing Networks and Markov Chains: Modeling and
Performance Evaluation with Computer Science Applications}, Wiley,
1998 and Edward D. Lazowska, John Zahorjan, G. Scott Graham, and
Kenneth C. Sevcik, @cite{Quantitative System Performance: Computer
System Analysis Using Queueing Network Models}, Prentice Hall,
1984. @url{http://www.cs.washington.edu/homes/lazowska/qsp/}. In
particular, see section 7.4.2.1 ("Exact Solution Techniques").

@auindex Bolch, G.
@auindex Greiner, S.
@auindex de Meer, H.
@auindex Trivedi, K.
@auindex Lazowska, E. D.
@auindex Zahorjan, J.
@auindex Graham, G. S.
@auindex Sevcik, K. C.

@c
@c Approximate MVA, with Bard-Schweitzer approximation
@c
@GETHELP{qncmmvaap}

@noindent @strong{REFERENCES}

@noindent Y. Bard, @cite{Some Extensions to Multiclass Queueing Network Analysis},
proc. 4th Int. Symp. on Modelling and Performance Evaluation of
Computer Systems, feb. 1979, pp. 51--62.

@auindex Bard, Y.

@noindent P. Schweitzer, @cite{Approximate Analysis of Multiclass Closed
Networks of Queues}, Proc. Int. Conf. on Stochastic Control and
Optimization, jun 1979, pp. 25--29.

@auindex Schweitzer, P.

This implementation is based on Edward D. Lazowska, John Zahorjan, G.
Scott Graham, and Kenneth C. Sevcik, @cite{Quantitative System
Performance: Computer System Analysis Using Queueing Network Models},
Prentice Hall,
1984. @url{http://www.cs.washington.edu/homes/lazowska/qsp/}.  In
particular, see section 7.4.2.2 ("Approximate Solution
Techniques"). This implementation is slightly different from the one
described above, as it computes the average response times @math{R}
instead of the residence times.

@auindex Lazowska, E. D.
@auindex Zahorjan, J.
@auindex Graham, G. S.
@auindex Sevcik, K. C.

@subsection Mixed Networks

@c
@c MVA for mixed networks
@c
@GETHELP{qnmix}

@noindent @strong{REFERENCES}

@noindent Edward D. Lazowska, John Zahorjan, G. Scott Graham, and Kenneth C.
Sevcik, @cite{Quantitative System Performance: Computer System
Analysis Using Queueing Network Models}, Prentice Hall,
1984. @url{http://www.cs.washington.edu/homes/lazowska/qsp/}. In
particular, see section 7.4.3 ("Mixed Model Solution Techniques").
Note that in this function we compute the mean response time @math{R}
instead of the mean residence time as in the reference.

@auindex Lazowska, E. D.
@auindex Zahorjan, J.
@auindex Graham, G. S.
@auindex Sevcik, K. C.

@noindent Herb Schwetman, @cite{Implementing the Mean Value Algorithm for the
Solution of Queueing Network Models}, Technical Report
@uref{http://www.cs.purdue.edu/research/technical_reports/1980/TR%2080-355.pdf,
CSD-TR-355}, Department of Computer Sciences, Purdue University, feb
15, 1982,

@auindex Schwetman, H.

@c
@c
@c
@node Generic Algorithms
@section Generic Algorithms

The @code{queueing} package provides a high-level function
@command{qnsolve} for analyzing QN models. @command{qnsolve} takes as
input a high-level description of the queueing model, and delegates
the actual solution of the model to one of the lower-level
function. @command{qnsolve} supports single or multiclass models, but at
the moment only product-form networks can be analyzed. For non
product-form networks @xref{Non Product-Form QNs}.

@command{qnsolve} accepts two input parameters. The first one is the list
of nodes, encoded as an Octave @emph{cell array}. The second parameter
is the vector of visit ratios @var{V}, which can be either a vector
(for single-class models) or a two-dimensional matrix (for
multiple-class models).

Individual nodes in the network are structures build using the
@command{qnmknode} function.

@GETHELP{qnmknode}

After the network has been defined, it is possible to solve it using
@command{qnsolve}.

@GETHELP{qnsolve}

@noindent @strong{EXAMPLE}

Let us consider a closed, multiclass network with @math{C=2} classes
and @math{K=3} service center. Let the population be @math{M=(2, 1)}
(class 1 has 2 requests, and class 2 has 1 request). The nodes are as
follows:

@itemize

@item Node 1 is a @math{M/M/1}--FCFS node, with load-dependent service
times. Service times are class-independent, and are defined by the
matrix @code{[0.2 0.1 0.1; 0.2 0.1 0.1]}. Thus, @code{@var{S}(1,2) =
0.2} means that service time for class 1 customers where there are 2
requests in 0.2. Note that service times are class-independent;

@item Node 2 is a @math{-/G/1}--PS node, with service times
@math{S_{1, 2} = 0.4} for class 1, and @math{S_{2, 2} = 0.6} for class 2
requests;

@item Node 3 is a @math{-/G/\infty} node (delay center), with service
times @math{S_{1, 3}=1} and @math{S_{2, 3}=2} for class 1 and 2
respectively.

@end itemize

After defining the per-class visit count @var{V} such that
@code{@var{V}(c,k)} is the visit count of class @math{c} requests to
service center @math{k}.  We can define and solve the model as
follows:

@example


@GETDEMO{qnsolve,1}
@end example

@GETHELP{qnclosed}

@noindent @strong{EXAMPLE}

@example
@GETDEMO{qnclosed,1}
@end example

@GETHELP{qnopen}


@c
@c
@c
@node Bounds Analysis
@section Bounds Analysis

@c
@GETHELP{qnosaba}

@GETHELP{qnomaba}

@c
@GETHELP{qncsaba}

@GETHELP{qncmaba}

@noindent @strong{REFERENCES}

@noindent Edward D. Lazowska, John Zahorjan, G.  Scott Graham, and Kenneth
C. Sevcik, @cite{Quantitative System Performance: Computer System
Analysis Using Queueing Network Models}, Prentice Hall,
1984. @url{http://www.cs.washington.edu/homes/lazowska/qsp/}. In
particular, see section 5.2 ("Asymptotic Bounds").

@auindex Lazowska, E. D.
@auindex Zahorjan, J.
@auindex Graham, G. S.
@auindex Sevcik, K. C.

@c
@GETHELP{qnosbsb}

@c
@GETHELP{qncsbsb}

@GETHELP{qncmbsb}

@noindent @strong{REFERENCES}

@noindent Edward D. Lazowska, John Zahorjan, G.  Scott Graham, and Kenneth
C. Sevcik, @cite{Quantitative System Performance: Computer System
Analysis Using Queueing Network Models}, Prentice Hall,
1984. @url{http://www.cs.washington.edu/homes/lazowska/qsp/}. In
particular, see section 5.4 ("Balanced Systems Bounds").

@auindex Lazowska, E. D.
@auindex Zahorjan, J.
@auindex Graham, G. S.
@auindex Sevcik, K. C.

@GETHELP{qncmcb}

@noindent @strong{REFERENCES}

@noindent Teemu Kerola, @cite{The Composite Bound Method (CBM) for Computing
Throughput Bounds in Multiple Class Environments}, Technical Report
CSD-TR-475, Department of Computer Sciences, Purdue University, mar 13,
1984 (Revised aug 27, 1984).

@auindex Kerola, T.

@c
@GETHELP{qncspb}

@noindent @strong{REFERENCES}

The original paper describing PB Bounds is C. H. Hsieh and S. Lam,
@cite{Two classes of performance bounds for closed queueing networks},
PEVA, vol. 7, n. 1, pp. 3--30, 1987

This function implements the non-iterative variant described in G.
Casale, R. R. Muntz, G. Serazzi, @cite{Geometric Bounds: a
Non-Iterative Analysis Technique for Closed Queueing Networks}, IEEE
Transactions on Computers, 57(6):780-794, June 2008.

@auindex Hsieh, C. H
@auindex Lam, S.
@auindex Casale, G.
@auindex Muntz, R. R.
@auindex Serazzi, G.

@c
@GETHELP{qncsgb}

@noindent @strong{REFERENCES}

@noindent G. Casale, R. R. Muntz, G. Serazzi,
@cite{Geometric Bounds: a Non-Iterative Analysis Technique for Closed
Queueing Networks}, IEEE Transactions on Computers, 57(6):780-794,
June 2008. @uref{http://doi.ieeecomputersociety.org/10.1109/TC.2008.37, 10.1109/TC.2008.37}

@auindex Casale, G.
@auindex Muntz, R. R.
@auindex Serazzi, G.

In this implementation we set @math{X^+} and @math{X^-} as the upper
and lower Asymptotic Bounds as computed by the @command{qncsab}
function, respectively.


@c
@c Examples
@c

@node QN Analysis Examples
@section QN Analysis Examples

In this section we illustrate with a few examples how the
@code{queueing} package can be used to evaluate queueing network
models. Further examples can be found in the demo blocks of the
functions described in this section, and can be accessed with the
@code{demo @emph{function}} Octave command.

@subsection Closed, Single Class Network

We now give a simple example on how the queueing toolbox can be used
to analyze a closed network. Let us consider again the network shown
in @ref{fig:qn_closed_single}. We denote with @math{S_k} the average
service time at center @math{k}, @math{k=1, 2, 3}. We use @math{S_1 =
1.0}, @math{S_2 = 2.0} and @math{S_3 = 0.8}. The routing of jobs
within the network is described with a @emph{routing probability
matrix} @math{\bf P}. Specifically, a request completing service at
center @math{i} is enqueued at center @math{j} with probability
@math{P_{i, j}}.  We use the following routing matrix:

@iftex
@tex
$$
P = \pmatrix{ 0 & 0.3 & 0.7 \cr
              1 & 0 & 0 \cr
              1 & 0 & 0 }
$$
@end tex
@end iftex
@ifnottex
@example
    / 0  0.3  0.7 \
P = | 1  0    0   |
    \ 1  0    0   /
@end example
@end ifnottex

The network above can be analyzed with the @command{qnclosed} function
@pxref{doc-qnclosed}. @command{qnclosed} requires the following
parameters:

@table @var

@item N
Number of requests in the network (since we are considering a closed
network, the number of requests is fixed)

@item S
Array of average service times at the centers: @code{@var{S}(k)} is
the average service time at center @math{k}.

@item V
Array of visit ratios: @code{@var{V}(k)} is the average number of
visits to center @math{k}.

@end table

We can compute @math{V_k} from the routing probability matrix
@math{P_{i, j}} using the @command{qncsvisits} function
@pxref{doc-qncsvisits}.  We can analyze the network for a given
population size @math{N} (for example, @math{N=10}) as follows:

@example
@group
@kbd{N = 10;}
@kbd{S = [1 2 0.8];}
@kbd{P = [0 0.3 0.7; 1 0 0; 1 0 0];}
@kbd{V = qncsvisits(P);}
@kbd{[U R Q X] = qnclosed( N, S, V )}
   @result{} U = 0.99139 0.59483 0.55518
   @result{} R = 7.4360  4.7531  1.7500
   @result{} Q = 7.3719  1.4136  1.2144
   @result{} X = 0.99139 0.29742 0.69397
@end group
@end example

The output of @command{qnclosed} includes the vector of utilizations
@math{U_k} at center @math{k}, response time @math{R_k}, average
number of customers @math{Q_k} and throughput @math{X_k}. In our
example, the throughput of center 1 is @math{X_1 = 0.99139}, and the
average number of requests in center 3 is @math{Q_3 = 1.2144}. The
utilization of center 1 is @math{U_1 = 0.99139}, which is the higher
value among the service centers. Tus, center 1 is the @emph{bottleneck
device}.

This network can also be analyzed with the @command{qnsolve} function
@pxref{doc-qnsolve}. @command{qnsolve} can handle open, closed or
mixed networks, and allows the network to be described in a very
flexible way.  First, let @var{Q1}, @var{Q2} and @var{Q3} be the
variables describing the service centers. Each variable is
instantiated with the @command{qnmknode} function.

@example
@group
@kbd{Q1 = qnmknode( "m/m/m-fcfs", 1 );}
@kbd{Q2 = qnmknode( "m/m/m-fcfs", 2 );}
@kbd{Q3 = qnmknode( "m/m/m-fcfs", 0.8 );}
@end group
@end example

The first parameter of @command{qnmknode} is a string describing the
type of the node. Here we use @code{"m/m/m-fcfs"} to denote a
@math{M/M/m}--FCFS center. The second parameter gives the average
service time. An optional third parameter can be used to specify the
number @math{m} of service centers. If omitted, it is assumed
@math{m=1} (single-server node).

Now, the network can be analyzed as follows:

@example
@group
@kbd{N = 10;}
@kbd{V = [1 0.3 0.7];}
@kbd{[U R Q X] = qnsolve( "closed", N, @{ Q1, Q2, Q3 @}, V )}
   @result{} U = 0.99139 0.59483 0.55518
   @result{} R = 7.4360  4.7531  1.7500
   @result{} Q = 7.3719  1.4136  1.2144
   @result{} X = 0.99139 0.29742 0.69397
@end group
@end example

@subsection Open, Single Class Network

Open networks can be analyzed in a similar way. Let us consider
an open network with @math{K=3} service centers, and routing
probability matrix as follows:

@iftex
@tex
$$
P = \pmatrix{ 0 & 0.3 & 0.5 \cr
              1 & 0 & 0 \cr
              1 & 0 & 0 }
$$
@end tex
@end iftex
@ifnottex
@example
    / 0  0.3  0.5 \
P = ! 1  0    0   |
    \ 1  0    0   /
@end example
@end ifnottex

In this network, requests can leave the system from center 1 with
probability @math{1-(0.3+0.5) = 0.2}. We suppose that external jobs
arrive at center 1 with rate @math{\lambda_1 = 0.15}; there are no
arrivals at centers 2 and 3.

Similarly to closed networks, we first need to compute the visit
counts @math{V_k} to center @math{k}. We use the
@command{qnosvisits} function as follows:

@example
@group
@kbd{P = [0 0.3 0.5; 1 0 0; 1 0 0];}
@kbd{lambda = [0.15 0 0];}
@kbd{V = qnosvisits(P, lambda)}
   @result{} V = 5.00000 1.50000 2.50000
@end group
@end example

@noindent where @code{@var{lambda}(k)} is the arrival rate at center @math{k},
and @var{P} is the routing matrix. Assuming the same service times as
in the previous example, the network can be analyzed with the
@command{qnopen} function @pxref{doc-qnopen}, as follows:

@example
@group
@kbd{S = [1 2 0.8];}
@kbd{[U R Q X] = qnopen( sum(lambda), S, V )}
   @result{} U = 0.75000 0.45000 0.30000
   @result{} R = 4.0000  3.6364  1.1429
   @result{} Q = 3.00000 0.81818 0.42857
   @result{} X = 0.75000 0.22500 0.37500
@end group
@end example

The first parameter of the @command{qnopen} function is the (scalar)
aggregate arrival rate.

Again, it is possible to use the @command{qnsolve} high-level function:

@example
@group
@kbd{Q1 = qnmknode( "m/m/m-fcfs", 1 );}
@kbd{Q2 = qnmknode( "m/m/m-fcfs", 2 );}
@kbd{Q3 = qnmknode( "m/m/m-fcfs", 0.8 );}
@kbd{lambda = [0.15 0 0];}
@kbd{[U R Q X] = qnsolve( "open", sum(lambda), @{ Q1, Q2, Q3 @}, V )}
   @result{} U = 0.75000 0.45000 0.30000
   @result{} R = 4.0000  3.6364  1.1429
   @result{} Q = 3.00000 0.81818 0.42857
   @result{} X = 0.75000 0.22500 0.37500
@end group
@end example

@subsection Closed Multiclass Network/1

The following example is taken from Herb Schwetman, @cite{Implementing
the Mean Value Algorith for the Solution of Queueing Network Models},
Technical Report CSD-TR-355, Department of Computer Sciences, Purdue
University, feb 15, 1982.

We consider the following multiclass QN with three servers and two classes

@float Figure,fig:apl
@center @image{qn_closed_multi_apl}
@end float

Servers 1 and 2 (labeled @emph{APL} and @emph{IMS}, respectively) are
infinite server nodes; server 3 (labeled @emph{SYS}) is Processor
Sharing (PS). Mean service times are given in the following table:

@multitable @columnfractions .15 .15 .15 .15
@headitem @tab  APL @tab IMS @tab SYS
@item Class 1 @tab 1 @tab - @tab 0.025
@item Class 2 @tab - @tab 15 @tab 0.500
@end multitable

There is no class switching. If  we assume a population of 15 requests
for  class 1,  and  5 requests  for class  2,  then the  model can  be
analyzed as follows:

@example
@GETDEMO{qncmmva,2}
  @result{}
U =

   14.32312    0.00000    0.35808
    0.00000    4.70699    0.15690

R =

    1.00000    0.00000    0.04726
    0.00000   15.00000    0.93374

Q =

   14.32312    0.00000    0.67688
    0.00000    4.70699    0.29301

X =

   14.32312    0.00000   14.32312
    0.00000    0.31380    0.31380
@end example

@subsection Closed Multiclass Network/2

The following example is taken from M. Marzolla, @cite{The qnetworks
Toolbox: A Software Package for Queueing Networks Analysis}, Technical
Report
@uref{http://www.informatica.unibo.it/ricerca/technical-report/2010/UBLCS-2010-04,
UBLCS-2010-04}, Department of Computer Science, University of Bologna,
Italy, February 2010.


@float Figure,fig:web_model
@center @image{qn_web_model,3in}
@caption{Three-tier enterprise system model}
@end float

The model shown in @ref{fig:web_model} shows a three-tier enterprise system
with @math{K=6} service centers. The first tier contains the 
@emph{Web server} (node 1), which is responsible for generating Web pages and
transmitting them to clients. The application logic is implemented by
nodes 2 and 3, and the storage tier is made of nodes 4--6.The system
is subject to two workload classes, both represented as closed
populations of @math{N_1} and @math{N_2} requests, respectively. Let
@math{D_{c, k}} denote the service demand of class @math{c} requests
at center @math{k}. We use the parameter values:

@multitable @columnfractions .2 .33 .1 .1
@headitem Serv. no. @tab  Name @tab Class 1 @tab Class 2
@item 1 @tab Web Server    @tab 12 @tab 2
@item 2 @tab App. Server 1 @tab 14 @tab 20
@item 3 @tab App. Server 2 @tab 23 @tab 14
@item 4 @tab DB Server 1   @tab 20 @tab 90
@item 5 @tab DB Server 2   @tab 80 @tab 30
@item 6 @tab DB Server 3   @tab 31 @tab 33
@end multitable

We set the total number of requests to 100, that is @math{N_1 + N_2 =
N = 100}, and we study how different population mixes @math{(N_1,
N_2)} affect the system throughput and response time. Let
@math{\beta_1 \in (0, 1)} denote the fraction of class 1 requests:
@math{N_1 = \beta_1 N}, @math{N_2 = (1-\beta_1)N}. The following
Octave code defines the model for @math{\beta_1 = 0.1}:

@example
@group
N = 100;     # total population size
beta1 = 0.1; # fraction of class 1 reqs.
S = [12 14 23 20 80 31; \
      2 20 14 90 30 33 ];
V = ones(size(S));
pop = [fix(beta1*N) N-fix(beta1*N)];
[U R Q X] = qncmmva(pop, S, V);
@end group
@end example

The @command{qncmmva(pop, S, V)} function invocation (line 7)
uses the multiclass MVA algorithm to compute per-class utilizations
@math{U_{c, k}}, response times @math{R_{c,k}}, mean queue lengths
@math{Q_{c,k}} and throughputs @math{X_{c,k}} at each service center
@math{k}, given a population vector @var{pop}, mean service times
@var{S} and visit ratios @var{V}. Since we are given the service
demands @math{D_{c, k} = S_{c, k} V_{c,k}}, but function
@command{qncmmva()} requires separate service times and visit
ratios, we set the service times equal to the demands (line 3--4), and
all visit ratios equal to one (line 5). Overall class and system
throughputs and response times can also be computed:

@example
@group
X1 = X(1,1) / V(1,1)     # class 1 throughput
        @result{} X1 =  0.0044219
X2 = X(2,1) / V(2,1)     # class 2 throughput
        @result{} X2 =  0.010128
XX = X1 + X2             # system throughput
        @result{} XX =  0.014550
R1 = dot(R(1,:), V(1,:)) # class 1 resp. time
        @result{} R1 =  2261.5
R2 = dot(R(2,:), V(2,:)) # class 2 resp. time
        @result{} R2 =  8885.9
RR = N / XX              # system resp. time
        @result{} RR =  6872.7
@end group
@end example

@code{dot(X,Y)} computes the dot product of two vectors.
@code{R(1,:)} is the first row of matrix @var{R} and @code{V(1,:)} is
the first row of matrix @var{V}, so @code{dot(R(1,:), V(1,:))}
computes @math{\sum_k R_{1,k} V_{1,k}}.

@float Figure,fig:web
@center @image{web,3in}
@caption{Throughput and Response Times as a function of the population mix}
@end float

We can also compute the system power @math{\Phi = X / R}, which
defines how efficiently resources are being used: high values of
@math{\Phi} denote the desirable situation of high throughput and low
response time. @ref{fig:power} shows @math{\Phi} as a function of
@math{\beta_1}. We observe a ``plateau'' of the global system power,
corresponding to values of @math{\beta_1} which approximately lie
between @math{0.3} and @math{0.7}. The per-class power exhibits an
interesting (although not completely surprising) pattern, where the
class with higher population exhibits worst efficiency as it produces
higher contention on the resources.

@float Figure,fig:power
@center @image{power,3in}
@caption{System Power as a function of the population mix}
@end float

@subsection Closed Multiclass Network/3

We now consider an example of multiclass network with class switching.
The example is taken from @ref{Sch82}, and is shown in Figure
@ref{fig:class_switching}.

@float Figure,fig:class_switching
@center @image{qn_closed_multi_cs,3in}
@caption{Multiclass Model with Class Switching}
@end float

The system consists of three devices and two job classes. The CPU node
is a PS server, while the two nodes labeled I/O are FCFS. Class 1 mean
service time at the CPU is 0.01; class 2 mean service time at the CPU
is 0.05. The mean service time at node 2 is 0.1, and is
class-independent. Similarly, the mean service time at node 3 is
0.07. Jobs in class 1 leave the CPU and join class 2 with probability
0.1; jobs of class 2 leave the CPU and join class 1 with probability
0.2. There are @math{N=3} jobs, which are initially allocated to class
1. However, note that since class switching is allowed, the total
number of jobs in each class does not remain constant; however the
total number of jobs does.

@example
@GETDEMO{qncmmva,3}
  @result{}
U =

   0.12609   0.61784   0.25218
   0.31522   0.13239   0.31522

R =

   0.014653   0.133148   0.163256
   0.073266   0.133148   0.163256

Q =

   0.18476   1.17519   0.41170
   0.46190   0.25183   0.51462

X =

   12.6089    8.8262    2.5218
    6.3044    1.8913    3.1522
@end example
