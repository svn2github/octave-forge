#!/usr/bin/awk -f

# Usage: change to the directory which has the files you want to convert
# then type oct2mat files.  This will convert all files in that directory,
# storing the output in /tmp/oct2mat/, auplot_points=1000; endif
#
# $Id$
# Copyright 2001,2002,2003,2004 Paul Kienzle
# Copyright 2010 Alois Schloegl 
# Copyright 2010 Jaroslav Hajek 
# This is part of Octave-Forge's Oct2Mat toolbox
#
# Goal: automatically convert most octave code so that it will run on matlab.
#    * Preferably, the code should run on matlab, but the lack of varargin
#    support makes this awkward for some functions.
#    * Code that isn't convertible automatically, should be marked as octave
#    specific or matlab specific.  Note that system specific code can be
#    selected at the time of preprocessing.
#    * I'm assuming primary development is done in octave, so it will not
#    need preprocessing.  Similarly, octave coding style and octave
#    features should not be compromised for the sake of translation.
#    * Translation should be possible on a machine without octave installed,
#    so no cheating and using the parse tree from within octave.
# Matlab specific and octave specific code
#    #<mat line -> line %<mat
#    line #<oct -> %<oct line
#    * So if something is specific to matlab, prefix the line with #<mat
#    and if it is specific to octave, postfix the line with #<oct.  This
#    can be used to replace ... with varargin, but it will not work for
#    very well for things like legend text in which only a bit of the
#    line needs to be changed.  This would require a proper preprocessor,
#    and would mean that all files would have to be preprocessed before
#    submitting them to either octave or matlab.
#    * Consider adding version specific flags: #<oct20 #<oct21 #<mat4 #<mat5
# Handles
#    ! -> ~
#    "str" -> 'str'
#    "s'r" -> 's''r'
#    endfunction ->
#    endblah -> end
#    # -> %
#    +=, -=, &=, |=, *=, /=, \=, ^=, .*=, ./=, .\=, .^=
#    k++; k--; simple form 
#    [0,blah()](1:n), [1:10](3:5)
#    blah()(1:n), (1:10)(3:5)
#    num2cell(1:n)(3:5), {1,2,3,4,5,6,7}(3:5)  
#    blah() -> blah
#    gset blah -> 
#    blah \<nl> -> blah ...<nl>
#    blah ( blah1 <nl> blah2 ) -> blah ( blah1 ...<nl> blah2 )
#    SEEK_SET, SEEK_CUR, SEEK_END -> -1, 0, 1
#    __error_text__ -> lasterr
# Support functions:
#    octave2matlab/*.m and octave2matlab/borrow/*.m 
#    Note: these routines should be run through octave2matlab
#    striplegend removes ;blah; from string
# Does not yet handle:
#    blah(k++), blah(k--);
#    __y -> y__
#    x=y=blah;   ->  y=blah; x=y;
#    function [x y]=blah -> function [x, y]=blah
#    global y=blah; -> global y; if isempty(y), y=blah; end
#    do a until (c);
#    end -> <nl>   if 'end' happens to be the end for the function def.
#    unwind_protect doblah unwind_protect_cleanup cleanblah end_unwind_protect
#        -> try doblah cleanblah catch cleanblah end
#        instead sends them all to null
#    fun(expr)(:) 
#    (expr)(:) 
# Does not handle octave's builtin variables
#    Ideally, references to globals would be eliminated entirely but that is
#    of course impossible (the halting problem and all that), so instead
#    any octave builtin variable that is referred to in the function must
#    be declared global at the start of the function.  This is tricky without
#    a parser.
# Does not handle plotting:
#    * In octave, title, xlabel, ylabel, grid, axis, etc. come before plot
#    but in matlab they come after.  This can be handled automatically
#    with a few functions:
#       octave_decorate to be called before title, xlabel, etc.:
#          if ishold and __octave_hold, hold('off') and clear __octave_hold
#          if ~ishold, axes;
#          set __octave_decorate
#       octave_plot to be called before plot:
#          if __octave_decorate and ~ishold 
#             hold('on'); set __octave_hold
#          clear __octave_decorate
#       octave_hold to be called before hold:
#          if __octave_hold, hold('off') and clear __octave_hold
#       octave_subplot to be called before subplot
#          clear __octave_decorate, __octave_hold
#    * Legends will be a problem.  Will have to strip them out of calls
#    to plot and add them back in calls to legend. This will need
#    a modified version of plot since it may be receiving its format
#    string as a variable.
#    * Matlab5 does not accept numbers in lieu of colours or symbols.  Could
#    be folded into the legend fixes if so inclined.
#    * matlab restores graph state automatically on the next plot, octave
#    generally does it manually while the plot is still displayed.  The
#    manual state restoration must not be executed under matlab, since it 
#    will modify the existing graph.  This is a prime candidate for #<oct
#    tags.
#    * figure(0) is not valid in matlab
# Variable argument/return lists:
#    Only possible in Matlab 5
#    Problems with va_arg() used as a parameter to a function call, since
#       cannot increment __idx until after the function call. Subsequent
#       va_arg() within the same function call will need __idx+1,__idx+2,...
#    function [...] = blah -> function [varargout] = blah
#    vrval(i)=blah -> varargout(i) = { blah }
#    function blah(blah,...) -> function blah(blah,varargin)
#    va_start() -> __idx = 1;
#    blah(va_arg()) -> blah(varargin(__idx))<nl> __idx = __idx+1;
#    [~,ix] = min(...) -> [tmp_o2m_,ix]=min(...)
# Comments and strings
#    * don't convert text therein, except of course for examples and text
#    destined for eval.  May need home-brew eval which does all the
#    translations herein.
#    * gets confused with transpose operator (which looks very much like a
#    string delimiter, so it isn't surprising).  Make sure transpose and
#    and strings don't appear on the same line of code or there may be
#    confusion
#  semicolon ";" 
#    can not distinguish between [..;..] and ... ;

function fixquotes(x)
{
  inquote=incomment=0;
  y="";
  for (i=1; i <= length(x); i++) {
    ch = substr(x,i,1);
## test scripts are in comment blocks, so process them anyway
#    if (incomment) 
#      y = y ch;
#    else 
    if (inquote)
      if (ch==quote_ch) {
	inquote=0;
	y = y "'";
      }
      else if (ch=="'") y = y ch ch;
      else y = y ch;
    else if (ch == "'") {
      inquote = 1;
      quote_ch = ch;
      y = y ch;
    }
    else if (ch == "\"") {
      inquote = 1;
      quote_ch = ch;
      y = y "'";
    }
    else if (ch == "%") {
      incomment = 1;
      y = y ch;
    }
    else y = y ch;
  }
  return y;
}

# given a string beginning with "{", "(" or "[", attempts to find 
# a matching "}", ")" or "]" w.r.t. nesting.
# Can also match backwards, i.e. }{, )( and ][.
function matching_paren(s) {
  if (length(s) == 0)
    return 0;
  lpar = substr(s, 0, 1);
  if (lpar == "{")
    rpar = "}";
  else if (lpar == "}")
    rpar = "{";
  else if (lpar == "(")
    rpar = ")";
  else if (lpar == ")")
    rpar = "(";
  else if (lpar == "[")
    rpar = "]";
  else if (lpar == "]")
    rpar = "[";
  else
    return 0;

  lev = 1;
  rem = substr(s, 2);
  while (lev > 0 && length(rem) > 0) {
    idxl = index(rem, lpar);
    idxr = index(rem, rpar);
    if (idxr > 0) {
      if (idxl > 0 && idxl < idxr) {
	lev += 1;
	rem = substr(rem, idxl+1);
      } else {
	lev -= 1;
	rem = substr(rem, idxr+1);
      }
    } else
      rem = "";
  }

  if (lev == 0)
    return length(s) - length(rem);
  else
    return 0;
}

function reverse(s)
{
  p = ""
  for(i=length(s); i > 0; i--) { p = p substr(s, i, 1) }
  return p
}

function tmpvarname()
{
  tmpcounter += 1;
  return "o2m_tmp_" tmpcounter
}

function subst_indexed_expr(line, rpos) {
  if (line ~ /\<while\>/) {
    bad = 1;
    print "cannot convert indexed expression in while() clause at line " NR >> "/tmp/oct2mat.log"
    return line;
  }

  ## strip leading whitespace.
  if (match(line, /^[ \t]+/)) {
    n = RLENGTH;
    spc = substr(line, 1, n);
    line = substr(line, n+1);
    return spc subst_indexed_expr(line, rpos - n);
  }

  par = substr(line, rpos, 1);
  lpiece = substr(line, 1, rpos);
  lpiece = reverse(lpiece);
  n = matching_paren(lpiece);
  if (n == 0) {
    bad = 1;
    print "couldn't find matching parenthesis at line " NR >> "/tmp/oct2mat.log"
    return line;
  }
  rem = substr(lpiece, n+1);

  ## check for a semicolon
  sem = index(rem, ";");
  if (sem > 0) {
    sem = length(lpiece) + 1 - (n + sem);
    lpart = substr(line, 1, sem);
    rpart = substr(line, sem+1);
    return lpart subst_indexed_expr(rpart, rpos - sem);
  }

  if (par == ")") {
    ## Attempt to include an indexed token.
    if (match(rem, /^[ \t]*\w+/))
      n += RLENGTH;
  }

  varname = tmpvarname();
  prestmt = varname " = " substr(line, rpos-n+1, n) ";\n";
  return prestmt substr(line, 1, rpos-n) varname substr(line, rpos+1);
}


#BEGIN { target=ENVIRON["HOME"] "/matlab/"; }
BEGIN { 
        target="/tmp/oct2mat/"; 
        ocnt = 0; 
	tmpcounter = 0;
	bad = 0;
	VarFunId = /[A-Za-z_][A-Za-z_0-9]+/; 
}

FNR==1 {
  if (file) { 
    if (file=="-") print body "\n" copyright;
    else print body "\n" copyright > file;
  }
  body=copyright="";
  if (FILENAME=="-") file="-"; else file=target FILENAME; 
  incopyright=0;
  print "Converting " FILENAME;
  print "--Converting " FILENAME >> "/tmp/oct2mat.log";
}

/^## Copyright/ { incopyright=1; }
/^$/ { incopyright=0; }
/^[^#]/ {incopyright=0; }

{

    if (sub("#<oct","")) $0 = "#<oct" $0;
    if (sub("#<mat","")) $0 = sprintf("%-73s#<mat",$0);
    #####  Extract comments ###################
    COMMENTS = ""; 
    if (match($0,/[#%]/)>0) {
            PosComment = RSTART; 
            if (substr($0,1,RSTART) ~ /["']/) {
                PosComment = 0; 
                StringOn = 0;
                i = 0; 
                DLM = "";
                prevChar = ",";
                while (PosComment == 0 && i<length($0)) {
                    i++;
                    c = substr($0,i,1);
                    if (StringOn == 0) {
                        if (c ~ /"/ || (c ~ /'/ && prevChar ~ /[= \t,;\n\r]/ ) ) {
                                StringOn = 1;
                                DLM = c; 
                        } 
                        else if (c ~ /[#%]/)        
                                PosComment = i;
                    } 
                    else if (StringOn == 1) {
                            if (c=="\\")
                                 i++;         #skip next character 
                            else if (c==DLM)
                                 StringOn = 0;         
                    }           
                    if (c !~ /[ \t]/) prevChar = c;
                }   
            }
            if (PosComment>0) {
                    ## Extract comments and remove them from $0 
                    COMMENTS = "%" substr($0,PosComment+1);
                    $0 = substr($0,1,PosComment-1);
            }        
    }                               

    gsub("[(][)]","");
    gsub("gset[^;%]*;","");
    gsub("gset[^;]*%","%");
    gsub("gset[^;]*$","");
    gsub("\\*\\*","^");         ## replace ** with ^ 
    
    #### replace DO ... UNTIL (COND); % comment -> WHILE(1) ... IF(COND) BREAK; ENDIF; ENDWHILE; %% comment    
    if ($0 ~ /\<do\>/) {
           $0 = gensub(/^([ \t]*)(do)([ \t]*)$/,"\\1while (1)\\3", "g");
    }        
    if ($0 ~ /\<until\>/) {
	$0 = gensub(/(^[ \t]*)(\<until\>)([^%]*)/,
	   "\\1if\\3 break; endif; endwhile; % while end ", "g");
        }

    #### replace "=dd.ee.(kk)" with "=getfield(dd.ee,kk)"  -------------- 
        $0 = gensub(/^([^=]*=[^=]*)(\<[[:alnum:]_\.]*)\.\((\<[^\(]*)\)/,"\\1getfield(\\2,\\3)", "g");
    #### replace "dd.ee.(kk) = vv;" with "setfield(dd.ee,kk,vv);"  -------------- 
        $0 = gensub(/^([ \t]*)(\<[[:alnum:]_.\]*)\.\((\<[^\(]*)\)[ \t]*=[ \t]*([^;]*);[ \t]*$/,"\\1setfield(\\2,\\3,\\4)", "g");
    
    gsub(/\<endfunction\>/,"");
    gsub(/\<endif\>/,"end");
    gsub(/\<endwhile\>/,"end");
    gsub(/\<endfor\>/,"end");
    gsub(/\<endswitch\>/,"end");
    gsub(/\<endclassdef\>/,"end");
    gsub(/\<end_try_catch\>/,"end");
    gsub(/\<struct_contains\>/,"isfield");
    gsub(/\<cell[ \t]*\([ \t]*\)[ \t]*;/, "{};");  ## cell() -> {}
    gsub("SEEK_CUR",0);
    gsub("SEEK_END",1);
    gsub("SEEK_SET",-1);
    gsub(/\<usage\>/,"error");
    gsub("__error_text__","lasterr");
    gsub("unwind_protect_cleanup","end");
    gsub("end_unwind_protect","");
    gsub("unwind_protect","try");
    gsub("!","~");
    gsub("[\\\\]$","..."); 

    #### multiple assignments a=b=c=d=e; ###############
    if ($0 ~ /[^;]+=[^;]+=[^;]+;/) {
        $0 = gensub(/([[:alpha:]_\(\)\{\}]+)([ \t]*=[ \t]*)([[:alnum:]_\(\)\{\}]+)([ \t]*=[ \t]*)([[:alnum:]_\(\)\{\}]+;)/,"\\3\\4\\5 \\1\\2\\3;","g");
        $0 = gensub(/([[:alpha:]_\(\)\{\}]+)([ \t]*=[ \t]*)([[:alnum:]_\(\)\{\}]+)([ \t]*=[ \t]*)([[:alnum:]_\(\)\{\}]+;)/,"\\3\\4\\5 \\1\\2\\3;","g");
        $0 = gensub(/([[:alpha:]_\(\)\{\}]+)([ \t]*=[ \t]*)([[:alnum:]_\(\)\{\}]+)([ \t]*=[ \t]*)([[:alnum:]_\(\)\{\}]+;)/,"\\3\\4\\5 \\1\\2\\3;","g");
    }     

    #############################################################
    # Special conversions - without claiming a general solution #
    # main/control/inst/rlocus.m
	#args{1,++kk} = real (rlpol (ii,:));
        $0 = gensub(/([ \t]*)([[:alpha:]_]\w*)\{1,\+\+([[:alpha:]_]\w*)\}([ \t]*=.*;$[ \t]*)/,"\\3 = \\3 + 1; \\2{1,\\3}\\4","g")

    # main/control/inst/rlocus.m
	#set (hplt(kk--), "markersize", 2);
        $0 = gensub(/(set \(hplt\(kk\-\-\), )\"(markersize|linewidth)\"(, 2\);)/,"set (hplt(kk), \"\\2\", 2); kk = kk - 1;","g")

    # main/optim/...
	#   nev(2) += 1;
	#   nev(2)++;
	$0 = gensub(/(^[ \t]*)(nev\([1-9]\))[ \t]*\+=[ \t]*([[:alnum:]_]+)[ \t]*(;[ \t]*$)/,
	   "\\1\\2 = \\2 + \\3\\4", "g");
	$0 = gensub(/(^[ \t]*)(nev\([1-9]\))[ \t]*\+\+[ \t]*(;[ \t]*$)/,
	   "\\1\\2 = \\2 + 1\\4", "g");

    #############################################################

    ## function and variable names starting with "_" (underscore): _fun -> o2m_tmp__fun    
    $0 = gensub(/(^|.*[^[:alnum:]_])(_\w)/,"\\1o2m_tmp_\\2","g");

    if (1) { ## EXPERIMENTAL ...
      if ($0 ~ /\+\+|--/) {
        ## substitute simple ++ and -- expressions like k++; x(k)++;

	#### y++; y(k)++; xx=++yy;
	$0 = gensub(/(^[ \t]*)(\w*[ \t]*=|)([ \t]*)([[:alpha:]_]\w*(\y|\(\w+\)))[ \t]*(\+\+)[ \t]*(;[ \t]*$)/,
	   "\\1\\2 \\4; \\3\\4 = \\4 + 1\\5", "g");
	$0 = gensub(/(^[ \t]*)(\w*[ \t]*=|)([ \t]*)\+\+[ \t]*([[:alpha:]_]\w*(|\(\w+\)))[ \t]*(;[ \t]*$)/,
	   "\\1\\3\\4 = \\4 + 1; \\2 \\4\\5", "g");
	$0 = gensub(/(^[ \t]*)(\w*[ \t]*=|)([ \t]*)([[:alpha:]_]\w*(\y|\(\w+\)))[ \t]*\-\-[ \t]*(;[ \t]*$)/,
	   "\\1\\2 \\4; \\3\\4 = \\4 - 1\\5", "g");
	$0 = gensub(/(^[ \t]*)(\w*[ \t]*=|)([ \t]*)\-\-[ \t]*([[:alpha:]_]\w*(|\(\w+\)))[ \t]*(;[ \t]*$)/,
	   "\\1\\3\\4 = \\4 - 1; \\2 \\4\\5", "g");

	#### ++y(m>12);
	$0 = gensub(/(^[ \t]*)\+\+[ \t]*([[:alpha:]_]\w*)[ \t]*(\(.*\));[ \t]*$/,
	   "\\1o2m_tmp = \\3; \\2(o2m_tmp) = \\2(o2m_tmp) + 1;", "g");
	$0 = gensub(/(^[ \t]*)\-\-[ \t]*([[:alpha:]_]\w*)[ \t]*(\(.*\));[ \t]*$/,
	   "\\1o2m_tmp = \\3; \\2(o2m_tmp) = \\2(o2m_tmp) - 1;", "g");

	#### ++y; zz -- ;
        #if ( /^([ \t]*)\+\+[ \t]*([[:alpha:]_][[:alnum:]_\.]*)([ \t]*;[ \t]*)/ ) {
	$0 = gensub(/^([ \t]*)\+\+[ \t]*([[:alpha:]_][[:alnum:]_\.]*)([ \t]*;[ \t]*)/,
	   "\\1\\2 = \\2 + 1; ", "g");
	$0 = gensub(/(^[ \t]*)\-\-[ \t]*([[:alpha:]_][[:alnum:]_\.]*)([ \t]*;[ \t]*)/,
	   "\\1\\2 = \\2 - 1; ", "g");
	$0 = gensub(/^([ \t]*)([[:alpha:]_][[:alnum:]_\.]*)[ \t]*\+\+([ \t]*;[ \t]*)/,
	   "\\1\\2 = \\2 + 1; ", "g");
	$0 = gensub(/^([ \t]*)([[:alpha:]_][[:alnum:]_\.]*)[ \t]*\-\-([ \t]*;[ \t]*)/,
	   "\\1\\2 = \\2 - 1; ", "g");

	##### y = y{k++}; y = y(k++);
        # main/zenity/inst/private/zenity_options.m
	# param = varargin{narg++};
	# opts = varargin(narg++);
	# param = varargin{++narg};
        $0 = gensub(/(^[ \t]*)([[:alpha:]_]\w*)[ \t]*=[ \t]*([[:alpha:]_]\w*)[ \t]*\{[ \t]*\+\+[ \t]*([[:alpha:]_]\w*)[ \t]*\}[ \t]*(;[ \t]*$)/,
           "\\1\\4 = \\4 + 1; \\2 = \\3{\\4}\\5","g");
        $0 = gensub(/(^[ \t]*)([[:alpha:]_]\w*)[ \t]*=[ \t]*([[:alpha:]_]\w*)[ \t]*\{[ \t]*([[:alpha:]_]\w*)[ \t]*\+\+[ \t]*\}[ \t]*(;[ \t]*$)/,
           "\\1\\2 = \\3{\\4}; \\4 = \\4 + 1\\5","g");
        $0 = gensub(/(^[ \t]*)([[:alpha:]_]\w*)[ \t]*=[ \t]*([[:alpha:]_]\w*)[ \t]*\{[ \t]*\-\-[ \t]*([[:alpha:]_]\w*)[ \t]*\}[ \t]*(;[ \t]*$)/,
           "\\1\\4 = \\4 - 1; \\2 = \\3{\\4}\\5","g");
        $0 = gensub(/(^[ \t]*)([[:alpha:]_]\w*)[ \t]*=[ \t]*([[:alpha:]_]\w*)[ \t]*\{[ \t]*([[:alpha:]_]\w*)[ \t]*\-\-[ \t]*\}[ \t]*(;[ \t]*$)/,
           "\\1\\2 = \\3{\\4}; \\4 = \\4 - 1\\5","g");

        $0 = gensub(/(^[ \t]*)([[:alpha:]_]\w*)[ \t]*=[ \t]*([[:alpha:]_]\w*)[ \t]*\([ \t]*\+\+[ \t]*([[:alpha:]_]\w*)[ \t]*\)[ \t]*(;[ \t]*$)/,
           "\\1\\4 = \\4 + 1; \\3 = \\3{\\4}\\5","g");
        $0 = gensub(/(^[ \t]*)([[:alpha:]_]\w*)[ \t]*=[ \t]*([[:alpha:]_]\w*)[ \t]*\([ \t]*([[:alpha:]_]\w*)[ \t]*\+\+[ \t]*\)[ \t]*(;[ \t]*$)/,
           "\\1\\2 = \\3{\\4}; \\4 = \\4 + 1\\5","g");
        $0 = gensub(/(^[ \t]*)([[:alpha:]_]\w*)[ \t]*=[ \t]*([[:alpha:]_]\w*)[ \t]*\([ \t]*\-\-[ \t]*([[:alpha:]_]\w*)[ \t]*\)[ \t]*(;[ \t]*$)/,
           "\\1\\4 = \\4 - 1; \\2 = \\3{\\4}\\5","g");
        $0 = gensub(/(^[ \t]*)([[:alpha:]_]\w*)[ \t]*=[ \t]*([[:alpha:]_]\w*)[ \t]*\([ \t]*([[:alpha:]_]\w*)[ \t]*\-\-[ \t]*\)[ \t]*(;[ \t]*$)/,
           "\\1\\2 = \\3{\\4}; \\4 = \\4 - 1\\5","g");

    	# main/image/inst/imhist.m
		#varargout{vr_val_cnt++} = nn;
		#varargout{vr_val_cnt++} = xx;
 		#std_formats{++nfmt} = "dd-mmm-yyyy";  
 		#tmp(img_idx--) = tmap(img);
 		#str(--idx) = "*";
 		#outstruct.namesn(++nnames)=nn;

	##### yy.zz(k++) = a; yy.bb{k++} = "abc";
    	$0 = gensub(/(^[ \t]*)([[:alpha:]_][[:alnum:]_\.]*)[ \t]*\{[ \t]*\+\+[ \t]*([[:alpha:]_]\w*)[ \t]*\}[ \t]*(=.*;)([ \t]*$)/,
    	     "\\1\\3 = \\3 + 1; \\2{\\3} \\4\\5","g");
    	$0 = gensub(/(^[ \t]*)([[:alpha:]_][[:alnum:]_\.]*))[ \t]*\{[ \t]*([[:alpha:]_]\w*)[ \t]*\+\+[ \t]*\}[ \t]*(=.*;)([ \t]*$)/,
    	     "\\1\\2{\\3} \\4 \\3 = \\3 + 1;\\5","g");
    	$0 = gensub(/(^[ \t]*)([[:alpha:]_][[:alnum:]_\.]*)[ \t]*\([ \t]*\+\+[ \t]*([[:alpha:]_]\w*)[ \t]*\)[ \t]*(=.*;)([ \t]*$)/,
    	     "\\1\\3 = \\3 + 1; \\2(\\3) \\4\\5","g");
    	$0 = gensub(/(^[ \t]*)([[:alpha:]_][[:alnum:]_\.]*)[ \t]*\([ \t]*([[:alpha:]_]\w*)[ \t]*\+\+[ \t]*\)[ \t]*(=.*;)([ \t]*$)/,
    	     "\\1\\2(\\3) \\4 \\3 = \\3 + 1;\\5","g");

    	$0 = gensub(/(^[ \t]*)([[:alpha:]_][[:alnum:]_\.]*)[ \t]*\{[ \t]*--[ \t]*([[:alpha:]_]\w*)[ \t]*\}[ \t]*(=.*;)([ \t]*$)/,
    	     "\\1\\3 = \\3 - 1; \\2{\\3} \\4\\5","g");
    	$0 = gensub(/(^[ \t]*)([[:alpha:]_][[:alnum:]_\.]*)[ \t]*\{[ \t]*([[:alpha:]_]\w*)[ \t]*\-\-[ \t]*\}[ \t]*(=.*;)([ \t]*$)/,
    	     "\\1\\2{\\3} \\4 \\3 = \\3 - 1;\\5","g");
    	$0 = gensub(/(^[ \t]*)([[:alpha:]_][[:alnum:]_\.]*)[ \t]*\([ \t]*--[ \t]*([[:alpha:]_]\w*)[ \t]*\)[ \t]*(=.*;)([ \t]*$)/,
    	     "\\1\\3 = \\3 - 1; \\2(\\3) \\4\\5","g");
    	$0 = gensub(/(^[ \t]*)([[:alpha:]_][[:alnum:]_\.]*)[ \t]*\([ \t]*([[:alpha:]_]\w*)[ \t]*\-\-[ \t]*\)[ \t]*(=.*;)([ \t]*$)/,
    	     "\\1\\2(\\3) \\4 \\3 = \\3 - 1;\\5","g");
      }

      #####  +=, -=, *=, /=, \=, &=, |=, .+=, .-=, .*=, ./=, .\=, &=, |=, 	
      if (/(\+|-|\&|\||\.?\\|\.?\*|\.?\/|\.?\^)=/) {
	## +=, -=, &=, |=,  *=, /=, \=, ^= all operators might need parenthesizing the RHS. e.g. a &= b || c;
	##    unfortunately, this breaks the expression like k.x(:,1) += conv (x, y)(:) - [1; a](:)
	   $0 = gensub(/(^[ \t]*)([[:alpha:]_][[:alnum:]_\.]*)[ \t]*(\+|-|\&|\||\.?\*|\.?\\|\.?\/|\.?\^)=([ \t]*)([^;]*)([ \t]*;[ \t]*)/,
	      "\\1\\2 = \\2 \\3 (\\5)\\6", "g");
      }

      ## match expression indexing.
      bad = 0;
      while (match($0, /\)[ \t]*\(/) && !bad) { 
	# (expr)(index) or name(expr)(index)
	$0 = subst_indexed_expr($0, RSTART);
      } 

      bad = 0;
      while (match($0, /\)[ \t]*\{/) && !bad) { 
	# (expr){index} or name(expr){index}
	$0 = subst_indexed_expr($0, RSTART);
      } 

      bad = 0;
      while (match($0, /\][ \t]*\(/) && !bad) { 
	# [expr](index)
	$0 = subst_indexed_expr($0, RSTART);
      } 

      bad = 0;
      while (match($0, /\][ \t]*\{/) && !bad) { 
	# [expr]{index}
	$0 = subst_indexed_expr($0, RSTART);
      } 
    } ## EXPERIMENTAL
    
    #### add "..." when line is not closed ########
    {
        line = $0;
        lcnt = gsub(/\(/,"",line);
        rcnt = gsub(/\)/,"",line);        
        ocnt = ocnt+lcnt-rcnt;
        if (ocnt > 0 && !index($0 ,"...") )
                $0 = $0 " ...";
    }

    ##### report on failed conversions ####################
    if (/(\+|-|\&|\||\\|\*|\/|\^)=/) {
	print ".=:\t" FILENAME " line " NR "+: " $0  >> "/tmp/oct2mat.log"
    }
    if (/\+\+|\-\-/) {
	print "++|--:\t" FILENAME " line " NR "+: " $0  >> "/tmp/oct2mat.log"
    }
    if (/\<nth[ \t]*\(|\<is_list[ \t]*\(|\<islist[ \t]*\(|\<list[ \t]*\(|\<splice\>|\<leval\>/) {
        ## report obsolete functions 
	print "list(): " FILENAME " line " NR "+: " $0  >> "/tmp/oct2mat.log"
    }
    if (/\<do\>|\<until\>/) {
	print "do:\t" FILENAME " line " NR "+: " $0  >> "/tmp/oct2mat.log"
    }
    if (/\.\(/) {
	print "set/getfield:\t" FILENAME " line " NR "+: " $0  >> "/tmp/oct2mat.log"
    }
    
    ##### Restore Comments #####
    if (length(COMMENTS)>0) {        
            $0 = $0 COMMENTS
    }
    
    if (incopyright) copyright = copyright "\n" fixquotes($0); 
    else body = body "\n" fixquotes($0);
}
    
END  {
  if (file) { 
    if (file=="-") print body "\n" copyright;
    else print body "\n" copyright > file;
  }
}
