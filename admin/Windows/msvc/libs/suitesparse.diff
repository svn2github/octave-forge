diff -urN -x metis-4.0 original-libraries/SuiteSparse/AMD/Demo/Makefile SuiteSparse/AMD/Demo/Makefile
--- original-libraries/SuiteSparse/AMD/Demo/Makefile	2006-05-02 08:31:06.000000000 +0200
+++ SuiteSparse/AMD/Demo/Makefile	2006-12-15 17:45:44.000000000 +0100
@@ -2,10 +2,10 @@
 # compile the AMD demo (for both GNU make or original make)
 #-----------------------------------------------------------------------------
 
-default: amd_simple amd_demo amd_demo2 amd_l_demo
-
 include ../../UFconfig/UFconfig.mk
 
+default: amd_simple$(EXEEXT) amd_demo$(EXEEXT) amd_demo2$(EXEEXT) amd_l_demo$(EXEEXT)
+
 C = $(CC) $(CFLAGS) $(CONFIG) -I../Include -I../../UFconfig
 
 UFCONFIG = ../../UFconfig/UFconfig.h
@@ -24,54 +24,54 @@
 
 dist:
 
-amd_demo: amd_demo.c library $(INC)
-	$(C) -o amd_demo amd_demo.c ../Lib/libamd.a $(LIB)
+amd_demo$(EXEEXT): amd_demo.c library $(INC)
+	$(C) -o amd_demo$(EXEEXT) amd_demo.c ../Lib/$(LIBPRE)amd.$(LIBEXT) $(CLIB)
 	./amd_demo > my_amd_demo.out
-	- diff amd_demo.out my_amd_demo.out
+	- diff -b amd_demo.out my_amd_demo.out
 
-amd_l_demo: amd_l_demo.c library $(INC)
-	$(C) -o amd_l_demo amd_l_demo.c ../Lib/libamd.a $(LIB)
+amd_l_demo$(EXEEXT): amd_l_demo.c library $(INC)
+	$(C) -o amd_l_demo$(EXEEXT) amd_l_demo.c ../Lib/$(LIBPRE)amd.$(LIBEXT) $(CLIB)
 	./amd_l_demo > my_amd_l_demo.out
-	- diff amd_l_demo.out my_amd_l_demo.out
+	- diff -b amd_l_demo.out my_amd_l_demo.out
 
-amd_demo2: amd_demo2.c library $(INC)
-	$(C) -o amd_demo2 amd_demo2.c ../Lib/libamd.a $(LIB)
+amd_demo2$(EXEEXT): amd_demo2.c library $(INC)
+	$(C) -o amd_demo2$(EXEEXT) amd_demo2.c ../Lib/$(LIBPRE)amd.$(LIBEXT) $(CLIB)
 	./amd_demo2 > my_amd_demo2.out
-	- diff amd_demo2.out my_amd_demo2.out
+	- diff -b amd_demo2.out my_amd_demo2.out
 
-amd_simple: amd_simple.c library $(INC)
-	$(C) -o amd_simple amd_simple.c ../Lib/libamd.a $(LIB)
+amd_simple$(EXEEXT): amd_simple.c library $(INC)
+	$(C) -o amd_simple$(EXEEXT) amd_simple.c ../Lib/$(LIBPRE)amd.$(LIBEXT) $(CLIB)
 	./amd_simple > my_amd_simple.out
-	- diff amd_simple.out my_amd_simple.out
+	- diff -b amd_simple.out my_amd_simple.out
 
 #------------------------------------------------------------------------------
 # compile the Fortran demo
 #------------------------------------------------------------------------------
 
-fortran: amd_f77demo amd_f77simple
+fortran: amd_f77demo$(EXEEXT) amd_f77simple$(EXEEXT)
 
-cross: amd_f77cross
+cross: amd_f77cross$(EXEEXT)
 
-amd_f77demo: amd_f77demo.f f77lib
-	$(F77) $(F77FLAGS) -o amd_f77demo amd_f77demo.f ../Lib/libamdf77.a \
+amd_f77demo$(EXEEXT): amd_f77demo.f f77lib
+	$(F77) $(F77FLAGS) -o amd_f77demo$(EXEEXT) amd_f77demo.f ../Lib/$(LIBPRE)amdf77.$(LIBEXT) \
 	    $(F77LIB)
 	./amd_f77demo > my_amd_f77demo.out
-	- diff amd_f77demo.out my_amd_f77demo.out
+	- diff -b amd_f77demo.out my_amd_f77demo.out
 
-amd_f77simple: amd_f77simple.f f77lib
-	$(F77) $(F77FLAGS) -o amd_f77simple amd_f77simple.f \
-	    ../Lib/libamdf77.a $(F77LIB)
+amd_f77simple$(EXEEXT): amd_f77simple.f f77lib
+	$(F77) $(F77FLAGS) -o amd_f77simple$(EXEEXT) amd_f77simple.f \
+	    ../Lib/$(LIBPRE)amdf77.$(LIBEXT) $(F77LIB)
 	./amd_f77simple > my_amd_f77simple.out
-	- diff amd_f77simple.out my_amd_f77simple.out
+	- diff -b amd_f77simple.out my_amd_f77simple.out
 
 amd_f77wrapper.o: amd_f77wrapper.c
 	$(C) -DDINT -c amd_f77wrapper.c
 
-amd_f77cross:  amd_f77cross.f amd_f77wrapper.o ../Lib/libamd.a
+amd_f77cross:  amd_f77cross.f amd_f77wrapper.o ../Lib/$(LIBPRE)amd.$(LIBEXT)
 	$(F77) $(F77FLAGS) -o amd_f77cross amd_f77cross.f amd_f77wrapper.o \
-	    ../Lib/libamd.a $(F77LIB)
+	    ../Lib/$(LIBPRE)amd.$(LIBEXT) $(F77LIB)
 	./amd_f77cross > my_amd_f77cross.out
-	- diff amd_f77cross.out my_amd_f77cross.out
+	- diff -b amd_f77cross.out my_amd_f77cross.out
 
 #------------------------------------------------------------------------------
 # Remove all but the files in the original distribution
@@ -83,10 +83,10 @@
 purge: distclean
 
 distclean: clean
-	- $(RM) amd_demo my_amd_demo.out
-	- $(RM) amd_l_demo my_amd_l_demo.out
-	- $(RM) amd_demo2 my_amd_demo2.out
-	- $(RM) amd_simple my_amd_simple.out
-	- $(RM) amd_f77demo my_amd_f77demo.out
-	- $(RM) amd_f77simple my_amd_f77simple.out
-	- $(RM) amd_f77cross my_amd_f77cross.out
+	- $(RM) amd_demo$(EXEEXT) my_amd_demo.out
+	- $(RM) amd_l_demo$(EXEEXT) my_amd_l_demo.out
+	- $(RM) amd_demo2$(EXEEXT) my_amd_demo2.out
+	- $(RM) amd_simple$(EXEEXT) my_amd_simple.out
+	- $(RM) amd_f77demo$(EXEEXT) my_amd_f77demo.out
+	- $(RM) amd_f77simple$(EXEEXT) my_amd_f77simple.out
+	- $(RM) amd_f77cross$(EXEEXT) my_amd_f77cross.out
diff -urN -x metis-4.0 original-libraries/SuiteSparse/AMD/Makefile SuiteSparse/AMD/Makefile
--- original-libraries/SuiteSparse/AMD/Makefile	2006-04-29 15:28:14.000000000 +0200
+++ SuiteSparse/AMD/Makefile	2006-12-15 17:40:38.000000000 +0100
@@ -2,13 +2,13 @@
 # AMD Makefile (for GNU Make or original make)
 #------------------------------------------------------------------------------
 
-default: demo
+default: do_demo
 
 include ../UFconfig/UFconfig.mk
 
 # Compile all C code, including the C-callable routine and the mexFunctions.
 # Do not compile the FORTRAN versions, or MATLAB interface.
-demo:
+do_demo:
 	( cd Source ; $(MAKE) )
 	( cd Demo   ; $(MAKE) )
 
diff -urN -x metis-4.0 original-libraries/SuiteSparse/AMD/Source/GNUmakefile SuiteSparse/AMD/Source/GNUmakefile
--- original-libraries/SuiteSparse/AMD/Source/GNUmakefile	2006-05-02 08:12:28.000000000 +0200
+++ SuiteSparse/AMD/Source/GNUmakefile	2006-12-15 17:41:28.000000000 +0100
@@ -2,10 +2,10 @@
 # AMD Makefile for compiling on Unix systems (for GNU make only)
 #-------------------------------------------------------------------------------
 
-default: ../Lib/libamd.a
-
 include ../../UFconfig/UFconfig.mk
 
+default: ../Lib/$(LIBPRE)amd.$(LIBEXT)
+
 C = $(CC) $(CFLAGS) $(CONFIG) -I../Include -I../../UFconfig
 
 #-------------------------------------------------------------------------------
@@ -43,15 +43,15 @@
 # Create the libamd.a library (C versions only)
 #-------------------------------------------------------------------------------
 
-../Lib/libamd.a: amd_global.o $(AMDI) $(AMDL)
-	$(AR) ../Lib/libamd.a $^
-	- $(RANLIB) ../Lib/libamd.a
+../Lib/$(LIBPRE)amd.$(LIBEXT): amd_global.o $(AMDI) $(AMDL)
+	$(AR) ../Lib/$(LIBPRE)amd.$(LIBEXT) $^
+	- $(RANLIB) ../Lib/$(LIBPRE)amd.$(LIBEXT)
 
 #-------------------------------------------------------------------------------
 # compile the Fortran versions and the libamdf77.a library
 #-------------------------------------------------------------------------------
 
-fortran: ../Lib/libamdf77.a
+fortran: ../Lib/$(LIBPRE)amdf77.$(LIBEXT)
 
 AMDF77 = amd.o amdbar.o
 
@@ -61,9 +61,9 @@
 amdbar.o: amdbar.f
 	$(F77) $(F77FLAGS) -c amdbar.f -o amdbar.o
 
-../Lib/libamdf77.a: $(AMDF77)
-	$(AR) ../Lib/libamdf77.a $^
-	- $(RANLIB) ../Lib/libamdf77.a
+../Lib/$(LIBPRE)amdf77.$(LIBEXT): $(AMDF77)
+	$(AR) ../Lib/$(LIBPRE)amdf77.$(LIBEXT) $^
+	- $(RANLIB) ../Lib/$(LIBPRE)amdf77.$(LIBEXT)
 
 #-------------------------------------------------------------------------------
 # Remove all but the files in the original distribution
@@ -75,5 +75,5 @@
 purge: distclean
 
 distclean: clean
-	- $(RM) ../Lib/libamd.a
-	- $(RM) ../Lib/libamdf77.a
+	- $(RM) ../Lib/$(LIBPRE)amd.$(LIBEXT)
+	- $(RM) ../Lib/$(LIBPRE)amdf77.$(LIBEXT)
diff -urN -x metis-4.0 original-libraries/SuiteSparse/BTF/Lib/Makefile SuiteSparse/BTF/Lib/Makefile
--- original-libraries/SuiteSparse/BTF/Lib/Makefile	2006-01-30 11:43:22.000000000 +0100
+++ SuiteSparse/BTF/Lib/Makefile	2006-12-15 17:58:48.000000000 +0100
@@ -15,13 +15,13 @@
 
 all: library
 
-library: libbtf.a
+library: $(LIBPRE)btf.$(LIBEXT)
 
 OBJ = btf_order.o maxtrans.o strongcomp.o
 
-libbtf.a: $(OBJ)
-	$(AR) libbtf.a $(OBJ)
-	$(RANLIB) libbtf.a
+$(LIBPRE)btf.$(LIBEXT): $(OBJ)
+	$(AR) $(LIBPRE)btf.$(LIBEXT) $(OBJ)
+	$(RANLIB) $(LIBPRE)btf.$(LIBEXT)
 
 $(OBJ): $(INC)
 
@@ -41,7 +41,7 @@
 purge: distclean
 
 distclean: clean
-	- $(RM) libbtf.a 
+	- $(RM) $(LIBPRE)btf.$(LIBEXT) 
 
 clean:
 	- $(RM) $(CLEAN)
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CAMD/Demo/Makefile SuiteSparse/CAMD/Demo/Makefile
--- original-libraries/SuiteSparse/CAMD/Demo/Makefile	2006-05-02 08:19:04.000000000 +0200
+++ SuiteSparse/CAMD/Demo/Makefile	2006-12-15 17:51:40.000000000 +0100
@@ -2,10 +2,10 @@
 # compile the CAMD demo (for both GNU make or original make)
 #-----------------------------------------------------------------------------
 
-default: camd_simple camd_demo camd_demo2 camd_l_demo
-
 include ../../UFconfig/UFconfig.mk
 
+default: camd_simple$(EXEEXT) camd_demo$(EXEEXT) camd_demo2$(EXEEXT) camd_l_demo$(EXEEXT)
+
 C = $(CC) $(CFLAGS) $(CONFIG) -I../Include -I../../UFconfig
 
 UFCONFIG = ../../UFconfig/UFconfig.h
@@ -21,25 +21,25 @@
 
 dist:
 
-camd_demo: camd_demo.c library $(INC)
-	$(C) -o camd_demo camd_demo.c ../Lib/libcamd.a $(LIB)
+camd_demo$(EXEEXT): camd_demo.c library $(INC)
+	$(C) -o camd_demo$(EXEEXT) camd_demo.c ../Lib/$(LIBPRE)camd.$(LIBEXT) $(CLIB)
 	./camd_demo > my_camd_demo.out
-	- diff camd_demo.out my_camd_demo.out
+	- diff -b camd_demo.out my_camd_demo.out
 
-camd_l_demo: camd_l_demo.c library $(INC)
-	$(C) -o camd_l_demo camd_l_demo.c ../Lib/libcamd.a $(LIB)
+camd_l_demo$(EXEEXT): camd_l_demo.c library $(INC)
+	$(C) -o camd_l_demo$(EXEEXT) camd_l_demo.c ../Lib/$(LIBPRE)camd.$(LIBEXT) $(CLIB)
 	./camd_l_demo > my_camd_l_demo.out
-	- diff camd_l_demo.out my_camd_l_demo.out
+	- diff -b camd_l_demo.out my_camd_l_demo.out
 
-camd_demo2: camd_demo2.c library $(INC)
-	$(C) -o camd_demo2 camd_demo2.c ../Lib/libcamd.a $(LIB)
+camd_demo2$(EXEEXT): camd_demo2.c library $(INC)
+	$(C) -o camd_demo2$(EXEEXT) camd_demo2.c ../Lib/$(LIBPRE)camd.$(LIBEXT) $(CLIB)
 	./camd_demo2 > my_camd_demo2.out
-	- diff camd_demo2.out my_camd_demo2.out
+	- diff -b camd_demo2.out my_camd_demo2.out
 
-camd_simple: camd_simple.c library $(INC)
-	$(C) -o camd_simple camd_simple.c ../Lib/libcamd.a $(LIB)
+camd_simple$(EXEEXT): camd_simple.c library $(INC)
+	$(C) -o camd_simple$(EXEEXT) camd_simple.c ../Lib/$(LIBPRE)camd.$(LIBEXT) $(CLIB)
 	./camd_simple > my_camd_simple.out
-	- diff camd_simple.out my_camd_simple.out
+	- diff -b camd_simple.out my_camd_simple.out
 
 #------------------------------------------------------------------------------
 # Remove all but the files in the original distribution
@@ -51,7 +51,7 @@
 purge: distclean
 
 distclean: clean
-	- $(RM) camd_demo my_camd_demo.out
-	- $(RM) camd_l_demo my_camd_l_demo.out
-	- $(RM) camd_demo2 my_camd_demo2.out
-	- $(RM) camd_simple my_camd_simple.out
+	- $(RM) camd_demo$(EXEEXT) my_camd_demo.out
+	- $(RM) camd_l_demo$(EXEEXT) my_camd_l_demo.out
+	- $(RM) camd_demo2$(EXEEXT) my_camd_demo2.out
+	- $(RM) camd_simple$(EXEEXT) my_camd_simple.out
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CAMD/Makefile SuiteSparse/CAMD/Makefile
--- original-libraries/SuiteSparse/CAMD/Makefile	2006-04-29 15:28:36.000000000 +0200
+++ SuiteSparse/CAMD/Makefile	2006-12-15 17:52:06.000000000 +0100
@@ -2,13 +2,13 @@
 # CAMD Makefile (for GNU Make or original make)
 #------------------------------------------------------------------------------
 
-default: demo
+default: do_demo
 
 include ../UFconfig/UFconfig.mk
 
 # Compile all C code, including the C-callable routine and the mexFunctions.
 # Do not compile the FORTRAN versions, or MATLAB interface.
-demo:
+do_demo:
 	( cd Source ; $(MAKE) )
 	( cd Demo   ; $(MAKE) )
 
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CAMD/Source/GNUmakefile SuiteSparse/CAMD/Source/GNUmakefile
--- original-libraries/SuiteSparse/CAMD/Source/GNUmakefile	2006-05-02 08:19:44.000000000 +0200
+++ SuiteSparse/CAMD/Source/GNUmakefile	2006-12-15 17:50:26.000000000 +0100
@@ -2,10 +2,10 @@
 # CAMD Makefile for compiling on Unix systems (for GNU make only)
 #-------------------------------------------------------------------------------
 
-default: ../Lib/libcamd.a
-
 include ../../UFconfig/UFconfig.mk
 
+default: ../Lib/$(LIBPRE)camd.$(LIBEXT)
+
 C = $(CC) $(CFLAGS) $(CONFIG) -I../Include -I../../UFconfig
 
 #-------------------------------------------------------------------------------
@@ -43,9 +43,9 @@
 # Create the libcamd.a library (C versions only)
 #-------------------------------------------------------------------------------
 
-../Lib/libcamd.a: camd_global.o $(CAMDI) $(CAMDL)
-	$(AR) ../Lib/libcamd.a $^
-	- $(RANLIB) ../Lib/libcamd.a
+../Lib/$(LIBPRE)camd.$(LIBEXT): camd_global.o $(CAMDI) $(CAMDL)
+	$(AR) ../Lib/$(LIBPRE)camd.$(LIBEXT) $^
+	- $(RANLIB) ../Lib/$(LIBPRE)camd.$(LIBEXT)
 
 #-------------------------------------------------------------------------------
 # Remove all but the files in the original distribution
@@ -57,4 +57,4 @@
 purge: distclean
 
 distclean: clean
-	- $(RM) ../Lib/libcamd.a
+	- $(RM) ../Lib/$(LIBPRE)camd.$(LIBEXT)
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CCOLAMD/Makefile SuiteSparse/CCOLAMD/Makefile
--- original-libraries/SuiteSparse/CCOLAMD/Makefile	2006-08-16 10:16:04.000000000 +0200
+++ SuiteSparse/CCOLAMD/Makefile	2006-12-15 18:02:50.000000000 +0100
@@ -1,51 +1,51 @@
 
-default: ccolamd_example ccolamd_l_example libccolamd.a
-
 include ../UFconfig/UFconfig.mk
 
+default: ccolamd_example$(EXEEXT) ccolamd_l_example$(EXEEXT) $(LIBPRE)ccolamd.$(LIBEXT)
+
 I = -I../UFconfig
 
-ccolamd_example:  ccolamd_example.c libccolamd.a
-	$(CC) $(CFLAGS) $(I) -o ccolamd_example ccolamd_example.c libccolamd.a -lm
+ccolamd_example$(EXEEXT):  ccolamd_example.c $(LIBPRE)ccolamd.$(LIBEXT)
+	$(CC) $(CFLAGS) $(I) -o ccolamd_example$(EXEEXT) ccolamd_example.c $(LIBPRE)ccolamd.$(LIBEXT) $(CLIB)
 	- ./ccolamd_example > my_ccolamd_example.out
-	- diff ccolamd_example.out my_ccolamd_example.out
+	- diff -b ccolamd_example.out my_ccolamd_example.out
 
-ccolamd_l_example:  ccolamd_l_example.c libccolamd.a
-	$(CC) $(CFLAGS) $(I) -o ccolamd_l_example ccolamd_l_example.c libccolamd.a -lm
+ccolamd_l_example$(EXEEXT):  ccolamd_l_example.c $(LIBPRE)ccolamd.$(LIBEXT)
+	$(CC) $(CFLAGS) $(I) -o ccolamd_l_example$(EXEEXT) ccolamd_l_example.c $(LIBPRE)ccolamd.$(LIBEXT) $(CLIB)
 	- ./ccolamd_l_example > my_ccolamd_l_example.out
-	- diff ccolamd_l_example.out my_ccolamd_l_example.out
+	- diff -b ccolamd_l_example.out my_ccolamd_l_example.out
 
 purge: distclean
 
 distclean: clean2
-	- $(RM) libccolamd.a
+	- $(RM) $(LIBPRE)ccolamd.$(LIBEXT)
 
 clean2: clean
-	- $(RM) *.o *.dll ccolamd_example ccolamd_l_example
+	- $(RM) *.o *.dll ccolamd_example$(EXEEXT) ccolamd_l_example$(EXEEXT)
 	- $(RM) ccolamd.mex* csymamd.mex*
 	- $(RM) ccolamdtestmex.mex* csymamdtestmex.mex*
 	- $(RM) my_ccolamd_example.out my_ccolamd_l_example.out
 
 # Compiles the MATLAB-callable routines
-mex: ccolamdmex.c csymamdmex.c libccolamd.a
-	$(MEX) $(I) -output ccolamd ccolamdmex.c libccolamd.a
-	$(MEX) $(I) -output csymamd csymamdmex.c libccolamd.a
+mex: ccolamdmex.c csymamdmex.c $(LIBPRE)ccolamd.$(LIBEXT)
+	$(MEX) $(I) -output ccolamd ccolamdmex.c $(LIBPRE)ccolamd.$(LIBEXT)
+	$(MEX) $(I) -output csymamd csymamdmex.c $(LIBPRE)ccolamd.$(LIBEXT)
 
 # Compiles the extensive test code
-test: mex ccolamdtestmex.c csymamdtestmex.c libccolamd.a
-	$(MEX) $(I) ccolamdtestmex.c libccolamd.a
-	$(MEX) $(I) csymamdtestmex.c libccolamd.a
+test: mex ccolamdtestmex.c csymamdtestmex.c $(LIBPRE)ccolamd.$(LIBEXT)
+	$(MEX) $(I) ccolamdtestmex.c $(LIBPRE)ccolamd.$(LIBEXT)
+	$(MEX) $(I) csymamdtestmex.c $(LIBPRE)ccolamd.$(LIBEXT)
 
 # creates libccolamd.a, a C-callable CCOLAMD library
-libccolamd.a:  ccolamd.c ccolamd_global.c ccolamd.h
+$(LIBPRE)ccolamd.$(LIBEXT):  ccolamd.c ccolamd_global.c ccolamd.h
 	$(CC) $(CFLAGS) $(I) -c ccolamd_global.c
 	$(CC) $(CFLAGS) $(I) -c ccolamd.c
 	$(CC) $(CFLAGS) $(I) -c ccolamd.c -DDLONG -o ccolamd_l.o
-	$(AR) libccolamd.a ccolamd.o ccolamd_l.o ccolamd_global.o
+	$(AR) $(LIBPRE)ccolamd.$(LIBEXT) ccolamd.o ccolamd_l.o ccolamd_global.o
 
-ccode: libccolamd.a
+ccode: $(LIBPRE)ccolamd.$(LIBEXT)
 
-library: libccolamd.a
+library: $(LIBPRE)ccolamd.$(LIBEXT)
 
 clean:
 	- $(RM) $(CLEAN)
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CHOLMOD/Demo/Makefile SuiteSparse/CHOLMOD/Demo/Makefile
--- original-libraries/SuiteSparse/CHOLMOD/Demo/Makefile	2006-08-25 10:41:40.000000000 +0200
+++ SuiteSparse/CHOLMOD/Demo/Makefile	2006-12-15 22:21:32.000000000 +0100
@@ -11,9 +11,9 @@
 
 #-------------------------------------------------------------------------------
 # With METIS, CCOLAMD, CAMD, and the Partition Module:
-LIB2 = ../Lib/libcholmod.a ../../AMD/Lib/libamd.a ../../COLAMD/libcolamd.a \
-	../../CCOLAMD/libccolamd.a ../../CAMD/Lib/libcamd.a \
-	$(METIS) $(LAPACK) $(BLAS) $(XERBLA) $(LIB)
+LIB2 = ../Lib/$(LIBPRE)cholmod.$(LIBEXT) ../../AMD/Lib/$(LIBPRE)amd.$(LIBEXT) ../../COLAMD/$(LIBPRE)colamd.$(LIBEXT) \
+	../../CCOLAMD/$(LIBPRE)ccolamd.$(LIBEXT) ../../CAMD/Lib/$(LIBPRE)camd.$(LIBEXT) \
+	$(METIS) $(LAPACK) $(BLAS) $(XERBLA) $(CLIB)
 # Use this instead, if you compile with -DNPARTITION:
 # LIB2 = ../Lib/libcholmod.a ../../AMD/Lib/libamd.a ../../COLAMD/libcolamd.a \
 	$(LAPACK) $(BLAS) $(XERBLA) $(LIB)
@@ -21,9 +21,9 @@
 
 C = $(CC) $(CFLAGS) $(CHOLMOD_CONFIG)
 
-code: library cholmod_demo cholmod_l_demo cholmod_simple
+code: library cholmod_demo$(EXEEXT) cholmod_l_demo$(EXEEXT) cholmod_simple$(EXEEXT)
 
-fortran: readhb readhb2 reade 
+fortran: readhb$(EXEEXT) readhb2$(EXEEXT) reade$(EXEEXT) 
 
 all: code
 	./cholmod_demo < Matrix/bcsstk01.tri
@@ -41,8 +41,8 @@
 distclean: purge
 
 purge: clean
-	- $(RM) cholmod_demo cholmod_l_demo readhb readhb2 reade
-	- $(RM) cholmod_simple
+	- $(RM) cholmod_demo$(EXEEXT) cholmod_l_demo$(EXEEXT) readhb$(EXEEXT) readhb2$(EXEEXT) reade$(EXEEXT)
+	- $(RM) cholmod_simple$(EXEEXT)
 
 clean:
 	- $(RM) $(CLEAN)
@@ -66,20 +66,20 @@
 
 I = -I../Include -I../../UFconfig
 
-cholmod_demo: library cholmod_demo.c cholmod_demo.h
-	$(C) -o cholmod_demo $(I) cholmod_demo.c $(LIB2)
+cholmod_demo$(EXEEXT): library cholmod_demo.c cholmod_demo.h
+	$(C) -o cholmod_demo$(EXEEXT) $(I) cholmod_demo.c $(LIB2)
 
-cholmod_simple: library cholmod_simple.c
-	$(C) -o cholmod_simple $(I) cholmod_simple.c $(LIB2)
+cholmod_simple$(EXEEXT): library cholmod_simple.c
+	$(C) -o cholmod_simple$(EXEEXT) $(I) cholmod_simple.c $(LIB2)
 
-cholmod_l_demo: library cholmod_l_demo.c cholmod_demo.h
-	$(C) -o cholmod_l_demo $(I) cholmod_l_demo.c $(LIB2)
+cholmod_l_demo$(EXEEXT): library cholmod_l_demo.c cholmod_demo.h
+	$(C) -o cholmod_l_demo$(EXEEXT) $(I) cholmod_l_demo.c $(LIB2)
 
-readhb: readhb.f
-	$(F77) $(FFLAGS) -o readhb readhb.f
+readhb$(EXEEXT): readhb.f
+	$(F77) $(FFLAGS) -o readhb$(EXEEXT) readhb.f
 
-readhb2: readhb2.f
-	$(F77) $(FFLAGS) -O -o readhb2 readhb2.f
+readhb2$(EXEEXT): readhb2.f
+	$(F77) $(FFLAGS) -O -o readhb2$(EXEEXT) readhb2.f
 
-reade: reade.f
-	$(F77) $(FFLAGS) -O -o reade reade.f
+reade$(EXEEXT): reade.f
+	$(F77) $(FFLAGS) -O -o reade$(EXEEXT) reade.f
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CHOLMOD/Include/cholmod_blas.h SuiteSparse/CHOLMOD/Include/cholmod_blas.h
--- original-libraries/SuiteSparse/CHOLMOD/Include/cholmod_blas.h	2006-11-29 10:12:36.000000000 +0100
+++ SuiteSparse/CHOLMOD/Include/cholmod_blas.h	2006-12-15 22:27:02.000000000 +0100
@@ -48,8 +48,10 @@
 #define CHOLMOD_CYGWIN
 #else
 #define CHOLMOD_WINDOWS
+#ifndef BLAS_UNDERSCORE
 #define BLAS_NO_UNDERSCORE
 #endif
+#endif
 #define CHOLMOD_ARCHITECTURE "Microsoft Windows"
 
 #elif defined (__hppa) || defined (__hpux) || defined (MHPUX) || defined (ARCH_HPUX)
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CHOLMOD/Lib/Makefile SuiteSparse/CHOLMOD/Lib/Makefile
--- original-libraries/SuiteSparse/CHOLMOD/Lib/Makefile	2006-10-24 11:09:36.000000000 +0200
+++ SuiteSparse/CHOLMOD/Lib/Makefile	2006-12-15 22:16:38.000000000 +0100
@@ -10,14 +10,14 @@
 
 C = $(CC) $(CFLAGS) $(CHOLMOD_CONFIG)
 
-all: libcholmod.a
+all: $(LIBPRE)cholmod.$(LIBEXT)
 
-library: libcholmod.a
+library: $(LIBPRE)cholmod.$(LIBEXT)
 
 purge: distclean
 
 distclean: clean
-	- $(RM) libcholmod.a
+	- $(RM) $(LIBPRE)cholmod.$(LIBEXT)
 
 clean:
 	- $(RM) $(CLEAN)
@@ -109,9 +109,9 @@
 # to compile just the double/int version, use OBJ = $(DI)
 OBJ = $(DI) $(DL)
 
-libcholmod.a: $(OBJ)
-	$(AR) libcholmod.a $(OBJ)
-	$(RANLIB) libcholmod.a
+$(LIBPRE)cholmod.$(LIBEXT): $(OBJ)
+	$(AR) $(LIBPRE)cholmod.$(LIBEXT) $(OBJ)
+	$(RANLIB) $(LIBPRE)cholmod.$(LIBEXT)
 
 $(OBJ): $(INC)
 
diff -urN -x metis-4.0 original-libraries/SuiteSparse/COLAMD/Makefile SuiteSparse/COLAMD/Makefile
--- original-libraries/SuiteSparse/COLAMD/Makefile	2006-05-02 17:43:46.000000000 +0200
+++ SuiteSparse/COLAMD/Makefile	2006-12-15 17:55:52.000000000 +0100
@@ -1,51 +1,51 @@
 
-default: libcolamd.a colamd_example colamd_l_example
-
 include ../UFconfig/UFconfig.mk
 
+default: $(LIBPRE)colamd.$(LIBEXT) colamd_example$(EXEEXT) colamd_l_example$(EXEEXT)
+
 I = -I../UFconfig
 
-colamd_example: colamd_example.c libcolamd.a
-	$(CC) $(CFLAGS) $(I) -o colamd_example colamd_example.c libcolamd.a -lm
+colamd_example$(EXEEXT): colamd_example.c $(LIBPRE)colamd.$(LIBEXT)
+	$(CC) $(CFLAGS) $(I) -o colamd_example$(EXEEXT) colamd_example.c $(LIBPRE)colamd.$(LIBEXT) $(CLIB)
 	- ./colamd_example > my_colamd_example.out
-	- diff colamd_example.out my_colamd_example.out
+	- diff -b colamd_example.out my_colamd_example.out
 
-colamd_l_example: colamd_l_example.c libcolamd.a
-	$(CC) $(CFLAGS) $(I) -o colamd_l_example colamd_l_example.c libcolamd.a -lm
+colamd_l_example$(EXEEXT): colamd_l_example.c $(LIBPRE)colamd.$(LIBEXT)
+	$(CC) $(CFLAGS) $(I) -o colamd_l_example$(EXEEXT) colamd_l_example.c $(LIBPRE)colamd.$(LIBEXT) $(CLIB)
 	- ./colamd_l_example > my_colamd_l_example.out
-	- diff colamd_example.out my_colamd_example.out
+	- diff -b colamd_example.out my_colamd_example.out
 
 purge: distclean
 
 distclean: clean2
-	- $(RM) libcolamd.a
+	- $(RM) $(LIBPRE)colamd.$(LIBEXT)
 
 clean2: clean
-	- $(RM) *.o *.dll colamd_example colamd_l_example
+	- $(RM) *.o *.dll colamd_example$(EXEEXT) colamd_l_example$(EXEEXT)
 	- $(RM) colamdmex.mex* symamdmex.mex*
 	- $(RM) colamdtestmex.mex* symamdtestmex.mex*
 	- $(RM) my_colamd_example.out my_colamd_l_example.out
 
 # Compiles the MATLAB-callable routines
-mex: colamdmex.c symamdmex.c libcolamd.a
-	$(MEX) $(I) colamdmex.c libcolamd.a
-	$(MEX) $(I) symamdmex.c libcolamd.a
+mex: colamdmex.c symamdmex.c $(LIBPRE)colamd.$(LIBEXT)
+	$(MEX) $(I) colamdmex.c $(LIBPRE)colamd.$(LIBEXT)
+	$(MEX) $(I) symamdmex.c $(LIBPRE)colamd.$(LIBEXT)
 
 # Compiles the extensive test code
-test: mex colamdtestmex.c symamdtestmex.c libcolamd.a
-	$(MEX) $(I) colamdtestmex.c libcolamd.a
-	$(MEX) $(I) symamdtestmex.c libcolamd.a
+test: mex colamdtestmex.c symamdtestmex.c $(LIBPRE)colamd.$(LIBEXT)
+	$(MEX) $(I) colamdtestmex.c $(LIBPRE)colamd.$(LIBEXT)
+	$(MEX) $(I) symamdtestmex.c $(LIBPRE)colamd.$(LIBEXT)
 
 # creates libcolamd.a, a C-callable COLAMD library
-libcolamd.a:  colamd.c colamd_global.c colamd.h
+$(LIBPRE)colamd.$(LIBEXT):  colamd.c colamd_global.c colamd.h
 	$(CC) $(CFLAGS) $(I) -c colamd_global.c
 	$(CC) $(CFLAGS) $(I) -c colamd.c
 	$(CC) $(CFLAGS) $(I) -c colamd.c -DDLONG -o colamd_l.o
-	$(AR) libcolamd.a colamd.o colamd_l.o colamd_global.o
+	$(AR) $(LIBPRE)colamd.$(LIBEXT) colamd.o colamd_l.o colamd_global.o
 
-ccode: libcolamd.a
+ccode: $(LIBPRE)colamd.$(LIBEXT)
 
-library: libcolamd.a
+library: $(LIBPRE)colamd.$(LIBEXT)
 
 clean:
 	- $(RM) $(CLEAN)
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CSparse/Demo/Makefile SuiteSparse/CSparse/Demo/Makefile
--- original-libraries/SuiteSparse/CSparse/Demo/Makefile	2006-11-29 14:42:38.000000000 +0100
+++ SuiteSparse/CSparse/Demo/Makefile	2006-12-15 23:10:44.000000000 +0100
@@ -1,11 +1,13 @@
-CC = cc
-CFLAGS = -O
+# CC = cc
+# CFLAGS = -O
+
+include ../../UFconfig/UFconfig.mk
 
 I = -I../Source
 
-CS = ../Source/libcsparse.a
+CS = ../Source/$(LIBPRE)csparse.$(LIBEXT)
 
-all: lib cs_demo1 cs_demo2 cs_demo3
+all: lib cs_demo1$(EXEEXT) cs_demo2$(EXEEXT) cs_demo3$(EXEEXT)
 	- ./cs_demo1 < ../Matrix/t1
 	- ./cs_demo2 < ../Matrix/t1
 	- ./cs_demo2 < ../Matrix/ash219
@@ -21,14 +23,14 @@
 lib:
 	( cd ../Source ; $(MAKE) )
 
-cs_demo1: lib cs_demo1.c Makefile
-	$(CC) $(CFLAGS) $(I) -o cs_demo1 cs_demo1.c $(CS) -lm
+cs_demo1$(EXEEXT): lib cs_demo1.c Makefile
+	$(CC) $(CFLAGS) $(I) -o cs_demo1$(EXEEXT) cs_demo1.c $(CS) $(CLIB)
 
-cs_demo2: lib cs_demo2.c cs_demo.c cs_demo.h Makefile
-	$(CC) $(CFLAGS) $(I) -o cs_demo2 cs_demo2.c cs_demo.c $(CS) -lm
+cs_demo2$(EXEEXT): lib cs_demo2.c cs_demo.c cs_demo.h Makefile
+	$(CC) $(CFLAGS) $(I) -o cs_demo2$(EXEEXT) cs_demo2.c cs_demo.c $(CS) $(CLIB)
 
-cs_demo3: lib cs_demo3.c cs_demo.c cs_demo.h Makefile
-	$(CC) $(CFLAGS) $(I) -o cs_demo3 cs_demo3.c cs_demo.c $(CS) -lm
+cs_demo3$(EXEEXT): lib cs_demo3.c cs_demo.c cs_demo.h Makefile
+	$(CC) $(CFLAGS) $(I) -o cs_demo3$(EXEEXT) cs_demo3.c cs_demo.c $(CS) $(CLIB)
 
 clean:
 	rm -f *.o
@@ -36,4 +38,4 @@
 purge: distclean
 
 distclean: clean
-	rm -f cs_demo1 cs_demo2 cs_demo3 *.a
+	rm -f cs_demo1$(EXEEXT) cs_demo2$(EXEEXT) cs_demo3$(EXEEXT) *.$(LIBEXT)
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CSparse/Source/Makefile SuiteSparse/CSparse/Source/Makefile
--- original-libraries/SuiteSparse/CSparse/Source/Makefile	2006-04-12 11:15:34.000000000 +0200
+++ SuiteSparse/CSparse/Source/Makefile	2006-12-15 23:08:54.000000000 +0100
@@ -1,11 +1,13 @@
 # Modify the "-O" optimization option for best performance (-O3 on Linux):
-CC = cc
-CFLAGS = -O
+# CC = cc
+# CFLAGS = -O
 
-AR = ar cr
-RANLIB = ranlib
+# AR = ar cr
+# RANLIB = ranlib
 
-all: libcsparse.a
+include ../../UFconfig/UFconfig.mk
+
+all: $(LIBPRE)csparse.$(LIBEXT)
 
 CS = cs_add.o cs_amd.o cs_chol.o cs_cholsol.o cs_counts.o cs_cumsum.o \
 	cs_droptol.o cs_dropzeros.o cs_dupl.o cs_entry.o \
@@ -19,9 +21,9 @@
 
 $(CS): cs.h Makefile
 
-libcsparse.a: $(CS)
-	$(AR) libcsparse.a $(CS)
-	$(RANLIB) libcsparse.a
+$(LIBPRE)csparse.$(LIBEXT): $(CS)
+	$(AR) $(LIBPRE)csparse.$(LIBEXT) $(CS)
+	$(RANLIB) $(LIBPRE)csparse.$(LIBEXT)
 
 clean:
 	rm -f *.o
@@ -29,4 +31,4 @@
 purge: distclean
 
 distclean: clean
-	rm -f *.a
+	rm -f *.$(LIBEXT)
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/ChangeLog SuiteSparse/CXSparse-C++/ChangeLog
--- original-libraries/SuiteSparse/CXSparse-C++/ChangeLog	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/ChangeLog	2006-08-23 13:07:36.000000000 +0200
@@ -0,0 +1,160 @@
+Aug 23, 2006: v2.0.2
+
+    * change to cs_updown mexFunction, to handle multiple rank updates
+
+    * symbolic links removed from Tcov/ directory in the distribution.
+	They are now created by Tcov/Makefile as needed.  This makes the
+	zip files cleaner.  Tcov/*test.c test files renamed.
+
+July 19, 2006:
+
+    * minor fix to cs_must_compile.m and cs_make.m, to allow CSparse to be
+	compiled in MATLAB 6.5 with cs_make.
+
+    * minor fix to cspy for complex matrices (imaginary part was ignored).
+
+    * no change to version number or date, since there are no changes that
+	affect the appearance of CSparse in the book ("Direct Methods for
+	Sparse Linear Systems", SIAM, 2006).
+
+June 24, 2006:
+
+    * minor typos in comments corrected.  No change in code itself,
+	and no change in version number or date.
+
+May 27, 2006, v2.0.1:
+
+    * minor bug fix.  cs_util.c modified, so that cs_sprealloc (T,0) works
+	properly for a triplet matrix T (setting T->nzmax equal to T->nz).
+	The line in v2.0.0:
+
+	    nzmax = (nzmax <= 0) ? (A->p [A->n]) : nzmax ;
+
+	changes to the following in v2.0.1:
+
+	    if (nzmax <= 0) nzmax = (CS_CSC (A)) ? (A->p [A->n]) : A->nz ;
+
+    * minor typographical changes arising from the editting of the book.
+
+Apr 12, 2006, v2.0.0:
+
+    * random permutation option added to cs_maxtrans and cs_dmperm, to help
+	avoid rare cases where the O(|A|n) time complexity is reached in
+	practice (GHS_indef/boyd2 in the UF sparse matrix collection, for
+	example).  New cs_randperm function added.
+
+Apr 10, 2006:
+
+    * stylistic changes for the book (except for the bug fix):
+
+    * "int order" parameter of cs_amd, cs_lusol, cs_cholsol, cs_qrsol, cs_sqr,
+	cs_schol changed.  Now 0 means no ordering, 1 is A+A', 2 is S*S', and
+	3 is A*A'.  In v1.2 and earlier, "order" took on a value ranging from
+	-1 to 2.  "int n" parameter rearranged for cs_ipvec, cs_pvec, cs_post
+	(int n moved to the end).  cs_triplet renamed cs_compress.
+
+	To ensure that these changes are propagated into user code that calls
+	CSparse, the "order" parameter has been placed as the first parameter
+	in all these routines.  Your compiler will complain (gcc will halt) if
+	you upgrade from v1.2 to v2.0 without changing your code.  This is much
+	better than a silent error in which you get the wrong ordering by
+	mistake (with a huge penalty in run-time performance and no compiler
+	warnings).
+
+	New syntax (v2.0 and later):
+	----------------------------
+
+	    order = 0: natural ordering
+	    order = 1: amd (A+A')
+	    order = 2: amd (S'*S), where S=A except dense rows dropped
+	    order = 3: amd (A'*A)
+
+	    int cs_cholsol (int order, const cs *A, double *b) ;
+	    int cs_lusol (int order, const cs *A, double *b, double tol) ;
+	    int cs_qrsol (int order, const cs *A, double *b) ;
+	    int *cs_amd (int order, const cs *A) ;
+	    css *cs_schol (int order, const cs *A) ;
+	    css *cs_sqr (int order, const cs *A, int qr) ;
+
+	    int *cs_post (const int *parent, int n) ;
+	    int cs_ipvec (const int *p, const double *b, double *x, int n) ;
+	    int cs_pvec (const int *p, const double *b, double *x, int n) ;
+
+	    cs *cs_compress (const cs *T) ;
+
+	Old syntax (v1.2 and earlier):
+	------------------------------
+
+	    order = -1: natural ordering
+	    order = 0: amd (A+A')
+	    order = 1: amd (S'*S), where S=A except dense rows dropped
+	    order = 2: amd (A'*A)
+
+	    int cs_cholsol (const cs *A, double *b, int order) ;
+	    int cs_lusol (const cs *A, double *b, int order, double tol) ;
+	    int cs_qrsol (const cs *A, double *b, int order) ;
+	    int *cs_amd (const cs *A, int order) ;
+	    css *cs_schol (const cs *A, int order) ;
+	    css *cs_sqr (const cs *A, int order, int qr) ;
+
+	    int *cs_post (int n, const int *parent) ;
+	    int cs_ipvec (int n, const int *p, const double *b, double *x) ;
+	    int cs_pvec (int n, const int *p, const double *b, double *x) ;
+
+	    cs *cs_triplet (const cs *T) ;
+
+    * CS_OVERFLOW macro removed (removed from cs_malloc.c; not needed).
+
+    * S->leftmost added to css (it was tacked onto S->pinv before).
+
+    * P,Q,R,S components of csd struct changed to p,q,r,s.
+
+    * Pinv and Q components of css struct changed to pinv and q.
+
+    * CS_CSC and CS_TRIPLET macros added, to clarify which CSparse functions
+	accept cs matrices in compressed column form, triplet form, or both.
+
+    * check for negative row/column indices added to cs_entry.
+
+    * cs_ereach and cs_leaf functions added.
+
+    * call to cs_sprealloc added to cs_fkeep.
+
+    * bug fixes in cs_counts and cs_amd (memory leak under rare out-of-memory
+	conditions).
+
+Mar 15, 2006:
+
+    * cs_scc modified so that the row and columns of each component are put in
+	their natural order.  cs_dmperm modified so that columns of each block
+	(instead of rows) are placed in their natural order.
+
+    * cs_splsolve renamed cs_spsolve, generalized to handle both Lx=b and
+	Ux=b, and non-unit diagonal, and placed in its own file (cs_spsolve.c;
+	it was a static function in cs_lu.c).  cs_lsolve_mex.c and
+	cs_splsolve_mex.c merged (the latter was removed).  cs_spsolve.c file
+	added
+
+    * cs_dmspy changed, so that block borders line up better with the matrix.
+
+Mar 6, 2006:
+
+    * Makefile modified so that the Tcov tests (which may not be portable)
+	are not compiled and run by the default "make" in the CSparse directory.
+	To compile everything, including the Tcov tests, use "make all".
+	Trivial change to cs.h.
+
+Feb 27, 2006:
+
+    * cs_reach, cs_dfs, cs_splsolve, cs_lu, and cs_scc changed to remove O(n)
+	initialized workspace.
+    * cs_reach and cs_splsolve now user-callable (were static in cs_lu.c).
+
+Feb 20, 2006:
+
+    * various changes to simplify the construction of CXSparse
+
+Feb 7, 2006:
+
+    * changed prototypes, adding "const" where appropriate.
+
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Demo/Makefile SuiteSparse/CXSparse-C++/Demo/Makefile
--- original-libraries/SuiteSparse/CXSparse-C++/Demo/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Demo/Makefile	2007-01-31 15:50:55.613183200 +0100
@@ -0,0 +1,171 @@
+# CC = cc-msvc
+# CFLAGS = -O2 -EHs -MD -TP
+
+include ../../UFconfig/UFconfig.mk
+
+I = -I../Source -I../../UFconfig
+
+CXXFLAGS = $(CFLAGS) -EHs
+
+CS = ../Source/$(LIBPRE)cxsparse.$(LIBEXT)
+
+all: $(CS) cs_demo1$(EXEEXT) cs_demo2$(EXEEXT) readhb$(EXEEXT) cs_demo3$(EXEEXT) \
+	cs_di_demo1$(EXEEXT) cs_di_demo2$(EXEEXT) cs_di_demo3$(EXEEXT) \
+	cs_dl_demo1$(EXEEXT) cs_dl_demo2$(EXEEXT) cs_dl_demo3$(EXEEXT) \
+	cs_ci_demo1$(EXEEXT) cs_ci_demo2$(EXEEXT) cs_ci_demo3$(EXEEXT) \
+	cs_cl_demo1$(EXEEXT) cs_cl_demo2$(EXEEXT) cs_cl_demo3$(EXEEXT)  \
+	tests cs_idemo$(EXEEXT)
+
+tests: test_convert test test_di test_dl test_ci test_cl
+
+test: cs_demo1$(EXEEXT) cs_demo2$(EXEEXT) cs_demo3$(EXEEXT)
+	- ./cs_demo1 < ../../CXSparse/Matrix/t1
+	- ./cs_demo2 < ../../CXSparse/Matrix/t1
+	- ./cs_demo2 < ../../CXSparse/Matrix/fs_183_1
+	- ./cs_demo2 < ../../CXSparse/Matrix/west0067
+	- ./cs_demo2 < ../../CXSparse/Matrix/lp_afiro
+	- ./cs_demo2 < ../../CXSparse/Matrix/ash219
+	- ./cs_demo2 < ../../CXSparse/Matrix/mbeacxc
+	- ./cs_demo2 < ../../CXSparse/Matrix/bcsstk01
+	- ./cs_demo3 < ../../CXSparse/Matrix/bcsstk01
+	- ./cs_demo2 < ../../CXSparse/Matrix/bcsstk16
+	- ./cs_demo3 < ../../CXSparse/Matrix/bcsstk16
+
+test_di: cs_di_demo1$(EXEEXT) cs_di_demo2$(EXEEXT) cs_di_demo3$(EXEEXT)
+	- ./cs_di_demo1 < ../../CXSparse/Matrix/t1
+	- ./cs_di_demo2 < ../../CXSparse/Matrix/t1
+	- ./cs_di_demo2 < ../../CXSparse/Matrix/fs_183_1
+	- ./cs_di_demo2 < ../../CXSparse/Matrix/west0067
+	- ./cs_di_demo2 < ../../CXSparse/Matrix/lp_afiro
+	- ./cs_di_demo2 < ../../CXSparse/Matrix/ash219
+	- ./cs_di_demo2 < ../../CXSparse/Matrix/mbeacxc
+	- ./cs_di_demo2 < ../../CXSparse/Matrix/bcsstk01
+	- ./cs_di_demo3 < ../../CXSparse/Matrix/bcsstk01
+	- ./cs_di_demo2 < ../../CXSparse/Matrix/bcsstk16
+	- ./cs_di_demo3 < ../../CXSparse/Matrix/bcsstk16
+
+test_dl: cs_dl_demo1$(EXEEXT) cs_dl_demo2$(EXEEXT) cs_dl_demo3$(EXEEXT)
+	- ./cs_dl_demo1 < ../../CXSparse/Matrix/t1
+	- ./cs_dl_demo2 < ../../CXSparse/Matrix/t1
+	- ./cs_dl_demo2 < ../../CXSparse/Matrix/fs_183_1
+	- ./cs_dl_demo2 < ../../CXSparse/Matrix/west0067
+	- ./cs_dl_demo2 < ../../CXSparse/Matrix/lp_afiro
+	- ./cs_dl_demo2 < ../../CXSparse/Matrix/ash219
+	- ./cs_dl_demo2 < ../../CXSparse/Matrix/mbeacxc
+	- ./cs_dl_demo2 < ../../CXSparse/Matrix/bcsstk01
+	- ./cs_dl_demo3 < ../../CXSparse/Matrix/bcsstk01
+	- ./cs_dl_demo2 < ../../CXSparse/Matrix/bcsstk16
+	- ./cs_dl_demo3 < ../../CXSparse/Matrix/bcsstk16
+
+test_ci: cs_ci_demo1$(EXEEXT) cs_ci_demo2$(EXEEXT) cs_ci_demo3$(EXEEXT)
+	- ./cs_ci_demo1 < ../../CXSparse/Matrix/t2
+	- ./cs_ci_demo2 < ../../CXSparse/Matrix/t2
+	- ./cs_ci_demo2 < ../../CXSparse/Matrix/t3
+	- ./cs_ci_demo2 < ../../CXSparse/Matrix/t4
+	- ./cs_ci_demo2 < ../../CXSparse/Matrix/c_west0067
+	- ./cs_ci_demo2 < ../../CXSparse/Matrix/c_mbeacxc
+	- ./cs_ci_demo2 < ../../CXSparse/Matrix/young1c
+	- ./cs_ci_demo2 < ../../CXSparse/Matrix/qc324
+	- ./cs_ci_demo2 < ../../CXSparse/Matrix/neumann
+	- ./cs_ci_demo2 < ../../CXSparse/Matrix/mhd1280b
+	- ./cs_ci_demo3 < ../../CXSparse/Matrix/mhd1280b
+
+test_cl: cs_cl_demo1$(EXEEXT) cs_cl_demo2$(EXEEXT) cs_cl_demo3$(EXEEXT)
+	- ./cs_cl_demo1 < ../../CXSparse/Matrix/t2
+	- ./cs_cl_demo2 < ../../CXSparse/Matrix/t2
+	- ./cs_cl_demo2 < ../../CXSparse/Matrix/t3
+	- ./cs_cl_demo2 < ../../CXSparse/Matrix/t4
+	- ./cs_cl_demo2 < ../../CXSparse/Matrix/c_west0067
+	- ./cs_cl_demo2 < ../../CXSparse/Matrix/c_mbeacxc
+	- ./cs_cl_demo2 < ../../CXSparse/Matrix/young1c
+	- ./cs_cl_demo2 < ../../CXSparse/Matrix/qc324
+	- ./cs_cl_demo2 < ../../CXSparse/Matrix/neumann
+	- ./cs_cl_demo2 < ../../CXSparse/Matrix/mhd1280b
+	- ./cs_cl_demo3 < ../../CXSparse/Matrix/mhd1280b
+
+test_convert: cs_idemo$(EXEEXT) cs_ldemo$(EXEEXT)
+	- ./cs_idemo < ../../CXSparse/Matrix/t2
+	- ./cs_ldemo < ../../CXSparse/Matrix/t2
+
+$(CS):
+	( cd ../Source ; $(MAKE) )
+
+cs_demo1$(EXEEXT): $(CS) cs_demo1.cpp Makefile $(CS)
+	$(CC) $(CXXFLAGS) $(I) -o cs_demo1$(EXEEXT) cs_demo1.cpp $(CS) $(CLIB)
+
+cs_demo2$(EXEEXT): $(CS) cs_demo2.cpp cs_demo.cpp cs_demo.h Makefile $(CS)
+	$(CC) $(CXXFLAGS) $(I) -o cs_demo2$(EXEEXT) cs_demo2.cpp cs_demo.cpp $(CS) $(CLIB)
+
+cs_demo3$(EXEEXT): $(CS) cs_demo3.cpp cs_demo.cpp cs_demo.h Makefile $(CS)
+	$(CC) $(CXXFLAGS) $(I) -o cs_demo3$(EXEEXT) cs_demo3.cpp cs_demo.cpp $(CS) $(CLIB)
+
+
+
+
+cs_di_demo1$(EXEEXT): $(CS) cs_di_demo1.cpp Makefile $(CS)
+	$(CC) $(CXXFLAGS) $(I) -o cs_di_demo1$(EXEEXT) cs_di_demo1.cpp $(CS) $(CLIB)
+
+cs_di_demo2$(EXEEXT): $(CS) cs_di_demo2.cpp cs_di_demo.cpp cs_di_demo.h Makefile $(CS)
+	$(CC) $(CXXFLAGS) $(I) -o cs_di_demo2$(EXEEXT) cs_di_demo2.cpp cs_di_demo.cpp $(CS) $(CLIB)
+
+cs_di_demo3$(EXEEXT): $(CS) cs_di_demo3.cpp cs_di_demo.cpp cs_di_demo.h Makefile $(CS)
+	$(CC) $(CXXFLAGS) $(I) -o cs_di_demo3$(EXEEXT) cs_di_demo3.cpp cs_di_demo.cpp $(CS) $(CLIB)
+
+
+
+
+cs_ci_demo1$(EXEEXT): $(CS) cs_ci_demo1.cpp Makefile $(CS)
+	$(CC) $(CXXFLAGS) $(I) -o cs_ci_demo1$(EXEEXT) cs_ci_demo1.cpp $(CS) $(CLIB)
+
+cs_ci_demo2$(EXEEXT): $(CS) cs_ci_demo2.cpp cs_ci_demo.cpp cs_ci_demo.h Makefile $(CS)
+	$(CC) $(CXXFLAGS) $(I) -o cs_ci_demo2$(EXEEXT) cs_ci_demo2.cpp cs_ci_demo.cpp $(CS) $(CLIB)
+
+cs_ci_demo3$(EXEEXT): $(CS) cs_ci_demo3.cpp cs_ci_demo.cpp cs_ci_demo.h Makefile $(CS)
+	$(CC) $(CXXFLAGS) $(I) -o cs_ci_demo3$(EXEEXT) cs_ci_demo3.cpp cs_ci_demo.cpp $(CS) $(CLIB)
+
+
+
+cs_dl_demo1$(EXEEXT): $(CS) cs_dl_demo1.cpp Makefile $(CS)
+	$(CC) $(CXXFLAGS) $(I) -o cs_dl_demo1$(EXEEXT) cs_dl_demo1.cpp $(CS) $(CLIB)
+
+cs_dl_demo2$(EXEEXT): $(CS) cs_dl_demo2.cpp cs_dl_demo.cpp cs_dl_demo.h Makefile $(CS)
+	$(CC) $(CXXFLAGS) $(I) -o cs_dl_demo2$(EXEEXT) cs_dl_demo2.cpp cs_dl_demo.cpp $(CS) $(CLIB)
+
+cs_dl_demo3$(EXEEXT): $(CS) cs_dl_demo3.cpp cs_dl_demo.cpp cs_dl_demo.h Makefile $(CS)
+	$(CC) $(CXXFLAGS) $(I) -o cs_dl_demo3$(EXEEXT) cs_dl_demo3.cpp cs_dl_demo.cpp $(CS) $(CLIB)
+
+
+cs_cl_demo1$(EXEEXT): $(CS) cs_cl_demo1.cpp Makefile $(CS)
+	$(CC) $(CXXFLAGS) $(I) -o cs_cl_demo1$(EXEEXT) cs_cl_demo1.cpp $(CS) $(CLIB)
+
+cs_cl_demo2$(EXEEXT): $(CS) cs_cl_demo2.cpp cs_cl_demo.cpp cs_cl_demo.h Makefile $(CS)
+	$(CC) $(CXXFLAGS) $(I) -o cs_cl_demo2$(EXEEXT) cs_cl_demo2.cpp cs_cl_demo.cpp $(CS) $(CLIB)
+
+cs_cl_demo3$(EXEEXT): $(CS) cs_cl_demo3.cpp cs_cl_demo.cpp cs_cl_demo.h Makefile $(CS)
+	$(CC) $(CXXFLAGS) $(I) -o cs_cl_demo3$(EXEEXT) cs_cl_demo3.cpp cs_cl_demo.cpp $(CS) $(CLIB)
+
+
+
+
+cs_idemo$(EXEEXT): $(CS) cs_idemo.cpp Makefile $(CS)
+	$(CC) $(CXXFLAGS) $(I) -o cs_idemo$(EXEEXT) cs_idemo.cpp $(CS) $(CLIB)
+
+cs_ldemo$(EXEEXT): $(CS) cs_ldemo.cpp Makefile $(CS)
+	$(CC) $(CXXFLAGS) $(I) -o cs_ldemo$(EXEEXT) cs_ldemo.cpp $(CS) $(CLIB)
+
+
+readhb$(EXEEXT): readhb.f Makefile
+	g77 -o readhb$(EXEEXT) readhb.f
+
+clean:
+	rm -f *.o *.obj
+
+purge: distclean
+
+distclean: clean
+	rm -f cs_demo1$(EXEEXT) cs_demo2$(EXEEXT) cs_demo3$(EXEEXT) readhb$(EXEEXT) *.$(LIBEXT)
+	rm -f cs_di_demo1$(EXEEXT) cs_di_demo2$(EXEEXT) cs_di_demo3$(EXEEXT)
+	rm -f cs_dl_demo1$(EXEEXT) cs_dl_demo2$(EXEEXT) cs_dl_demo3$(EXEEXT)
+	rm -f cs_ci_demo1$(EXEEXT) cs_ci_demo2$(EXEEXT) cs_ci_demo3$(EXEEXT)
+	rm -f cs_cl_demo1$(EXEEXT) cs_cl_demo2$(EXEEXT) cs_cl_demo3$(EXEEXT)
+	rm -f cs_idemo$(EXEEXT) cs_ldemo$(EXEEXT)
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Demo/README.txt SuiteSparse/CXSparse-C++/Demo/README.txt
--- original-libraries/SuiteSparse/CXSparse-C++/Demo/README.txt	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Demo/README.txt	2006-02-18 06:38:48.000000000 +0100
@@ -0,0 +1,4 @@
+CXSparse/Demo:  to compile a run the demos, just type "make" in this directory.
+The printed residuals should all be small, except for the mbeacxc matrix
+(which is numerically and structurally singular), and ash219 (which is a
+least-squares problem).  See cs_demo.out for the proper output of "make".
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_ci_demo.cpp SuiteSparse/CXSparse-C++/Demo/cs_ci_demo.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_ci_demo.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Demo/cs_ci_demo.cpp	2006-11-24 16:34:46.000000000 +0100
@@ -0,0 +1,288 @@
+#include "cs_ci_demo.h"
+#include <time.h>
+/* 1 if A is square & upper tri., -1 if square & lower tri., 0 otherwise */
+static int is_sym (cs_ci *A)
+{
+    int is_upper, is_lower, j, p, n = A->n, m = A->m, *Ap = A->p, *Ai = A->i ;
+    if (m != n) return (0) ;
+    is_upper = 1 ;
+    is_lower = 1 ;
+    for (j = 0 ; j < n ; j++)
+    {
+	for (p = Ap [j] ; p < Ap [j+1] ; p++)
+	{
+	    if (Ai [p] > j) is_upper = 0 ;
+	    if (Ai [p] < j) is_lower = 0 ;
+	}
+    }
+    return (is_upper ? 1 : (is_lower ? -1 : 0)) ;
+}
+
+/* true for off-diagonal entries */
+static int dropdiag (int i, int j, CPLX aij, void *other) { return (i != j) ;}
+
+/* C = A + triu(A,1)' */
+static cs_ci *make_sym (cs_ci *A)
+{
+    cs_ci *AT, *C ;
+    AT = cs_ci_transpose (A, 1) ;		/* AT = A' */
+    cs_ci_fkeep (AT, &dropdiag, NULL) ;	/* drop diagonal entries from AT */
+    C = cs_ci_add (A, AT, 1, 1) ;		/* C = A+AT */
+    cs_ci_spfree (AT) ;
+    return (C) ;
+}
+
+/* create a right-hand side */
+static void rhs (CPLX *x, CPLX *b, int m)
+{
+    int i ;
+    for (i = 0 ; i < m ; i++) b [i] = 1 + ((double) i) / m ;
+    for (i = 0 ; i < m ; i++) x [i] = b [i] ;
+}
+
+/* infinity-norm of x */
+static double norm (CPLX *x, int n)
+{
+    int i ;
+    double normx = 0 ;
+    for (i = 0 ; i < n ; i++) normx = CS_MAX (normx, abs (x [i])) ;
+    return (normx) ;
+}
+
+/* compute residual, norm(A*x-b,inf) / (norm(A,1)*norm(x,inf) + norm(b,inf)) */
+static void print_resid (int ok, cs_ci *A, CPLX *x, CPLX *b, CPLX *resid)
+{
+    int i, m, n ;
+    if (!ok) { printf ("    (failed)\n") ; return ; }
+    m = A->m ; n = A->n ;
+    for (i = 0 ; i < m ; i++) resid [i] = -b [i] ;  /* resid = -b */
+    cs_ci_gaxpy (A, x, resid) ;			    /* resid = resid + A*x  */
+    printf ("resid: %8.2e\n", norm (resid,m) / ((n == 0) ? 1 :
+	(cs_ci_norm (A) * norm (x,n) + norm (b,m)))) ;
+}
+
+static double tic (void) { return (clock () / (double) CLOCKS_PER_SEC) ; }
+static double toc (double t) { double s = tic () ; return (CS_MAX (0, s-t)) ; }
+
+static void print_order (int order)
+{
+    switch (order)
+    {
+	case 0: printf ("natural    ") ; break ;
+	case 1: printf ("amd(A+A')  ") ; break ;
+	case 2: printf ("amd(S'*S)  ") ; break ;
+	case 3: printf ("amd(A'*A)  ") ; break ;
+    }
+}
+
+/* read a problem from a file */
+problem *get_problem (FILE *f, double tol)
+{
+    cs_ci *T, *A, *C ;
+    int sym, m, n, mn, nz1, nz2 ;
+    problem *Prob ;
+    Prob = (problem *)cs_ci_calloc (1, sizeof (problem)) ;
+    if (!Prob) return (NULL) ;
+    T = cs_ci_load (f) ;			/* load triplet matrix T from a file */
+    Prob->A = A = cs_ci_compress (T) ;	/* A = compressed-column form of T */
+    cs_ci_spfree (T) ;			/* clear T */
+    if (!cs_ci_dupl (A)) return (free_problem (Prob)) ; /* sum up duplicates */
+    Prob->sym = sym = is_sym (A) ;	/* determine if A is symmetric */
+    m = A->m ; n = A->n ;
+    mn = CS_MAX (m,n) ;
+    nz1 = A->p [n] ;
+    cs_ci_dropzeros (A) ;			/* drop zero entries */
+    nz2 = A->p [n] ;
+    if (tol > 0) cs_ci_droptol (A, tol) ;	/* drop tiny entries (just to test) */
+    Prob->C = C = sym ? make_sym (A) : A ;  /* C = A + triu(A,1)', or C=A */
+    if (!C) return (free_problem (Prob)) ;
+    printf ("\n--- Matrix: %d-by-%d, nnz: %d (sym: %d: nnz %d), norm: %8.2e\n",
+	    m, n, A->p [n], sym, sym ? C->p [n] : 0, cs_ci_norm (C)) ;
+    if (nz1 != nz2) printf ("zero entries dropped: %d\n", nz1 - nz2) ;
+    if (nz2 != A->p [n]) printf ("tiny entries dropped: %d\n", nz2 - A->p [n]) ;
+    Prob->b = (CPLX *)cs_ci_malloc (mn, sizeof (CPLX)) ;
+    Prob->x = (CPLX *)cs_ci_malloc (mn, sizeof (CPLX)) ;
+    Prob->resid = (CPLX *)cs_ci_malloc (mn, sizeof (CPLX)) ;
+    return ((!Prob->b || !Prob->x || !Prob->resid) ? free_problem (Prob) : Prob) ;
+}
+
+/* free a problem */
+problem *free_problem (problem *Prob)
+{
+    if (!Prob) return (NULL) ;
+    cs_ci_spfree (Prob->A) ;
+    if (Prob->sym) cs_ci_spfree (Prob->C) ;
+    cs_ci_free (Prob->b) ;
+    cs_ci_free (Prob->x) ;
+    cs_ci_free (Prob->resid) ;
+    return (problem *)(cs_ci_free (Prob)) ;
+}
+
+/* solve a linear system using Cholesky, LU, and QR, with various orderings */
+int demo2 (problem *Prob)
+{
+    cs_ci *A, *C ;
+    CPLX *b, *x, *resid ;
+    double t, tol ;
+    int k, m, n, ok, order, nb, ns, *r, *s, *rr, sprank ;
+    cs_cid *D ;
+    if (!Prob) return (0) ;
+    A = Prob->A ; C = Prob->C ; b = Prob->b ; x = Prob->x ; resid = Prob->resid;
+    m = A->m ; n = A->n ;
+    tol = Prob->sym ? 0.001 : 1 ;		/* partial pivoting tolerance */
+    D = cs_ci_dmperm (C, 1) ;			/* randomized dmperm analysis */
+    if (!D) return (0) ;
+    nb = D->nb ; r = D->r ; s = D->s ; rr = D->rr ;
+    sprank = rr [3] ;
+    for (ns = 0, k = 0 ; k < nb ; k++)
+    {
+	ns += ((r [k+1] == r [k]+1) && (s [k+1] == s [k]+1)) ;
+    }
+    printf ("blocks: %d singletons: %d structural rank: %d\n", nb, ns, sprank) ;
+    cs_ci_dfree (D) ;
+    for (order = 0 ; order <= 3 ; order += 3)	/* natural and amd(A'*A) */
+    {
+	if (!order && m > 1000) continue ;
+	printf ("QR   ") ;
+	print_order (order) ;
+	rhs (x, b, m) ;				/* compute right-hand side */
+	t = tic () ;
+	ok = cs_ci_qrsol (order, C, x) ;		/* min norm(Ax-b) with QR */
+	printf ("time: %8.2f ", toc (t)) ;
+	print_resid (ok, C, x, b, resid) ;	/* print residual */
+    }
+    if (m != n || sprank < n) return (1) ;	/* return if rect. or singular*/
+    for (order = 0 ; order <= 3 ; order++)	/* try all orderings */
+    {
+	if (!order && m > 1000) continue ;
+	printf ("LU   ") ;
+	print_order (order) ;
+	rhs (x, b, m) ;				/* compute right-hand side */
+	t = tic () ;
+	ok = cs_ci_lusol (order, C, x, tol) ;	/* solve Ax=b with LU */
+	printf ("time: %8.2f ", toc (t)) ;
+	print_resid (ok, C, x, b, resid) ;	/* print residual */
+    }
+    if (!Prob->sym) return (1) ;
+    for (order = 0 ; order <= 1 ; order++)	/* natural and amd(A+A') */
+    {
+	if (!order && m > 1000) continue ;
+	printf ("Chol ") ;
+	print_order (order) ;
+	rhs (x, b, m) ;				/* compute right-hand side */
+	t = tic () ;
+	ok = cs_ci_cholsol (order, C, x) ;		/* solve Ax=b with Cholesky */
+	printf ("time: %8.2f ", toc (t)) ;
+	print_resid (ok, C, x, b, resid) ;	/* print residual */
+    }
+    return (1) ;
+} 
+
+/* free workspace for demo3 */
+static int done3 (int ok, cs_cis *S, cs_cin *N, CPLX *y, cs_ci *W, cs_ci *E, int *p)
+{
+    cs_ci_sfree (S) ;
+    cs_ci_nfree (N) ;
+    cs_ci_free (y) ;
+    cs_ci_spfree (W) ;
+    cs_ci_spfree (E) ;
+    cs_ci_free (p) ;
+    return (ok) ;
+}
+
+/* Cholesky update/downdate */
+int demo3 (problem *Prob)
+{
+    cs_ci *A, *C, *W = NULL, *WW, *WT, *E = NULL, *W2 ;
+    int n, k, *Li, *Lp, *Wi, *Wp, p1, p2, *p = NULL, ok ;
+    CPLX *b, *x, *resid, *y = NULL, *Lx, *Wx, s ;
+    double t, t1 ;
+    cs_cis *S = NULL ;
+    cs_cin *N = NULL ;
+    if (!Prob || !Prob->sym || Prob->A->n == 0) return (0) ;
+    A = Prob->A ; C = Prob->C ; b = Prob->b ; x = Prob->x ; resid = Prob->resid;
+    n = A->n ;
+    if (!Prob->sym || n == 0) return (1) ;
+    rhs (x, b, n) ;				/* compute right-hand side */
+    printf ("\nchol then update/downdate ") ;
+    print_order (1) ;
+    y = (CPLX *)cs_ci_malloc (n, sizeof (CPLX)) ;
+    t = tic () ;
+    S = cs_ci_schol (1, C) ;			/* symbolic Chol, amd(A+A') */
+    printf ("\nsymbolic chol time %8.2f\n", toc (t)) ;
+    t = tic () ;
+    N = cs_ci_chol (C, S) ;			/* numeric Cholesky */
+    printf ("numeric  chol time %8.2f\n", toc (t)) ;
+    if (!S || !N || !y) return (done3 (0, S, N, y, W, E, p)) ;
+    t = tic () ;
+    cs_ci_ipvec (S->pinv, b, y, n) ;		/* y = P*b */
+    cs_ci_lsolve (N->L, y) ;			/* y = L\y */
+    cs_ci_ltsolve (N->L, y) ;			/* y = L'\y */
+    cs_ci_pvec (S->pinv, y, x, n) ;		/* x = P'*y */
+    printf ("solve    chol time %8.2f\n", toc (t)) ;
+    printf ("original: ") ;
+    print_resid (1, C, x, b, resid) ;		/* print residual */
+    k = n/2 ;					/* construct W  */
+    W = cs_ci_spalloc (n, 1, n, 1, 0) ;
+    if (!W) return (done3 (0, S, N, y, W, E, p)) ;
+    Lp = N->L->p ; Li = N->L->i ; Lx = N->L->x ;
+    Wp = W->p ; Wi = W->i ; Wx = W->x ;
+    Wp [0] = 0 ;
+    p1 = Lp [k] ;
+    Wp [1] = Lp [k+1] - p1 ;
+    s = Lx [p1] ;
+    srand (1) ;
+    for ( ; p1 < Lp [k+1] ; p1++)
+    {
+	p2 = p1 - Lp [k] ;
+	Wi [p2] = Li [p1] ;
+	Wx [p2] = s * CPLX(rand () / ((double) RAND_MAX)) ;
+    }
+    t = tic () ;
+    ok = cs_ci_updown (N->L, +1, W, S->parent) ;	/* update: L*L'+W*W' */
+    t1 = toc (t) ;
+    printf ("update:   time: %8.2f\n", t1) ;
+    if (!ok) return (done3 (0, S, N, y, W, E, p)) ;
+    t = tic () ;
+    cs_ci_ipvec (S->pinv, b, y, n) ;		/* y = P*b */
+    cs_ci_lsolve (N->L, y) ;			/* y = L\y */
+    cs_ci_ltsolve (N->L, y) ;			/* y = L'\y */
+    cs_ci_pvec (S->pinv, y, x, n) ;		/* x = P'*y */
+    t = toc (t) ;
+    p = cs_ci_pinv (S->pinv, n) ;
+    W2 = cs_ci_permute (W, p, NULL, 1) ;		/* E = C + (P'W)*(P'W)' */
+    WT = cs_ci_transpose (W2,1) ;
+    WW = cs_ci_multiply (W2, WT) ;
+    cs_ci_spfree (WT) ;
+    cs_ci_spfree (W2) ;
+    E = cs_ci_add (C, WW, 1, 1) ;
+    cs_ci_spfree (WW) ;
+    if (!E || !p) return (done3 (0, S, N, y, W, E, p)) ;
+    printf ("update:   time: %8.2f (incl solve) ", t1+t) ;
+    print_resid (1, E, x, b, resid) ;		/* print residual */
+    cs_ci_nfree (N) ;				/* clear N */
+    t = tic () ;
+    N = cs_ci_chol (E, S) ;			/* numeric Cholesky */
+    if (!N) return (done3 (0, S, N, y, W, E, p)) ;
+    cs_ci_ipvec (S->pinv, b, y, n) ;		/* y = P*b */
+    cs_ci_lsolve (N->L, y) ;			/* y = L\y */
+    cs_ci_ltsolve (N->L, y) ;			/* y = L'\y */
+    cs_ci_pvec (S->pinv, y, x, n) ;		/* x = P'*y */
+    t = toc (t) ;
+    printf ("rechol:   time: %8.2f (incl solve) ", t) ;
+    print_resid (1, E, x, b, resid) ;		/* print residual */
+    t = tic () ;
+    ok = cs_ci_updown (N->L, -1, W, S->parent) ;	/* downdate: L*L'-W*W' */
+    t1 = toc (t) ;
+    if (!ok) return (done3 (0, S, N, y, W, E, p)) ;
+    printf ("downdate: time: %8.2f\n", t1) ;
+    t = tic () ;
+    cs_ci_ipvec (S->pinv, b, y, n) ;		/* y = P*b */
+    cs_ci_lsolve (N->L, y) ;			/* y = L\y */
+    cs_ci_ltsolve (N->L, y) ;			/* y = L'\y */
+    cs_ci_pvec (S->pinv, y, x, n) ;		/* x = P'*y */
+    t = toc (t) ;
+    printf ("downdate: time: %8.2f (incl solve) ", t1+t) ;
+    print_resid (1, C, x, b, resid) ;		/* print residual */
+    return (done3 (1, S, N, y, W, E, p)) ;
+} 
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_ci_demo.h SuiteSparse/CXSparse-C++/Demo/cs_ci_demo.h
--- original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_ci_demo.h	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Demo/cs_ci_demo.h	2006-11-24 16:31:18.000000000 +0100
@@ -0,0 +1,15 @@
+#include "cs.h"
+typedef struct problem_struct
+{
+    cs_ci *A ;
+    cs_ci *C ;
+    int sym ;
+    CPLX *x ;
+    CPLX *b ;
+    CPLX *resid ;
+} problem ;
+
+problem *get_problem (FILE *f, double tol) ;
+int demo2 (problem *Prob) ;
+int demo3 (problem *Prob) ;
+problem *free_problem (problem *Prob) ;
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_ci_demo1.cpp SuiteSparse/CXSparse-C++/Demo/cs_ci_demo1.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_ci_demo1.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Demo/cs_ci_demo1.cpp	2006-08-25 08:04:44.000000000 +0200
@@ -0,0 +1,27 @@
+#include "cs.h"
+int main (void)
+{
+    cs_ci *T, *A, *Eye, *AT, *C, *D ;
+    int i, m ;
+    T = cs_ci_load (stdin) ;		/* load triplet matrix T from stdin */
+    printf ("T:\n") ; cs_ci_print (T, 0) ;	/* print T */
+    A = cs_ci_compress (T) ;		/* A = compressed-column form of T */
+    printf ("A:\n") ; cs_ci_print (A, 0) ;	/* print A */
+    cs_ci_spfree (T) ;			/* clear T */
+    AT = cs_ci_transpose (A, 1) ;		/* AT = A' */
+    printf ("AT:\n") ; cs_ci_print (AT, 0) ; /* print AT */
+    m = A ? A->m : 0 ;			/* m = # of rows of A */
+    T = cs_ci_spalloc (m, m, m, 1, 1) ;	/* create triplet identity matrix */
+    for (i = 0 ; i < m ; i++) cs_ci_entry (T, i, i, 1) ;
+    Eye = cs_ci_compress (T) ;		/* Eye = speye (m) */
+    cs_ci_spfree (T) ;
+    C = cs_ci_multiply (A, AT) ;		/* C = A*A' */
+    D = cs_ci_add (C, Eye, 1, cs_ci_norm (C)) ;   /* D = C + Eye*norm (C,1) */
+    printf ("D:\n") ; cs_ci_print (D, 0) ;	/* print D */
+    cs_ci_spfree (A) ;			/* clear A AT C D Eye */
+    cs_ci_spfree (AT) ;
+    cs_ci_spfree (C) ;
+    cs_ci_spfree (D) ;
+    cs_ci_spfree (Eye) ;
+    return (0) ;
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_ci_demo2.cpp SuiteSparse/CXSparse-C++/Demo/cs_ci_demo2.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_ci_demo2.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Demo/cs_ci_demo2.cpp	2006-08-25 08:04:44.000000000 +0200
@@ -0,0 +1,9 @@
+#include "cs_ci_demo.h"
+/* cs_ci_demo2: read a matrix and solve a linear system */
+int main (void)
+{
+    problem *Prob = get_problem (stdin, 1e-14) ;
+    demo2 (Prob) ;
+    free_problem (Prob) ;
+    return (0) ;
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_ci_demo3.cpp SuiteSparse/CXSparse-C++/Demo/cs_ci_demo3.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_ci_demo3.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Demo/cs_ci_demo3.cpp	2006-08-25 08:04:44.000000000 +0200
@@ -0,0 +1,9 @@
+#include "cs_ci_demo.h"
+/* cs_ci_demo3: read a matrix and test Cholesky update/downdate */
+int main (void)
+{
+    problem *Prob = get_problem (stdin, 0) ;
+    demo3 (Prob) ;
+    free_problem (Prob) ;
+    return (0) ;
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_cl_demo.cpp SuiteSparse/CXSparse-C++/Demo/cs_cl_demo.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_cl_demo.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Demo/cs_cl_demo.cpp	2006-11-24 16:37:22.000000000 +0100
@@ -0,0 +1,288 @@
+#include "cs_cl_demo.h"
+#include <time.h>
+/* 1 if A is square & upper tri., -1 if square & lower tri., 0 otherwise */
+static UF_long is_sym (cs_cl *A)
+{
+    UF_long is_upper, is_lower, j, p, n = A->n, m = A->m, *Ap = A->p, *Ai = A->i ;
+    if (m != n) return (0) ;
+    is_upper = 1 ;
+    is_lower = 1 ;
+    for (j = 0 ; j < n ; j++)
+    {
+	for (p = Ap [j] ; p < Ap [j+1] ; p++)
+	{
+	    if (Ai [p] > j) is_upper = 0 ;
+	    if (Ai [p] < j) is_lower = 0 ;
+	}
+    }
+    return (is_upper ? 1 : (is_lower ? -1 : 0)) ;
+}
+
+/* true for off-diagonal entries */
+static UF_long dropdiag (UF_long i, UF_long j, CPLX aij, void *other) { return (i != j) ;}
+
+/* C = A + triu(A,1)' */
+static cs_cl *make_sym (cs_cl *A)
+{
+    cs_cl *AT, *C ;
+    AT = cs_cl_transpose (A, 1) ;		/* AT = A' */
+    cs_cl_fkeep (AT, &dropdiag, NULL) ;	/* drop diagonal entries from AT */
+    C = cs_cl_add (A, AT, 1, 1) ;		/* C = A+AT */
+    cs_cl_spfree (AT) ;
+    return (C) ;
+}
+
+/* create a right-hand side */
+static void rhs (CPLX *x, CPLX *b, UF_long m)
+{
+    UF_long i ;
+    for (i = 0 ; i < m ; i++) b [i] = 1 + ((double) i) / m ;
+    for (i = 0 ; i < m ; i++) x [i] = b [i] ;
+}
+
+/* infinity-norm of x */
+static double norm (CPLX *x, UF_long n)
+{
+    UF_long i ;
+    double normx = 0 ;
+    for (i = 0 ; i < n ; i++) normx = CS_MAX (normx, abs (x [i])) ;
+    return (normx) ;
+}
+
+/* compute residual, norm(A*x-b,inf) / (norm(A,1)*norm(x,inf) + norm(b,inf)) */
+static void print_resid (UF_long ok, cs_cl *A, CPLX *x, CPLX *b, CPLX *resid)
+{
+    UF_long i, m, n ;
+    if (!ok) { printf ("    (failed)\n") ; return ; }
+    m = A->m ; n = A->n ;
+    for (i = 0 ; i < m ; i++) resid [i] = -b [i] ;  /* resid = -b */
+    cs_cl_gaxpy (A, x, resid) ;			    /* resid = resid + A*x  */
+    printf ("resid: %8.2e\n", norm (resid,m) / ((n == 0) ? 1 :
+	(cs_cl_norm (A) * norm (x,n) + norm (b,m)))) ;
+}
+
+static double tic (void) { return (clock () / (double) CLOCKS_PER_SEC) ; }
+static double toc (double t) { double s = tic () ; return (CS_MAX (0, s-t)) ; }
+
+static void print_order (UF_long order)
+{
+    switch (order)
+    {
+	case 0: printf ("natural    ") ; break ;
+	case 1: printf ("amd(A+A')  ") ; break ;
+	case 2: printf ("amd(S'*S)  ") ; break ;
+	case 3: printf ("amd(A'*A)  ") ; break ;
+    }
+}
+
+/* read a problem from a file */
+problem *get_problem (FILE *f, double tol)
+{
+    cs_cl *T, *A, *C ;
+    UF_long sym, m, n, mn, nz1, nz2 ;
+    problem *Prob ;
+    Prob = (problem *)cs_cl_calloc (1, sizeof (problem)) ;
+    if (!Prob) return (NULL) ;
+    T = cs_cl_load (f) ;			/* load triplet matrix T from a file */
+    Prob->A = A = cs_cl_compress (T) ;	/* A = compressed-column form of T */
+    cs_cl_spfree (T) ;			/* clear T */
+    if (!cs_cl_dupl (A)) return (free_problem (Prob)) ; /* sum up duplicates */
+    Prob->sym = sym = is_sym (A) ;	/* determine if A is symmetric */
+    m = A->m ; n = A->n ;
+    mn = CS_MAX (m,n) ;
+    nz1 = A->p [n] ;
+    cs_cl_dropzeros (A) ;			/* drop zero entries */
+    nz2 = A->p [n] ;
+    if (tol > 0) cs_cl_droptol (A, tol) ;	/* drop tiny entries (just to test) */
+    Prob->C = C = sym ? make_sym (A) : A ;  /* C = A + triu(A,1)', or C=A */
+    if (!C) return (free_problem (Prob)) ;
+    printf ("\n--- Matrix: %ld-by-%ld, nnz: %ld (sym: %ld: nnz %ld), norm: %8.2e\n",
+	    m, n, A->p [n], sym, sym ? C->p [n] : 0, cs_cl_norm (C)) ;
+    if (nz1 != nz2) printf ("zero entries dropped: %ld\n", nz1 - nz2) ;
+    if (nz2 != A->p [n]) printf ("tiny entries dropped: %ld\n", nz2 - A->p [n]) ;
+    Prob->b = (CPLX *)cs_cl_malloc (mn, sizeof (CPLX)) ;
+    Prob->x = (CPLX *)cs_cl_malloc (mn, sizeof (CPLX)) ;
+    Prob->resid = (CPLX *)cs_cl_malloc (mn, sizeof (CPLX)) ;
+    return ((!Prob->b || !Prob->x || !Prob->resid) ? free_problem (Prob) : Prob) ;
+}
+
+/* free a problem */
+problem *free_problem (problem *Prob)
+{
+    if (!Prob) return (NULL) ;
+    cs_cl_spfree (Prob->A) ;
+    if (Prob->sym) cs_cl_spfree (Prob->C) ;
+    cs_cl_free (Prob->b) ;
+    cs_cl_free (Prob->x) ;
+    cs_cl_free (Prob->resid) ;
+    return (problem *)(cs_cl_free (Prob)) ;
+}
+
+/* solve a linear system using Cholesky, LU, and QR, with various orderings */
+UF_long demo2 (problem *Prob)
+{
+    cs_cl *A, *C ;
+    CPLX *b, *x, *resid ;
+    double t, tol ;
+    UF_long k, m, n, ok, order, nb, ns, *r, *s, *rr, sprank ;
+    cs_cld *D ;
+    if (!Prob) return (0) ;
+    A = Prob->A ; C = Prob->C ; b = Prob->b ; x = Prob->x ; resid = Prob->resid;
+    m = A->m ; n = A->n ;
+    tol = Prob->sym ? 0.001 : 1 ;		/* partial pivoting tolerance */
+    D = cs_cl_dmperm (C, 1) ;			/* randomized dmperm analysis */
+    if (!D) return (0) ;
+    nb = D->nb ; r = D->r ; s = D->s ; rr = D->rr ;
+    sprank = rr [3] ;
+    for (ns = 0, k = 0 ; k < nb ; k++)
+    {
+	ns += ((r [k+1] == r [k]+1) && (s [k+1] == s [k]+1)) ;
+    }
+    printf ("blocks: %ld singletons: %ld structural rank: %ld\n", nb, ns, sprank) ;
+    cs_cl_dfree (D) ;
+    for (order = 0 ; order <= 3 ; order += 3)	/* natural and amd(A'*A) */
+    {
+	if (!order && m > 1000) continue ;
+	printf ("QR   ") ;
+	print_order (order) ;
+	rhs (x, b, m) ;				/* compute right-hand side */
+	t = tic () ;
+	ok = cs_cl_qrsol (order, C, x) ;		/* min norm(Ax-b) with QR */
+	printf ("time: %8.2f ", toc (t)) ;
+	print_resid (ok, C, x, b, resid) ;	/* print residual */
+    }
+    if (m != n || sprank < n) return (1) ;	/* return if rect. or singular*/
+    for (order = 0 ; order <= 3 ; order++)	/* try all orderings */
+    {
+	if (!order && m > 1000) continue ;
+	printf ("LU   ") ;
+	print_order (order) ;
+	rhs (x, b, m) ;				/* compute right-hand side */
+	t = tic () ;
+	ok = cs_cl_lusol (order, C, x, tol) ;	/* solve Ax=b with LU */
+	printf ("time: %8.2f ", toc (t)) ;
+	print_resid (ok, C, x, b, resid) ;	/* print residual */
+    }
+    if (!Prob->sym) return (1) ;
+    for (order = 0 ; order <= 1 ; order++)	/* natural and amd(A+A') */
+    {
+	if (!order && m > 1000) continue ;
+	printf ("Chol ") ;
+	print_order (order) ;
+	rhs (x, b, m) ;				/* compute right-hand side */
+	t = tic () ;
+	ok = cs_cl_cholsol (order, C, x) ;		/* solve Ax=b with Cholesky */
+	printf ("time: %8.2f ", toc (t)) ;
+	print_resid (ok, C, x, b, resid) ;	/* print residual */
+    }
+    return (1) ;
+} 
+
+/* free workspace for demo3 */
+static UF_long done3 (UF_long ok, cs_cls *S, cs_cln *N, CPLX *y, cs_cl *W, cs_cl *E, UF_long *p)
+{
+    cs_cl_sfree (S) ;
+    cs_cl_nfree (N) ;
+    cs_cl_free (y) ;
+    cs_cl_spfree (W) ;
+    cs_cl_spfree (E) ;
+    cs_cl_free (p) ;
+    return (ok) ;
+}
+
+/* Cholesky update/downdate */
+UF_long demo3 (problem *Prob)
+{
+    cs_cl *A, *C, *W = NULL, *WW, *WT, *E = NULL, *W2 ;
+    UF_long n, k, *Li, *Lp, *Wi, *Wp, p1, p2, *p = NULL, ok ;
+    CPLX *b, *x, *resid, *y = NULL, *Lx, *Wx, s ;
+    double t, t1 ;
+    cs_cls *S = NULL ;
+    cs_cln *N = NULL ;
+    if (!Prob || !Prob->sym || Prob->A->n == 0) return (0) ;
+    A = Prob->A ; C = Prob->C ; b = Prob->b ; x = Prob->x ; resid = Prob->resid;
+    n = A->n ;
+    if (!Prob->sym || n == 0) return (1) ;
+    rhs (x, b, n) ;				/* compute right-hand side */
+    printf ("\nchol then update/downdate ") ;
+    print_order (1) ;
+    y = (CPLX *)cs_cl_malloc (n, sizeof (CPLX)) ;
+    t = tic () ;
+    S = cs_cl_schol (1, C) ;			/* symbolic Chol, amd(A+A') */
+    printf ("\nsymbolic chol time %8.2f\n", toc (t)) ;
+    t = tic () ;
+    N = cs_cl_chol (C, S) ;			/* numeric Cholesky */
+    printf ("numeric  chol time %8.2f\n", toc (t)) ;
+    if (!S || !N || !y) return (done3 (0, S, N, y, W, E, p)) ;
+    t = tic () ;
+    cs_cl_ipvec (S->pinv, b, y, n) ;		/* y = P*b */
+    cs_cl_lsolve (N->L, y) ;			/* y = L\y */
+    cs_cl_ltsolve (N->L, y) ;			/* y = L'\y */
+    cs_cl_pvec (S->pinv, y, x, n) ;		/* x = P'*y */
+    printf ("solve    chol time %8.2f\n", toc (t)) ;
+    printf ("original: ") ;
+    print_resid (1, C, x, b, resid) ;		/* print residual */
+    k = n/2 ;					/* construct W  */
+    W = cs_cl_spalloc (n, 1, n, 1, 0) ;
+    if (!W) return (done3 (0, S, N, y, W, E, p)) ;
+    Lp = N->L->p ; Li = N->L->i ; Lx = N->L->x ;
+    Wp = W->p ; Wi = W->i ; Wx = W->x ;
+    Wp [0] = 0 ;
+    p1 = Lp [k] ;
+    Wp [1] = Lp [k+1] - p1 ;
+    s = Lx [p1] ;
+    srand (1) ;
+    for ( ; p1 < Lp [k+1] ; p1++)
+    {
+	p2 = p1 - Lp [k] ;
+	Wi [p2] = Li [p1] ;
+	Wx [p2] = s * CPLX (rand () / ((double) RAND_MAX)) ;
+    }
+    t = tic () ;
+    ok = cs_cl_updown (N->L, +1, W, S->parent) ;	/* update: L*L'+W*W' */
+    t1 = toc (t) ;
+    printf ("update:   time: %8.2f\n", t1) ;
+    if (!ok) return (done3 (0, S, N, y, W, E, p)) ;
+    t = tic () ;
+    cs_cl_ipvec (S->pinv, b, y, n) ;		/* y = P*b */
+    cs_cl_lsolve (N->L, y) ;			/* y = L\y */
+    cs_cl_ltsolve (N->L, y) ;			/* y = L'\y */
+    cs_cl_pvec (S->pinv, y, x, n) ;		/* x = P'*y */
+    t = toc (t) ;
+    p = cs_cl_pinv (S->pinv, n) ;
+    W2 = cs_cl_permute (W, p, NULL, 1) ;		/* E = C + (P'W)*(P'W)' */
+    WT = cs_cl_transpose (W2,1) ;
+    WW = cs_cl_multiply (W2, WT) ;
+    cs_cl_spfree (WT) ;
+    cs_cl_spfree (W2) ;
+    E = cs_cl_add (C, WW, 1, 1) ;
+    cs_cl_spfree (WW) ;
+    if (!E || !p) return (done3 (0, S, N, y, W, E, p)) ;
+    printf ("update:   time: %8.2f (incl solve) ", t1+t) ;
+    print_resid (1, E, x, b, resid) ;		/* print residual */
+    cs_cl_nfree (N) ;				/* clear N */
+    t = tic () ;
+    N = cs_cl_chol (E, S) ;			/* numeric Cholesky */
+    if (!N) return (done3 (0, S, N, y, W, E, p)) ;
+    cs_cl_ipvec (S->pinv, b, y, n) ;		/* y = P*b */
+    cs_cl_lsolve (N->L, y) ;			/* y = L\y */
+    cs_cl_ltsolve (N->L, y) ;			/* y = L'\y */
+    cs_cl_pvec (S->pinv, y, x, n) ;		/* x = P'*y */
+    t = toc (t) ;
+    printf ("rechol:   time: %8.2f (incl solve) ", t) ;
+    print_resid (1, E, x, b, resid) ;		/* print residual */
+    t = tic () ;
+    ok = cs_cl_updown (N->L, -1, W, S->parent) ;	/* downdate: L*L'-W*W' */
+    t1 = toc (t) ;
+    if (!ok) return (done3 (0, S, N, y, W, E, p)) ;
+    printf ("downdate: time: %8.2f\n", t1) ;
+    t = tic () ;
+    cs_cl_ipvec (S->pinv, b, y, n) ;		/* y = P*b */
+    cs_cl_lsolve (N->L, y) ;			/* y = L\y */
+    cs_cl_ltsolve (N->L, y) ;			/* y = L'\y */
+    cs_cl_pvec (S->pinv, y, x, n) ;		/* x = P'*y */
+    t = toc (t) ;
+    printf ("downdate: time: %8.2f (incl solve) ", t1+t) ;
+    print_resid (1, C, x, b, resid) ;		/* print residual */
+    return (done3 (1, S, N, y, W, E, p)) ;
+} 
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_cl_demo.h SuiteSparse/CXSparse-C++/Demo/cs_cl_demo.h
--- original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_cl_demo.h	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Demo/cs_cl_demo.h	2006-11-24 16:35:30.000000000 +0100
@@ -0,0 +1,15 @@
+#include "cs.h"
+typedef struct problem_struct
+{
+    cs_cl *A ;
+    cs_cl *C ;
+    UF_long sym ;
+    CPLX *x ;
+    CPLX *b ;
+    CPLX *resid ;
+} problem ;
+
+problem *get_problem (FILE *f, double tol) ;
+UF_long demo2 (problem *Prob) ;
+UF_long demo3 (problem *Prob) ;
+problem *free_problem (problem *Prob) ;
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_cl_demo1.cpp SuiteSparse/CXSparse-C++/Demo/cs_cl_demo1.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_cl_demo1.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Demo/cs_cl_demo1.cpp	2006-08-25 08:04:44.000000000 +0200
@@ -0,0 +1,27 @@
+#include "cs.h"
+int main (void)
+{
+    cs_cl *T, *A, *Eye, *AT, *C, *D ;
+    UF_long i, m ;
+    T = cs_cl_load (stdin) ;		/* load triplet matrix T from stdin */
+    printf ("T:\n") ; cs_cl_print (T, 0) ;	/* print T */
+    A = cs_cl_compress (T) ;		/* A = compressed-column form of T */
+    printf ("A:\n") ; cs_cl_print (A, 0) ;	/* print A */
+    cs_cl_spfree (T) ;			/* clear T */
+    AT = cs_cl_transpose (A, 1) ;		/* AT = A' */
+    printf ("AT:\n") ; cs_cl_print (AT, 0) ; /* print AT */
+    m = A ? A->m : 0 ;			/* m = # of rows of A */
+    T = cs_cl_spalloc (m, m, m, 1, 1) ;	/* create triplet identity matrix */
+    for (i = 0 ; i < m ; i++) cs_cl_entry (T, i, i, 1) ;
+    Eye = cs_cl_compress (T) ;		/* Eye = speye (m) */
+    cs_cl_spfree (T) ;
+    C = cs_cl_multiply (A, AT) ;		/* C = A*A' */
+    D = cs_cl_add (C, Eye, 1, cs_cl_norm (C)) ;   /* D = C + Eye*norm (C,1) */
+    printf ("D:\n") ; cs_cl_print (D, 0) ;	/* print D */
+    cs_cl_spfree (A) ;			/* clear A AT C D Eye */
+    cs_cl_spfree (AT) ;
+    cs_cl_spfree (C) ;
+    cs_cl_spfree (D) ;
+    cs_cl_spfree (Eye) ;
+    return (0) ;
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_cl_demo2.cpp SuiteSparse/CXSparse-C++/Demo/cs_cl_demo2.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_cl_demo2.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Demo/cs_cl_demo2.cpp	2006-08-25 08:04:44.000000000 +0200
@@ -0,0 +1,9 @@
+#include "cs_cl_demo.h"
+/* cs_cl_demo2: read a matrix and solve a linear system */
+int main (void)
+{
+    problem *Prob = get_problem (stdin, 1e-14) ;
+    demo2 (Prob) ;
+    free_problem (Prob) ;
+    return (0) ;
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_cl_demo3.cpp SuiteSparse/CXSparse-C++/Demo/cs_cl_demo3.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_cl_demo3.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Demo/cs_cl_demo3.cpp	2006-08-25 08:04:44.000000000 +0200
@@ -0,0 +1,9 @@
+#include "cs_cl_demo.h"
+/* cs_cl_demo3: read a matrix and test Cholesky update/downdate */
+int main (void)
+{
+    problem *Prob = get_problem (stdin, 0) ;
+    demo3 (Prob) ;
+    free_problem (Prob) ;
+    return (0) ;
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_demo.cpp SuiteSparse/CXSparse-C++/Demo/cs_demo.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_demo.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Demo/cs_demo.cpp	2006-11-24 16:26:22.000000000 +0100
@@ -0,0 +1,286 @@
+#include "cs_demo.h"
+#include <time.h>
+/* 1 if A is square & upper tri., -1 if square & lower tri., 0 otherwise */
+static int is_sym (cs *A)
+{
+    int is_upper, is_lower, j, p, n = A->n, m = A->m, *Ap = A->p, *Ai = A->i ;
+    if (m != n) return (0) ;
+    is_upper = 1 ;
+    is_lower = 1 ;
+    for (j = 0 ; j < n ; j++)
+    {
+	for (p = Ap [j] ; p < Ap [j+1] ; p++)
+	{
+	    if (Ai [p] > j) is_upper = 0 ;
+	    if (Ai [p] < j) is_lower = 0 ;
+	}
+    }
+    return (is_upper ? 1 : (is_lower ? -1 : 0)) ;
+}
+
+/* true for off-diagonal entries */
+static int dropdiag (int i, int j, double aij, void *other) { return (i != j) ;}
+
+/* C = A + triu(A,1)' */
+static cs *make_sym (cs *A)
+{
+    cs *AT, *C ;
+    AT = cs_transpose (A, 1) ;		/* AT = A' */
+    cs_fkeep (AT, &dropdiag, NULL) ;	/* drop diagonal entries from AT */
+    C = cs_add (A, AT, 1, 1) ;		/* C = A+AT */
+    cs_spfree (AT) ;
+    return (C) ;
+}
+
+/* create a right-hand side */
+static void rhs (double *x, double *b, int m)
+{
+    int i ;
+    for (i = 0 ; i < m ; i++) b [i] = 1 + ((double) i) / m ;
+    for (i = 0 ; i < m ; i++) x [i] = b [i] ;
+}
+
+/* infinity-norm of x */
+static double norm (double *x, int n)
+{
+    int i ;
+    double normx = 0 ;
+    for (i = 0 ; i < n ; i++) normx = CS_MAX (normx, fabs (x [i])) ;
+    return (normx) ;
+}
+
+/* compute residual, norm(A*x-b,inf) / (norm(A,1)*norm(x,inf) + norm(b,inf)) */
+static void print_resid (int ok, cs *A, double *x, double *b, double *resid)
+{
+    int i, m, n ;
+    if (!ok) { printf ("    (failed)\n") ; return ; }
+    m = A->m ; n = A->n ;
+    for (i = 0 ; i < m ; i++) resid [i] = -b [i] ;  /* resid = -b */
+    cs_gaxpy (A, x, resid) ;			    /* resid = resid + A*x  */
+    printf ("resid: %8.2e\n", norm (resid,m) / ((n == 0) ? 1 :
+	(cs_norm (A) * norm (x,n) + norm (b,m)))) ;
+}
+
+static double tic (void) { return (clock () / (double) CLOCKS_PER_SEC) ; }
+static double toc (double t) { double s = tic () ; return (CS_MAX (0, s-t)) ; }
+
+static void print_order (int order)
+{
+    switch (order)
+    {
+	case 0: printf ("natural    ") ; break ;
+	case 1: printf ("amd(A+A')  ") ; break ;
+	case 2: printf ("amd(S'*S)  ") ; break ;
+	case 3: printf ("amd(A'*A)  ") ; break ;
+    }
+}
+
+/* read a problem from a file */
+problem *get_problem (FILE *f, double tol)
+{
+    cs *T, *A, *C ;
+    int sym, m, n, mn, nz1, nz2 ;
+    problem *Prob ;
+    Prob = (problem *)cs_calloc (1, sizeof (problem)) ;
+    if (!Prob) return (NULL) ;
+    T = cs_load (f) ;			/* load triplet matrix T from a file */
+    Prob->A = A = cs_compress (T) ;	/* A = compressed-column form of T */
+    cs_spfree (T) ;			/* clear T */
+    if (!cs_dupl (A)) return (free_problem (Prob)) ; /* sum up duplicates */
+    Prob->sym = sym = is_sym (A) ;	/* determine if A is symmetric */
+    m = A->m ; n = A->n ;
+    mn = CS_MAX (m,n) ;
+    nz1 = A->p [n] ;
+    cs_dropzeros (A) ;			/* drop zero entries */
+    nz2 = A->p [n] ;
+    if (tol > 0) cs_droptol (A, tol) ;	/* drop tiny entries (just to test) */
+    Prob->C = C = sym ? make_sym (A) : A ;  /* C = A + triu(A,1)', or C=A */
+    if (!C) return (free_problem (Prob)) ;
+    printf ("\n--- Matrix: %d-by-%d, nnz: %d (sym: %d: nnz %d), norm: %8.2e\n",
+	    m, n, A->p [n], sym, sym ? C->p [n] : 0, cs_norm (C)) ;
+    if (nz1 != nz2) printf ("zero entries dropped: %d\n", nz1 - nz2) ;
+    if (nz2 != A->p [n]) printf ("tiny entries dropped: %d\n", nz2 - A->p [n]) ;
+    Prob->b = (double *)cs_malloc (mn, sizeof (double)) ;
+    Prob->x = (double *)cs_malloc (mn, sizeof (double)) ;
+    Prob->resid = (double *)cs_malloc (mn, sizeof (double)) ;
+    return ((!Prob->b || !Prob->x || !Prob->resid) ? free_problem (Prob) : Prob) ;
+}
+
+/* free a problem */
+problem *free_problem (problem *Prob)
+{
+    if (!Prob) return (NULL) ;
+    cs_spfree (Prob->A) ;
+    if (Prob->sym) cs_spfree (Prob->C) ;
+    cs_free (Prob->b) ;
+    cs_free (Prob->x) ;
+    cs_free (Prob->resid) ;
+    return (problem *)(cs_free (Prob)) ;
+}
+
+/* solve a linear system using Cholesky, LU, and QR, with various orderings */
+int demo2 (problem *Prob)
+{
+    cs *A, *C ;
+    double *b, *x, *resid,  t, tol ;
+    int k, m, n, ok, order, nb, ns, *r, *s, *rr, sprank ;
+    csd *D ;
+    if (!Prob) return (0) ;
+    A = Prob->A ; C = Prob->C ; b = Prob->b ; x = Prob->x ; resid = Prob->resid;
+    m = A->m ; n = A->n ;
+    tol = Prob->sym ? 0.001 : 1 ;		/* partial pivoting tolerance */
+    D = cs_dmperm (C, 1) ;			/* randomized dmperm analysis */
+    if (!D) return (0) ;
+    nb = D->nb ; r = D->r ; s = D->s ; rr = D->rr ;
+    sprank = rr [3] ;
+    for (ns = 0, k = 0 ; k < nb ; k++)
+    {
+	ns += ((r [k+1] == r [k]+1) && (s [k+1] == s [k]+1)) ;
+    }
+    printf ("blocks: %d singletons: %d structural rank: %d\n", nb, ns, sprank) ;
+    cs_dfree (D) ;
+    for (order = 0 ; order <= 3 ; order += 3)	/* natural and amd(A'*A) */
+    {
+	if (!order && m > 1000) continue ;
+	printf ("QR   ") ;
+	print_order (order) ;
+	rhs (x, b, m) ;				/* compute right-hand side */
+	t = tic () ;
+	ok = cs_qrsol (order, C, x) ;		/* min norm(Ax-b) with QR */
+	printf ("time: %8.2f ", toc (t)) ;
+	print_resid (ok, C, x, b, resid) ;	/* print residual */
+    }
+    if (m != n || sprank < n) return (1) ;	/* return if rect. or singular*/
+    for (order = 0 ; order <= 3 ; order++)	/* try all orderings */
+    {
+	if (!order && m > 1000) continue ;
+	printf ("LU   ") ;
+	print_order (order) ;
+	rhs (x, b, m) ;				/* compute right-hand side */
+	t = tic () ;
+	ok = cs_lusol (order, C, x, tol) ;	/* solve Ax=b with LU */
+	printf ("time: %8.2f ", toc (t)) ;
+	print_resid (ok, C, x, b, resid) ;	/* print residual */
+    }
+    if (!Prob->sym) return (1) ;
+    for (order = 0 ; order <= 1 ; order++)	/* natural and amd(A+A') */
+    {
+	if (!order && m > 1000) continue ;
+	printf ("Chol ") ;
+	print_order (order) ;
+	rhs (x, b, m) ;				/* compute right-hand side */
+	t = tic () ;
+	ok = cs_cholsol (order, C, x) ;		/* solve Ax=b with Cholesky */
+	printf ("time: %8.2f ", toc (t)) ;
+	print_resid (ok, C, x, b, resid) ;	/* print residual */
+    }
+    return (1) ;
+} 
+
+/* free workspace for demo3 */
+static int done3 (int ok, css *S, csn *N, double *y, cs *W, cs *E, int *p)
+{
+    cs_sfree (S) ;
+    cs_nfree (N) ;
+    cs_free (y) ;
+    cs_spfree (W) ;
+    cs_spfree (E) ;
+    cs_free (p) ;
+    return (ok) ;
+}
+
+/* Cholesky update/downdate */
+int demo3 (problem *Prob)
+{
+    cs *A, *C, *W = NULL, *WW, *WT, *E = NULL, *W2 ;
+    int n, k, *Li, *Lp, *Wi, *Wp, p1, p2, *p = NULL, ok ;
+    double *b, *x, *resid, *y = NULL, *Lx, *Wx, s,  t, t1 ;
+    css *S = NULL ;
+    csn *N = NULL ;
+    if (!Prob || !Prob->sym || Prob->A->n == 0) return (0) ;
+    A = Prob->A ; C = Prob->C ; b = Prob->b ; x = Prob->x ; resid = Prob->resid;
+    n = A->n ;
+    if (!Prob->sym || n == 0) return (1) ;
+    rhs (x, b, n) ;				/* compute right-hand side */
+    printf ("\nchol then update/downdate ") ;
+    print_order (1) ;
+    y = (double *)cs_malloc (n, sizeof (double)) ;
+    t = tic () ;
+    S = cs_schol (1, C) ;			/* symbolic Chol, amd(A+A') */
+    printf ("\nsymbolic chol time %8.2f\n", toc (t)) ;
+    t = tic () ;
+    N = cs_chol (C, S) ;			/* numeric Cholesky */
+    printf ("numeric  chol time %8.2f\n", toc (t)) ;
+    if (!S || !N || !y) return (done3 (0, S, N, y, W, E, p)) ;
+    t = tic () ;
+    cs_ipvec (S->pinv, b, y, n) ;		/* y = P*b */
+    cs_lsolve (N->L, y) ;			/* y = L\y */
+    cs_ltsolve (N->L, y) ;			/* y = L'\y */
+    cs_pvec (S->pinv, y, x, n) ;		/* x = P'*y */
+    printf ("solve    chol time %8.2f\n", toc (t)) ;
+    printf ("original: ") ;
+    print_resid (1, C, x, b, resid) ;		/* print residual */
+    k = n/2 ;					/* construct W  */
+    W = cs_spalloc (n, 1, n, 1, 0) ;
+    if (!W) return (done3 (0, S, N, y, W, E, p)) ;
+    Lp = N->L->p ; Li = N->L->i ; Lx = N->L->x ;
+    Wp = W->p ; Wi = W->i ; Wx = W->x ;
+    Wp [0] = 0 ;
+    p1 = Lp [k] ;
+    Wp [1] = Lp [k+1] - p1 ;
+    s = Lx [p1] ;
+    srand (1) ;
+    for ( ; p1 < Lp [k+1] ; p1++)
+    {
+	p2 = p1 - Lp [k] ;
+	Wi [p2] = Li [p1] ;
+	Wx [p2] = s * rand () / ((double) RAND_MAX) ;
+    }
+    t = tic () ;
+    ok = cs_updown (N->L, +1, W, S->parent) ;	/* update: L*L'+W*W' */
+    t1 = toc (t) ;
+    printf ("update:   time: %8.2f\n", t1) ;
+    if (!ok) return (done3 (0, S, N, y, W, E, p)) ;
+    t = tic () ;
+    cs_ipvec (S->pinv, b, y, n) ;		/* y = P*b */
+    cs_lsolve (N->L, y) ;			/* y = L\y */
+    cs_ltsolve (N->L, y) ;			/* y = L'\y */
+    cs_pvec (S->pinv, y, x, n) ;		/* x = P'*y */
+    t = toc (t) ;
+    p = cs_pinv (S->pinv, n) ;
+    W2 = cs_permute (W, p, NULL, 1) ;		/* E = C + (P'W)*(P'W)' */
+    WT = cs_transpose (W2,1) ;
+    WW = cs_multiply (W2, WT) ;
+    cs_spfree (WT) ;
+    cs_spfree (W2) ;
+    E = cs_add (C, WW, 1, 1) ;
+    cs_spfree (WW) ;
+    if (!E || !p) return (done3 (0, S, N, y, W, E, p)) ;
+    printf ("update:   time: %8.2f (incl solve) ", t1+t) ;
+    print_resid (1, E, x, b, resid) ;		/* print residual */
+    cs_nfree (N) ;				/* clear N */
+    t = tic () ;
+    N = cs_chol (E, S) ;			/* numeric Cholesky */
+    if (!N) return (done3 (0, S, N, y, W, E, p)) ;
+    cs_ipvec (S->pinv, b, y, n) ;		/* y = P*b */
+    cs_lsolve (N->L, y) ;			/* y = L\y */
+    cs_ltsolve (N->L, y) ;			/* y = L'\y */
+    cs_pvec (S->pinv, y, x, n) ;		/* x = P'*y */
+    t = toc (t) ;
+    printf ("rechol:   time: %8.2f (incl solve) ", t) ;
+    print_resid (1, E, x, b, resid) ;		/* print residual */
+    t = tic () ;
+    ok = cs_updown (N->L, -1, W, S->parent) ;	/* downdate: L*L'-W*W' */
+    t1 = toc (t) ;
+    if (!ok) return (done3 (0, S, N, y, W, E, p)) ;
+    printf ("downdate: time: %8.2f\n", t1) ;
+    t = tic () ;
+    cs_ipvec (S->pinv, b, y, n) ;		/* y = P*b */
+    cs_lsolve (N->L, y) ;			/* y = L\y */
+    cs_ltsolve (N->L, y) ;			/* y = L'\y */
+    cs_pvec (S->pinv, y, x, n) ;		/* x = P'*y */
+    t = toc (t) ;
+    printf ("downdate: time: %8.2f (incl solve) ", t1+t) ;
+    print_resid (1, C, x, b, resid) ;		/* print residual */
+    return (done3 (1, S, N, y, W, E, p)) ;
+} 
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_demo.h SuiteSparse/CXSparse-C++/Demo/cs_demo.h
--- original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_demo.h	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Demo/cs_demo.h	2006-04-03 20:06:32.000000000 +0200
@@ -0,0 +1,15 @@
+#include "cs.h"
+typedef struct problem_struct
+{
+    cs *A ;
+    cs *C ;
+    int sym ;
+    double *x ;
+    double *b ;
+    double *resid ;
+} problem ;
+
+problem *get_problem (FILE *f, double tol) ;
+int demo2 (problem *Prob) ;
+int demo3 (problem *Prob) ;
+problem *free_problem (problem *Prob) ;
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_demo.out SuiteSparse/CXSparse-C++/Demo/cs_demo.out
--- original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_demo.out	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Demo/cs_demo.out	2006-08-25 08:06:36.000000000 +0200
@@ -0,0 +1,1152 @@
+make[1]: Entering directory `/amd/netapp3/vol/research0a/research18/sparse/UFsparse/CXSparse/Demo'
+./cs_idemo < ../Matrix/t2
+
+--- cs_idemo
+
+T:
+CXSparse Version 2.0.2, Aug 23, 2006.  Copyright (c) Timothy A. Davis, 2006
+triplet: 4-by-4, nzmax: 16 nnz: 10
+    2 2 : (3, 3.14159)
+    1 0 : (3.1, 42)
+    3 3 : (1, 7)
+    0 2 : (3.2, 0.1)
+    1 1 : (2.9, 1.3)
+    3 0 : (3.5, 0)
+    3 1 : (0.4, 2.71828)
+    1 3 : (0.9, 99)
+    0 0 : (4.5, 6)
+    2 1 : (1.7, 1)
+
+Treal:
+CXSparse Version 2.0.2, Aug 23, 2006.  Copyright (c) Timothy A. Davis, 2006
+triplet: 4-by-4, nzmax: 16 nnz: 10
+    2 2 : 3
+    1 0 : 3.1
+    3 3 : 1
+    0 2 : 3.2
+    1 1 : 2.9
+    3 0 : 3.5
+    3 1 : 0.4
+    1 3 : 0.9
+    0 0 : 4.5
+    2 1 : 1.7
+
+Timag:
+CXSparse Version 2.0.2, Aug 23, 2006.  Copyright (c) Timothy A. Davis, 2006
+triplet: 4-by-4, nzmax: 16 nnz: 10
+    2 2 : 3.14159
+    1 0 : 42
+    3 3 : 7
+    0 2 : 0.1
+    1 1 : 1.3
+    3 0 : 0
+    3 1 : 2.71828
+    1 3 : 99
+    0 0 : 6
+    2 1 : 1
+
+A:
+CXSparse Version 2.0.2, Aug 23, 2006.  Copyright (c) Timothy A. Davis, 2006
+4-by-4, nzmax: 10 nnz: 10, 1-norm: 106.075
+    col 0 : locations 0 to 2
+      1 : (3.1, 42)
+      3 : (3.5, 0)
+      0 : (4.5, 6)
+    col 1 : locations 3 to 5
+      1 : (2.9, 1.3)
+      3 : (0.4, 2.71828)
+      2 : (1.7, 1)
+    col 2 : locations 6 to 7
+      2 : (3, 3.14159)
+      0 : (3.2, 0.1)
+    col 3 : locations 8 to 9
+      3 : (1, 7)
+      1 : (0.9, 99)
+
+C1 = real(A):
+CXSparse Version 2.0.2, Aug 23, 2006.  Copyright (c) Timothy A. Davis, 2006
+4-by-4, nzmax: 10 nnz: 10, 1-norm: 11.1
+    col 0 : locations 0 to 2
+      1 : 3.1
+      3 : 3.5
+      0 : 4.5
+    col 1 : locations 3 to 5
+      1 : 2.9
+      3 : 0.4
+      2 : 1.7
+    col 2 : locations 6 to 7
+      2 : 3
+      0 : 3.2
+    col 3 : locations 8 to 9
+      3 : 1
+      1 : 0.9
+
+C2 = imag(A):
+CXSparse Version 2.0.2, Aug 23, 2006.  Copyright (c) Timothy A. Davis, 2006
+4-by-4, nzmax: 10 nnz: 10, 1-norm: 106
+    col 0 : locations 0 to 2
+      1 : 42
+      3 : 0
+      0 : 6
+    col 1 : locations 3 to 5
+      1 : 1.3
+      3 : 2.71828
+      2 : 1
+    col 2 : locations 6 to 7
+      2 : 3.14159
+      0 : 0.1
+    col 3 : locations 8 to 9
+      3 : 7
+      1 : 99
+
+A1:
+CXSparse Version 2.0.2, Aug 23, 2006.  Copyright (c) Timothy A. Davis, 2006
+4-by-4, nzmax: 10 nnz: 10, 1-norm: 11.1
+    col 0 : locations 0 to 2
+      1 : (3.1, 0)
+      3 : (3.5, 0)
+      0 : (4.5, 0)
+    col 1 : locations 3 to 5
+      1 : (2.9, 0)
+      3 : (0.4, 0)
+      2 : (1.7, 0)
+    col 2 : locations 6 to 7
+      2 : (3, 0)
+      0 : (3.2, 0)
+    col 3 : locations 8 to 9
+      3 : (1, 0)
+      1 : (0.9, 0)
+
+A2:
+CXSparse Version 2.0.2, Aug 23, 2006.  Copyright (c) Timothy A. Davis, 2006
+4-by-4, nzmax: 10 nnz: 10, 1-norm: 106
+    col 0 : locations 0 to 2
+      1 : (0, 42)
+      3 : (0, 0)
+      0 : (0, 6)
+    col 1 : locations 3 to 5
+      1 : (0, 1.3)
+      3 : (0, 2.71828)
+      2 : (0, 1)
+    col 2 : locations 6 to 7
+      2 : (0, 3.14159)
+      0 : (0, 0.1)
+    col 3 : locations 8 to 9
+      3 : (0, 7)
+      1 : (0, 99)
+
+B = conj(A):
+CXSparse Version 2.0.2, Aug 23, 2006.  Copyright (c) Timothy A. Davis, 2006
+4-by-4, nzmax: 10 nnz: 10, 1-norm: 106.075
+    col 0 : locations 0 to 2
+      1 : (3.1, -42)
+      3 : (3.5, 0)
+      0 : (4.5, -6)
+    col 1 : locations 3 to 5
+      1 : (2.9, -1.3)
+      3 : (0.4, -2.71828)
+      2 : (1.7, -1)
+    col 2 : locations 6 to 7
+      2 : (3, -3.14159)
+      0 : (3.2, -0.1)
+    col 3 : locations 8 to 9
+      3 : (1, -7)
+      1 : (0.9, -99)
+./cs_ldemo < ../Matrix/t2
+
+--- cs_ldemo
+
+T:
+CXSparse Version 2.0.2, Aug 23, 2006.  Copyright (c) Timothy A. Davis, 2006
+triplet: 4-by-4, nzmax: 16 nnz: 10
+    2 2 : (3, 3.14159)
+    1 0 : (3.1, 42)
+    3 3 : (1, 7)
+    0 2 : (3.2, 0.1)
+    1 1 : (2.9, 1.3)
+    3 0 : (3.5, 0)
+    3 1 : (0.4, 2.71828)
+    1 3 : (0.9, 99)
+    0 0 : (4.5, 6)
+    2 1 : (1.7, 1)
+
+Treal:
+CXSparse Version 2.0.2, Aug 23, 2006.  Copyright (c) Timothy A. Davis, 2006
+triplet: 4-by-4, nzmax: 16 nnz: 10
+    2 2 : 3
+    1 0 : 3.1
+    3 3 : 1
+    0 2 : 3.2
+    1 1 : 2.9
+    3 0 : 3.5
+    3 1 : 0.4
+    1 3 : 0.9
+    0 0 : 4.5
+    2 1 : 1.7
+
+Timag:
+CXSparse Version 2.0.2, Aug 23, 2006.  Copyright (c) Timothy A. Davis, 2006
+triplet: 4-by-4, nzmax: 16 nnz: 10
+    2 2 : 3.14159
+    1 0 : 42
+    3 3 : 7
+    0 2 : 0.1
+    1 1 : 1.3
+    3 0 : 0
+    3 1 : 2.71828
+    1 3 : 99
+    0 0 : 6
+    2 1 : 1
+
+A:
+CXSparse Version 2.0.2, Aug 23, 2006.  Copyright (c) Timothy A. Davis, 2006
+4-by-4, nzmax: 10 nnz: 10, 1-norm: 106.075
+    col 0 : locations 0 to 2
+      1 : (3.1, 42)
+      3 : (3.5, 0)
+      0 : (4.5, 6)
+    col 1 : locations 3 to 5
+      1 : (2.9, 1.3)
+      3 : (0.4, 2.71828)
+      2 : (1.7, 1)
+    col 2 : locations 6 to 7
+      2 : (3, 3.14159)
+      0 : (3.2, 0.1)
+    col 3 : locations 8 to 9
+      3 : (1, 7)
+      1 : (0.9, 99)
+
+C1 = real(A):
+CXSparse Version 2.0.2, Aug 23, 2006.  Copyright (c) Timothy A. Davis, 2006
+4-by-4, nzmax: 10 nnz: 10, 1-norm: 11.1
+    col 0 : locations 0 to 2
+      1 : 3.1
+      3 : 3.5
+      0 : 4.5
+    col 1 : locations 3 to 5
+      1 : 2.9
+      3 : 0.4
+      2 : 1.7
+    col 2 : locations 6 to 7
+      2 : 3
+      0 : 3.2
+    col 3 : locations 8 to 9
+      3 : 1
+      1 : 0.9
+
+C2 = imag(A):
+CXSparse Version 2.0.2, Aug 23, 2006.  Copyright (c) Timothy A. Davis, 2006
+4-by-4, nzmax: 10 nnz: 10, 1-norm: 106
+    col 0 : locations 0 to 2
+      1 : 42
+      3 : 0
+      0 : 6
+    col 1 : locations 3 to 5
+      1 : 1.3
+      3 : 2.71828
+      2 : 1
+    col 2 : locations 6 to 7
+      2 : 3.14159
+      0 : 0.1
+    col 3 : locations 8 to 9
+      3 : 7
+      1 : 99
+
+A1:
+CXSparse Version 2.0.2, Aug 23, 2006.  Copyright (c) Timothy A. Davis, 2006
+4-by-4, nzmax: 10 nnz: 10, 1-norm: 11.1
+    col 0 : locations 0 to 2
+      1 : (3.1, 0)
+      3 : (3.5, 0)
+      0 : (4.5, 0)
+    col 1 : locations 3 to 5
+      1 : (2.9, 0)
+      3 : (0.4, 0)
+      2 : (1.7, 0)
+    col 2 : locations 6 to 7
+      2 : (3, 0)
+      0 : (3.2, 0)
+    col 3 : locations 8 to 9
+      3 : (1, 0)
+      1 : (0.9, 0)
+
+A2:
+CXSparse Version 2.0.2, Aug 23, 2006.  Copyright (c) Timothy A. Davis, 2006
+4-by-4, nzmax: 10 nnz: 10, 1-norm: 106
+    col 0 : locations 0 to 2
+      1 : (0, 42)
+      3 : (0, 0)
+      0 : (0, 6)
+    col 1 : locations 3 to 5
+      1 : (0, 1.3)
+      3 : (0, 2.71828)
+      2 : (0, 1)
+    col 2 : locations 6 to 7
+      2 : (0, 3.14159)
+      0 : (0, 0.1)
+    col 3 : locations 8 to 9
+      3 : (0, 7)
+      1 : (0, 99)
+
+B = conj(A):
+CXSparse Version 2.0.2, Aug 23, 2006.  Copyright (c) Timothy A. Davis, 2006
+4-by-4, nzmax: 10 nnz: 10, 1-norm: 106.075
+    col 0 : locations 0 to 2
+      1 : (3.1, -42)
+      3 : (3.5, 0)
+      0 : (4.5, -6)
+    col 1 : locations 3 to 5
+      1 : (2.9, -1.3)
+      3 : (0.4, -2.71828)
+      2 : (1.7, -1)
+    col 2 : locations 6 to 7
+      2 : (3, -3.14159)
+      0 : (3.2, -0.1)
+    col 3 : locations 8 to 9
+      3 : (1, -7)
+      1 : (0.9, -99)
+./cs_demo1 < ../Matrix/t1
+T:
+CXSparse Version 2.0.2, Aug 23, 2006.  Copyright (c) Timothy A. Davis, 2006
+triplet: 4-by-4, nzmax: 16 nnz: 10
+    2 2 : 3
+    1 0 : 3.1
+    3 3 : 1
+    0 2 : 3.2
+    1 1 : 2.9
+    3 0 : 3.5
+    3 1 : 0.4
+    1 3 : 0.9
+    0 0 : 4.5
+    2 1 : 1.7
+A:
+CXSparse Version 2.0.2, Aug 23, 2006.  Copyright (c) Timothy A. Davis, 2006
+4-by-4, nzmax: 10 nnz: 10, 1-norm: 11.1
+    col 0 : locations 0 to 2
+      1 : 3.1
+      3 : 3.5
+      0 : 4.5
+    col 1 : locations 3 to 5
+      1 : 2.9
+      3 : 0.4
+      2 : 1.7
+    col 2 : locations 6 to 7
+      2 : 3
+      0 : 3.2
+    col 3 : locations 8 to 9
+      3 : 1
+      1 : 0.9
+AT:
+CXSparse Version 2.0.2, Aug 23, 2006.  Copyright (c) Timothy A. Davis, 2006
+4-by-4, nzmax: 10 nnz: 10, 1-norm: 7.7
+    col 0 : locations 0 to 1
+      0 : 4.5
+      2 : 3.2
+    col 1 : locations 2 to 4
+      0 : 3.1
+      1 : 2.9
+      3 : 0.9
+    col 2 : locations 5 to 6
+      1 : 1.7
+      2 : 3
+    col 3 : locations 7 to 9
+      0 : 3.5
+      1 : 0.4
+      3 : 1
+D:
+CXSparse Version 2.0.2, Aug 23, 2006.  Copyright (c) Timothy A. Davis, 2006
+4-by-4, nzmax: 16 nnz: 16, 1-norm: 139.58
+    col 0 : locations 0 to 3
+      1 : 13.95
+      3 : 15.75
+      0 : 100.28
+      2 : 9.6
+    col 1 : locations 4 to 7
+      1 : 88.62
+      3 : 12.91
+      0 : 13.95
+      2 : 4.93
+    col 2 : locations 8 to 11
+      1 : 4.93
+      3 : 0.68
+      2 : 81.68
+      0 : 9.6
+    col 3 : locations 12 to 15
+      1 : 12.91
+      3 : 83.2
+      0 : 15.75
+      2 : 0.68
+./cs_demo2 < ../Matrix/t1
+
+--- Matrix: 4-by-4, nnz: 10 (sym: 0: nnz 0), norm: 1.11e+01
+blocks: 1 singletons: 0 structural rank: 4
+QR   natural    time:     0.00 resid: 1.53e-17
+QR   amd(A'*A)  time:     0.00 resid: 1.04e-17
+LU   natural    time:     0.00 resid: 1.04e-17
+LU   amd(A+A')  time:     0.00 resid: 4.94e-18
+LU   amd(S'*S)  time:     0.00 resid: 4.94e-18
+LU   amd(A'*A)  time:     0.00 resid: 4.94e-18
+./cs_demo2 < ../Matrix/fs_183_1
+
+--- Matrix: 183-by-183, nnz: 988 (sym: 0: nnz 0), norm: 1.70e+09
+zero entries dropped: 71
+tiny entries dropped: 10
+blocks: 38 singletons: 37 structural rank: 183
+QR   natural    time:     0.00 resid: 2.76e-28
+QR   amd(A'*A)  time:     0.01 resid: 3.59e-28
+LU   natural    time:     0.00 resid: 3.08e-28
+LU   amd(A+A')  time:     0.00 resid: 1.42e-27
+LU   amd(S'*S)  time:     0.00 resid: 7.11e-28
+LU   amd(A'*A)  time:     0.00 resid: 7.11e-28
+./cs_demo2 < ../Matrix/west0067
+
+--- Matrix: 67-by-67, nnz: 294 (sym: 0: nnz 0), norm: 6.14e+00
+blocks: 2 singletons: 1 structural rank: 67
+QR   natural    time:     0.00 resid: 1.95e-17
+QR   amd(A'*A)  time:     0.00 resid: 1.38e-17
+LU   natural    time:     0.00 resid: 3.85e-17
+LU   amd(A+A')  time:     0.00 resid: 1.95e-17
+LU   amd(S'*S)  time:     0.00 resid: 2.60e-17
+LU   amd(A'*A)  time:     0.00 resid: 2.60e-17
+./cs_demo2 < ../Matrix/lp_afiro
+
+--- Matrix: 27-by-51, nnz: 102 (sym: 0: nnz 0), norm: 3.43e+00
+blocks: 1 singletons: 0 structural rank: 27
+QR   natural    time:     0.00 resid: 1.39e-16
+QR   amd(A'*A)  time:     0.00 resid: 2.15e-16
+./cs_demo2 < ../Matrix/ash219
+
+--- Matrix: 219-by-85, nnz: 438 (sym: 0: nnz 0), norm: 9.00e+00
+blocks: 1 singletons: 0 structural rank: 85
+QR   natural    time:     0.00 resid: 1.61e-02
+QR   amd(A'*A)  time:     0.00 resid: 1.61e-02
+./cs_demo2 < ../Matrix/mbeacxc
+
+--- Matrix: 492-by-490, nnz: 49920 (sym: 0: nnz 0), norm: 9.29e-01
+blocks: 10 singletons: 8 structural rank: 448
+QR   natural    time:     0.24 resid:      nan
+QR   amd(A'*A)  time:     0.28 resid:      nan
+./cs_demo2 < ../Matrix/bcsstk01
+
+--- Matrix: 48-by-48, nnz: 224 (sym: -1: nnz 400), norm: 3.57e+09
+blocks: 1 singletons: 0 structural rank: 48
+QR   natural    time:     0.00 resid: 4.06e-19
+QR   amd(A'*A)  time:     0.00 resid: 2.33e-19
+LU   natural    time:     0.00 resid: 2.63e-19
+LU   amd(A+A')  time:     0.00 resid: 8.63e-20
+LU   amd(S'*S)  time:     0.00 resid: 2.04e-19
+LU   amd(A'*A)  time:     0.00 resid: 2.04e-19
+Chol natural    time:     0.00 resid: 1.90e-19
+Chol amd(A+A')  time:     0.00 resid: 2.01e-19
+./cs_demo3 < ../Matrix/bcsstk01
+
+--- Matrix: 48-by-48, nnz: 224 (sym: -1: nnz 400), norm: 3.57e+09
+
+chol then update/downdate amd(A+A')  
+symbolic chol time     0.00
+numeric  chol time     0.00
+solve    chol time     0.00
+original: resid: 2.01e-19
+update:   time:     0.00
+update:   time:     0.00 (incl solve) resid: 1.11e-18
+rechol:   time:     0.00 (incl solve) resid: 1.20e-18
+downdate: time:     0.00
+downdate: time:     0.00 (incl solve) resid: 3.30e-17
+./cs_demo2 < ../Matrix/bcsstk16
+
+--- Matrix: 4884-by-4884, nnz: 147631 (sym: -1: nnz 290378), norm: 7.01e+09
+blocks: 75 singletons: 74 structural rank: 4884
+QR   amd(A'*A)  time:     2.08 resid: 1.43e-22
+LU   amd(A+A')  time:     1.09 resid: 1.06e-22
+LU   amd(S'*S)  time:     1.08 resid: 1.21e-22
+LU   amd(A'*A)  time:     1.12 resid: 1.70e-22
+Chol amd(A+A')  time:     0.57 resid: 9.28e-23
+./cs_demo3 < ../Matrix/bcsstk16
+
+--- Matrix: 4884-by-4884, nnz: 147631 (sym: -1: nnz 290378), norm: 7.01e+09
+
+chol then update/downdate amd(A+A')  
+symbolic chol time     0.02
+numeric  chol time     0.52
+solve    chol time     0.01
+original: resid: 9.28e-23
+update:   time:     0.00
+update:   time:     0.01 (incl solve) resid: 1.05e-23
+rechol:   time:     0.52 (incl solve) resid: 8.72e-24
+downdate: time:     0.00
+downdate: time:     0.01 (incl solve) resid: 3.60e-22
+./cs_di_demo1 < ../Matrix/t1
+T:
+CXSparse Version 2.0.2, Aug 23, 2006.  Copyright (c) Timothy A. Davis, 2006
+triplet: 4-by-4, nzmax: 16 nnz: 10
+    2 2 : 3
+    1 0 : 3.1
+    3 3 : 1
+    0 2 : 3.2
+    1 1 : 2.9
+    3 0 : 3.5
+    3 1 : 0.4
+    1 3 : 0.9
+    0 0 : 4.5
+    2 1 : 1.7
+A:
+CXSparse Version 2.0.2, Aug 23, 2006.  Copyright (c) Timothy A. Davis, 2006
+4-by-4, nzmax: 10 nnz: 10, 1-norm: 11.1
+    col 0 : locations 0 to 2
+      1 : 3.1
+      3 : 3.5
+      0 : 4.5
+    col 1 : locations 3 to 5
+      1 : 2.9
+      3 : 0.4
+      2 : 1.7
+    col 2 : locations 6 to 7
+      2 : 3
+      0 : 3.2
+    col 3 : locations 8 to 9
+      3 : 1
+      1 : 0.9
+AT:
+CXSparse Version 2.0.2, Aug 23, 2006.  Copyright (c) Timothy A. Davis, 2006
+4-by-4, nzmax: 10 nnz: 10, 1-norm: 7.7
+    col 0 : locations 0 to 1
+      0 : 4.5
+      2 : 3.2
+    col 1 : locations 2 to 4
+      0 : 3.1
+      1 : 2.9
+      3 : 0.9
+    col 2 : locations 5 to 6
+      1 : 1.7
+      2 : 3
+    col 3 : locations 7 to 9
+      0 : 3.5
+      1 : 0.4
+      3 : 1
+D:
+CXSparse Version 2.0.2, Aug 23, 2006.  Copyright (c) Timothy A. Davis, 2006
+4-by-4, nzmax: 16 nnz: 16, 1-norm: 139.58
+    col 0 : locations 0 to 3
+      1 : 13.95
+      3 : 15.75
+      0 : 100.28
+      2 : 9.6
+    col 1 : locations 4 to 7
+      1 : 88.62
+      3 : 12.91
+      0 : 13.95
+      2 : 4.93
+    col 2 : locations 8 to 11
+      1 : 4.93
+      3 : 0.68
+      2 : 81.68
+      0 : 9.6
+    col 3 : locations 12 to 15
+      1 : 12.91
+      3 : 83.2
+      0 : 15.75
+      2 : 0.68
+./cs_di_demo2 < ../Matrix/t1
+
+--- Matrix: 4-by-4, nnz: 10 (sym: 0: nnz 0), norm: 1.11e+01
+blocks: 1 singletons: 0 structural rank: 4
+QR   natural    time:     0.00 resid: 1.53e-17
+QR   amd(A'*A)  time:     0.00 resid: 1.04e-17
+LU   natural    time:     0.00 resid: 1.04e-17
+LU   amd(A+A')  time:     0.00 resid: 4.94e-18
+LU   amd(S'*S)  time:     0.00 resid: 4.94e-18
+LU   amd(A'*A)  time:     0.00 resid: 4.94e-18
+./cs_di_demo2 < ../Matrix/fs_183_1
+
+--- Matrix: 183-by-183, nnz: 988 (sym: 0: nnz 0), norm: 1.70e+09
+zero entries dropped: 71
+tiny entries dropped: 10
+blocks: 38 singletons: 37 structural rank: 183
+QR   natural    time:     0.01 resid: 2.76e-28
+QR   amd(A'*A)  time:     0.00 resid: 3.59e-28
+LU   natural    time:     0.00 resid: 3.08e-28
+LU   amd(A+A')  time:     0.00 resid: 1.42e-27
+LU   amd(S'*S)  time:     0.00 resid: 7.11e-28
+LU   amd(A'*A)  time:     0.00 resid: 7.11e-28
+./cs_di_demo2 < ../Matrix/west0067
+
+--- Matrix: 67-by-67, nnz: 294 (sym: 0: nnz 0), norm: 6.14e+00
+blocks: 2 singletons: 1 structural rank: 67
+QR   natural    time:     0.00 resid: 1.95e-17
+QR   amd(A'*A)  time:     0.00 resid: 1.38e-17
+LU   natural    time:     0.00 resid: 3.85e-17
+LU   amd(A+A')  time:     0.00 resid: 1.95e-17
+LU   amd(S'*S)  time:     0.00 resid: 2.60e-17
+LU   amd(A'*A)  time:     0.00 resid: 2.60e-17
+./cs_di_demo2 < ../Matrix/lp_afiro
+
+--- Matrix: 27-by-51, nnz: 102 (sym: 0: nnz 0), norm: 3.43e+00
+blocks: 1 singletons: 0 structural rank: 27
+QR   natural    time:     0.00 resid: 1.39e-16
+QR   amd(A'*A)  time:     0.00 resid: 2.15e-16
+./cs_di_demo2 < ../Matrix/ash219
+
+--- Matrix: 219-by-85, nnz: 438 (sym: 0: nnz 0), norm: 9.00e+00
+blocks: 1 singletons: 0 structural rank: 85
+QR   natural    time:     0.00 resid: 1.61e-02
+QR   amd(A'*A)  time:     0.00 resid: 1.61e-02
+./cs_di_demo2 < ../Matrix/mbeacxc
+
+--- Matrix: 492-by-490, nnz: 49920 (sym: 0: nnz 0), norm: 9.29e-01
+blocks: 10 singletons: 8 structural rank: 448
+QR   natural    time:     0.24 resid:      nan
+QR   amd(A'*A)  time:     0.28 resid:      nan
+./cs_di_demo2 < ../Matrix/bcsstk01
+
+--- Matrix: 48-by-48, nnz: 224 (sym: -1: nnz 400), norm: 3.57e+09
+blocks: 1 singletons: 0 structural rank: 48
+QR   natural    time:     0.00 resid: 4.06e-19
+QR   amd(A'*A)  time:     0.00 resid: 2.33e-19
+LU   natural    time:     0.00 resid: 2.63e-19
+LU   amd(A+A')  time:     0.00 resid: 8.63e-20
+LU   amd(S'*S)  time:     0.00 resid: 2.04e-19
+LU   amd(A'*A)  time:     0.00 resid: 2.04e-19
+Chol natural    time:     0.00 resid: 1.90e-19
+Chol amd(A+A')  time:     0.00 resid: 2.01e-19
+./cs_di_demo3 < ../Matrix/bcsstk01
+
+--- Matrix: 48-by-48, nnz: 224 (sym: -1: nnz 400), norm: 3.57e+09
+
+chol then update/downdate amd(A+A')  
+symbolic chol time     0.00
+numeric  chol time     0.00
+solve    chol time     0.00
+original: resid: 2.01e-19
+update:   time:     0.00
+update:   time:     0.00 (incl solve) resid: 1.11e-18
+rechol:   time:     0.00 (incl solve) resid: 1.20e-18
+downdate: time:     0.00
+downdate: time:     0.00 (incl solve) resid: 3.30e-17
+./cs_di_demo2 < ../Matrix/bcsstk16
+
+--- Matrix: 4884-by-4884, nnz: 147631 (sym: -1: nnz 290378), norm: 7.01e+09
+blocks: 75 singletons: 74 structural rank: 4884
+QR   amd(A'*A)  time:     2.09 resid: 1.43e-22
+LU   amd(A+A')  time:     1.08 resid: 1.06e-22
+LU   amd(S'*S)  time:     1.07 resid: 1.21e-22
+LU   amd(A'*A)  time:     1.12 resid: 1.70e-22
+Chol amd(A+A')  time:     0.57 resid: 9.28e-23
+./cs_di_demo3 < ../Matrix/bcsstk16
+
+--- Matrix: 4884-by-4884, nnz: 147631 (sym: -1: nnz 290378), norm: 7.01e+09
+
+chol then update/downdate amd(A+A')  
+symbolic chol time     0.03
+numeric  chol time     0.53
+solve    chol time     0.01
+original: resid: 9.28e-23
+update:   time:     0.00
+update:   time:     0.02 (incl solve) resid: 1.05e-23
+rechol:   time:     0.53 (incl solve) resid: 8.72e-24
+downdate: time:     0.01
+downdate: time:     0.02 (incl solve) resid: 3.60e-22
+./cs_dl_demo1 < ../Matrix/t1
+T:
+CXSparse Version 2.0.2, Aug 23, 2006.  Copyright (c) Timothy A. Davis, 2006
+triplet: 4-by-4, nzmax: 16 nnz: 10
+    2 2 : 3
+    1 0 : 3.1
+    3 3 : 1
+    0 2 : 3.2
+    1 1 : 2.9
+    3 0 : 3.5
+    3 1 : 0.4
+    1 3 : 0.9
+    0 0 : 4.5
+    2 1 : 1.7
+A:
+CXSparse Version 2.0.2, Aug 23, 2006.  Copyright (c) Timothy A. Davis, 2006
+4-by-4, nzmax: 10 nnz: 10, 1-norm: 11.1
+    col 0 : locations 0 to 2
+      1 : 3.1
+      3 : 3.5
+      0 : 4.5
+    col 1 : locations 3 to 5
+      1 : 2.9
+      3 : 0.4
+      2 : 1.7
+    col 2 : locations 6 to 7
+      2 : 3
+      0 : 3.2
+    col 3 : locations 8 to 9
+      3 : 1
+      1 : 0.9
+AT:
+CXSparse Version 2.0.2, Aug 23, 2006.  Copyright (c) Timothy A. Davis, 2006
+4-by-4, nzmax: 10 nnz: 10, 1-norm: 7.7
+    col 0 : locations 0 to 1
+      0 : 4.5
+      2 : 3.2
+    col 1 : locations 2 to 4
+      0 : 3.1
+      1 : 2.9
+      3 : 0.9
+    col 2 : locations 5 to 6
+      1 : 1.7
+      2 : 3
+    col 3 : locations 7 to 9
+      0 : 3.5
+      1 : 0.4
+      3 : 1
+D:
+CXSparse Version 2.0.2, Aug 23, 2006.  Copyright (c) Timothy A. Davis, 2006
+4-by-4, nzmax: 16 nnz: 16, 1-norm: 139.58
+    col 0 : locations 0 to 3
+      1 : 13.95
+      3 : 15.75
+      0 : 100.28
+      2 : 9.6
+    col 1 : locations 4 to 7
+      1 : 88.62
+      3 : 12.91
+      0 : 13.95
+      2 : 4.93
+    col 2 : locations 8 to 11
+      1 : 4.93
+      3 : 0.68
+      2 : 81.68
+      0 : 9.6
+    col 3 : locations 12 to 15
+      1 : 12.91
+      3 : 83.2
+      0 : 15.75
+      2 : 0.68
+./cs_dl_demo2 < ../Matrix/t1
+
+--- Matrix: 4-by-4, nnz: 10 (sym: 0: nnz 0), norm: 1.11e+01
+blocks: 1 singletons: 0 structural rank: 4
+QR   natural    time:     0.00 resid: 1.53e-17
+QR   amd(A'*A)  time:     0.00 resid: 1.04e-17
+LU   natural    time:     0.00 resid: 1.04e-17
+LU   amd(A+A')  time:     0.00 resid: 4.94e-18
+LU   amd(S'*S)  time:     0.00 resid: 4.94e-18
+LU   amd(A'*A)  time:     0.00 resid: 4.94e-18
+./cs_dl_demo2 < ../Matrix/fs_183_1
+
+--- Matrix: 183-by-183, nnz: 988 (sym: 0: nnz 0), norm: 1.70e+09
+zero entries dropped: 71
+tiny entries dropped: 10
+blocks: 38 singletons: 37 structural rank: 183
+QR   natural    time:     0.01 resid: 2.76e-28
+QR   amd(A'*A)  time:     0.00 resid: 3.59e-28
+LU   natural    time:     0.00 resid: 3.08e-28
+LU   amd(A+A')  time:     0.00 resid: 1.42e-27
+LU   amd(S'*S)  time:     0.00 resid: 7.11e-28
+LU   amd(A'*A)  time:     0.00 resid: 7.11e-28
+./cs_dl_demo2 < ../Matrix/west0067
+
+--- Matrix: 67-by-67, nnz: 294 (sym: 0: nnz 0), norm: 6.14e+00
+blocks: 2 singletons: 1 structural rank: 67
+QR   natural    time:     0.00 resid: 1.95e-17
+QR   amd(A'*A)  time:     0.00 resid: 1.38e-17
+LU   natural    time:     0.00 resid: 3.85e-17
+LU   amd(A+A')  time:     0.00 resid: 1.95e-17
+LU   amd(S'*S)  time:     0.00 resid: 2.60e-17
+LU   amd(A'*A)  time:     0.00 resid: 2.60e-17
+./cs_dl_demo2 < ../Matrix/lp_afiro
+
+--- Matrix: 27-by-51, nnz: 102 (sym: 0: nnz 0), norm: 3.43e+00
+blocks: 1 singletons: 0 structural rank: 27
+QR   natural    time:     0.00 resid: 1.39e-16
+QR   amd(A'*A)  time:     0.00 resid: 2.15e-16
+./cs_dl_demo2 < ../Matrix/ash219
+
+--- Matrix: 219-by-85, nnz: 438 (sym: 0: nnz 0), norm: 9.00e+00
+blocks: 1 singletons: 0 structural rank: 85
+QR   natural    time:     0.00 resid: 1.61e-02
+QR   amd(A'*A)  time:     0.00 resid: 1.61e-02
+./cs_dl_demo2 < ../Matrix/mbeacxc
+
+--- Matrix: 492-by-490, nnz: 49920 (sym: 0: nnz 0), norm: 9.29e-01
+blocks: 10 singletons: 8 structural rank: 448
+QR   natural    time:     0.23 resid:      nan
+QR   amd(A'*A)  time:     0.28 resid:      nan
+./cs_dl_demo2 < ../Matrix/bcsstk01
+
+--- Matrix: 48-by-48, nnz: 224 (sym: -1: nnz 400), norm: 3.57e+09
+blocks: 1 singletons: 0 structural rank: 48
+QR   natural    time:     0.00 resid: 4.06e-19
+QR   amd(A'*A)  time:     0.00 resid: 2.33e-19
+LU   natural    time:     0.00 resid: 2.63e-19
+LU   amd(A+A')  time:     0.00 resid: 8.63e-20
+LU   amd(S'*S)  time:     0.00 resid: 2.04e-19
+LU   amd(A'*A)  time:     0.00 resid: 2.04e-19
+Chol natural    time:     0.00 resid: 1.90e-19
+Chol amd(A+A')  time:     0.00 resid: 2.01e-19
+./cs_dl_demo3 < ../Matrix/bcsstk01
+
+--- Matrix: 48-by-48, nnz: 224 (sym: -1: nnz 400), norm: 3.57e+09
+
+chol then update/downdate amd(A+A')  
+symbolic chol time     0.00
+numeric  chol time     0.00
+solve    chol time     0.00
+original: resid: 2.01e-19
+update:   time:     0.00
+update:   time:     0.00 (incl solve) resid: 1.11e-18
+rechol:   time:     0.00 (incl solve) resid: 1.20e-18
+downdate: time:     0.00
+downdate: time:     0.00 (incl solve) resid: 3.30e-17
+./cs_dl_demo2 < ../Matrix/bcsstk16
+
+--- Matrix: 4884-by-4884, nnz: 147631 (sym: -1: nnz 290378), norm: 7.01e+09
+blocks: 75 singletons: 74 structural rank: 4884
+QR   amd(A'*A)  time:     2.07 resid: 1.43e-22
+LU   amd(A+A')  time:     1.09 resid: 1.06e-22
+LU   amd(S'*S)  time:     1.08 resid: 1.21e-22
+LU   amd(A'*A)  time:     1.13 resid: 1.70e-22
+Chol amd(A+A')  time:     0.57 resid: 9.28e-23
+./cs_dl_demo3 < ../Matrix/bcsstk16
+
+--- Matrix: 4884-by-4884, nnz: 147631 (sym: -1: nnz 290378), norm: 7.01e+09
+
+chol then update/downdate amd(A+A')  
+symbolic chol time     0.03
+numeric  chol time     0.52
+solve    chol time     0.02
+original: resid: 9.28e-23
+update:   time:     0.00
+update:   time:     0.01 (incl solve) resid: 1.05e-23
+rechol:   time:     0.53 (incl solve) resid: 8.72e-24
+downdate: time:     0.00
+downdate: time:     0.01 (incl solve) resid: 3.60e-22
+./cs_ci_demo1 < ../Matrix/t2
+T:
+CXSparse Version 2.0.2, Aug 23, 2006.  Copyright (c) Timothy A. Davis, 2006
+triplet: 4-by-4, nzmax: 16 nnz: 10
+    2 2 : (3, 3.14159)
+    1 0 : (3.1, 42)
+    3 3 : (1, 7)
+    0 2 : (3.2, 0.1)
+    1 1 : (2.9, 1.3)
+    3 0 : (3.5, 0)
+    3 1 : (0.4, 2.71828)
+    1 3 : (0.9, 99)
+    0 0 : (4.5, 6)
+    2 1 : (1.7, 1)
+A:
+CXSparse Version 2.0.2, Aug 23, 2006.  Copyright (c) Timothy A. Davis, 2006
+4-by-4, nzmax: 10 nnz: 10, 1-norm: 106.075
+    col 0 : locations 0 to 2
+      1 : (3.1, 42)
+      3 : (3.5, 0)
+      0 : (4.5, 6)
+    col 1 : locations 3 to 5
+      1 : (2.9, 1.3)
+      3 : (0.4, 2.71828)
+      2 : (1.7, 1)
+    col 2 : locations 6 to 7
+      2 : (3, 3.14159)
+      0 : (3.2, 0.1)
+    col 3 : locations 8 to 9
+      3 : (1, 7)
+      1 : (0.9, 99)
+AT:
+CXSparse Version 2.0.2, Aug 23, 2006.  Copyright (c) Timothy A. Davis, 2006
+4-by-4, nzmax: 10 nnz: 10, 1-norm: 144.296
+    col 0 : locations 0 to 1
+      0 : (4.5, -6)
+      2 : (3.2, -0.1)
+    col 1 : locations 2 to 4
+      0 : (3.1, -42)
+      1 : (2.9, -1.3)
+      3 : (0.9, -99)
+    col 2 : locations 5 to 6
+      1 : (1.7, -1)
+      2 : (3, -3.14159)
+    col 3 : locations 7 to 9
+      0 : (3.5, -0)
+      1 : (0.4, -2.71828)
+      3 : (1, -7)
+D:
+CXSparse Version 2.0.2, Aug 23, 2006.  Copyright (c) Timothy A. Davis, 2006
+4-by-4, nzmax: 16 nnz: 16, 1-norm: 25308.3
+    col 0 : locations 0 to 3
+      1 : (265.95, 170.4)
+      3 : (15.75, -21)
+      0 : (12720.7, 0)
+      2 : (9.91416, 9.7531)
+    col 1 : locations 4 to 7
+      1 : (24239.7, 0)
+      3 : (709.444, -232.337)
+      0 : (265.95, -170.4)
+      2 : (6.23, 0.69)
+    col 2 : locations 8 to 11
+      1 : (6.23, -0.69)
+      3 : (3.39828, 4.22108)
+      2 : (12676.9, 0)
+      0 : (9.91416, -9.7531)
+    col 3 : locations 12 to 15
+      1 : (709.444, 232.337)
+      3 : (12724, 0)
+      0 : (15.75, 21)
+      2 : (3.39828, -4.22108)
+./cs_ci_demo2 < ../Matrix/t2
+
+--- Matrix: 4-by-4, nnz: 10 (sym: 0: nnz 0), norm: 1.06e+02
+blocks: 1 singletons: 0 structural rank: 4
+QR   natural    time:     0.00 resid: 8.73e-18
+QR   amd(A'*A)  time:     0.00 resid: 2.07e-17
+LU   natural    time:     0.00 resid: 2.67e-18
+LU   amd(A+A')  time:     0.00 resid: 2.12e-18
+LU   amd(S'*S)  time:     0.00 resid: 2.93e-18
+LU   amd(A'*A)  time:     0.00 resid: 2.12e-18
+./cs_ci_demo2 < ../Matrix/t3
+
+--- Matrix: 3-by-4, nnz: 12 (sym: 0: nnz 0), norm: 3.06e+00
+blocks: 1 singletons: 0 structural rank: 3
+QR   natural    time:     0.00 resid: 1.17e-16
+QR   amd(A'*A)  time:     0.00 resid: 1.17e-16
+./cs_ci_demo2 < ../Matrix/t4
+
+--- Matrix: 2-by-2, nnz: 3 (sym: 1: nnz 4), norm: 2.83e+00
+blocks: 1 singletons: 0 structural rank: 2
+QR   natural    time:     0.00 resid: 2.74e-17
+QR   amd(A'*A)  time:     0.00 resid: 2.74e-17
+LU   natural    time:     0.00 resid: 0.00e+00
+LU   amd(A+A')  time:     0.00 resid: 0.00e+00
+LU   amd(S'*S)  time:     0.00 resid: 0.00e+00
+LU   amd(A'*A)  time:     0.00 resid: 0.00e+00
+Chol natural    time:     0.00     (failed)
+Chol amd(A+A')  time:     0.00     (failed)
+./cs_ci_demo2 < ../Matrix/c_west0067
+
+--- Matrix: 67-by-67, nnz: 294 (sym: 0: nnz 0), norm: 6.17e+00
+blocks: 2 singletons: 1 structural rank: 67
+QR   natural    time:     0.00 resid: 5.56e-17
+QR   amd(A'*A)  time:     0.00 resid: 9.08e-17
+LU   natural    time:     0.00 resid: 6.33e-17
+LU   amd(A+A')  time:     0.00 resid: 6.63e-17
+LU   amd(S'*S)  time:     0.00 resid: 3.28e-17
+LU   amd(A'*A)  time:     0.00 resid: 4.32e-17
+./cs_ci_demo2 < ../Matrix/c_mbeacxc
+
+--- Matrix: 492-by-490, nnz: 49920 (sym: 0: nnz 0), norm: 9.29e-01
+blocks: 10 singletons: 8 structural rank: 448
+QR   natural    time:     0.65 resid:      nan
+QR   amd(A'*A)  time:     0.69 resid:      nan
+./cs_ci_demo2 < ../Matrix/young1c
+
+--- Matrix: 841-by-841, nnz: 4089 (sym: 0: nnz 0), norm: 7.30e+02
+blocks: 1 singletons: 0 structural rank: 841
+QR   natural    time:     0.02 resid: 9.29e-17
+QR   amd(A'*A)  time:     0.03 resid: 8.25e-17
+LU   natural    time:     0.01 resid: 1.45e-16
+LU   amd(A+A')  time:     0.01 resid: 3.89e-16
+LU   amd(S'*S)  time:     0.01 resid: 2.49e-16
+LU   amd(A'*A)  time:     0.01 resid: 2.49e-16
+./cs_ci_demo2 < ../Matrix/qc324
+
+--- Matrix: 324-by-324, nnz: 26730 (sym: 0: nnz 0), norm: 1.71e+00
+blocks: 1 singletons: 0 structural rank: 324
+QR   natural    time:     0.05 resid: 5.99e-17
+QR   amd(A'*A)  time:     0.06 resid: 5.46e-17
+LU   natural    time:     0.02 resid: 3.76e-17
+LU   amd(A+A')  time:     0.03 resid: 4.34e-17
+LU   amd(S'*S)  time:     0.04 resid: 3.76e-17
+LU   amd(A'*A)  time:     0.03 resid: 3.76e-17
+./cs_ci_demo2 < ../Matrix/neumann
+
+--- Matrix: 1600-by-1600, nnz: 7840 (sym: 0: nnz 0), norm: 1.41e+01
+blocks: 1 singletons: 0 structural rank: 1600
+QR   amd(A'*A)  time:     0.04 resid: 6.98e-16
+LU   amd(A+A')  time:     0.02 resid: 4.32e-16
+LU   amd(S'*S)  time:     0.02 resid: 4.63e-16
+LU   amd(A'*A)  time:     0.03 resid: 4.63e-16
+./cs_ci_demo2 < ../Matrix/mhd1280b
+
+--- Matrix: 1280-by-1280, nnz: 11963 (sym: -1: nnz 22646), norm: 8.00e+01
+tiny entries dropped: 66
+blocks: 20 singletons: 14 structural rank: 1280
+QR   amd(A'*A)  time:     0.01 resid: 3.77e-25
+LU   amd(A+A')  time:     0.01 resid: 2.07e-25
+LU   amd(S'*S)  time:     0.02 resid: 1.53e-25
+LU   amd(A'*A)  time:     0.01 resid: 1.53e-25
+Chol amd(A+A')  time:     0.01 resid: 3.63e-16
+./cs_ci_demo3 < ../Matrix/mhd1280b
+
+--- Matrix: 1280-by-1280, nnz: 12029 (sym: -1: nnz 22778), norm: 8.00e+01
+
+chol then update/downdate amd(A+A')  
+symbolic chol time     0.00
+numeric  chol time     0.00
+solve    chol time     0.00
+original: resid: 3.64e-16
+update:   time:     0.00
+update:   time:     0.00 (incl solve) resid: 3.64e-16
+rechol:   time:     0.00 (incl solve) resid: 3.64e-16
+downdate: time:     0.00
+downdate: time:     0.00 (incl solve) resid: 1.89e-15
+./cs_cl_demo1 < ../Matrix/t2
+T:
+CXSparse Version 2.0.2, Aug 23, 2006.  Copyright (c) Timothy A. Davis, 2006
+triplet: 4-by-4, nzmax: 16 nnz: 10
+    2 2 : (3, 3.14159)
+    1 0 : (3.1, 42)
+    3 3 : (1, 7)
+    0 2 : (3.2, 0.1)
+    1 1 : (2.9, 1.3)
+    3 0 : (3.5, 0)
+    3 1 : (0.4, 2.71828)
+    1 3 : (0.9, 99)
+    0 0 : (4.5, 6)
+    2 1 : (1.7, 1)
+A:
+CXSparse Version 2.0.2, Aug 23, 2006.  Copyright (c) Timothy A. Davis, 2006
+4-by-4, nzmax: 10 nnz: 10, 1-norm: 106.075
+    col 0 : locations 0 to 2
+      1 : (3.1, 42)
+      3 : (3.5, 0)
+      0 : (4.5, 6)
+    col 1 : locations 3 to 5
+      1 : (2.9, 1.3)
+      3 : (0.4, 2.71828)
+      2 : (1.7, 1)
+    col 2 : locations 6 to 7
+      2 : (3, 3.14159)
+      0 : (3.2, 0.1)
+    col 3 : locations 8 to 9
+      3 : (1, 7)
+      1 : (0.9, 99)
+AT:
+CXSparse Version 2.0.2, Aug 23, 2006.  Copyright (c) Timothy A. Davis, 2006
+4-by-4, nzmax: 10 nnz: 10, 1-norm: 144.296
+    col 0 : locations 0 to 1
+      0 : (4.5, -6)
+      2 : (3.2, -0.1)
+    col 1 : locations 2 to 4
+      0 : (3.1, -42)
+      1 : (2.9, -1.3)
+      3 : (0.9, -99)
+    col 2 : locations 5 to 6
+      1 : (1.7, -1)
+      2 : (3, -3.14159)
+    col 3 : locations 7 to 9
+      0 : (3.5, -0)
+      1 : (0.4, -2.71828)
+      3 : (1, -7)
+D:
+CXSparse Version 2.0.2, Aug 23, 2006.  Copyright (c) Timothy A. Davis, 2006
+4-by-4, nzmax: 16 nnz: 16, 1-norm: 25308.3
+    col 0 : locations 0 to 3
+      1 : (265.95, 170.4)
+      3 : (15.75, -21)
+      0 : (12720.7, 0)
+      2 : (9.91416, 9.7531)
+    col 1 : locations 4 to 7
+      1 : (24239.7, 0)
+      3 : (709.444, -232.337)
+      0 : (265.95, -170.4)
+      2 : (6.23, 0.69)
+    col 2 : locations 8 to 11
+      1 : (6.23, -0.69)
+      3 : (3.39828, 4.22108)
+      2 : (12676.9, 0)
+      0 : (9.91416, -9.7531)
+    col 3 : locations 12 to 15
+      1 : (709.444, 232.337)
+      3 : (12724, 0)
+      0 : (15.75, 21)
+      2 : (3.39828, -4.22108)
+./cs_cl_demo2 < ../Matrix/t2
+
+--- Matrix: 4-by-4, nnz: 10 (sym: 0: nnz 0), norm: 1.06e+02
+blocks: 1 singletons: 0 structural rank: 4
+QR   natural    time:     0.00 resid: 8.73e-18
+QR   amd(A'*A)  time:     0.00 resid: 2.07e-17
+LU   natural    time:     0.00 resid: 2.67e-18
+LU   amd(A+A')  time:     0.00 resid: 2.12e-18
+LU   amd(S'*S)  time:     0.00 resid: 2.93e-18
+LU   amd(A'*A)  time:     0.00 resid: 2.12e-18
+./cs_cl_demo2 < ../Matrix/t3
+
+--- Matrix: 3-by-4, nnz: 12 (sym: 0: nnz 0), norm: 3.06e+00
+blocks: 1 singletons: 0 structural rank: 3
+QR   natural    time:     0.00 resid: 1.17e-16
+QR   amd(A'*A)  time:     0.00 resid: 1.17e-16
+./cs_cl_demo2 < ../Matrix/t4
+
+--- Matrix: 2-by-2, nnz: 3 (sym: 1: nnz 4), norm: 2.83e+00
+blocks: 1 singletons: 0 structural rank: 2
+QR   natural    time:     0.00 resid: 2.74e-17
+QR   amd(A'*A)  time:     0.00 resid: 2.74e-17
+LU   natural    time:     0.00 resid: 0.00e+00
+LU   amd(A+A')  time:     0.00 resid: 0.00e+00
+LU   amd(S'*S)  time:     0.00 resid: 0.00e+00
+LU   amd(A'*A)  time:     0.00 resid: 0.00e+00
+Chol natural    time:     0.00     (failed)
+Chol amd(A+A')  time:     0.00     (failed)
+./cs_cl_demo2 < ../Matrix/c_west0067
+
+--- Matrix: 67-by-67, nnz: 294 (sym: 0: nnz 0), norm: 6.17e+00
+blocks: 2 singletons: 1 structural rank: 67
+QR   natural    time:     0.00 resid: 5.56e-17
+QR   amd(A'*A)  time:     0.00 resid: 9.08e-17
+LU   natural    time:     0.00 resid: 6.33e-17
+LU   amd(A+A')  time:     0.00 resid: 6.63e-17
+LU   amd(S'*S)  time:     0.00 resid: 3.28e-17
+LU   amd(A'*A)  time:     0.00 resid: 4.32e-17
+./cs_cl_demo2 < ../Matrix/c_mbeacxc
+
+--- Matrix: 492-by-490, nnz: 49920 (sym: 0: nnz 0), norm: 9.29e-01
+blocks: 10 singletons: 8 structural rank: 448
+QR   natural    time:     0.66 resid:      nan
+QR   amd(A'*A)  time:     0.68 resid:      nan
+./cs_cl_demo2 < ../Matrix/young1c
+
+--- Matrix: 841-by-841, nnz: 4089 (sym: 0: nnz 0), norm: 7.30e+02
+blocks: 1 singletons: 0 structural rank: 841
+QR   natural    time:     0.02 resid: 9.29e-17
+QR   amd(A'*A)  time:     0.02 resid: 8.25e-17
+LU   natural    time:     0.01 resid: 1.45e-16
+LU   amd(A+A')  time:     0.03 resid: 3.89e-16
+LU   amd(S'*S)  time:     0.01 resid: 2.49e-16
+LU   amd(A'*A)  time:     0.01 resid: 2.49e-16
+./cs_cl_demo2 < ../Matrix/qc324
+
+--- Matrix: 324-by-324, nnz: 26730 (sym: 0: nnz 0), norm: 1.71e+00
+blocks: 1 singletons: 0 structural rank: 324
+QR   natural    time:     0.05 resid: 5.99e-17
+QR   amd(A'*A)  time:     0.06 resid: 5.46e-17
+LU   natural    time:     0.02 resid: 3.76e-17
+LU   amd(A+A')  time:     0.03 resid: 4.34e-17
+LU   amd(S'*S)  time:     0.04 resid: 3.76e-17
+LU   amd(A'*A)  time:     0.03 resid: 3.76e-17
+./cs_cl_demo2 < ../Matrix/neumann
+
+--- Matrix: 1600-by-1600, nnz: 7840 (sym: 0: nnz 0), norm: 1.41e+01
+blocks: 1 singletons: 0 structural rank: 1600
+QR   amd(A'*A)  time:     0.03 resid: 6.98e-16
+LU   amd(A+A')  time:     0.01 resid: 4.32e-16
+LU   amd(S'*S)  time:     0.02 resid: 4.63e-16
+LU   amd(A'*A)  time:     0.03 resid: 4.63e-16
+./cs_cl_demo2 < ../Matrix/mhd1280b
+
+--- Matrix: 1280-by-1280, nnz: 11963 (sym: -1: nnz 22646), norm: 8.00e+01
+tiny entries dropped: 66
+blocks: 20 singletons: 14 structural rank: 1280
+QR   amd(A'*A)  time:     0.01 resid: 3.77e-25
+LU   amd(A+A')  time:     0.00 resid: 2.07e-25
+LU   amd(S'*S)  time:     0.01 resid: 1.53e-25
+LU   amd(A'*A)  time:     0.00 resid: 1.53e-25
+Chol amd(A+A')  time:     0.01 resid: 3.63e-16
+./cs_cl_demo3 < ../Matrix/mhd1280b
+
+--- Matrix: 1280-by-1280, nnz: 12029 (sym: -1: nnz 22778), norm: 8.00e+01
+
+chol then update/downdate amd(A+A')  
+symbolic chol time     0.00
+numeric  chol time     0.00
+solve    chol time     0.00
+original: resid: 3.64e-16
+update:   time:     0.00
+update:   time:     0.00 (incl solve) resid: 3.64e-16
+rechol:   time:     0.00 (incl solve) resid: 3.64e-16
+downdate: time:     0.00
+downdate: time:     0.00 (incl solve) resid: 1.89e-15
+make[1]: Leaving directory `/amd/netapp3/vol/research0a/research18/sparse/UFsparse/CXSparse/Demo'
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_demo1.cpp SuiteSparse/CXSparse-C++/Demo/cs_demo1.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_demo1.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Demo/cs_demo1.cpp	2006-05-27 14:57:04.000000000 +0200
@@ -0,0 +1,27 @@
+#include "cs.h"
+int main (void)
+{
+    cs *T, *A, *Eye, *AT, *C, *D ;
+    int i, m ;
+    T = cs_load (stdin) ;		/* load triplet matrix T from stdin */
+    printf ("T:\n") ; cs_print (T, 0) ;	/* print T */
+    A = cs_compress (T) ;		/* A = compressed-column form of T */
+    printf ("A:\n") ; cs_print (A, 0) ;	/* print A */
+    cs_spfree (T) ;			/* clear T */
+    AT = cs_transpose (A, 1) ;		/* AT = A' */
+    printf ("AT:\n") ; cs_print (AT, 0) ; /* print AT */
+    m = A ? A->m : 0 ;			/* m = # of rows of A */
+    T = cs_spalloc (m, m, m, 1, 1) ;	/* create triplet identity matrix */
+    for (i = 0 ; i < m ; i++) cs_entry (T, i, i, 1) ;
+    Eye = cs_compress (T) ;		/* Eye = speye (m) */
+    cs_spfree (T) ;
+    C = cs_multiply (A, AT) ;		/* C = A*A' */
+    D = cs_add (C, Eye, 1, cs_norm (C)) ;   /* D = C + Eye*norm (C,1) */
+    printf ("D:\n") ; cs_print (D, 0) ;	/* print D */
+    cs_spfree (A) ;			/* clear A AT C D Eye */
+    cs_spfree (AT) ;
+    cs_spfree (C) ;
+    cs_spfree (D) ;
+    cs_spfree (Eye) ;
+    return (0) ;
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_demo2.cpp SuiteSparse/CXSparse-C++/Demo/cs_demo2.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_demo2.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Demo/cs_demo2.cpp	2006-11-24 16:24:58.000000000 +0100
@@ -0,0 +1,9 @@
+#include "cs_demo.h"
+/* cs_demo2: read a matrix and solve a linear system */
+int main (void)
+{
+    problem *Prob = (problem *)get_problem (stdin, 1e-14) ;
+    demo2 (Prob) ;
+    free_problem (Prob) ;
+    return (0) ;
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_demo3.cpp SuiteSparse/CXSparse-C++/Demo/cs_demo3.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_demo3.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Demo/cs_demo3.cpp	2005-10-22 10:06:26.000000000 +0200
@@ -0,0 +1,9 @@
+#include "cs_demo.h"
+/* cs_demo3: read a matrix and test Cholesky update/downdate */
+int main (void)
+{
+    problem *Prob = get_problem (stdin, 0) ;
+    demo3 (Prob) ;
+    free_problem (Prob) ;
+    return (0) ;
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_di_demo.cpp SuiteSparse/CXSparse-C++/Demo/cs_di_demo.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_di_demo.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Demo/cs_di_demo.cpp	2006-11-24 16:29:24.000000000 +0100
@@ -0,0 +1,286 @@
+#include "cs_di_demo.h"
+#include <time.h>
+/* 1 if A is square & upper tri., -1 if square & lower tri., 0 otherwise */
+static int is_sym (cs_di *A)
+{
+    int is_upper, is_lower, j, p, n = A->n, m = A->m, *Ap = A->p, *Ai = A->i ;
+    if (m != n) return (0) ;
+    is_upper = 1 ;
+    is_lower = 1 ;
+    for (j = 0 ; j < n ; j++)
+    {
+	for (p = Ap [j] ; p < Ap [j+1] ; p++)
+	{
+	    if (Ai [p] > j) is_upper = 0 ;
+	    if (Ai [p] < j) is_lower = 0 ;
+	}
+    }
+    return (is_upper ? 1 : (is_lower ? -1 : 0)) ;
+}
+
+/* true for off-diagonal entries */
+static int dropdiag (int i, int j, double aij, void *other) { return (i != j) ;}
+
+/* C = A + triu(A,1)' */
+static cs_di *make_sym (cs_di *A)
+{
+    cs_di *AT, *C ;
+    AT = cs_di_transpose (A, 1) ;		/* AT = A' */
+    cs_di_fkeep (AT, &dropdiag, NULL) ;	/* drop diagonal entries from AT */
+    C = cs_di_add (A, AT, 1, 1) ;		/* C = A+AT */
+    cs_di_spfree (AT) ;
+    return (C) ;
+}
+
+/* create a right-hand side */
+static void rhs (double *x, double *b, int m)
+{
+    int i ;
+    for (i = 0 ; i < m ; i++) b [i] = 1 + ((double) i) / m ;
+    for (i = 0 ; i < m ; i++) x [i] = b [i] ;
+}
+
+/* infinity-norm of x */
+static double norm (double *x, int n)
+{
+    int i ;
+    double normx = 0 ;
+    for (i = 0 ; i < n ; i++) normx = CS_MAX (normx, fabs (x [i])) ;
+    return (normx) ;
+}
+
+/* compute residual, norm(A*x-b,inf) / (norm(A,1)*norm(x,inf) + norm(b,inf)) */
+static void print_resid (int ok, cs_di *A, double *x, double *b, double *resid)
+{
+    int i, m, n ;
+    if (!ok) { printf ("    (failed)\n") ; return ; }
+    m = A->m ; n = A->n ;
+    for (i = 0 ; i < m ; i++) resid [i] = -b [i] ;  /* resid = -b */
+    cs_di_gaxpy (A, x, resid) ;			    /* resid = resid + A*x  */
+    printf ("resid: %8.2e\n", norm (resid,m) / ((n == 0) ? 1 :
+	(cs_di_norm (A) * norm (x,n) + norm (b,m)))) ;
+}
+
+static double tic (void) { return (clock () / (double) CLOCKS_PER_SEC) ; }
+static double toc (double t) { double s = tic () ; return (CS_MAX (0, s-t)) ; }
+
+static void print_order (int order)
+{
+    switch (order)
+    {
+	case 0: printf ("natural    ") ; break ;
+	case 1: printf ("amd(A+A')  ") ; break ;
+	case 2: printf ("amd(S'*S)  ") ; break ;
+	case 3: printf ("amd(A'*A)  ") ; break ;
+    }
+}
+
+/* read a problem from a file */
+problem *get_problem (FILE *f, double tol)
+{
+    cs_di *T, *A, *C ;
+    int sym, m, n, mn, nz1, nz2 ;
+    problem *Prob ;
+    Prob = (problem *)cs_di_calloc (1, sizeof (problem)) ;
+    if (!Prob) return (NULL) ;
+    T = cs_di_load (f) ;			/* load triplet matrix T from a file */
+    Prob->A = A = cs_di_compress (T) ;	/* A = compressed-column form of T */
+    cs_di_spfree (T) ;			/* clear T */
+    if (!cs_di_dupl (A)) return (free_problem (Prob)) ; /* sum up duplicates */
+    Prob->sym = sym = is_sym (A) ;	/* determine if A is symmetric */
+    m = A->m ; n = A->n ;
+    mn = CS_MAX (m,n) ;
+    nz1 = A->p [n] ;
+    cs_di_dropzeros (A) ;			/* drop zero entries */
+    nz2 = A->p [n] ;
+    if (tol > 0) cs_di_droptol (A, tol) ;	/* drop tiny entries (just to test) */
+    Prob->C = C = sym ? make_sym (A) : A ;  /* C = A + triu(A,1)', or C=A */
+    if (!C) return (free_problem (Prob)) ;
+    printf ("\n--- Matrix: %d-by-%d, nnz: %d (sym: %d: nnz %d), norm: %8.2e\n",
+	    m, n, A->p [n], sym, sym ? C->p [n] : 0, cs_di_norm (C)) ;
+    if (nz1 != nz2) printf ("zero entries dropped: %d\n", nz1 - nz2) ;
+    if (nz2 != A->p [n]) printf ("tiny entries dropped: %d\n", nz2 - A->p [n]) ;
+    Prob->b = (double *)cs_di_malloc (mn, sizeof (double)) ;
+    Prob->x = (double *)cs_di_malloc (mn, sizeof (double)) ;
+    Prob->resid = (double *)cs_di_malloc (mn, sizeof (double)) ;
+    return ((!Prob->b || !Prob->x || !Prob->resid) ? free_problem (Prob) : Prob) ;
+}
+
+/* free a problem */
+problem *free_problem (problem *Prob)
+{
+    if (!Prob) return (NULL) ;
+    cs_di_spfree (Prob->A) ;
+    if (Prob->sym) cs_di_spfree (Prob->C) ;
+    cs_di_free (Prob->b) ;
+    cs_di_free (Prob->x) ;
+    cs_di_free (Prob->resid) ;
+    return (problem *)(cs_di_free (Prob)) ;
+}
+
+/* solve a linear system using Cholesky, LU, and QR, with various orderings */
+int demo2 (problem *Prob)
+{
+    cs_di *A, *C ;
+    double *b, *x, *resid,  t, tol ;
+    int k, m, n, ok, order, nb, ns, *r, *s, *rr, sprank ;
+    cs_did *D ;
+    if (!Prob) return (0) ;
+    A = Prob->A ; C = Prob->C ; b = Prob->b ; x = Prob->x ; resid = Prob->resid;
+    m = A->m ; n = A->n ;
+    tol = Prob->sym ? 0.001 : 1 ;		/* partial pivoting tolerance */
+    D = cs_di_dmperm (C, 1) ;			/* randomized dmperm analysis */
+    if (!D) return (0) ;
+    nb = D->nb ; r = D->r ; s = D->s ; rr = D->rr ;
+    sprank = rr [3] ;
+    for (ns = 0, k = 0 ; k < nb ; k++)
+    {
+	ns += ((r [k+1] == r [k]+1) && (s [k+1] == s [k]+1)) ;
+    }
+    printf ("blocks: %d singletons: %d structural rank: %d\n", nb, ns, sprank) ;
+    cs_di_dfree (D) ;
+    for (order = 0 ; order <= 3 ; order += 3)	/* natural and amd(A'*A) */
+    {
+	if (!order && m > 1000) continue ;
+	printf ("QR   ") ;
+	print_order (order) ;
+	rhs (x, b, m) ;				/* compute right-hand side */
+	t = tic () ;
+	ok = cs_di_qrsol (order, C, x) ;		/* min norm(Ax-b) with QR */
+	printf ("time: %8.2f ", toc (t)) ;
+	print_resid (ok, C, x, b, resid) ;	/* print residual */
+    }
+    if (m != n || sprank < n) return (1) ;	/* return if rect. or singular*/
+    for (order = 0 ; order <= 3 ; order++)	/* try all orderings */
+    {
+	if (!order && m > 1000) continue ;
+	printf ("LU   ") ;
+	print_order (order) ;
+	rhs (x, b, m) ;				/* compute right-hand side */
+	t = tic () ;
+	ok = cs_di_lusol (order, C, x, tol) ;	/* solve Ax=b with LU */
+	printf ("time: %8.2f ", toc (t)) ;
+	print_resid (ok, C, x, b, resid) ;	/* print residual */
+    }
+    if (!Prob->sym) return (1) ;
+    for (order = 0 ; order <= 1 ; order++)	/* natural and amd(A+A') */
+    {
+	if (!order && m > 1000) continue ;
+	printf ("Chol ") ;
+	print_order (order) ;
+	rhs (x, b, m) ;				/* compute right-hand side */
+	t = tic () ;
+	ok = cs_di_cholsol (order, C, x) ;		/* solve Ax=b with Cholesky */
+	printf ("time: %8.2f ", toc (t)) ;
+	print_resid (ok, C, x, b, resid) ;	/* print residual */
+    }
+    return (1) ;
+} 
+
+/* free workspace for demo3 */
+static int done3 (int ok, cs_dis *S, cs_din *N, double *y, cs_di *W, cs_di *E, int *p)
+{
+    cs_di_sfree (S) ;
+    cs_di_nfree (N) ;
+    cs_di_free (y) ;
+    cs_di_spfree (W) ;
+    cs_di_spfree (E) ;
+    cs_di_free (p) ;
+    return (ok) ;
+}
+
+/* Cholesky update/downdate */
+int demo3 (problem *Prob)
+{
+    cs_di *A, *C, *W = NULL, *WW, *WT, *E = NULL, *W2 ;
+    int n, k, *Li, *Lp, *Wi, *Wp, p1, p2, *p = NULL, ok ;
+    double *b, *x, *resid, *y = NULL, *Lx, *Wx, s,  t, t1 ;
+    cs_dis *S = NULL ;
+    cs_din *N = NULL ;
+    if (!Prob || !Prob->sym || Prob->A->n == 0) return (0) ;
+    A = Prob->A ; C = Prob->C ; b = Prob->b ; x = Prob->x ; resid = Prob->resid;
+    n = A->n ;
+    if (!Prob->sym || n == 0) return (1) ;
+    rhs (x, b, n) ;				/* compute right-hand side */
+    printf ("\nchol then update/downdate ") ;
+    print_order (1) ;
+    y = (double *)cs_di_malloc (n, sizeof (double)) ;
+    t = tic () ;
+    S = cs_di_schol (1, C) ;			/* symbolic Chol, amd(A+A') */
+    printf ("\nsymbolic chol time %8.2f\n", toc (t)) ;
+    t = tic () ;
+    N = cs_di_chol (C, S) ;			/* numeric Cholesky */
+    printf ("numeric  chol time %8.2f\n", toc (t)) ;
+    if (!S || !N || !y) return (done3 (0, S, N, y, W, E, p)) ;
+    t = tic () ;
+    cs_di_ipvec (S->pinv, b, y, n) ;		/* y = P*b */
+    cs_di_lsolve (N->L, y) ;			/* y = L\y */
+    cs_di_ltsolve (N->L, y) ;			/* y = L'\y */
+    cs_di_pvec (S->pinv, y, x, n) ;		/* x = P'*y */
+    printf ("solve    chol time %8.2f\n", toc (t)) ;
+    printf ("original: ") ;
+    print_resid (1, C, x, b, resid) ;		/* print residual */
+    k = n/2 ;					/* construct W  */
+    W = cs_di_spalloc (n, 1, n, 1, 0) ;
+    if (!W) return (done3 (0, S, N, y, W, E, p)) ;
+    Lp = N->L->p ; Li = N->L->i ; Lx = N->L->x ;
+    Wp = W->p ; Wi = W->i ; Wx = W->x ;
+    Wp [0] = 0 ;
+    p1 = Lp [k] ;
+    Wp [1] = Lp [k+1] - p1 ;
+    s = Lx [p1] ;
+    srand (1) ;
+    for ( ; p1 < Lp [k+1] ; p1++)
+    {
+	p2 = p1 - Lp [k] ;
+	Wi [p2] = Li [p1] ;
+	Wx [p2] = s * rand () / ((double) RAND_MAX) ;
+    }
+    t = tic () ;
+    ok = cs_di_updown (N->L, +1, W, S->parent) ;	/* update: L*L'+W*W' */
+    t1 = toc (t) ;
+    printf ("update:   time: %8.2f\n", t1) ;
+    if (!ok) return (done3 (0, S, N, y, W, E, p)) ;
+    t = tic () ;
+    cs_di_ipvec (S->pinv, b, y, n) ;		/* y = P*b */
+    cs_di_lsolve (N->L, y) ;			/* y = L\y */
+    cs_di_ltsolve (N->L, y) ;			/* y = L'\y */
+    cs_di_pvec (S->pinv, y, x, n) ;		/* x = P'*y */
+    t = toc (t) ;
+    p = cs_di_pinv (S->pinv, n) ;
+    W2 = cs_di_permute (W, p, NULL, 1) ;		/* E = C + (P'W)*(P'W)' */
+    WT = cs_di_transpose (W2,1) ;
+    WW = cs_di_multiply (W2, WT) ;
+    cs_di_spfree (WT) ;
+    cs_di_spfree (W2) ;
+    E = cs_di_add (C, WW, 1, 1) ;
+    cs_di_spfree (WW) ;
+    if (!E || !p) return (done3 (0, S, N, y, W, E, p)) ;
+    printf ("update:   time: %8.2f (incl solve) ", t1+t) ;
+    print_resid (1, E, x, b, resid) ;		/* print residual */
+    cs_di_nfree (N) ;				/* clear N */
+    t = tic () ;
+    N = cs_di_chol (E, S) ;			/* numeric Cholesky */
+    if (!N) return (done3 (0, S, N, y, W, E, p)) ;
+    cs_di_ipvec (S->pinv, b, y, n) ;		/* y = P*b */
+    cs_di_lsolve (N->L, y) ;			/* y = L\y */
+    cs_di_ltsolve (N->L, y) ;			/* y = L'\y */
+    cs_di_pvec (S->pinv, y, x, n) ;		/* x = P'*y */
+    t = toc (t) ;
+    printf ("rechol:   time: %8.2f (incl solve) ", t) ;
+    print_resid (1, E, x, b, resid) ;		/* print residual */
+    t = tic () ;
+    ok = cs_di_updown (N->L, -1, W, S->parent) ;	/* downdate: L*L'-W*W' */
+    t1 = toc (t) ;
+    if (!ok) return (done3 (0, S, N, y, W, E, p)) ;
+    printf ("downdate: time: %8.2f\n", t1) ;
+    t = tic () ;
+    cs_di_ipvec (S->pinv, b, y, n) ;		/* y = P*b */
+    cs_di_lsolve (N->L, y) ;			/* y = L\y */
+    cs_di_ltsolve (N->L, y) ;			/* y = L'\y */
+    cs_di_pvec (S->pinv, y, x, n) ;		/* x = P'*y */
+    t = toc (t) ;
+    printf ("downdate: time: %8.2f (incl solve) ", t1+t) ;
+    print_resid (1, C, x, b, resid) ;		/* print residual */
+    return (done3 (1, S, N, y, W, E, p)) ;
+} 
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_di_demo.h SuiteSparse/CXSparse-C++/Demo/cs_di_demo.h
--- original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_di_demo.h	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Demo/cs_di_demo.h	2006-08-25 08:04:44.000000000 +0200
@@ -0,0 +1,15 @@
+#include "cs.h"
+typedef struct problem_struct
+{
+    cs_di *A ;
+    cs_di *C ;
+    int sym ;
+    double *x ;
+    double *b ;
+    double *resid ;
+} problem ;
+
+problem *get_problem (FILE *f, double tol) ;
+int demo2 (problem *Prob) ;
+int demo3 (problem *Prob) ;
+problem *free_problem (problem *Prob) ;
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_di_demo1.cpp SuiteSparse/CXSparse-C++/Demo/cs_di_demo1.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_di_demo1.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Demo/cs_di_demo1.cpp	2006-08-25 08:04:44.000000000 +0200
@@ -0,0 +1,27 @@
+#include "cs.h"
+int main (void)
+{
+    cs_di *T, *A, *Eye, *AT, *C, *D ;
+    int i, m ;
+    T = cs_di_load (stdin) ;		/* load triplet matrix T from stdin */
+    printf ("T:\n") ; cs_di_print (T, 0) ;	/* print T */
+    A = cs_di_compress (T) ;		/* A = compressed-column form of T */
+    printf ("A:\n") ; cs_di_print (A, 0) ;	/* print A */
+    cs_di_spfree (T) ;			/* clear T */
+    AT = cs_di_transpose (A, 1) ;		/* AT = A' */
+    printf ("AT:\n") ; cs_di_print (AT, 0) ; /* print AT */
+    m = A ? A->m : 0 ;			/* m = # of rows of A */
+    T = cs_di_spalloc (m, m, m, 1, 1) ;	/* create triplet identity matrix */
+    for (i = 0 ; i < m ; i++) cs_di_entry (T, i, i, 1) ;
+    Eye = cs_di_compress (T) ;		/* Eye = speye (m) */
+    cs_di_spfree (T) ;
+    C = cs_di_multiply (A, AT) ;		/* C = A*A' */
+    D = cs_di_add (C, Eye, 1, cs_di_norm (C)) ;   /* D = C + Eye*norm (C,1) */
+    printf ("D:\n") ; cs_di_print (D, 0) ;	/* print D */
+    cs_di_spfree (A) ;			/* clear A AT C D Eye */
+    cs_di_spfree (AT) ;
+    cs_di_spfree (C) ;
+    cs_di_spfree (D) ;
+    cs_di_spfree (Eye) ;
+    return (0) ;
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_di_demo2.cpp SuiteSparse/CXSparse-C++/Demo/cs_di_demo2.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_di_demo2.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Demo/cs_di_demo2.cpp	2006-08-25 08:04:44.000000000 +0200
@@ -0,0 +1,9 @@
+#include "cs_di_demo.h"
+/* cs_di_demo2: read a matrix and solve a linear system */
+int main (void)
+{
+    problem *Prob = get_problem (stdin, 1e-14) ;
+    demo2 (Prob) ;
+    free_problem (Prob) ;
+    return (0) ;
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_di_demo3.cpp SuiteSparse/CXSparse-C++/Demo/cs_di_demo3.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_di_demo3.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Demo/cs_di_demo3.cpp	2006-08-25 08:04:44.000000000 +0200
@@ -0,0 +1,9 @@
+#include "cs_di_demo.h"
+/* cs_di_demo3: read a matrix and test Cholesky update/downdate */
+int main (void)
+{
+    problem *Prob = get_problem (stdin, 0) ;
+    demo3 (Prob) ;
+    free_problem (Prob) ;
+    return (0) ;
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_dl_demo.cpp SuiteSparse/CXSparse-C++/Demo/cs_dl_demo.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_dl_demo.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Demo/cs_dl_demo.cpp	2006-11-24 16:30:26.000000000 +0100
@@ -0,0 +1,286 @@
+#include "cs_dl_demo.h"
+#include <time.h>
+/* 1 if A is square & upper tri., -1 if square & lower tri., 0 otherwise */
+static UF_long is_sym (cs_dl *A)
+{
+    UF_long is_upper, is_lower, j, p, n = A->n, m = A->m, *Ap = A->p, *Ai = A->i ;
+    if (m != n) return (0) ;
+    is_upper = 1 ;
+    is_lower = 1 ;
+    for (j = 0 ; j < n ; j++)
+    {
+	for (p = Ap [j] ; p < Ap [j+1] ; p++)
+	{
+	    if (Ai [p] > j) is_upper = 0 ;
+	    if (Ai [p] < j) is_lower = 0 ;
+	}
+    }
+    return (is_upper ? 1 : (is_lower ? -1 : 0)) ;
+}
+
+/* true for off-diagonal entries */
+static UF_long dropdiag (UF_long i, UF_long j, double aij, void *other) { return (i != j) ;}
+
+/* C = A + triu(A,1)' */
+static cs_dl *make_sym (cs_dl *A)
+{
+    cs_dl *AT, *C ;
+    AT = cs_dl_transpose (A, 1) ;		/* AT = A' */
+    cs_dl_fkeep (AT, &dropdiag, NULL) ;	/* drop diagonal entries from AT */
+    C = cs_dl_add (A, AT, 1, 1) ;		/* C = A+AT */
+    cs_dl_spfree (AT) ;
+    return (C) ;
+}
+
+/* create a right-hand side */
+static void rhs (double *x, double *b, UF_long m)
+{
+    UF_long i ;
+    for (i = 0 ; i < m ; i++) b [i] = 1 + ((double) i) / m ;
+    for (i = 0 ; i < m ; i++) x [i] = b [i] ;
+}
+
+/* infinity-norm of x */
+static double norm (double *x, UF_long n)
+{
+    UF_long i ;
+    double normx = 0 ;
+    for (i = 0 ; i < n ; i++) normx = CS_MAX (normx, fabs (x [i])) ;
+    return (normx) ;
+}
+
+/* compute residual, norm(A*x-b,inf) / (norm(A,1)*norm(x,inf) + norm(b,inf)) */
+static void print_resid (UF_long ok, cs_dl *A, double *x, double *b, double *resid)
+{
+    UF_long i, m, n ;
+    if (!ok) { printf ("    (failed)\n") ; return ; }
+    m = A->m ; n = A->n ;
+    for (i = 0 ; i < m ; i++) resid [i] = -b [i] ;  /* resid = -b */
+    cs_dl_gaxpy (A, x, resid) ;			    /* resid = resid + A*x  */
+    printf ("resid: %8.2e\n", norm (resid,m) / ((n == 0) ? 1 :
+	(cs_dl_norm (A) * norm (x,n) + norm (b,m)))) ;
+}
+
+static double tic (void) { return (clock () / (double) CLOCKS_PER_SEC) ; }
+static double toc (double t) { double s = tic () ; return (CS_MAX (0, s-t)) ; }
+
+static void print_order (UF_long order)
+{
+    switch (order)
+    {
+	case 0: printf ("natural    ") ; break ;
+	case 1: printf ("amd(A+A')  ") ; break ;
+	case 2: printf ("amd(S'*S)  ") ; break ;
+	case 3: printf ("amd(A'*A)  ") ; break ;
+    }
+}
+
+/* read a problem from a file */
+problem *get_problem (FILE *f, double tol)
+{
+    cs_dl *T, *A, *C ;
+    UF_long sym, m, n, mn, nz1, nz2 ;
+    problem *Prob ;
+    Prob = (problem *)cs_dl_calloc (1, sizeof (problem)) ;
+    if (!Prob) return (NULL) ;
+    T = cs_dl_load (f) ;			/* load triplet matrix T from a file */
+    Prob->A = A = cs_dl_compress (T) ;	/* A = compressed-column form of T */
+    cs_dl_spfree (T) ;			/* clear T */
+    if (!cs_dl_dupl (A)) return (free_problem (Prob)) ; /* sum up duplicates */
+    Prob->sym = sym = is_sym (A) ;	/* determine if A is symmetric */
+    m = A->m ; n = A->n ;
+    mn = CS_MAX (m,n) ;
+    nz1 = A->p [n] ;
+    cs_dl_dropzeros (A) ;			/* drop zero entries */
+    nz2 = A->p [n] ;
+    if (tol > 0) cs_dl_droptol (A, tol) ;	/* drop tiny entries (just to test) */
+    Prob->C = C = sym ? make_sym (A) : A ;  /* C = A + triu(A,1)', or C=A */
+    if (!C) return (free_problem (Prob)) ;
+    printf ("\n--- Matrix: %ld-by-%ld, nnz: %ld (sym: %ld: nnz %ld), norm: %8.2e\n",
+	    m, n, A->p [n], sym, sym ? C->p [n] : 0, cs_dl_norm (C)) ;
+    if (nz1 != nz2) printf ("zero entries dropped: %ld\n", nz1 - nz2) ;
+    if (nz2 != A->p [n]) printf ("tiny entries dropped: %ld\n", nz2 - A->p [n]) ;
+    Prob->b = (double *)cs_dl_malloc (mn, sizeof (double)) ;
+    Prob->x = (double *)cs_dl_malloc (mn, sizeof (double)) ;
+    Prob->resid = (double *)cs_dl_malloc (mn, sizeof (double)) ;
+    return ((!Prob->b || !Prob->x || !Prob->resid) ? free_problem (Prob) : Prob) ;
+}
+
+/* free a problem */
+problem *free_problem (problem *Prob)
+{
+    if (!Prob) return (NULL) ;
+    cs_dl_spfree (Prob->A) ;
+    if (Prob->sym) cs_dl_spfree (Prob->C) ;
+    cs_dl_free (Prob->b) ;
+    cs_dl_free (Prob->x) ;
+    cs_dl_free (Prob->resid) ;
+    return (problem *)(cs_dl_free (Prob)) ;
+}
+
+/* solve a linear system using Cholesky, LU, and QR, with various orderings */
+UF_long demo2 (problem *Prob)
+{
+    cs_dl *A, *C ;
+    double *b, *x, *resid,  t, tol ;
+    UF_long k, m, n, ok, order, nb, ns, *r, *s, *rr, sprank ;
+    cs_dld *D ;
+    if (!Prob) return (0) ;
+    A = Prob->A ; C = Prob->C ; b = Prob->b ; x = Prob->x ; resid = Prob->resid;
+    m = A->m ; n = A->n ;
+    tol = Prob->sym ? 0.001 : 1 ;		/* partial pivoting tolerance */
+    D = cs_dl_dmperm (C, 1) ;			/* randomized dmperm analysis */
+    if (!D) return (0) ;
+    nb = D->nb ; r = D->r ; s = D->s ; rr = D->rr ;
+    sprank = rr [3] ;
+    for (ns = 0, k = 0 ; k < nb ; k++)
+    {
+	ns += ((r [k+1] == r [k]+1) && (s [k+1] == s [k]+1)) ;
+    }
+    printf ("blocks: %ld singletons: %ld structural rank: %ld\n", nb, ns, sprank) ;
+    cs_dl_dfree (D) ;
+    for (order = 0 ; order <= 3 ; order += 3)	/* natural and amd(A'*A) */
+    {
+	if (!order && m > 1000) continue ;
+	printf ("QR   ") ;
+	print_order (order) ;
+	rhs (x, b, m) ;				/* compute right-hand side */
+	t = tic () ;
+	ok = cs_dl_qrsol (order, C, x) ;		/* min norm(Ax-b) with QR */
+	printf ("time: %8.2f ", toc (t)) ;
+	print_resid (ok, C, x, b, resid) ;	/* print residual */
+    }
+    if (m != n || sprank < n) return (1) ;	/* return if rect. or singular*/
+    for (order = 0 ; order <= 3 ; order++)	/* try all orderings */
+    {
+	if (!order && m > 1000) continue ;
+	printf ("LU   ") ;
+	print_order (order) ;
+	rhs (x, b, m) ;				/* compute right-hand side */
+	t = tic () ;
+	ok = cs_dl_lusol (order, C, x, tol) ;	/* solve Ax=b with LU */
+	printf ("time: %8.2f ", toc (t)) ;
+	print_resid (ok, C, x, b, resid) ;	/* print residual */
+    }
+    if (!Prob->sym) return (1) ;
+    for (order = 0 ; order <= 1 ; order++)	/* natural and amd(A+A') */
+    {
+	if (!order && m > 1000) continue ;
+	printf ("Chol ") ;
+	print_order (order) ;
+	rhs (x, b, m) ;				/* compute right-hand side */
+	t = tic () ;
+	ok = cs_dl_cholsol (order, C, x) ;		/* solve Ax=b with Cholesky */
+	printf ("time: %8.2f ", toc (t)) ;
+	print_resid (ok, C, x, b, resid) ;	/* print residual */
+    }
+    return (1) ;
+} 
+
+/* free workspace for demo3 */
+static UF_long done3 (UF_long ok, cs_dls *S, cs_dln *N, double *y, cs_dl *W, cs_dl *E, UF_long *p)
+{
+    cs_dl_sfree (S) ;
+    cs_dl_nfree (N) ;
+    cs_dl_free (y) ;
+    cs_dl_spfree (W) ;
+    cs_dl_spfree (E) ;
+    cs_dl_free (p) ;
+    return (ok) ;
+}
+
+/* Cholesky update/downdate */
+UF_long demo3 (problem *Prob)
+{
+    cs_dl *A, *C, *W = NULL, *WW, *WT, *E = NULL, *W2 ;
+    UF_long n, k, *Li, *Lp, *Wi, *Wp, p1, p2, *p = NULL, ok ;
+    double *b, *x, *resid, *y = NULL, *Lx, *Wx, s,  t, t1 ;
+    cs_dls *S = NULL ;
+    cs_dln *N = NULL ;
+    if (!Prob || !Prob->sym || Prob->A->n == 0) return (0) ;
+    A = Prob->A ; C = Prob->C ; b = Prob->b ; x = Prob->x ; resid = Prob->resid;
+    n = A->n ;
+    if (!Prob->sym || n == 0) return (1) ;
+    rhs (x, b, n) ;				/* compute right-hand side */
+    printf ("\nchol then update/downdate ") ;
+    print_order (1) ;
+    y = (double *)cs_dl_malloc (n, sizeof (double)) ;
+    t = tic () ;
+    S = cs_dl_schol (1, C) ;			/* symbolic Chol, amd(A+A') */
+    printf ("\nsymbolic chol time %8.2f\n", toc (t)) ;
+    t = tic () ;
+    N = cs_dl_chol (C, S) ;			/* numeric Cholesky */
+    printf ("numeric  chol time %8.2f\n", toc (t)) ;
+    if (!S || !N || !y) return (done3 (0, S, N, y, W, E, p)) ;
+    t = tic () ;
+    cs_dl_ipvec (S->pinv, b, y, n) ;		/* y = P*b */
+    cs_dl_lsolve (N->L, y) ;			/* y = L\y */
+    cs_dl_ltsolve (N->L, y) ;			/* y = L'\y */
+    cs_dl_pvec (S->pinv, y, x, n) ;		/* x = P'*y */
+    printf ("solve    chol time %8.2f\n", toc (t)) ;
+    printf ("original: ") ;
+    print_resid (1, C, x, b, resid) ;		/* print residual */
+    k = n/2 ;					/* construct W  */
+    W = cs_dl_spalloc (n, 1, n, 1, 0) ;
+    if (!W) return (done3 (0, S, N, y, W, E, p)) ;
+    Lp = N->L->p ; Li = N->L->i ; Lx = N->L->x ;
+    Wp = W->p ; Wi = W->i ; Wx = W->x ;
+    Wp [0] = 0 ;
+    p1 = Lp [k] ;
+    Wp [1] = Lp [k+1] - p1 ;
+    s = Lx [p1] ;
+    srand (1) ;
+    for ( ; p1 < Lp [k+1] ; p1++)
+    {
+	p2 = p1 - Lp [k] ;
+	Wi [p2] = Li [p1] ;
+	Wx [p2] = s * rand () / ((double) RAND_MAX) ;
+    }
+    t = tic () ;
+    ok = cs_dl_updown (N->L, +1, W, S->parent) ;	/* update: L*L'+W*W' */
+    t1 = toc (t) ;
+    printf ("update:   time: %8.2f\n", t1) ;
+    if (!ok) return (done3 (0, S, N, y, W, E, p)) ;
+    t = tic () ;
+    cs_dl_ipvec (S->pinv, b, y, n) ;		/* y = P*b */
+    cs_dl_lsolve (N->L, y) ;			/* y = L\y */
+    cs_dl_ltsolve (N->L, y) ;			/* y = L'\y */
+    cs_dl_pvec (S->pinv, y, x, n) ;		/* x = P'*y */
+    t = toc (t) ;
+    p = cs_dl_pinv (S->pinv, n) ;
+    W2 = cs_dl_permute (W, p, NULL, 1) ;		/* E = C + (P'W)*(P'W)' */
+    WT = cs_dl_transpose (W2,1) ;
+    WW = cs_dl_multiply (W2, WT) ;
+    cs_dl_spfree (WT) ;
+    cs_dl_spfree (W2) ;
+    E = cs_dl_add (C, WW, 1, 1) ;
+    cs_dl_spfree (WW) ;
+    if (!E || !p) return (done3 (0, S, N, y, W, E, p)) ;
+    printf ("update:   time: %8.2f (incl solve) ", t1+t) ;
+    print_resid (1, E, x, b, resid) ;		/* print residual */
+    cs_dl_nfree (N) ;				/* clear N */
+    t = tic () ;
+    N = cs_dl_chol (E, S) ;			/* numeric Cholesky */
+    if (!N) return (done3 (0, S, N, y, W, E, p)) ;
+    cs_dl_ipvec (S->pinv, b, y, n) ;		/* y = P*b */
+    cs_dl_lsolve (N->L, y) ;			/* y = L\y */
+    cs_dl_ltsolve (N->L, y) ;			/* y = L'\y */
+    cs_dl_pvec (S->pinv, y, x, n) ;		/* x = P'*y */
+    t = toc (t) ;
+    printf ("rechol:   time: %8.2f (incl solve) ", t) ;
+    print_resid (1, E, x, b, resid) ;		/* print residual */
+    t = tic () ;
+    ok = cs_dl_updown (N->L, -1, W, S->parent) ;	/* downdate: L*L'-W*W' */
+    t1 = toc (t) ;
+    if (!ok) return (done3 (0, S, N, y, W, E, p)) ;
+    printf ("downdate: time: %8.2f\n", t1) ;
+    t = tic () ;
+    cs_dl_ipvec (S->pinv, b, y, n) ;		/* y = P*b */
+    cs_dl_lsolve (N->L, y) ;			/* y = L\y */
+    cs_dl_ltsolve (N->L, y) ;			/* y = L'\y */
+    cs_dl_pvec (S->pinv, y, x, n) ;		/* x = P'*y */
+    t = toc (t) ;
+    printf ("downdate: time: %8.2f (incl solve) ", t1+t) ;
+    print_resid (1, C, x, b, resid) ;		/* print residual */
+    return (done3 (1, S, N, y, W, E, p)) ;
+} 
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_dl_demo.h SuiteSparse/CXSparse-C++/Demo/cs_dl_demo.h
--- original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_dl_demo.h	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Demo/cs_dl_demo.h	2006-08-25 08:04:44.000000000 +0200
@@ -0,0 +1,15 @@
+#include "cs.h"
+typedef struct problem_struct
+{
+    cs_dl *A ;
+    cs_dl *C ;
+    UF_long sym ;
+    double *x ;
+    double *b ;
+    double *resid ;
+} problem ;
+
+problem *get_problem (FILE *f, double tol) ;
+UF_long demo2 (problem *Prob) ;
+UF_long demo3 (problem *Prob) ;
+problem *free_problem (problem *Prob) ;
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_dl_demo1.cpp SuiteSparse/CXSparse-C++/Demo/cs_dl_demo1.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_dl_demo1.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Demo/cs_dl_demo1.cpp	2006-08-25 08:04:44.000000000 +0200
@@ -0,0 +1,27 @@
+#include "cs.h"
+int main (void)
+{
+    cs_dl *T, *A, *Eye, *AT, *C, *D ;
+    UF_long i, m ;
+    T = cs_dl_load (stdin) ;		/* load triplet matrix T from stdin */
+    printf ("T:\n") ; cs_dl_print (T, 0) ;	/* print T */
+    A = cs_dl_compress (T) ;		/* A = compressed-column form of T */
+    printf ("A:\n") ; cs_dl_print (A, 0) ;	/* print A */
+    cs_dl_spfree (T) ;			/* clear T */
+    AT = cs_dl_transpose (A, 1) ;		/* AT = A' */
+    printf ("AT:\n") ; cs_dl_print (AT, 0) ; /* print AT */
+    m = A ? A->m : 0 ;			/* m = # of rows of A */
+    T = cs_dl_spalloc (m, m, m, 1, 1) ;	/* create triplet identity matrix */
+    for (i = 0 ; i < m ; i++) cs_dl_entry (T, i, i, 1) ;
+    Eye = cs_dl_compress (T) ;		/* Eye = speye (m) */
+    cs_dl_spfree (T) ;
+    C = cs_dl_multiply (A, AT) ;		/* C = A*A' */
+    D = cs_dl_add (C, Eye, 1, cs_dl_norm (C)) ;   /* D = C + Eye*norm (C,1) */
+    printf ("D:\n") ; cs_dl_print (D, 0) ;	/* print D */
+    cs_dl_spfree (A) ;			/* clear A AT C D Eye */
+    cs_dl_spfree (AT) ;
+    cs_dl_spfree (C) ;
+    cs_dl_spfree (D) ;
+    cs_dl_spfree (Eye) ;
+    return (0) ;
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_dl_demo2.cpp SuiteSparse/CXSparse-C++/Demo/cs_dl_demo2.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_dl_demo2.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Demo/cs_dl_demo2.cpp	2006-08-25 08:04:44.000000000 +0200
@@ -0,0 +1,9 @@
+#include "cs_dl_demo.h"
+/* cs_dl_demo2: read a matrix and solve a linear system */
+int main (void)
+{
+    problem *Prob = get_problem (stdin, 1e-14) ;
+    demo2 (Prob) ;
+    free_problem (Prob) ;
+    return (0) ;
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_dl_demo3.cpp SuiteSparse/CXSparse-C++/Demo/cs_dl_demo3.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_dl_demo3.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Demo/cs_dl_demo3.cpp	2006-08-25 08:04:44.000000000 +0200
@@ -0,0 +1,9 @@
+#include "cs_dl_demo.h"
+/* cs_dl_demo3: read a matrix and test Cholesky update/downdate */
+int main (void)
+{
+    problem *Prob = get_problem (stdin, 0) ;
+    demo3 (Prob) ;
+    free_problem (Prob) ;
+    return (0) ;
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_idemo.cpp SuiteSparse/CXSparse-C++/Demo/cs_idemo.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_idemo.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Demo/cs_idemo.cpp	2006-04-07 18:23:04.000000000 +0200
@@ -0,0 +1,57 @@
+#include "cs.h"
+/* test real/complex conversion routines (int version) */
+int main (void)
+{
+    cs_ci *T, *A, *A1, *A2, *B ;
+    cs_di *C1, *C2, *Treal, *Timag ;
+
+    printf ("\n--- cs_idemo\n") ;
+
+    T = cs_ci_load (stdin) ;		/* load a complex triplet matrix, T */
+    printf ("\nT:\n") ;
+    cs_ci_print (T, 0) ;
+
+    Treal = cs_i_real (T, 1) ;		/* Treal = real part of T */
+    printf ("\nTreal:\n") ;
+    cs_di_print (Treal, 0) ;
+
+    Timag = cs_i_real (T, 0) ;		/* Treal = imaginary part of T */
+    printf ("\nTimag:\n") ;
+    cs_di_print (Timag, 0) ;
+
+    A = cs_ci_compress (T) ;		/* A = compressed-column form of T */
+    printf ("\nA:\n") ;
+    cs_ci_print (A, 0) ;
+
+    C1 = cs_i_real (A, 1) ;		/* C1 = real (A) */
+    printf ("\nC1 = real(A):\n") ;
+    cs_di_print (C1, 0) ;
+
+    C2 = cs_i_real (A, 0) ;		/* C2 = imag (A) */
+    printf ("\nC2 = imag(A):\n") ;
+    cs_di_print (C2, 0) ;
+
+    A1 = cs_i_complex (C1, 1) ;		/* A1 = complex version of C1 */
+    printf ("\nA1:\n") ;
+    cs_ci_print (A1, 0) ;
+
+    A2 = cs_i_complex (C2, 0) ;		/* A2 = complex version of C2 (imag.) */
+    printf ("\nA2:\n") ;
+    cs_ci_print (A2, 0) ;
+
+    B = cs_ci_add (A1, A2, 1., -1.) ;	/* B = A1 - A2 */
+    printf ("\nB = conj(A):\n") ;
+    cs_ci_print (B, 0) ;
+
+    cs_ci_spfree (T) ;
+    cs_ci_spfree (A) ;
+    cs_ci_spfree (A1) ;
+    cs_ci_spfree (A2) ;
+    cs_ci_spfree (B) ;
+    cs_di_spfree (C1) ;
+    cs_di_spfree (C2) ;
+    cs_di_spfree (Treal) ;
+    cs_di_spfree (Timag) ;
+
+    return (0) ;
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_ldemo.cpp SuiteSparse/CXSparse-C++/Demo/cs_ldemo.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Demo/cs_ldemo.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Demo/cs_ldemo.cpp	2006-04-07 18:23:04.000000000 +0200
@@ -0,0 +1,57 @@
+#include "cs.h"
+/* test real/complex conversion routines (int version) */
+int main (void)
+{
+    cs_cl *T, *A, *A1, *A2, *B ;
+    cs_dl *C1, *C2, *Treal, *Timag ;
+
+    printf ("\n--- cs_ldemo\n") ;
+
+    T = cs_cl_load (stdin) ;		/* load a complex triplet matrix, T */
+    printf ("\nT:\n") ;
+    cs_cl_print (T, 0) ;
+
+    Treal = cs_l_real (T, 1) ;		/* Treal = real part of T */
+    printf ("\nTreal:\n") ;
+    cs_dl_print (Treal, 0) ;
+
+    Timag = cs_l_real (T, 0) ;		/* Treal = imaginary part of T */
+    printf ("\nTimag:\n") ;
+    cs_dl_print (Timag, 0) ;
+
+    A = cs_cl_compress (T) ;		/* A = compressed-column form of T */
+    printf ("\nA:\n") ;
+    cs_cl_print (A, 0) ;
+
+    C1 = cs_l_real (A, 1) ;		/* C1 = real (A) */
+    printf ("\nC1 = real(A):\n") ;
+    cs_dl_print (C1, 0) ;
+
+    C2 = cs_l_real (A, 0) ;		/* C2 = imag (A) */
+    printf ("\nC2 = imag(A):\n") ;
+    cs_dl_print (C2, 0) ;
+
+    A1 = cs_l_complex (C1, 1) ;		/* A1 = complex version of C1 */
+    printf ("\nA1:\n") ;
+    cs_cl_print (A1, 0) ;
+
+    A2 = cs_l_complex (C2, 0) ;		/* A2 = complex version of C2 (imag.) */
+    printf ("\nA2:\n") ;
+    cs_cl_print (A2, 0) ;
+
+    B = cs_cl_add (A1, A2, 1., -1.) ;	/* B = A1 - A2 */
+    printf ("\nB = conj(A):\n") ;
+    cs_cl_print (B, 0) ;
+
+    cs_cl_spfree (T) ;
+    cs_cl_spfree (A) ;
+    cs_cl_spfree (A1) ;
+    cs_cl_spfree (A2) ;
+    cs_cl_spfree (B) ;
+    cs_dl_spfree (C1) ;
+    cs_dl_spfree (C2) ;
+    cs_dl_spfree (Treal) ;
+    cs_dl_spfree (Timag) ;
+
+    return (0) ;
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Demo/readhb.f SuiteSparse/CXSparse-C++/Demo/readhb.f
--- original-libraries/SuiteSparse/CXSparse-C++/Demo/readhb.f	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Demo/readhb.f	2006-02-22 12:47:58.000000000 +0100
@@ -0,0 +1,98 @@
+c-----------------------------------------------------------------------
+c Read a sparse matrix in the Harwell/Boeing format and output a matrix
+c in zero-based triplet format.  Only the lower triangular part of a
+c symmetric matrix is provided.  Does not handle skew-symmetric
+c matrices.
+c-----------------------------------------------------------------------
+
+        integer nzmax, nmax
+        parameter (nzmax = 100000000, nmax = 1000000)
+        integer Ptr (nmax), Index (nzmax), n, nz, totcrd, ptrcrd,
+     $		indcrd, valcrd, rhscrd, ncol, nrow, nrhs, row, col, p
+        character title*72, key*30, type*3, ptrfmt*16,
+     $          indfmt*16, valfmt*20, rhsfmt*20
+        logical sym
+        double precision Value (nzmax), skew
+        character rhstyp*3
+        integer nzrhs, nel, stype
+
+c-----------------------------------------------------------------------
+
+c       read header information from Harwell/Boeing matrix
+
+        read (5, 10, err = 998)
+     $          title, key,
+     $          totcrd, ptrcrd, indcrd, valcrd, rhscrd,
+     $          type, nrow, ncol, nz, nel,
+     $          ptrfmt, indfmt, valfmt, rhsfmt
+        if (rhscrd .gt. 0) then
+c          new Harwell/Boeing format:
+           read (5, 20, err = 998) rhstyp,nrhs,nzrhs
+        endif
+10      format (a72, a8 / 5i14 / a3, 11x, 4i14 / 2a16, 2a20)
+20      format (a3, 11x, 2i14)
+
+        skew = 0.0
+        if (type (2:2) .eq. 'Z' .or. type (2:2) .eq. 'z') skew = -1.0
+        if (type (2:2) .eq. 'S' .or. type (2:2) .eq. 's') skew =  1.0
+        sym = skew .ne. 0.0
+
+        write (0, 30) title, key, type, nrow, ncol, nz
+        if (rhscrd .gt. 0) then
+c          new Harwell/Boeing format:
+c          write (0, 40) rhstyp,nrhs,nzrhs
+        endif
+30      format ( /
+     $          ' title: ', a72 /
+     $          ' key: ', a8 /
+     $          ' type: ', a3, ' nrow: ', i14, ' ncol: ', i14 /
+     $          ' nz: ', i14)
+40      format (' rhstyp: ', a3, ' nrhs: ', i14, ' nzrhs: ', i14)
+*       write (0, *) ' sym: ', sym, ' skew: ', skew
+
+	if (skew .eq. -1) then
+	   write (0, *) 'Cannot handle skew-symmetric matrices'
+	   stop
+	endif
+
+        n = max (nrow, ncol)
+
+        if (ncol .ge. nmax .or. nz .gt. nzmax) then
+           write (0, *) ' Matrix too big!'
+           stop
+        endif
+
+        read (5, ptrfmt, err = 998) (Ptr (p), p = 1, ncol+1)
+        read (5, indfmt, err = 998) (Index (p), p = 1, nz)
+
+c       read the values
+        if (valcrd .gt. 0) then
+           read (5, valfmt, err = 998) (Value (p), p = 1, nz)
+        endif
+
+c  create the triplet form of the input matrix
+c  stype = 0: unsymmetric
+c  stype = -1: symmetric, lower triangular part present
+
+	stype = -skew
+
+        do 100 col = 1, ncol
+           do 90 p = Ptr (col), Ptr (col+1) - 1
+              row = Index (p)
+	      if (valcrd .gt. 0) then
+                 write (6, 200) row-1, col-1, Value (p)
+c                if (sym .and. row .ne. col) then
+c		    write (6, 200) col-1, row-1, skew * Value (p)
+c		 endif
+	      else
+                 write (6, 201) row-1, col-1
+	      endif
+90         continue
+100     continue
+200	format (2i8, e30.18e3)
+201	format (2i8, ' 1')
+        stop
+
+998     write (0,*) 'Read error: Harwell/Boeing matrix'
+        stop
+        end
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/License.txt SuiteSparse/CXSparse-C++/License.txt
--- original-libraries/SuiteSparse/CXSparse-C++/License.txt	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/License.txt	2006-02-18 06:18:34.000000000 +0100
@@ -0,0 +1,19 @@
+CXSparse: a Concise Sparse matrix package - Extended.
+Copyright (c) 2006, Timothy A. Davis.
+http://www.cise.ufl.edu/research/sparse/CSparse
+
+--------------------------------------------------------------------------------
+
+CXSparse is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version.
+
+CXSparse is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with this Module; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Makefile SuiteSparse/CXSparse-C++/Makefile
--- original-libraries/SuiteSparse/CXSparse-C++/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Makefile	2006-03-03 08:35:34.000000000 +0100
@@ -0,0 +1,25 @@
+# CXSparse Makefile
+
+C:
+	( cd Source ; $(MAKE) )
+	( cd Demo ; $(MAKE) )
+
+all: C tcov
+
+library:
+	( cd Source ; $(MAKE) )
+
+tcov:
+	( cd Tcov ; $(MAKE) )
+
+clean:
+	( cd Source ; $(MAKE) clean )
+	( cd Demo ; $(MAKE) clean )
+	( cd Tcov ; $(MAKE) clean )
+
+purge:
+	( cd Source ; $(MAKE) purge )
+	( cd Demo ; $(MAKE) purge )
+	( cd Tcov ; $(MAKE) purge )
+
+distclean: purge
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/README.txt SuiteSparse/CXSparse-C++/README.txt
--- original-libraries/SuiteSparse/CXSparse-C++/README.txt	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/README.txt	2006-08-24 21:49:50.000000000 +0200
@@ -0,0 +1,264 @@
+CXSparse: a Concise Sparse Matrix package - Extended.
+Version 2.0.2, Copyright (c) 2006, Timothy A. Davis, Aug 23, 2006.
+Derived from CSparse.  Conversion originally by David Bateman, Motorola,
+and then modified by Tim Davis.  ANSI C99 is required, with support for
+the _Complex data type.
+
+CXSparse is a version of CSparse that operates on both real and complex
+matrices, using either int or UF_long integers.  A UF_long is normally
+just a long on most platforms, but becomes __int64 on WIN64.
+
+Refer to "Direct Methods for Sparse Linear Systems," Timothy A. Davis,
+SIAM, Philaelphia, 2006.  No detailed user guide is included in this
+package; the user guide is the book itself.
+
+To compile the C-library (./Source), C demo programs (./Demo) just type "make"
+in this directory.  To run the exhaustive statement coverage tests, type
+"make" in the Tcov directory; the Tcov tests assume you are using Linux.  To
+remove all files not in the original distribution, type "make distclean".  No
+MATLAB interface is provided.  I recommend that you use a different level of
+optimization than "cc -O", which was chosen so that the Makefile is portable.
+See Source/Makefile.
+
+This package is backward compatible with CSparse.  That is, user code that
+uses CSparse may switch to using CXSparse without any changes to the user code.
+Each CXSparse function has a generic version with the same name as the CSparse
+function, and four type-specific versions.  For example:
+
+    cs_add	same as cs_add_di by default, but can be changed to use UF_long
+		integers if user code is compiled with -DCS_LONG, and/or can
+		be changed to operate on complex matrices with -DCS_COMPLEX.
+
+    cs_di_add	double/int version of cs_add
+    cs_dl_add	double/UF_long version of cs_add
+    cs_ci_add	complex/int version of cs_add
+    cs_cl_add	complex/UF_long version of cs_add
+
+The sparse matrix data structures are treated in the same way:  cs, css,
+csn, and csd become cs_di, cs_dis, cs_din, and cs_did for the double/int case,
+cs_cl, cs_cls, cs_cln, and cs_cld for the complex/UF_long case, and so on.
+
+See cs_demo.c for a type-generic user program, and cs_cl_demo.c for a
+type-specific version of the same program (complex/UF_long).
+
+Several macros are available in CXSparse (but not in CSparse) to allow user
+code to be written in a type-generic manner:
+
+    CS_INT	int by default, UF_long if -DCS_LONG compiler flag is used
+    CS_ENTRY	double by default, double complex if -DCS_COMPLEX flag is used.
+    CS_ID	"%d" or "%ld", for printf and scanf of the CS_INT type.
+    CS_INT_MAX	INT_MAX or LONG_MAX, the largest possible value of CS_INT.
+    CS_REAL(x)	x or creal(x)
+    CS_IMAG(x)	0 or cimag(x)
+    CS_CONJ(x)	x or conj(x)
+    CS_ABS(x)	fabs(x) or cabs(x)
+
+Even the name of the include file (cs.h) is the same.  To use CXSparse instead
+of CSparse, simply compile with -ICXSparse/Source instead of -ICSparse/Source,
+and link against libcxsparse.a instead of the CSparse libcsparse.a library.
+
+To determine at compile time if CXSparse or CSparse is being used:
+
+    #ifdef CXSPARSE
+	CXSparse is in use.  The generic functions equivalent to CSparse may
+	be used (cs_add, etc).  These generic functions can use different
+	types, depending on the -DCS_LONG and -DCS_COMPLEX compile flags, with
+	the default being double/int.  The type-specific functions and data
+	types (cs_di_add, cs_di, CS_INT, etc.) can be used.
+    #else
+	CSparse is in use.  Only the generic functions "cs_add", etc., are
+	available, and they are of type double/int.
+    #endif
+
+See cs.h for the prototypes of each function, and the book "Direct Methods
+for Sparse Linear Systems" for full documentation of CSparse and CXSparse.
+
+Other changes from CSparse:  cs_transpose performs the complex conjugate
+transpose if values>0 (C=A'), the pattern-only transpose if values=0
+(C=spones(A') in MATLAB), and the array transpose if values<0 (C=A.' in
+MATLAB notation).  A set of four conversion routines are included in CXSparse,
+to convert real matrices to/from complex matrices.
+
+CXSparse is generated automatically from CSparse.  Refer to
+http://www.cise.ufl.edu/research/sparse/CSparse for details.
+
+--------------------------------------------------------------------------------
+Contents:
+--------------------------------------------------------------------------------
+
+ChangeLog	Change Log for CSparse (most but not all apply to CXSparse)
+Demo/		demo C programs that use CXSparse
+lesser.txt	the GNU LGPL
+License.txt	license (GNU LGPL)
+Makefile	Makefile for the whole package
+Matrix/		sample matrices (with extra complex matrices CXSparse)
+README.txt	this file
+Source/		primary CXSparse source files
+Tcov/		CXSparse tests
+
+
+--------------------------------------------------------------------------------
+./Source:	Primary source code for CXSparse
+--------------------------------------------------------------------------------
+
+cs_add.c	add sparse matrices
+cs_amd.c	approximate minimum degree
+cs_chol.c	sparse Cholesky
+cs_cholsol.c	x=A\b using sparse Cholesky
+cs_compress.c	convert a compress form to compressed-column form
+cs_counts.c	column counts for Cholesky and QR
+cs_convert.c	convert real to complex and complex to real (not in CSparse)
+cs_cumsum.c	cumulative sum
+cs_dfs.c	depth-first-search
+cs_dmperm.c	Dulmage-Mendelsohn permutation
+cs_droptol.c	drop small entries from a sparse matrix
+cs_dropzeros.c	drop zeros from a sparse matrix
+cs_dupl.c	remove (and sum) duplicates
+cs_entry.c	add an entry to a triplet matrix
+cs_ereach.c	nonzero pattern of Cholesky L(k,:) from etree and triu(A(:,k))
+cs_etree.c	find elimination tree
+cs_fkeep.c	drop entries from a sparse matrix
+cs_gaxpy.c	sparse matrix times dense matrix
+cs.h		include file for CXSparse
+cs_happly.c	apply Householder reflection
+cs_house.c	Householder reflection (*** NOTE: different algo. from CSparse)
+cs_ipvec.c	x(p)=b
+cs_leaf.c	determine if j is a leaf of the skeleton matrix and find lca
+cs_load.c	load a sparse matrix from a file
+cs_lsolve.c	x=L\b
+cs_ltsolve.c	x=L'\b
+cs_lu.c		sparse LU factorization
+cs_lusol.c	x=A\b using sparse LU factorization
+cs_malloc.c	memory manager
+cs_maxtrans.c	maximum transveral (permutation for zero-free diagonal)
+cs_multiply.c	sparse matrix multiply
+cs_norm.c	sparse matrix norm
+cs_permute.c	permute a sparse matrix
+cs_pinv.c	invert a permutation vector
+cs_post.c	postorder an elimination tree
+cs_print.c	print a sparse matrix
+cs_pvec.c	x=b(p)
+cs_qr.c		sparse QR
+cs_qrsol.c	solve a least-squares problem
+cs_randperm.c	random permutation
+cs_reach.c	find nonzero pattern of x=L\b for sparse L and b
+cs_scatter.c	scatter a sparse vector
+cs_scc.c	strongly-connected components
+cs_schol.c	symbolic Cholesky
+cs_spsolve.c	x=Z\b where Z, x, and b are sparse, and Z upper/lower triangular
+cs_sqr.c	symbolic QR (also can be used for LU)
+cs_symperm.c	symmetric permutation of a sparse matrix
+cs_tdfs.c	depth-first-search of a tree
+cs_transpose.c	transpose a sparse matrix
+cs_updown.c	sparse rank-1 Cholesky update/downate
+cs_usolve.c	x=U\b
+cs_util.c	various utilities (allocate/free matrices, workspace, etc)
+cs_utsolve.c	x=U'\b
+Makefile	Makefile for CXSparse
+README.txt	README file for CXSparse
+
+--------------------------------------------------------------------------------
+./Demo:		C program demos
+--------------------------------------------------------------------------------
+
+cs_ci_demo1.c	complex/int version of cs_demo1.c
+cs_ci_demo2.c	complex/int version of cs_demo2.c
+cs_ci_demo3.c	complex/int version of cs_demo3.c
+cs_ci_demo.c	complex/int version of cs_demo.c
+cs_ci_demo.h	complex/int version of cs_demo.h
+
+cs_cl_demo1.c	complex/UF_long version of cs_demo1.c
+cs_cl_demo2.c	complex/UF_long version of cs_demo2.c
+cs_cl_demo3.c	complex/UF_long version of cs_demo3.c
+cs_cl_demo.c	complex/UF_long version of cs_demo.c
+cs_cl_demo.h	complex/UF_long version of cs_demo.h
+
+cs_demo1.c	read a matrix from a file and perform basic matrix operations
+cs_demo2.c	read a matrix from a file and solve a linear system
+cs_demo3.c	read a matrix, solve a linear system, update/downdate
+cs_demo.c	support routines for cs_demo*.c
+cs_demo.h	include file for demo programs
+
+cs_demo.out	output of "make", which runs the demos on some matrices
+
+cs_di_demo1.c	double/int version of cs_demo1.c
+cs_di_demo2.c	double/int version of cs_demo2.c
+cs_di_demo3.c	double/int version of cs_demo3.c
+cs_di_demo.c	double/int version of cs_demo.c
+cs_di_demo.h	double/int version of cs_demo.h
+
+cs_dl_demo1.c	double/UF_long version of cs_demo1.c
+cs_dl_demo2.c	double/UF_long version of cs_demo2.c
+cs_dl_demo3.c	double/UF_long version of cs_demo3.c
+cs_dl_demo.c	double/UF_long version of cs_demo.c
+cs_dl_demo.h	double/UF_long version of cs_demo.h
+
+cs_idemo.c	convert real matrices to/from complex (int version)
+cs_ldemo.c	convert real matrices to/from complex (UF_long version)
+
+Makefile	Makefile for Demo programs
+readhb.f	read a Rutherford-Boeing matrix (real matrices only)
+README.txt	Demo README file
+
+--------------------------------------------------------------------------------
+./Matrix:	    Sample matrices, most from Rutherford/Boeing collection
+--------------------------------------------------------------------------------
+
+ash219		    overdetermined pattern of Holland survey.  Ashkenazi, 1974.
+bcsstk01	    stiffness matrix for small generalized eigenvalue problem
+bcsstk16	    stiffness matrix, Corp of Engineers dam
+fs_183_1	    unsymmetric facsimile convergence matrix
+lp_afiro	    NETLIB afiro linear programming problem
+mbeacxc		    US economy, 1972.  Dan Szyld, while at NYU
+t1		    small example used in Chapter 2
+west0067	    Cavett problem with 5 components (chemical eng., Westerberg)
+
+c_mbeacxc	    complex version of mbeacxc
+c_west0067	    complex version of west0067
+mhd1280b	    Alfven spectra in magnetohydrodynamics (complex)
+neumann		    complex matrix
+qc324		    model of H+ in an electromagnetic field (complex)
+t2		    small complex matrix
+t3		    small complex matrix
+t4		    small complex matrix
+young1c		    aeronautical problem (complex matrix)
+
+--------------------------------------------------------------------------------
+./Tcov:		    Exhaustive test coverage of CXSparse
+--------------------------------------------------------------------------------
+
+covall		    same as covall.linux
+covall.linux	    find coverage (Linux)
+covall.sol	    find coverage (Solaris)
+cov.awk		    coverage summary
+cover		    print uncovered lines
+covs		    print uncovered lines
+cstcov_malloc_test.c    malloc test
+cstcov_malloc_test.h
+cstcov_test.c	    main program for Tcov tests
+gcovs		    run gcov (Linux)
+Makefile	    Makefile for Tcov tests
+nil		    an empty matrix
+zero		    a 1-by-1 zero matrix
+czero		    a 1-by-1 complex zero matrix
+README.txt	    README file for Tcov directory
+
+--------------------------------------------------------------------------------
+Change Log:
+--------------------------------------------------------------------------------
+
+May 5, 2006.  Version 2.0.1 released.
+
+    * long changed to UF_long, dependency in ../UFconfig/UFconfig.h added.
+	"UF_long" is a #define'd term in UFconfig.h.  It is normally defined
+	as "long", but can be redefined as something else if desired.
+	On Windows-64, it becomes __int64.
+
+Mar 6, 2006
+
+    "double complex" changed to "double _Complex", to avoid conflicts when
+    CXSparse is compiled with a C++ compiler.  Other minor changes to cs.h.
+
+Refer to CSparse for changes in CSparse, which are immediately propagated
+into CXSparse (those Change Log entries are not repeated here).
+
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Source/Makefile SuiteSparse/CXSparse-C++/Source/Makefile
--- original-libraries/SuiteSparse/CXSparse-C++/Source/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Source/Makefile	2006-12-17 14:29:06.000000000 +0100
@@ -0,0 +1,102 @@
+# Modify the "-O" optimization option for best performance (-O3 on Linux):
+# CC = cc-msvc
+# CFLAGS = -EHs -O2 -MD -TP
+
+include ../../UFconfig/UFconfig.mk
+
+I = -I../../UFconfig
+CXXFLAGS = $(CFLAGS) -EHs
+
+# AR = ar-msvc cr
+# RANLIB = ranlib-msvc
+
+all: $(LIBPRE)cxsparse.$(LIBEXT)
+
+CS_SOURCE = cs_add.cpp cs_amd.cpp cs_chol.cpp cs_cholsol.cpp cs_counts.cpp cs_cumsum.cpp \
+	cs_droptol.cpp cs_dropzeros.cpp cs_dupl.cpp cs_entry.cpp \
+	cs_etree.cpp cs_fkeep.cpp cs_gaxpy.cpp cs_happly.cpp cs_house.cpp cs_ipvec.cpp \
+	cs_lsolve.cpp cs_ltsolve.cpp cs_lu.cpp cs_lusol.cpp cs_util.cpp cs_multiply.cpp \
+	cs_permute.cpp cs_pinv.cpp cs_post.cpp cs_pvec.cpp cs_qr.cpp cs_qrsol.cpp \
+	cs_scatter.cpp cs_schol.cpp cs_sqr.cpp cs_symperm.cpp cs_tdfs.cpp cs_malloc.cpp \
+	cs_transpose.cpp cs_compress.cpp cs_usolve.cpp cs_utsolve.cpp cs_scc.cpp \
+	cs_maxtrans.cpp cs_dmperm.cpp cs_updown.cpp cs_print.cpp cs_norm.cpp cs_load.cpp \
+	cs_dfs.cpp cs_reach.cpp cs_spsolve.cpp cs_leaf.cpp cs_ereach.cpp cs_randperm.cpp
+
+CS_DI_OBJ =  cs_add_di.o cs_amd_di.o cs_chol_di.o cs_cholsol_di.o cs_counts_di.o \
+	cs_cumsum_di.o cs_droptol_di.o cs_dropzeros_di.o cs_dupl_di.o \
+	cs_entry_di.o cs_etree_di.o cs_fkeep_di.o cs_gaxpy_di.o cs_happly_di.o \
+	cs_house_di.o cs_ipvec_di.o cs_lsolve_di.o cs_ltsolve_di.o cs_lu_di.o \
+	cs_lusol_di.o cs_util_di.o cs_multiply_di.o cs_permute_di.o cs_pinv_di.o \
+	cs_post_di.o cs_pvec_di.o cs_qr_di.o cs_qrsol_di.o cs_scatter_di.o \
+	cs_schol_di.o cs_sqr_di.o cs_symperm_di.o cs_tdfs_di.o cs_malloc_di.o \
+	cs_transpose_di.o cs_compress_di.o cs_usolve_di.o cs_utsolve_di.o \
+	cs_scc_di.o cs_maxtrans_di.o cs_dmperm_di.o cs_updown_di.o cs_print_di.o \
+	cs_norm_di.o cs_load_di.o cs_dfs_di.o cs_reach_di.o cs_spsolve_di.o \
+	cs_leaf_di.o cs_ereach_di.o cs_randperm_di.o
+
+CS_DL_OBJ =  cs_add_dl.o cs_amd_dl.o cs_chol_dl.o cs_cholsol_dl.o cs_counts_dl.o \
+	cs_cumsum_dl.o cs_droptol_dl.o cs_dropzeros_dl.o cs_dupl_dl.o \
+	cs_entry_dl.o cs_etree_dl.o cs_fkeep_dl.o cs_gaxpy_dl.o cs_happly_dl.o \
+	cs_house_dl.o cs_ipvec_dl.o cs_lsolve_dl.o cs_ltsolve_dl.o cs_lu_dl.o \
+	cs_lusol_dl.o cs_util_dl.o cs_multiply_dl.o cs_permute_dl.o cs_pinv_dl.o \
+	cs_post_dl.o cs_pvec_dl.o cs_qr_dl.o cs_qrsol_dl.o cs_scatter_dl.o \
+	cs_schol_dl.o cs_sqr_dl.o cs_symperm_dl.o cs_tdfs_dl.o cs_malloc_dl.o \
+	cs_transpose_dl.o cs_compress_dl.o cs_usolve_dl.o cs_utsolve_dl.o \
+	cs_scc_dl.o cs_maxtrans_dl.o cs_dmperm_dl.o cs_updown_dl.o cs_print_dl.o \
+	cs_norm_dl.o cs_load_dl.o cs_dfs_dl.o cs_reach_dl.o cs_spsolve_dl.o \
+	cs_leaf_dl.o cs_ereach_dl.o cs_randperm_dl.o
+
+CS_CI_OBJ =  cs_add_ci.o cs_amd_ci.o cs_chol_ci.o cs_cholsol_ci.o cs_counts_ci.o \
+	cs_cumsum_ci.o cs_droptol_ci.o cs_dropzeros_ci.o cs_dupl_ci.o \
+	cs_entry_ci.o cs_etree_ci.o cs_fkeep_ci.o cs_gaxpy_ci.o cs_happly_ci.o \
+	cs_house_ci.o cs_ipvec_ci.o cs_lsolve_ci.o cs_ltsolve_ci.o cs_lu_ci.o \
+	cs_lusol_ci.o cs_util_ci.o cs_multiply_ci.o cs_permute_ci.o cs_pinv_ci.o \
+	cs_post_ci.o cs_pvec_ci.o cs_qr_ci.o cs_qrsol_ci.o cs_scatter_ci.o \
+	cs_schol_ci.o cs_sqr_ci.o cs_symperm_ci.o cs_tdfs_ci.o cs_malloc_ci.o \
+	cs_transpose_ci.o cs_compress_ci.o cs_usolve_ci.o cs_utsolve_ci.o \
+	cs_scc_ci.o cs_maxtrans_ci.o cs_dmperm_ci.o cs_updown_ci.o cs_print_ci.o \
+	cs_norm_ci.o cs_load_ci.o cs_dfs_ci.o cs_reach_ci.o cs_spsolve_ci.o \
+	cs_leaf_ci.o cs_ereach_ci.o cs_randperm_ci.o
+
+CS_CL_OBJ =  cs_add_cl.o cs_amd_cl.o cs_chol_cl.o cs_cholsol_cl.o cs_counts_cl.o \
+	cs_cumsum_cl.o cs_droptol_cl.o cs_dropzeros_cl.o cs_dupl_cl.o \
+	cs_entry_cl.o cs_etree_cl.o cs_fkeep_cl.o cs_gaxpy_cl.o cs_happly_cl.o \
+	cs_house_cl.o cs_ipvec_cl.o cs_lsolve_cl.o cs_ltsolve_cl.o cs_lu_cl.o \
+	cs_lusol_cl.o cs_util_cl.o cs_multiply_cl.o cs_permute_cl.o cs_pinv_cl.o \
+	cs_post_cl.o cs_pvec_cl.o cs_qr_cl.o cs_qrsol_cl.o cs_scatter_cl.o \
+	cs_schol_cl.o cs_sqr_cl.o cs_symperm_cl.o cs_tdfs_cl.o cs_malloc_cl.o \
+	cs_transpose_cl.o cs_compress_cl.o cs_usolve_cl.o cs_utsolve_cl.o \
+	cs_scc_cl.o cs_maxtrans_cl.o cs_dmperm_cl.o cs_updown_cl.o cs_print_cl.o \
+	cs_norm_cl.o cs_load_cl.o cs_dfs_cl.o cs_reach_cl.o cs_spsolve_cl.o \
+	cs_leaf_cl.o cs_ereach_cl.o cs_randperm_cl.o
+
+CS = cs_convert.o $(CS_DI_OBJ) $(CS_DL_OBJ) $(CS_CI_OBJ) $(CS_CL_OBJ)
+
+$(CS): cs.h Makefile
+
+cs_convert.o: cs_convert.cpp
+	$(CC) $(CXXFLAGS) $(I) -c $< -o $@
+
+%_di.o : %.cpp
+	$(CC) $(CXXFLAGS) $(I) -c $< -o $@
+
+%_dl.o : %.cpp
+	$(CC) $(CXXFLAGS) $(I) -DCS_LONG -c $< -o $@
+
+%_ci.o : %.cpp
+	$(CC) $(CXXFLAGS) $(I) -DCS_COMPLEX -c $< -o $@
+
+%_cl.o : %.cpp
+	$(CC) $(CXXFLAGS) $(I) -DCS_LONG -DCS_COMPLEX -c $< -o $@
+
+$(LIBPRE)cxsparse.$(LIBEXT): $(CS)
+	$(AR) $(LIBPRE)cxsparse.$(LIBEXT) $(CS)
+	$(RANLIB) $(LIBPRE)cxsparse.$(LIBEXT)
+
+clean:
+	rm -f *.o
+
+purge: distclean
+
+distclean: clean
+	rm -f *.$(LIBEXT)
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Source/README.txt SuiteSparse/CXSparse-C++/Source/README.txt
--- original-libraries/SuiteSparse/CXSparse-C++/Source/README.txt	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Source/README.txt	2006-02-18 06:38:00.000000000 +0100
@@ -0,0 +1,3 @@
+CXSparse/Source directory: primary ANSI C source code files for CXSparse.
+To compile the libcxsparse.a C-callable library, just type "make" in this
+directory.
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Source/cs.h SuiteSparse/CXSparse-C++/Source/cs.h
--- original-libraries/SuiteSparse/CXSparse-C++/Source/cs.h	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Source/cs.h	2006-12-19 13:44:49.451396000 +0100
@@ -0,0 +1,731 @@
+#ifndef _CXS_H
+#define _CXS_H
+#include <stdlib.h>
+#include <limits.h>
+#include <math.h>
+#include <stdio.h>
+#ifdef MATLAB_MEX_FILE
+#include "mex.h"
+#endif
+
+#include <complex>
+#define CPLX std::complex<double>
+#define I CPLX(0.0, 1.0)
+
+#ifdef _MSC_VER
+#pragma warning (disable: 4003)
+#endif
+
+#define CS_VER 2		    /* CXSparse Version 2.0.2 */
+#define CS_SUBVER 0
+#define CS_SUBSUB 2
+#define CS_DATE "Aug 23, 2006"	    /* CXSparse release date */
+#define CS_COPYRIGHT "Copyright (c) Timothy A. Davis, 2006"
+#define CXSPARSE
+
+/* define UF_long */
+#include "UFconfig.h"
+
+/* -------------------------------------------------------------------------- */
+/* double/int version of CXSparse */
+/* -------------------------------------------------------------------------- */
+
+/* --- primary CSparse routines and data structures ------------------------- */
+
+typedef struct cs_di_sparse  /* matrix in compressed-column or triplet form */
+{
+    int nzmax ;	    /* maximum number of entries */
+    int m ;	    /* number of rows */
+    int n ;	    /* number of columns */
+    int *p ;	    /* column pointers (size n+1) or col indices (size nzmax) */
+    int *i ;	    /* row indices, size nzmax */
+    double *x ;	    /* numerical values, size nzmax */
+    int nz ;	    /* # of entries in triplet matrix, -1 for compressed-col */
+} cs_di ;
+
+cs_di *cs_di_add (const cs_di *A, const cs_di *B, double alpha, double beta) ;
+int cs_di_cholsol (int order, const cs_di *A, double *b) ;
+int cs_di_dupl (cs_di *A) ;
+int cs_di_entry (cs_di *T, int i, int j, double x) ;
+int cs_di_lusol (int order, const cs_di *A, double *b, double tol) ;
+int cs_di_gaxpy (const cs_di *A, const double *x, double *y) ;
+cs_di *cs_di_multiply (const cs_di *A, const cs_di *B) ;
+int cs_di_qrsol (int order, const cs_di *A, double *b) ;
+cs_di *cs_di_transpose (const cs_di *A, int values) ;
+cs_di *cs_di_compress (const cs_di *T) ;
+double cs_di_norm (const cs_di *A) ;
+int cs_di_print (const cs_di *A, int brief) ;
+cs_di *cs_di_load (FILE *f) ;
+
+/* utilities */
+void *cs_di_calloc (int n, size_t size) ;
+void *cs_di_free (void *p) ;
+void *cs_di_realloc (void *p, int n, size_t size, int *ok) ;
+cs_di *cs_di_spalloc (int m, int n, int nzmax, int values, int t) ;
+cs_di *cs_di_spfree (cs_di *A) ;
+int cs_di_sprealloc (cs_di *A, int nzmax) ;
+void *cs_di_malloc (int n, size_t size) ;
+
+/* --- secondary CSparse routines and data structures ----------------------- */
+
+typedef struct cs_di_symbolic  /* symbolic Cholesky, LU, or QR analysis */
+{
+    int *pinv ;	    /* inverse row perm. for QR, fill red. perm for Chol */
+    int *q ;	    /* fill-reducing column permutation for LU and QR */
+    int *parent ;   /* elimination tree for Cholesky and QR */
+    int *cp ;	    /* column pointers for Cholesky, row counts for QR */
+    int *leftmost ; /* leftmost[i] = min(find(A(i,:))), for QR */
+    int m2 ;	    /* # of rows for QR, after adding fictitious rows */
+    double lnz ;    /* # entries in L for LU or Cholesky; in V for QR */
+    double unz ;    /* # entries in U for LU; in R for QR */
+} cs_dis ;
+
+typedef struct cs_di_numeric   /* numeric Cholesky, LU, or QR factorization */
+{
+    cs_di *L ;	    /* L for LU and Cholesky, V for QR */
+    cs_di *U ;	    /* U for LU, r for QR, not used for Cholesky */
+    int *pinv ;	    /* partial pivoting for LU */
+    double *B ;	    /* beta [0..n-1] for QR */
+} cs_din ;
+
+typedef struct cs_di_dmperm_results    /* cs_di_dmperm or cs_di_scc output */
+{
+    int *p ;	    /* size m, row permutation */
+    int *q ;	    /* size n, column permutation */
+    int *r ;	    /* size nb+1, block k is rows r[k] to r[k+1]-1 in A(p,q) */
+    int *s ;	    /* size nb+1, block k is cols s[k] to s[k+1]-1 in A(p,q) */
+    int nb ;	    /* # of blocks in fine dmperm decomposition */
+    int rr [5] ;    /* coarse row decomposition */
+    int cc [5] ;    /* coarse column decomposition */
+} cs_did ;
+
+int *cs_di_amd (int order, const cs_di *A) ;
+cs_din *cs_di_chol (const cs_di *A, const cs_dis *S) ;
+cs_did *cs_di_dmperm (const cs_di *A, int seed) ;
+int cs_di_droptol (cs_di *A, double tol) ;
+int cs_di_dropzeros (cs_di *A) ;
+int cs_di_happly (const cs_di *V, int i, double beta, double *x) ;
+int cs_di_ipvec (const int *p, const double *b, double *x, int n) ;
+int cs_di_lsolve (const cs_di *L, double *x) ;
+int cs_di_ltsolve (const cs_di *L, double *x) ;
+cs_din *cs_di_lu (const cs_di *A, const cs_dis *S, double tol) ;
+cs_di *cs_di_permute (const cs_di *A, const int *p, const int *q, int values) ;
+int *cs_di_pinv (const int *p, int n) ;
+int cs_di_pvec (const int *p, const double *b, double *x, int n) ;
+cs_din *cs_di_qr (const cs_di *A, const cs_dis *S) ;
+cs_dis *cs_di_schol (int order, const cs_di *A) ;
+cs_dis *cs_di_sqr (int order, const cs_di *A, int qr) ;
+cs_di *cs_di_symperm (const cs_di *A, const int *pinv, int values) ;
+int cs_di_usolve (const cs_di *U, double *x) ;
+int cs_di_utsolve (const cs_di *U, double *x) ;
+int cs_di_updown (cs_di *L, int sigma, const cs_di *C, const int *parent) ;
+
+/* utilities */
+cs_dis *cs_di_sfree (cs_dis *S) ;
+cs_din *cs_di_nfree (cs_din *N) ;
+cs_did *cs_di_dfree (cs_did *D) ;
+
+/* --- tertiary CSparse routines -------------------------------------------- */
+
+int *cs_di_counts (const cs_di *A, const int *parent, const int *post,
+    int ata) ;
+double cs_di_cumsum (int *p, int *c, int n) ;
+int cs_di_dfs (int j, cs_di *G, int top, int *xi, int *pstack,
+    const int *pinv) ;
+int *cs_di_etree (const cs_di *A, int ata) ;
+int cs_di_fkeep (cs_di *A, int (*fkeep) (int, int, double, void *),
+    void *other) ;
+double cs_di_house (double *x, double *beta, int n) ;
+int *cs_di_maxtrans (const cs_di *A, int seed) ;
+int *cs_di_post (const int *parent, int n) ;
+cs_did *cs_di_scc (cs_di *A) ;
+int cs_di_scatter (const cs_di *A, int j, double beta, int *w, double *x,
+    int mark, cs_di *C, int nz) ;
+int cs_di_tdfs (int j, int k, int *head, const int *next, int *post,
+    int *stack) ;
+int cs_di_leaf (int i, int j, const int *first, int *maxfirst, int *prevleaf,
+    int *ancestor, int *jleaf) ;
+int cs_di_reach (cs_di *G, const cs_di *B, int k, int *xi, const int *pinv) ;
+int cs_di_spsolve (cs_di *L, const cs_di *B, int k, int *xi, double *x,
+    const int *pinv, int lo) ;
+int cs_di_ereach (const cs_di *A, int k, const int *parent, int *s, int *w) ;
+int *cs_di_randperm (int n, int seed) ;
+
+/* utilities */
+cs_did *cs_di_dalloc (int m, int n) ;
+cs_di *cs_di_done (cs_di *C, void *w, void *x, int ok) ;
+int *cs_di_idone (int *p, cs_di *C, void *w, int ok) ;
+cs_din *cs_di_ndone (cs_din *N, cs_di *C, void *w, void *x, int ok) ;
+cs_did *cs_di_ddone (cs_did *D, cs_di *C, void *w, int ok) ;
+
+
+/* -------------------------------------------------------------------------- */
+/* double/UF_long version of CXSparse */
+/* -------------------------------------------------------------------------- */
+
+/* --- primary CSparse routines and data structures ------------------------- */
+
+typedef struct cs_dl_sparse  /* matrix in compressed-column or triplet form */
+{
+    UF_long nzmax ; /* maximum number of entries */
+    UF_long m ;	    /* number of rows */
+    UF_long n ;	    /* number of columns */
+    UF_long *p ;    /* column pointers (size n+1) or col indlces (size nzmax) */
+    UF_long *i ;    /* row indices, size nzmax */
+    double *x ;	    /* numerical values, size nzmax */
+    UF_long nz ;    /* # of entries in triplet matrix, -1 for compressed-col */
+} cs_dl ;
+
+cs_dl *cs_dl_add (const cs_dl *A, const cs_dl *B, double alpha, double beta) ;
+UF_long cs_dl_cholsol (UF_long order, const cs_dl *A, double *b) ;
+UF_long cs_dl_dupl (cs_dl *A) ;
+UF_long cs_dl_entry (cs_dl *T, UF_long i, UF_long j, double x) ;
+UF_long cs_dl_lusol (UF_long order, const cs_dl *A, double *b, double tol) ;
+UF_long cs_dl_gaxpy (const cs_dl *A, const double *x, double *y) ;
+cs_dl *cs_dl_multiply (const cs_dl *A, const cs_dl *B) ;
+UF_long cs_dl_qrsol (UF_long order, const cs_dl *A, double *b) ;
+cs_dl *cs_dl_transpose (const cs_dl *A, UF_long values) ;
+cs_dl *cs_dl_compress (const cs_dl *T) ;
+double cs_dl_norm (const cs_dl *A) ;
+UF_long cs_dl_print (const cs_dl *A, UF_long brief) ;
+cs_dl *cs_dl_load (FILE *f) ;
+
+/* utilities */
+void *cs_dl_calloc (UF_long n, size_t size) ;
+void *cs_dl_free (void *p) ;
+void *cs_dl_realloc (void *p, UF_long n, size_t size, UF_long *ok) ;
+cs_dl *cs_dl_spalloc (UF_long m, UF_long n, UF_long nzmax, UF_long values,
+    UF_long t) ;
+cs_dl *cs_dl_spfree (cs_dl *A) ;
+UF_long cs_dl_sprealloc (cs_dl *A, UF_long nzmax) ;
+void *cs_dl_malloc (UF_long n, size_t size) ;
+
+/* --- secondary CSparse routines and data structures ----------------------- */
+
+typedef struct cs_dl_symbolic  /* symbolic Cholesky, LU, or QR analysis */
+{
+    UF_long *pinv ;	/* inverse row perm. for QR, fill red. perm for Chol */
+    UF_long *q ;	/* fill-reducing column permutation for LU and QR */
+    UF_long *parent ;	/* elimination tree for Cholesky and QR */
+    UF_long *cp ;	/* column pointers for Cholesky, row counts for QR */
+    UF_long *leftmost ;	/* leftmost[i] = min(find(A(i,:))), for QR */
+    UF_long m2 ;	/* # of rows for QR, after adding fictitious rows */
+    double lnz ;	/* # entries in L for LU or Cholesky; in V for QR */
+    double unz ;	/* # entries in U for LU; in R for QR */
+} cs_dls ;
+
+typedef struct cs_dl_numeric   /* numeric Cholesky, LU, or QR factorization */
+{
+    cs_dl *L ;	    /* L for LU and Cholesky, V for QR */
+    cs_dl *U ;	    /* U for LU, r for QR, not used for Cholesky */
+    UF_long *pinv ; /* partial pivoting for LU */
+    double *B ;	    /* beta [0..n-1] for QR */
+} cs_dln ;
+
+typedef struct cs_dl_dmperm_results    /* cs_dl_dmperm or cs_dl_scc output */
+{
+    UF_long *p ;    /* size m, row permutation */
+    UF_long *q ;    /* size n, column permutation */
+    UF_long *r ;    /* size nb+1, block k is rows r[k] to r[k+1]-1 in A(p,q) */
+    UF_long *s ;    /* size nb+1, block k is cols s[k] to s[k+1]-1 in A(p,q) */
+    UF_long nb ;    /* # of blocks in fine dmperm decomposition */
+    UF_long rr [5] ;	/* coarse row decomposition */
+    UF_long cc [5] ;	/* coarse column decomposition */
+} cs_dld ;
+
+UF_long *cs_dl_amd (UF_long order, const cs_dl *A) ;
+cs_dln *cs_dl_chol (const cs_dl *A, const cs_dls *S) ;
+cs_dld *cs_dl_dmperm (const cs_dl *A, UF_long seed) ;
+UF_long cs_dl_droptol (cs_dl *A, double tol) ;
+UF_long cs_dl_dropzeros (cs_dl *A) ;
+UF_long cs_dl_happly (const cs_dl *V, UF_long i, double beta, double *x) ;
+UF_long cs_dl_ipvec (const UF_long *p, const double *b, double *x, UF_long n) ;
+UF_long cs_dl_lsolve (const cs_dl *L, double *x) ;
+UF_long cs_dl_ltsolve (const cs_dl *L, double *x) ;
+cs_dln *cs_dl_lu (const cs_dl *A, const cs_dls *S, double tol) ;
+cs_dl *cs_dl_permute (const cs_dl *A, const UF_long *p, const UF_long *q,
+    UF_long values) ;
+UF_long *cs_dl_pinv (const UF_long *p, UF_long n) ;
+UF_long cs_dl_pvec (const UF_long *p, const double *b, double *x, UF_long n) ;
+cs_dln *cs_dl_qr (const cs_dl *A, const cs_dls *S) ;
+cs_dls *cs_dl_schol (UF_long order, const cs_dl *A) ;
+cs_dls *cs_dl_sqr (UF_long order, const cs_dl *A, UF_long qr) ;
+cs_dl *cs_dl_symperm (const cs_dl *A, const UF_long *pinv, UF_long values) ;
+UF_long cs_dl_usolve (const cs_dl *U, double *x) ;
+UF_long cs_dl_utsolve (const cs_dl *U, double *x) ;
+UF_long cs_dl_updown (cs_dl *L, UF_long sigma, const cs_dl *C,
+    const UF_long *parent) ;
+
+/* utilities */
+cs_dls *cs_dl_sfree (cs_dls *S) ;
+cs_dln *cs_dl_nfree (cs_dln *N) ;
+cs_dld *cs_dl_dfree (cs_dld *D) ;
+
+/* --- tertiary CSparse routines -------------------------------------------- */
+
+UF_long *cs_dl_counts (const cs_dl *A, const UF_long *parent,
+    const UF_long *post, UF_long ata) ;
+double cs_dl_cumsum (UF_long *p, UF_long *c, UF_long n) ;
+UF_long cs_dl_dfs (UF_long j, cs_dl *G, UF_long top, UF_long *xi,
+    UF_long *pstack, const UF_long *pinv) ;
+UF_long *cs_dl_etree (const cs_dl *A, UF_long ata) ;
+UF_long cs_dl_fkeep (cs_dl *A,
+    UF_long (*fkeep) (UF_long, UF_long, double, void *), void *other) ;
+double cs_dl_house (double *x, double *beta, UF_long n) ;
+UF_long *cs_dl_maxtrans (const cs_dl *A, UF_long seed) ;
+UF_long *cs_dl_post (const UF_long *parent, UF_long n) ;
+cs_dld *cs_dl_scc (cs_dl *A) ;
+UF_long cs_dl_scatter (const cs_dl *A, UF_long j, double beta, UF_long *w,
+    double *x, UF_long mark,cs_dl *C, UF_long nz) ;
+UF_long cs_dl_tdfs (UF_long j, UF_long k, UF_long *head, const UF_long *next,
+    UF_long *post, UF_long *stack) ;
+UF_long cs_dl_leaf (UF_long i, UF_long j, const UF_long *first,
+    UF_long *maxfirst, UF_long *prevleaf, UF_long *ancestor, UF_long *jleaf) ;
+UF_long cs_dl_reach (cs_dl *G, const cs_dl *B, UF_long k, UF_long *xi,
+    const UF_long *pinv) ;
+UF_long cs_dl_spsolve (cs_dl *L, const cs_dl *B, UF_long k, UF_long *xi,
+    double *x, const UF_long *pinv, UF_long lo) ;
+UF_long cs_dl_ereach (const cs_dl *A, UF_long k, const UF_long *parent,
+    UF_long *s, UF_long *w) ;
+UF_long *cs_dl_randperm (UF_long n, UF_long seed) ;
+
+/* utilities */
+cs_dld *cs_dl_dalloc (UF_long m, UF_long n) ;
+cs_dl *cs_dl_done (cs_dl *C, void *w, void *x, UF_long ok) ;
+UF_long *cs_dl_idone (UF_long *p, cs_dl *C, void *w, UF_long ok) ;
+cs_dln *cs_dl_ndone (cs_dln *N, cs_dl *C, void *w, void *x, UF_long ok) ;
+cs_dld *cs_dl_ddone (cs_dld *D, cs_dl *C, void *w, UF_long ok) ;
+
+
+/* -------------------------------------------------------------------------- */
+/* complex/int version of CXSparse */
+/* -------------------------------------------------------------------------- */
+
+/* --- primary CSparse routines and data structures ------------------------- */
+
+typedef struct cs_ci_sparse  /* matrix in compressed-column or triplet form */
+{
+    int nzmax ;	    /* maximum number of entries */
+    int m ;	    /* number of rows */
+    int n ;	    /* number of columns */
+    int *p ;	    /* column pointers (size n+1) or col indices (size nzmax) */
+    int *i ;	    /* row indices, size nzmax */
+    CPLX *x ;    /* numerical values, size nzmax */
+    int nz ;	    /* # of entries in triplet matrix, -1 for compressed-col */
+} cs_ci ;
+
+cs_ci *cs_ci_add (const cs_ci *A, const cs_ci *B, CPLX alpha,
+    CPLX beta) ;
+int cs_ci_cholsol (int order, const cs_ci *A, CPLX *b) ;
+int cs_ci_dupl (cs_ci *A) ;
+int cs_ci_entry (cs_ci *T, int i, int j, CPLX x) ;
+int cs_ci_lusol (int order, const cs_ci *A, CPLX *b, double tol) ;
+int cs_ci_gaxpy (const cs_ci *A, const CPLX *x, CPLX *y) ;
+cs_ci *cs_ci_multiply (const cs_ci *A, const cs_ci *B) ;
+int cs_ci_qrsol (int order, const cs_ci *A, CPLX *b) ;
+cs_ci *cs_ci_transpose (const cs_ci *A, int values) ;
+cs_ci *cs_ci_compress (const cs_ci *T) ;
+double cs_ci_norm (const cs_ci *A) ;
+int cs_ci_print (const cs_ci *A, int brief) ;
+cs_ci *cs_ci_load (FILE *f) ;
+
+/* utilities */
+void *cs_ci_calloc (int n, size_t size) ;
+void *cs_ci_free (void *p) ;
+void *cs_ci_realloc (void *p, int n, size_t size, int *ok) ;
+cs_ci *cs_ci_spalloc (int m, int n, int nzmax, int values, int t) ;
+cs_ci *cs_ci_spfree (cs_ci *A) ;
+int cs_ci_sprealloc (cs_ci *A, int nzmax) ;
+void *cs_ci_malloc (int n, size_t size) ;
+
+/* --- secondary CSparse routines and data structures ----------------------- */
+
+typedef struct cs_ci_symbolic  /* symbolic Cholesky, LU, or QR analysis */
+{
+    int *pinv ;	    /* inverse row perm. for QR, fill red. perm for Chol */
+    int *q ;	    /* fill-reducing column permutation for LU and QR */
+    int *parent ;   /* elimination tree for Cholesky and QR */
+    int *cp ;	    /* column pointers for Cholesky, row counts for QR */
+    int *leftmost ; /* leftmost[i] = min(find(A(i,:))), for QR */
+    int m2 ;	    /* # of rows for QR, after adding fictitious rows */
+    double lnz ;    /* # entries in L for LU or Cholesky; in V for QR */
+    double unz ;    /* # entries in U for LU; in R for QR */
+} cs_cis ;
+
+typedef struct cs_ci_numeric   /* numeric Cholesky, LU, or QR factorization */
+{
+    cs_ci *L ;	    /* L for LU and Cholesky, V for QR */
+    cs_ci *U ;	    /* U for LU, r for QR, not used for Cholesky */
+    int *pinv ;	    /* partial pivoting for LU */
+    CPLX *B ;	    /* beta [0..n-1] for QR */
+} cs_cin ;
+
+typedef struct cs_ci_dmperm_results    /* cs_ci_dmperm or cs_ci_scc output */
+{
+    int *p ;	    /* size m, row permutation */
+    int *q ;	    /* size n, column permutation */
+    int *r ;	    /* size nb+1, block k is rows r[k] to r[k+1]-1 in A(p,q) */
+    int *s ;	    /* size nb+1, block k is cols s[k] to s[k+1]-1 in A(p,q) */
+    int nb ;	    /* # of blocks in fine dmperm decomposition */
+    int rr [5] ;    /* coarse row decomposition */
+    int cc [5] ;    /* coarse column decomposition */
+} cs_cid ;
+
+int *cs_ci_amd (int order, const cs_ci *A) ;
+cs_cin *cs_ci_chol (const cs_ci *A, const cs_cis *S) ;
+cs_cid *cs_ci_dmperm (const cs_ci *A, int seed) ;
+int cs_ci_droptol (cs_ci *A, double tol) ;
+int cs_ci_dropzeros (cs_ci *A) ;
+int cs_ci_happly (const cs_ci *V, int i, CPLX beta,
+    CPLX *x) ;
+int cs_ci_ipvec (const int *p, const CPLX *b,
+    CPLX *x, int n) ;
+int cs_ci_lsolve (const cs_ci *L, CPLX *x) ;
+int cs_ci_ltsolve (const cs_ci *L, CPLX *x) ;
+cs_cin *cs_ci_lu (const cs_ci *A, const cs_cis *S, double tol) ;
+cs_ci *cs_ci_permute (const cs_ci *A, const int *p, const int *q, int values) ;
+int *cs_ci_pinv (const int *p, int n) ;
+int cs_ci_pvec (const int *p, const CPLX *b,
+    CPLX *x, int n) ;
+cs_cin *cs_ci_qr (const cs_ci *A, const cs_cis *S) ;
+cs_cis *cs_ci_schol (int order, const cs_ci *A) ;
+cs_cis *cs_ci_sqr (int order, const cs_ci *A, int qr) ;
+cs_ci *cs_ci_symperm (const cs_ci *A, const int *pinv, int values) ;
+int cs_ci_usolve (const cs_ci *U, CPLX *x) ;
+int cs_ci_utsolve (const cs_ci *U, CPLX *x) ;
+int cs_ci_updown (cs_ci *L, int sigma, const cs_ci *C, const int *parent) ;
+
+/* utilities */
+cs_cis *cs_ci_sfree (cs_cis *S) ;
+cs_cin *cs_ci_nfree (cs_cin *N) ;
+cs_cid *cs_ci_dfree (cs_cid *D) ;
+
+/* --- tertiary CSparse routines -------------------------------------------- */
+
+int *cs_ci_counts (const cs_ci *A, const int *parent, const int *post,
+    int ata) ;
+double cs_ci_cumsum (int *p, int *c, int n) ;
+int cs_ci_dfs (int j, cs_ci *G, int top, int *xi, int *pstack,
+    const int *pinv) ;
+int *cs_ci_etree (const cs_ci *A, int ata) ;
+int cs_ci_fkeep (cs_ci *A, int (*fkeep) (int, int, CPLX, void *),
+    void *other) ;
+CPLX cs_ci_house (CPLX *x, CPLX *beta, int n) ;
+int *cs_ci_maxtrans (const cs_ci *A, int seed) ;
+int *cs_ci_post (const int *parent, int n) ;
+cs_cid *cs_ci_scc (cs_ci *A) ;
+int cs_ci_scatter (const cs_ci *A, int j, CPLX beta, int *w, 
+    CPLX *x, int mark,cs_ci *C, int nz) ;
+int cs_ci_tdfs (int j, int k, int *head, const int *next, int *post,
+    int *stack) ;
+int cs_ci_leaf (int i, int j, const int *first, int *maxfirst, int *prevleaf,
+    int *ancestor, int *jleaf) ;
+int cs_ci_reach (cs_ci *G, const cs_ci *B, int k, int *xi, const int *pinv) ;
+int cs_ci_spsolve (cs_ci *L, const cs_ci *B, int k, int *xi, 
+    CPLX *x, const int *pinv, int lo) ;
+int cs_ci_ereach (const cs_ci *A, int k, const int *parent, int *s, int *w) ;
+int *cs_ci_randperm (int n, int seed) ;
+
+/* utilities */
+cs_cid *cs_ci_dalloc (int m, int n) ;
+cs_ci *cs_ci_done (cs_ci *C, void *w, void *x, int ok) ;
+int *cs_ci_idone (int *p, cs_ci *C, void *w, int ok) ;
+cs_cin *cs_ci_ndone (cs_cin *N, cs_ci *C, void *w, void *x, int ok) ;
+cs_cid *cs_ci_ddone (cs_cid *D, cs_ci *C, void *w, int ok) ;
+
+
+/* -------------------------------------------------------------------------- */
+/* complex/UF_long version of CXSparse */
+/* -------------------------------------------------------------------------- */
+
+/* --- primary CSparse routines and data structures ------------------------- */
+
+typedef struct cs_cl_sparse  /* matrix in compressed-column or triplet form */
+{
+    UF_long nzmax ; /* maximum number of entries */
+    UF_long m ;	    /* number of rows */
+    UF_long n ;	    /* number of columns */
+    UF_long *p ;    /* column pointers (size n+1) or col indlces (size nzmax) */
+    UF_long *i ;    /* row indices, size nzmax */
+    CPLX *x ;    /* numerical values, size nzmax */
+    UF_long nz ;    /* # of entries in triplet matrix, -1 for compressed-col */
+} cs_cl ;
+
+cs_cl *cs_cl_add (const cs_cl *A, const cs_cl *B, CPLX alpha,
+    CPLX beta) ;
+UF_long cs_cl_cholsol (UF_long order, const cs_cl *A, CPLX *b) ;
+UF_long cs_cl_dupl (cs_cl *A) ;
+UF_long cs_cl_entry (cs_cl *T, UF_long i, UF_long j, CPLX x) ;
+UF_long cs_cl_lusol (UF_long order, const cs_cl *A, CPLX *b,
+    double tol) ;
+UF_long cs_cl_gaxpy (const cs_cl *A, const CPLX *x,
+    CPLX *y) ;
+cs_cl *cs_cl_multiply (const cs_cl *A, const cs_cl *B) ;
+UF_long cs_cl_qrsol (UF_long order, const cs_cl *A, CPLX *b) ;
+cs_cl *cs_cl_transpose (const cs_cl *A, UF_long values) ;
+cs_cl *cs_cl_compress (const cs_cl *T) ;
+double cs_cl_norm (const cs_cl *A) ;
+UF_long cs_cl_print (const cs_cl *A, UF_long brief) ;
+cs_cl *cs_cl_load (FILE *f) ;
+
+/* utilities */
+void *cs_cl_calloc (UF_long n, size_t size) ;
+void *cs_cl_free (void *p) ;
+void *cs_cl_realloc (void *p, UF_long n, size_t size, UF_long *ok) ;
+cs_cl *cs_cl_spalloc (UF_long m, UF_long n, UF_long nzmax, UF_long values,
+    UF_long t) ;
+cs_cl *cs_cl_spfree (cs_cl *A) ;
+UF_long cs_cl_sprealloc (cs_cl *A, UF_long nzmax) ;
+void *cs_cl_malloc (UF_long n, size_t size) ;
+
+/* --- secondary CSparse routines and data structures ----------------------- */
+
+typedef struct cs_cl_symbolic  /* symbolic Cholesky, LU, or QR analysis */
+{
+    UF_long *pinv ;	/* inverse row perm. for QR, fill red. perm for Chol */
+    UF_long *q ;	/* fill-reducing column permutation for LU and QR */
+    UF_long *parent ;	/* elimination tree for Cholesky and QR */
+    UF_long *cp ;	/* column pointers for Cholesky, row counts for QR */
+    UF_long *leftmost ;	/* leftmost[i] = min(find(A(i,:))), for QR */
+    UF_long m2 ;	/* # of rows for QR, after adding fictitious rows */
+    double lnz ;	/* # entries in L for LU or Cholesky; in V for QR */
+    double unz ;	/* # entries in U for LU; in R for QR */
+} cs_cls ;
+
+typedef struct cs_cl_numeric   /* numeric Cholesky, LU, or QR factorization */
+{
+    cs_cl *L ;		/* L for LU and Cholesky, V for QR */
+    cs_cl *U ;		/* U for LU, r for QR, not used for Cholesky */
+    UF_long *pinv ;	/* partial pivoting for LU */
+    CPLX *B ;	    /* beta [0..n-1] for QR */
+} cs_cln ;
+
+typedef struct cs_cl_dmperm_results    /* cs_cl_dmperm or cs_cl_scc output */
+{
+    UF_long *p ;    /* size m, row permutation */
+    UF_long *q ;    /* size n, column permutation */
+    UF_long *r ;    /* size nb+1, block k is rows r[k] to r[k+1]-1 in A(p,q) */
+    UF_long *s ;    /* size nb+1, block k is cols s[k] to s[k+1]-1 in A(p,q) */
+    UF_long nb ;    /* # of blocks in fine dmperm decomposition */
+    UF_long rr [5] ;   /* coarse row decomposition */
+    UF_long cc [5] ;   /* coarse column decomposition */
+} cs_cld ;
+
+UF_long *cs_cl_amd (UF_long order, const cs_cl *A) ;
+cs_cln *cs_cl_chol (const cs_cl *A, const cs_cls *S) ;
+cs_cld *cs_cl_dmperm (const cs_cl *A, UF_long seed) ;
+UF_long cs_cl_droptol (cs_cl *A, double tol) ;
+UF_long cs_cl_dropzeros (cs_cl *A) ;
+UF_long cs_cl_happly (const cs_cl *V, UF_long i, CPLX beta,
+    CPLX *x) ;
+UF_long cs_cl_ipvec (const UF_long *p, const CPLX *b,
+    CPLX *x, UF_long n) ;
+UF_long cs_cl_lsolve (const cs_cl *L, CPLX *x) ;
+UF_long cs_cl_ltsolve (const cs_cl *L, CPLX *x) ;
+cs_cln *cs_cl_lu (const cs_cl *A, const cs_cls *S, double tol) ;
+cs_cl *cs_cl_permute (const cs_cl *A, const UF_long *p, const UF_long *q,
+    UF_long values) ;
+UF_long *cs_cl_pinv (const UF_long *p, UF_long n) ;
+UF_long cs_cl_pvec (const UF_long *p, const CPLX *b,
+    CPLX *x, UF_long n) ;
+cs_cln *cs_cl_qr (const cs_cl *A, const cs_cls *S) ;
+cs_cls *cs_cl_schol (UF_long order, const cs_cl *A) ;
+cs_cls *cs_cl_sqr (UF_long order, const cs_cl *A, UF_long qr) ;
+cs_cl *cs_cl_symperm (const cs_cl *A, const UF_long *pinv, UF_long values) ;
+UF_long cs_cl_usolve (const cs_cl *U, CPLX *x) ;
+UF_long cs_cl_utsolve (const cs_cl *U, CPLX *x) ;
+UF_long cs_cl_updown (cs_cl *L, UF_long sigma, const cs_cl *C,
+    const UF_long *parent) ;
+
+/* utilities */
+cs_cls *cs_cl_sfree (cs_cls *S) ;
+cs_cln *cs_cl_nfree (cs_cln *N) ;
+cs_cld *cs_cl_dfree (cs_cld *D) ;
+
+/* --- tertiary CSparse routines -------------------------------------------- */
+
+UF_long *cs_cl_counts (const cs_cl *A, const UF_long *parent,
+    const UF_long *post, UF_long ata) ;
+double cs_cl_cumsum (UF_long *p, UF_long *c, UF_long n) ;
+UF_long cs_cl_dfs (UF_long j, cs_cl *G, UF_long top, UF_long *xi,
+    UF_long *pstack, const UF_long *pinv) ;
+UF_long *cs_cl_etree (const cs_cl *A, UF_long ata) ;
+UF_long cs_cl_fkeep (cs_cl *A,
+    UF_long (*fkeep) (UF_long, UF_long, CPLX, void *), void *other) ;
+CPLX cs_cl_house (CPLX *x, CPLX *beta,
+    UF_long n) ;
+UF_long *cs_cl_maxtrans (const cs_cl *A, UF_long seed) ;
+UF_long *cs_cl_post (const UF_long *parent, UF_long n) ;
+cs_cld *cs_cl_scc (cs_cl *A) ;
+UF_long cs_cl_scatter (const cs_cl *A, UF_long j, CPLX beta,
+    UF_long *w, CPLX *x, UF_long mark,cs_cl *C, UF_long nz) ;
+UF_long cs_cl_tdfs (UF_long j, UF_long k, UF_long *head, const UF_long *next,
+    UF_long *post, UF_long *stack) ;
+UF_long cs_cl_leaf (UF_long i, UF_long j, const UF_long *first,
+    UF_long *maxfirst, UF_long *prevleaf, UF_long *ancestor, UF_long *jleaf) ;
+UF_long cs_cl_reach (cs_cl *G, const cs_cl *B, UF_long k, UF_long *xi,
+    const UF_long *pinv) ;
+UF_long cs_cl_spsolve (cs_cl *L, const cs_cl *B, UF_long k, UF_long *xi, 
+    CPLX *x, const UF_long *pinv, UF_long lo) ;
+UF_long cs_cl_ereach (const cs_cl *A, UF_long k, const UF_long *parent,
+    UF_long *s, UF_long *w) ;
+UF_long *cs_cl_randperm (UF_long n, UF_long seed) ;
+
+/* utilities */
+cs_cld *cs_cl_dalloc (UF_long m, UF_long n) ;
+cs_cl *cs_cl_done (cs_cl *C, void *w, void *x, UF_long ok) ;
+UF_long *cs_cl_idone (UF_long *p, cs_cl *C, void *w, UF_long ok) ;
+cs_cln *cs_cl_ndone (cs_cln *N, cs_cl *C, void *w, void *x, UF_long ok) ;
+cs_cld *cs_cl_ddone (cs_cld *D, cs_cl *C, void *w, UF_long ok) ;
+
+
+/* -------------------------------------------------------------------------- */
+/* Macros for constructing each version of CSparse */
+/* -------------------------------------------------------------------------- */
+
+#ifdef CS_LONG
+#define CS_INT UF_long
+#define CS_INT_MAX UF_long_max
+#define CS_ID UF_long_id
+#ifdef CS_COMPLEX
+#define CS_ENTRY CPLX
+#define CS_NAME(nm) cs_cl ## nm
+#else
+#define CS_ENTRY double
+#define CS_NAME(nm) cs_dl ## nm
+#endif
+#else
+#define CS_INT int
+#define CS_INT_MAX INT_MAX
+#define CS_ID "%d"
+#ifdef CS_COMPLEX
+#define CS_ENTRY CPLX
+#define CS_NAME(nm) cs_ci ## nm
+#else
+#define CS_ENTRY double
+#define CS_NAME(nm) cs_di ## nm
+#endif
+#endif
+
+#ifdef CS_COMPLEX
+#ifdef _MSC_VER
+#define CS_REAL(x) (x).real()
+#define CS_IMAG(x) (x).real()
+#define CS_CONJ(x) conj(x)
+#define CS_ABS(x) abs(x)
+#else
+#define CS_REAL(x) creal(x)
+#define CS_IMAG(x) cimag(x)
+#define CS_CONJ(x) conj(x)
+#define CS_ABS(x) cabs(x)
+#endif
+#else
+#define CS_REAL(x) (x)
+#define CS_IMAG(x) (0.)
+#define CS_CONJ(x) (x)
+#define CS_ABS(x) fabs(x)
+#endif
+
+#define CS_MAX(a,b) (((a) > (b)) ? (a) : (b))
+#define CS_MIN(a,b) (((a) < (b)) ? (a) : (b))
+#define CS_FLIP(i) (-(i)-2)
+#define CS_UNFLIP(i) (((i) < 0) ? CS_FLIP(i) : (i))
+#define CS_MARKED(w,j) (w [j] < 0)
+#define CS_MARK(w,j) { w [j] = CS_FLIP (w [j]) ; }
+#define CS_CSC(A) (A && (A->nz == -1))
+#define CS_TRIPLET(A) (A && (A->nz >= 0))
+
+/* --- primary CSparse routines and data structures ------------------------- */
+
+#define cs CS_NAME ()
+
+#define cs_add CS_NAME (_add)
+#define cs_cholsol CS_NAME (_cholsol)
+#define cs_dupl CS_NAME (_dupl)
+#define cs_entry CS_NAME (_entry)
+#define cs_lusol CS_NAME (_lusol)
+#define cs_gaxpy CS_NAME (_gaxpy)
+#define cs_multiply CS_NAME (_multiply)
+#define cs_qrsol CS_NAME (_qrsol)
+#define cs_transpose CS_NAME (_transpose)
+#define cs_compress CS_NAME (_compress)
+#define cs_norm CS_NAME (_norm)
+#define cs_print CS_NAME (_print)
+#define cs_load CS_NAME (_load)
+
+/* utilities */
+#define cs_calloc CS_NAME (_calloc)
+#define cs_free CS_NAME (_free)
+#define cs_realloc CS_NAME (_realloc)
+#define cs_spalloc CS_NAME (_spalloc)
+#define cs_spfree CS_NAME (_spfree)
+#define cs_sprealloc CS_NAME (_sprealloc)
+#define cs_malloc CS_NAME (_malloc)
+
+/* --- secondary CSparse routines and data structures ----------------------- */
+#define css CS_NAME (s)
+#define csn CS_NAME (n)
+#define csd CS_NAME (d)
+
+#define cs_amd CS_NAME (_amd)
+#define cs_chol CS_NAME (_chol)
+#define cs_dmperm CS_NAME (_dmperm)
+#define cs_droptol CS_NAME (_droptol)
+#define cs_dropzeros CS_NAME (_dropzeros)
+#define cs_happly CS_NAME (_happly)
+#define cs_ipvec CS_NAME (_ipvec)
+#define cs_lsolve CS_NAME (_lsolve)
+#define cs_ltsolve CS_NAME (_ltsolve)
+#define cs_lu CS_NAME (_lu)
+#define cs_permute CS_NAME (_permute)
+#define cs_pinv CS_NAME (_pinv)
+#define cs_pvec CS_NAME (_pvec)
+#define cs_qr CS_NAME (_qr)
+#define cs_schol CS_NAME (_schol)
+#define cs_sqr CS_NAME (_sqr)
+#define cs_symperm CS_NAME (_symperm)
+#define cs_usolve CS_NAME (_usolve)
+#define cs_utsolve CS_NAME (_utsolve)
+#define cs_updown CS_NAME (_updown)
+
+/* utilities */
+#define cs_sfree CS_NAME (_sfree)
+#define cs_nfree CS_NAME (_nfree)
+#define cs_dfree CS_NAME (_dfree)
+
+/* --- tertiary CSparse routines -------------------------------------------- */
+#define cs_counts CS_NAME (_counts)
+#define cs_cumsum CS_NAME (_cumsum)
+#define cs_dfs CS_NAME (_dfs)
+#define cs_etree CS_NAME (_etree)
+#define cs_fkeep CS_NAME (_fkeep)
+#define cs_house CS_NAME (_house)
+#define cs_invmatch CS_NAME (_invmatch)
+#define cs_maxtrans CS_NAME (_maxtrans)
+#define cs_post CS_NAME (_post)
+#define cs_scc CS_NAME (_scc)
+#define cs_scatter CS_NAME (_scatter)
+#define cs_tdfs CS_NAME (_tdfs)
+#define cs_reach CS_NAME (_reach)
+#define cs_spsolve CS_NAME (_spsolve)
+#define cs_ereach CS_NAME (_ereach)
+#define cs_randperm CS_NAME (_randperm)
+#define cs_leaf CS_NAME (_leaf)
+
+/* utilities */
+#define cs_dalloc CS_NAME (_dalloc)
+#define cs_done CS_NAME (_done)
+#define cs_idone CS_NAME (_idone)
+#define cs_ndone CS_NAME (_ndone)
+#define cs_ddone CS_NAME (_ddone)
+
+/* -------------------------------------------------------------------------- */
+/* Conversion routines */
+/* -------------------------------------------------------------------------- */
+
+cs_di *cs_i_real (cs_ci *A, int real) ;
+cs_ci *cs_i_complex (cs_di *A, int real) ;
+cs_dl *cs_l_real (cs_cl *A, UF_long real) ;
+cs_cl *cs_l_complex (cs_dl *A, UF_long real) ;
+
+#endif
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Source/cs_add.cpp SuiteSparse/CXSparse-C++/Source/cs_add.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Source/cs_add.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Source/cs_add.cpp	2006-11-24 15:55:08.000000000 +0100
@@ -0,0 +1,27 @@
+#include "cs.h"
+/* C = alpha*A + beta*B */
+cs *cs_add (const cs *A, const cs *B, CS_ENTRY alpha, CS_ENTRY beta)
+{
+    CS_INT p, j, nz = 0, anz, *Cp, *Ci, *Bp, m, n, bnz, *w, values ;
+    CS_ENTRY *x, *Bx, *Cx ;
+    cs *C ;
+    if (!CS_CSC (A) || !CS_CSC (B)) return (NULL) ;	    /* check inputs */
+    m = A->m ; anz = A->p [A->n] ;
+    n = B->n ; Bp = B->p ; Bx = B->x ; bnz = Bp [n] ;
+    w = (CS_INT *)cs_calloc (m, sizeof (CS_INT)) ;			    /* get workspace */
+    values = (A->x != NULL) && (Bx != NULL) ;
+    x = (CS_ENTRY *) (values ? cs_malloc (m, sizeof (CS_ENTRY)) : NULL) ;    /* get workspace */
+    C = cs_spalloc (m, n, anz + bnz, values, 0) ;	    /* allocate result*/
+    if (!C || !w || (values && !x)) return (cs_done (C, w, x, 0)) ;
+    Cp = C->p ; Ci = C->i ; Cx = C->x ;
+    for (j = 0 ; j < n ; j++)
+    {
+	Cp [j] = nz ;			/* column j of C starts here */
+	nz = cs_scatter (A, j, alpha, w, x, j+1, C, nz) ;   /* alpha*A(:,j)*/
+	nz = cs_scatter (B, j, beta, w, x, j+1, C, nz) ;    /* beta*B(:,j) */
+	if (values) for (p = Cp [j] ; p < nz ; p++) Cx [p] = x [Ci [p]] ;
+    }
+    Cp [n] = nz ;			/* finalize the last column of C */
+    cs_sprealloc (C, 0) ;		/* remove extra space from C */
+    return (cs_done (C, w, x, 1)) ;	/* success; free workspace, return C */
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Source/cs_amd.cpp SuiteSparse/CXSparse-C++/Source/cs_amd.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Source/cs_amd.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Source/cs_amd.cpp	2006-11-24 15:55:38.000000000 +0100
@@ -0,0 +1,364 @@
+#include "cs.h"
+/* clear w */
+static CS_INT cs_wclear (CS_INT mark, CS_INT lemax, CS_INT *w, CS_INT n)
+{
+    CS_INT k ;
+    if (mark < 2 || (mark + lemax < 0))
+    {
+	for (k = 0 ; k < n ; k++) if (w [k] != 0) w [k] = 1 ;
+	mark = 2 ;
+    }
+    return (mark) ;	/* at this point, w [0..n-1] < mark holds */
+}
+
+/* keep off-diagonal entries; drop diagonal entries */
+static CS_INT cs_diag (CS_INT i, CS_INT j, CS_ENTRY aij, void *other) { return (i != j) ; }
+
+/* p = amd(A+A') if symmetric is true, or amd(A'A) otherwise */
+CS_INT *cs_amd (CS_INT order, const cs *A)  /* order 0:natural, 1:Chol, 2:LU, 3:QR */
+{
+    cs *C, *A2, *AT ;
+    CS_INT *Cp, *Ci, *last, *W, *len, *nv, *next, *P, *head, *elen, *degree, *w,
+	*hhead, *ATp, *ATi, d, dk, dext, lemax = 0, e, elenk, eln, i, j, k, k1,
+	k2, k3, jlast, ln, dense, nzmax, mindeg = 0, nvi, nvj, nvk, mark, wnvi,
+	ok, cnz, nel = 0, p, p1, p2, p3, p4, pj, pk, pk1, pk2, pn, q, n, m, t ;
+    unsigned CS_INT h ;
+    /* --- Construct matrix C ----------------------------------------------- */
+    if (!CS_CSC (A) || order <= 0 || order > 3) return (NULL) ; /* check */
+    AT = cs_transpose (A, 0) ;		    /* compute A' */
+    if (!AT) return (NULL) ;
+    m = A->m ; n = A->n ;
+    dense = CS_MAX (16, 10 * sqrt ((double) n)) ;   /* find dense threshold */
+    dense = CS_MIN (n-2, dense) ;
+    if (order == 1 && n == m)
+    {
+	C = cs_add (A, AT, 0, 0) ;	    /* C = A+A' */
+    }
+    else if (order == 2)
+    {
+	ATp = AT->p ;			    /* drop dense columns from AT */
+	ATi = AT->i ;
+	for (p2 = 0, j = 0 ; j < m ; j++)
+	{
+	    p = ATp [j] ;		    /* column j of AT starts here */
+	    ATp [j] = p2 ;		    /* new column j starts here */
+	    if (ATp [j+1] - p > dense) continue ;   /* skip dense col j */
+	    for ( ; p < ATp [j+1] ; p++) ATi [p2++] = ATi [p] ;
+	}
+	ATp [m] = p2 ;			    /* finalize AT */
+	A2 = cs_transpose (AT, 0) ;	    /* A2 = AT' */
+	C = A2 ? cs_multiply (AT, A2) : NULL ;	/* C=A'*A with no dense rows */
+	cs_spfree (A2) ;
+    }
+    else
+    {
+	C = cs_multiply (AT, A) ;	    /* C=A'*A */
+    }
+    cs_spfree (AT) ;
+    if (!C) return (NULL) ;
+    cs_fkeep (C, &cs_diag, NULL) ;	    /* drop diagonal entries */
+    Cp = C->p ;
+    cnz = Cp [n] ;
+    P = (CS_INT *)cs_malloc (n+1, sizeof (CS_INT)) ;	    /* allocate result */
+    W = (CS_INT *)cs_malloc (8*(n+1), sizeof (CS_INT)) ; /* get workspace */
+    t = cnz + cnz/5 + 2*n ;		    /* add elbow room to C */
+    if (!P || !W || !cs_sprealloc (C, t)) return (cs_idone (P, C, W, 0)) ;
+    len  = W           ; nv     = W +   (n+1) ; next   = W + 2*(n+1) ;
+    head = W + 3*(n+1) ; elen   = W + 4*(n+1) ; degree = W + 5*(n+1) ;
+    w    = W + 6*(n+1) ; hhead  = W + 7*(n+1) ;
+    last = P ;				    /* use P as workspace for last */
+    /* --- Initialize quotient graph ---------------------------------------- */
+    for (k = 0 ; k < n ; k++) len [k] = Cp [k+1] - Cp [k] ;
+    len [n] = 0 ;
+    nzmax = C->nzmax ;
+    Ci = C->i ;
+    for (i = 0 ; i <= n ; i++)
+    {
+	head [i] = -1 ;			    /* degree list i is empty */
+	last [i] = -1 ;
+	next [i] = -1 ;
+	hhead [i] = -1 ;		    /* hash list i is empty */
+	nv [i] = 1 ;			    /* node i is just one node */
+	w [i] = 1 ;			    /* node i is alive */
+	elen [i] = 0 ;			    /* Ek of node i is empty */
+	degree [i] = len [i] ;		    /* degree of node i */
+    }
+    mark = cs_wclear (0, 0, w, n) ;	    /* clear w */
+    elen [n] = -2 ;			    /* n is a dead element */
+    Cp [n] = -1 ;			    /* n is a root of assembly tree */
+    w [n] = 0 ;				    /* n is a dead element */
+    /* --- Initialize degree lists ------------------------------------------ */
+    for (i = 0 ; i < n ; i++)
+    {
+	d = degree [i] ;
+	if (d == 0)			    /* node i is empty */
+	{
+	    elen [i] = -2 ;		    /* element i is dead */
+	    nel++ ;
+	    Cp [i] = -1 ;		    /* i is a root of assembly tree */
+	    w [i] = 0 ;
+	}
+	else if (d > dense)		    /* node i is dense */
+	{
+	    nv [i] = 0 ;		    /* absorb i into element n */
+	    elen [i] = -1 ;		    /* node i is dead */
+	    nel++ ;
+	    Cp [i] = CS_FLIP (n) ;
+	    nv [n]++ ;
+	}
+	else
+	{
+	    if (head [d] != -1) last [head [d]] = i ;
+	    next [i] = head [d] ;	    /* put node i in degree list d */
+	    head [d] = i ;
+	}
+    }
+    while (nel < n)			    /* while (selecting pivots) do */
+    {
+	/* --- Select node of minimum approximate degree -------------------- */
+	for (k = -1 ; mindeg < n && (k = head [mindeg]) == -1 ; mindeg++) ;
+	if (next [k] != -1) last [next [k]] = -1 ;
+	head [mindeg] = next [k] ;	    /* remove k from degree list */
+	elenk = elen [k] ;		    /* elenk = |Ek| */
+	nvk = nv [k] ;			    /* # of nodes k represents */
+	nel += nvk ;			    /* nv[k] nodes of A eliminated */
+	/* --- Garbage collection ------------------------------------------- */
+	if (elenk > 0 && cnz + mindeg >= nzmax)
+	{
+	    for (j = 0 ; j < n ; j++)
+	    {
+		if ((p = Cp [j]) >= 0)	    /* j is a live node or element */
+		{
+		    Cp [j] = Ci [p] ;	    /* save first entry of object */
+		    Ci [p] = CS_FLIP (j) ;  /* first entry is now CS_FLIP(j) */
+		}
+	    }
+	    for (q = 0, p = 0 ; p < cnz ; ) /* scan all of memory */
+	    {
+		if ((j = CS_FLIP (Ci [p++])) >= 0)  /* found object j */
+		{
+		    Ci [q] = Cp [j] ;	    /* restore first entry of object */
+		    Cp [j] = q++ ;	    /* new pointer to object j */
+		    for (k3 = 0 ; k3 < len [j]-1 ; k3++) Ci [q++] = Ci [p++] ;
+		}
+	    }
+	    cnz = q ;			    /* Ci [cnz...nzmax-1] now free */
+	}
+	/* --- Construct new element ---------------------------------------- */
+	dk = 0 ;
+	nv [k] = -nvk ;			    /* flag k as in Lk */
+	p = Cp [k] ;
+	pk1 = (elenk == 0) ? p : cnz ;	    /* do in place if elen[k] == 0 */
+	pk2 = pk1 ;
+	for (k1 = 1 ; k1 <= elenk + 1 ; k1++)
+	{
+	    if (k1 > elenk)
+	    {
+		e = k ;			    /* search the nodes in k */
+		pj = p ;		    /* list of nodes starts at Ci[pj]*/
+		ln = len [k] - elenk ;	    /* length of list of nodes in k */
+	    }
+	    else
+	    {
+		e = Ci [p++] ;		    /* search the nodes in e */
+		pj = Cp [e] ;
+		ln = len [e] ;		    /* length of list of nodes in e */
+	    }
+	    for (k2 = 1 ; k2 <= ln ; k2++)
+	    {
+		i = Ci [pj++] ;
+		if ((nvi = nv [i]) <= 0) continue ; /* node i dead, or seen */
+		dk += nvi ;		    /* degree[Lk] += size of node i */
+		nv [i] = -nvi ;		    /* negate nv[i] to denote i in Lk*/
+		Ci [pk2++] = i ;	    /* place i in Lk */
+		if (next [i] != -1) last [next [i]] = last [i] ;
+		if (last [i] != -1)	    /* remove i from degree list */
+		{
+		    next [last [i]] = next [i] ;
+		}
+		else
+		{
+		    head [degree [i]] = next [i] ;
+		}
+	    }
+	    if (e != k)
+	    {
+		Cp [e] = CS_FLIP (k) ;	    /* absorb e into k */
+		w [e] = 0 ;		    /* e is now a dead element */
+	    }
+	}
+	if (elenk != 0) cnz = pk2 ;	    /* Ci [cnz...nzmax] is free */
+	degree [k] = dk ;		    /* external degree of k - |Lk\i| */
+	Cp [k] = pk1 ;			    /* element k is in Ci[pk1..pk2-1] */
+	len [k] = pk2 - pk1 ;
+	elen [k] = -2 ;			    /* k is now an element */
+	/* --- Find set differences ----------------------------------------- */
+	mark = cs_wclear (mark, lemax, w, n) ;	/* clear w if necessary */
+	for (pk = pk1 ; pk < pk2 ; pk++)    /* scan 1: find |Le\Lk| */
+	{
+	    i = Ci [pk] ;
+	    if ((eln = elen [i]) <= 0) continue ;/* skip if elen[i] empty */
+	    nvi = -nv [i] ;			 /* nv [i] was negated */
+	    wnvi = mark - nvi ;
+	    for (p = Cp [i] ; p <= Cp [i] + eln - 1 ; p++)  /* scan Ei */
+	    {
+		e = Ci [p] ;
+		if (w [e] >= mark)
+		{
+		    w [e] -= nvi ;	    /* decrement |Le\Lk| */
+		}
+		else if (w [e] != 0)	    /* ensure e is a live element */
+		{
+		    w [e] = degree [e] + wnvi ;	/* 1st time e seen in scan 1 */
+		}
+	    }
+	}
+	/* --- Degree update ------------------------------------------------ */
+	for (pk = pk1 ; pk < pk2 ; pk++)    /* scan2: degree update */
+	{
+	    i = Ci [pk] ;		    /* consider node i in Lk */
+	    p1 = Cp [i] ;
+	    p2 = p1 + elen [i] - 1 ;
+	    pn = p1 ;
+	    for (h = 0, d = 0, p = p1 ; p <= p2 ; p++)    /* scan Ei */
+	    {
+		e = Ci [p] ;
+		if (w [e] != 0)		    /* e is an unabsorbed element */
+		{
+		    dext = w [e] - mark ;   /* dext = |Le\Lk| */
+		    if (dext > 0)
+		    {
+			d += dext ;	    /* sum up the set differences */
+			Ci [pn++] = e ;	    /* keep e in Ei */
+			h += e ;	    /* compute the hash of node i */
+		    }
+		    else
+		    {
+			Cp [e] = CS_FLIP (k) ;	/* aggressive absorb. e->k */
+			w [e] = 0 ;		/* e is a dead element */
+		    }
+		}
+	    }
+	    elen [i] = pn - p1 + 1 ;	    /* elen[i] = |Ei| */
+	    p3 = pn ;
+	    p4 = p1 + len [i] ;
+	    for (p = p2 + 1 ; p < p4 ; p++) /* prune edges in Ai */
+	    {
+		j = Ci [p] ;
+		if ((nvj = nv [j]) <= 0) continue ; /* node j dead or in Lk */
+		d += nvj ;		    /* degree(i) += |j| */
+		Ci [pn++] = j ;		    /* place j in node list of i */
+		h += j ;		    /* compute hash for node i */
+	    }
+	    if (d == 0)			    /* check for mass elimination */
+	    {
+		Cp [i] = CS_FLIP (k) ;	    /* absorb i into k */
+		nvi = -nv [i] ;
+		dk -= nvi ;		    /* |Lk| -= |i| */
+		nvk += nvi ;		    /* |k| += nv[i] */
+		nel += nvi ;
+		nv [i] = 0 ;
+		elen [i] = -1 ;		    /* node i is dead */
+	    }
+	    else
+	    {
+		degree [i] = CS_MIN (degree [i], d) ;	/* update degree(i) */
+		Ci [pn] = Ci [p3] ;	    /* move first node to end */
+		Ci [p3] = Ci [p1] ;	    /* move 1st el. to end of Ei */
+		Ci [p1] = k ;		    /* add k as 1st element in of Ei */
+		len [i] = pn - p1 + 1 ;	    /* new len of adj. list of node i */
+		h %= n ;		    /* finalize hash of i */
+		next [i] = hhead [h] ;	    /* place i in hash bucket */
+		hhead [h] = i ;
+		last [i] = h ;		    /* save hash of i in last[i] */
+	    }
+	}				    /* scan2 is done */
+	degree [k] = dk ;		    /* finalize |Lk| */
+	lemax = CS_MAX (lemax, dk) ;
+	mark = cs_wclear (mark+lemax, lemax, w, n) ;	/* clear w */
+	/* --- Supernode detection ------------------------------------------ */
+	for (pk = pk1 ; pk < pk2 ; pk++)
+	{
+	    i = Ci [pk] ;
+	    if (nv [i] >= 0) continue ;		/* skip if i is dead */
+	    h = last [i] ;			/* scan hash bucket of node i */
+	    i = hhead [h] ;
+	    hhead [h] = -1 ;			/* hash bucket will be empty */
+	    for ( ; i != -1 && next [i] != -1 ; i = next [i], mark++)
+	    {
+		ln = len [i] ;
+		eln = elen [i] ;
+		for (p = Cp [i]+1 ; p <= Cp [i] + ln-1 ; p++) w [Ci [p]] = mark;
+		jlast = i ;
+		for (j = next [i] ; j != -1 ; )	/* compare i with all j */
+		{
+		    ok = (len [j] == ln) && (elen [j] == eln) ;
+		    for (p = Cp [j] + 1 ; ok && p <= Cp [j] + ln - 1 ; p++)
+		    {
+			if (w [Ci [p]] != mark) ok = 0 ;    /* compare i and j*/
+		    }
+		    if (ok)			/* i and j are identical */
+		    {
+			Cp [j] = CS_FLIP (i) ;	/* absorb j into i */
+			nv [i] += nv [j] ;
+			nv [j] = 0 ;
+			elen [j] = -1 ;		/* node j is dead */
+			j = next [j] ;		/* delete j from hash bucket */
+			next [jlast] = j ;
+		    }
+		    else
+		    {
+			jlast = j ;		/* j and i are different */
+			j = next [j] ;
+		    }
+		}
+	    }
+	}
+	/* --- Finalize new element------------------------------------------ */
+	for (p = pk1, pk = pk1 ; pk < pk2 ; pk++)   /* finalize Lk */
+	{
+	    i = Ci [pk] ;
+	    if ((nvi = -nv [i]) <= 0) continue ;/* skip if i is dead */
+	    nv [i] = nvi ;			/* restore nv[i] */
+	    d = degree [i] + dk - nvi ;		/* compute external degree(i) */
+	    d = CS_MIN (d, n - nel - nvi) ;
+	    if (head [d] != -1) last [head [d]] = i ;
+	    next [i] = head [d] ;		/* put i back in degree list */
+	    last [i] = -1 ;
+	    head [d] = i ;
+	    mindeg = CS_MIN (mindeg, d) ;	/* find new minimum degree */
+	    degree [i] = d ;
+	    Ci [p++] = i ;			/* place i in Lk */
+	}
+	nv [k] = nvk ;			    /* # nodes absorbed into k */
+	if ((len [k] = p-pk1) == 0)	    /* length of adj list of element k*/
+	{
+	    Cp [k] = -1 ;		    /* k is a root of the tree */
+	    w [k] = 0 ;			    /* k is now a dead element */
+	}
+	if (elenk != 0) cnz = p ;	    /* free unused space in Lk */
+    }
+    /* --- Postordering ----------------------------------------------------- */
+    for (i = 0 ; i < n ; i++) Cp [i] = CS_FLIP (Cp [i]) ;/* fix assembly tree */
+    for (j = 0 ; j <= n ; j++) head [j] = -1 ;
+    for (j = n ; j >= 0 ; j--)		    /* place unordered nodes in lists */
+    {
+	if (nv [j] > 0) continue ;	    /* skip if j is an element */
+	next [j] = head [Cp [j]] ;	    /* place j in list of its parent */
+	head [Cp [j]] = j ;
+    }
+    for (e = n ; e >= 0 ; e--)		    /* place elements in lists */
+    {
+	if (nv [e] <= 0) continue ;	    /* skip unless e is an element */
+	if (Cp [e] != -1)
+	{
+	    next [e] = head [Cp [e]] ;	    /* place e in list of its parent */
+	    head [Cp [e]] = e ;
+	}
+    }
+    for (k = 0, i = 0 ; i <= n ; i++)	    /* postorder the assembly tree */
+    {
+	if (Cp [i] == -1) k = cs_tdfs (i, k, head, next, P, w) ;
+    }
+    return (cs_idone (P, C, W, 1)) ;
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Source/cs_chol.cpp SuiteSparse/CXSparse-C++/Source/cs_chol.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Source/cs_chol.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Source/cs_chol.cpp	2006-11-24 15:56:32.000000000 +0100
@@ -0,0 +1,59 @@
+#include "cs.h"
+/* L = chol (A, [pinv parent cp]), pinv is optional */
+csn *cs_chol (const cs *A, const css *S)
+{
+    CS_ENTRY d, lki, *Lx, *x, *Cx ;
+    CS_INT top, i, p, k, n, *Li, *Lp, *cp, *pinv, *s, *c, *parent, *Cp, *Ci ;
+    cs *L, *C, *E ;
+    csn *N ;
+    if (!CS_CSC (A) || !S || !S->cp || !S->parent) return (NULL) ;
+    n = A->n ;
+    N = (csn *)cs_calloc (1, sizeof (csn)) ;	    /* allocate result */
+    c = (CS_INT *)cs_malloc (2*n, sizeof (CS_INT)) ;	    /* get CS_INT workspace */
+    x = (CS_ENTRY *)cs_malloc (n, sizeof (CS_ENTRY)) ;    /* get CS_ENTRY workspace */
+    cp = S->cp ; pinv = S->pinv ; parent = S->parent ;
+    C = pinv ? cs_symperm (A, pinv, 1) : ((cs *) A) ;
+    E = pinv ? C : NULL ;	    /* E is alias for A, or a copy E=A(p,p) */
+    if (!N || !c || !x || !C) return (cs_ndone (N, E, c, x, 0)) ;
+    s = c + n ;
+    Cp = C->p ; Ci = C->i ; Cx = C->x ;
+    N->L = L = cs_spalloc (n, n, cp [n], 1, 0) ;    /* allocate result */
+    if (!L) return (cs_ndone (N, E, c, x, 0)) ;
+    Lp = L->p ; Li = L->i ; Lx = L->x ;
+    for (k = 0 ; k < n ; k++) Lp [k] = c [k] = cp [k] ;
+    for (k = 0 ; k < n ; k++)	    /* compute L(:,k) for L*L' = C */
+    {
+	/* --- Nonzero pattern of L(k,:) ------------------------------------ */
+	top = cs_ereach (C, k, parent, s, c) ;	    /* find pattern of L(k,:) */
+	x [k] = 0 ;				    /* x (0:k) is now zero */
+	for (p = Cp [k] ; p < Cp [k+1] ; p++)	    /* x = full(triu(C(:,k))) */
+	{
+	    if (Ci [p] <= k) x [Ci [p]] = Cx [p] ;
+	}
+	d = x [k] ;			/* d = C(k,k) */
+	x [k] = 0 ;			/* clear x for k+1st iteration */
+	/* --- Triangular solve --------------------------------------------- */
+	for ( ; top < n ; top++)    /* solve L(0:k-1,0:k-1) * x = C(:,k) */
+	{
+	    i = s [top] ;		/* s [top..n-1] is pattern of L(k,:) */
+	    lki = x [i] / Lx [Lp [i]] ; /* L(k,i) = x (i) / L(i,i) */
+	    x [i] = 0 ;			/* clear x for k+1st iteration */
+	    for (p = Lp [i] + 1 ; p < c [i] ; p++)
+	    {
+		x [Li [p]] -= Lx [p] * lki ;
+	    }
+	    d -= lki * CS_CONJ (lki) ;		/* d = d - L(k,i)*L(k,i) */
+	    p = c [i]++ ;
+	    Li [p] = k ;		/* store L(k,i) in column i */
+	    Lx [p] = lki ;
+	}
+	/* --- Compute L(k,k) ----------------------------------------------- */
+	if (CS_REAL (d) <= 0 || CS_IMAG (d) != 0)
+	    return (cs_ndone (N, E, c, x, 0)) ; /* not pos def */
+	p = c [k]++ ;
+	Li [p] = k ;		    /* store L(k,k) = sqrt (d) in column k */
+	Lx [p] = sqrt (d) ;
+    }
+    Lp [n] = cp [n] ;		    /* finalize L */
+    return (cs_ndone (N, E, c, x, 1)) ; /* success: free E,s,x; return N */
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Source/cs_cholsol.cpp SuiteSparse/CXSparse-C++/Source/cs_cholsol.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Source/cs_cholsol.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Source/cs_cholsol.cpp	2006-11-24 15:56:48.000000000 +0100
@@ -0,0 +1,26 @@
+#include "cs.h"
+/* x=A\b where A is symmetric positive definite; b overwritten with solution */
+CS_INT cs_cholsol (CS_INT order, const cs *A, CS_ENTRY *b)
+{
+    CS_ENTRY *x ;
+    css *S ;
+    csn *N ;
+    CS_INT n, ok ;
+    if (!CS_CSC (A) || !b) return (0) ;	    /* check inputs */
+    n = A->n ;
+    S = cs_schol (order, A) ;		    /* ordering and symbolic analysis */
+    N = cs_chol (A, S) ;		    /* numeric Cholesky factorization */
+    x = (CS_ENTRY *)cs_malloc (n, sizeof (CS_ENTRY)) ;    /* get workspace */
+    ok = (S && N && x) ;
+    if (ok)
+    {
+	cs_ipvec (S->pinv, b, x, n) ;	/* x = P*b */
+	cs_lsolve (N->L, x) ;		/* x = L\x */
+	cs_ltsolve (N->L, x) ;		/* x = L'\x */
+	cs_pvec (S->pinv, x, b, n) ;	/* b = P'*x */
+    }
+    cs_free (x) ;
+    cs_sfree (S) ;
+    cs_nfree (N) ;
+    return (ok) ;
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Source/cs_compress.cpp SuiteSparse/CXSparse-C++/Source/cs_compress.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Source/cs_compress.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Source/cs_compress.cpp	2006-11-24 16:05:58.000000000 +0100
@@ -0,0 +1,22 @@
+#include "cs.h"
+/* C = compressed-column form of a triplet matrix T */
+cs *cs_compress (const cs *T)
+{
+    CS_INT m, n, nz, p, k, *Cp, *Ci, *w, *Ti, *Tj ;
+    CS_ENTRY *Cx, *Tx ;
+    cs *C ;
+    if (!CS_TRIPLET (T)) return (NULL) ;		/* check inputs */
+    m = T->m ; n = T->n ; Ti = T->i ; Tj = T->p ; Tx = T->x ; nz = T->nz ;
+    C = cs_spalloc (m, n, nz, Tx != NULL, 0) ;		/* allocate result */
+    w = (CS_INT *)cs_calloc (n, sizeof (CS_INT)) ;			/* get workspace */
+    if (!C || !w) return (cs_done (C, w, NULL, 0)) ;	/* out of memory */
+    Cp = C->p ; Ci = C->i ; Cx = C->x ;
+    for (k = 0 ; k < nz ; k++) w [Tj [k]]++ ;		/* column counts */
+    cs_cumsum (Cp, w, n) ;				/* column pointers */
+    for (k = 0 ; k < nz ; k++)
+    {
+	Ci [p = w [Tj [k]]++] = Ti [k] ;    /* A(i,j) is the pth entry in C */
+	if (Cx) Cx [p] = Tx [k] ;
+    }
+    return (cs_done (C, w, NULL, 1)) ;	    /* success; free w and return C */
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Source/cs_convert.cpp SuiteSparse/CXSparse-C++/Source/cs_convert.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Source/cs_convert.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Source/cs_convert.cpp	2006-11-24 15:50:28.000000000 +0100
@@ -0,0 +1,93 @@
+#include "cs.h"
+
+/* convert from complex to real (int version) */
+/* C = real(A) if real is true, imag(A) otherwise */
+cs_di *cs_i_real (cs_ci *A, int real)
+{
+    cs_di *C ;
+    int n, triplet, nn, p, nz, *Ap, *Ai, *Cp, *Ci ;
+    CPLX *Ax ;
+    double *Cx ;
+    if (!A || !A->x) return (NULL) ;	/* return if A NULL or pattern-only */
+    n = A->n ; Ap = A->p ; Ai = A->i ; Ax = A->x ;
+    triplet = (A->nz >= 0) ;		/* true if A is a triplet matrix */
+    nz = triplet ? A->nz : Ap [n] ;
+    C = cs_di_spalloc (A->m, n, A->nzmax, 1, triplet) ;
+    if (!C) return (NULL) ;
+    Cp = C->p ; Ci = C->i ; Cx = C->x ;
+    nn = triplet ? nz : (n+1) ;
+    for (p = 0 ; p < nz ; p++) Ci [p] = Ai [p] ;
+    for (p = 0 ; p < nn ; p++) Cp [p] = Ap [p] ;
+    for (p = 0 ; p < nz ; p++) Cx [p] = real ? (Ax [p].real ()) : (Ax [p].imag ()) ;
+    if (triplet) C->nz = nz ;
+    return (C) ;
+}
+
+/* convert from real to complex (int version) */
+/* C = A if real is true, or C = i*A otherwise */
+cs_ci *cs_i_complex (cs_di *A, int real)
+{
+    cs_ci *C ;
+    int n, triplet, nn, p, nz, *Ap, *Ai, *Cp, *Ci ;
+    double *Ax ;
+    CPLX *Cx ;
+    if (!A || !A->x) return (NULL) ;	/* return if A NULL or pattern-only */
+    n = A->n ; Ap = A->p ; Ai = A->i ; Ax = A->x ;
+    triplet = (A->nz >= 0) ;		/* true if A is a triplet matrix */
+    nz = triplet ? A->nz : Ap [n] ;
+    C = cs_ci_spalloc (A->m, n, A->nzmax, 1, triplet) ;
+    if (!C) return (NULL) ;
+    Cp = C->p ; Ci = C->i ; Cx = C->x ;
+    nn = triplet ? nz : (n+1) ;
+    for (p = 0 ; p < nz ; p++) Ci [p] = Ai [p] ;
+    for (p = 0 ; p < nn ; p++) Cp [p] = Ap [p] ;
+    for (p = 0 ; p < nz ; p++) Cx [p] = real ? Ax [p] : (I * Ax [p]) ;
+    if (triplet) C->nz = nz ;
+    return (C) ;
+}
+
+/* convert from complex to real (UF_long version) */
+/* C = real(A) if real is true, imag(A) otherwise */
+cs_dl *cs_l_real (cs_cl *A, UF_long real)
+{
+    cs_dl *C ;
+    UF_long n, triplet, nn, p, nz, *Ap, *Ai, *Cp, *Ci ;
+    CPLX *Ax ;
+    double *Cx ;
+    if (!A || !A->x) return (NULL) ;	/* return if A NULL or pattern-only */
+    n = A->n ; Ap = A->p ; Ai = A->i ; Ax = A->x ;
+    triplet = (A->nz >= 0) ;		/* true if A is a triplet matrix */
+    nz = triplet ? A->nz : Ap [n] ;
+    C = cs_dl_spalloc (A->m, n, A->nzmax, 1, triplet) ;
+    if (!C) return (NULL) ;
+    Cp = C->p ; Ci = C->i ; Cx = C->x ;
+    nn = triplet ? nz : (n+1) ;
+    for (p = 0 ; p < nz ; p++) Ci [p] = Ai [p] ;
+    for (p = 0 ; p < nn ; p++) Cp [p] = Ap [p] ;
+    for (p = 0 ; p < nz ; p++) Cx [p] = real ? (Ax [p].real ()) : (Ax [p].imag ()) ;
+    if (triplet) C->nz = nz ;
+    return (C) ;
+}
+
+/* convert from real to complex (UF_long version) */
+/* C = A if real is true, or C = i*A otherwise */
+cs_cl *cs_l_complex (cs_dl *A, UF_long real)
+{
+    cs_cl *C ;
+    UF_long n, triplet, nn, p, nz, *Ap, *Ai, *Cp, *Ci ;
+    double *Ax ;
+    CPLX *Cx ;
+    if (!A || !A->x) return (NULL) ;	/* return if A NULL or pattern-only */
+    n = A->n ; Ap = A->p ; Ai = A->i ; Ax = A->x ;
+    triplet = (A->nz >= 0) ;		/* true if A is a triplet matrix */
+    nz = triplet ? A->nz : Ap [n] ;
+    C = cs_cl_spalloc (A->m, n, A->nzmax, 1, triplet) ;
+    if (!C) return (NULL) ;
+    Cp = C->p ; Ci = C->i ; Cx = C->x ;
+    nn = triplet ? nz : (n+1) ;
+    for (p = 0 ; p < nz ; p++) Ci [p] = Ai [p] ;
+    for (p = 0 ; p < nn ; p++) Cp [p] = Ap [p] ;
+    for (p = 0 ; p < nz ; p++) Cx [p] = real ? Ax [p] : (I * Ax [p]) ;
+    if (triplet) C->nz = nz ;
+    return (C) ;
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Source/cs_counts.cpp SuiteSparse/CXSparse-C++/Source/cs_counts.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Source/cs_counts.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Source/cs_counts.cpp	2006-11-24 15:57:10.000000000 +0100
@@ -0,0 +1,61 @@
+#include "cs.h"
+/* column counts of LL'=A or LL'=A'A, given parent & post ordering */
+#define HEAD(k,j) (ata ? head [k] : j)
+#define NEXT(J)   (ata ? next [J] : -1)
+static void init_ata (cs *AT, const CS_INT *post, CS_INT *w, CS_INT **head, CS_INT **next)
+{
+    CS_INT i, k, p, m = AT->n, n = AT->m, *ATp = AT->p, *ATi = AT->i ;
+    *head = w+4*n, *next = w+5*n+1 ;
+    for (k = 0 ; k < n ; k++) w [post [k]] = k ;    /* invert post */
+    for (i = 0 ; i < m ; i++)
+    {
+	for (k = n, p = ATp[i] ; p < ATp[i+1] ; p++) k = CS_MIN (k, w [ATi[p]]);
+	(*next) [i] = (*head) [k] ;	/* place row i in linked list k */
+	(*head) [k] = i ;
+    }
+}
+CS_INT *cs_counts (const cs *A, const CS_INT *parent, const CS_INT *post, CS_INT ata)
+{
+    CS_INT i, j, k, n, m, J, s, p, q, jleaf, *ATp, *ATi, *maxfirst, *prevleaf,
+	*ancestor, *head = NULL, *next = NULL, *colcount, *w, *first, *delta ;
+    cs *AT ;
+    if (!CS_CSC (A) || !parent || !post) return (NULL) ;    /* check inputs */
+    m = A->m ; n = A->n ;
+    s = 4*n + (ata ? (n+m+1) : 0) ;
+    delta = colcount = (CS_INT *)cs_malloc (n, sizeof (CS_INT)) ;	/* allocate result */
+    w = (CS_INT *)cs_malloc (s, sizeof (CS_INT)) ;			/* get workspace */
+    AT = cs_transpose (A, 0) ;				/* AT = A' */
+    if (!AT || !colcount || !w) return (cs_idone (colcount, AT, w, 0)) ;
+    ancestor = w ; maxfirst = w+n ; prevleaf = w+2*n ; first = w+3*n ;
+    for (k = 0 ; k < s ; k++) w [k] = -1 ;	/* clear workspace w [0..s-1] */
+    for (k = 0 ; k < n ; k++)			/* find first [j] */
+    {
+	j = post [k] ;
+	delta [j] = (first [j] == -1) ? 1 : 0 ;  /* delta[j]=1 if j is a leaf */
+	for ( ; j != -1 && first [j] == -1 ; j = parent [j]) first [j] = k ;
+    }
+    ATp = AT->p ; ATi = AT->i ;
+    if (ata) init_ata (AT, post, w, &head, &next) ;
+    for (i = 0 ; i < n ; i++) ancestor [i] = i ; /* each node in its own set */
+    for (k = 0 ; k < n ; k++)
+    {
+	j = post [k] ;		/* j is the kth node in postordered etree */
+	if (parent [j] != -1) delta [parent [j]]-- ;	/* j is not a root */
+	for (J = HEAD (k,j) ; J != -1 ; J = NEXT (J))	/* J=j for LL'=A case */
+	{
+	    for (p = ATp [J] ; p < ATp [J+1] ; p++)
+	    {
+		i = ATi [p] ;
+		q = cs_leaf (i, j, first, maxfirst, prevleaf, ancestor, &jleaf);
+		if (jleaf >= 1) delta [j]++ ;   /* A(i,j) is in skeleton */
+		if (jleaf == 2) delta [q]-- ;	/* account for overlap in q */
+	    }
+	}
+	if (parent [j] != -1) ancestor [j] = parent [j] ;
+    }
+    for (j = 0 ; j < n ; j++)		/* sum up delta's of each child */
+    {
+	if (parent [j] != -1) colcount [parent [j]] += colcount [j] ;
+    }
+    return (cs_idone (colcount, AT, w, 1)) ;	/* success: free workspace */
+} 
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Source/cs_cumsum.cpp SuiteSparse/CXSparse-C++/Source/cs_cumsum.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Source/cs_cumsum.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Source/cs_cumsum.cpp	2006-11-24 16:13:06.000000000 +0100
@@ -0,0 +1,17 @@
+#include "cs.h"
+/* p [0..n] = cumulative sum of c [0..n-1], and then copy p [0..n-1] into c */
+double cs_cumsum (CS_INT *p, CS_INT *c, CS_INT n)
+{
+    CS_INT i, nz = 0 ;
+    CS_ENTRY nz2 = 0 ;
+    if (!p || !c) return (-1) ;	    /* check inputs */
+    for (i = 0 ; i < n ; i++)
+    {
+	p [i] = nz ;
+	nz += c [i] ;
+	nz2 += c [i] ;		    /* also in CS_ENTRY to avoid CS_INT overflow */
+	c [i] = p [i] ;		    /* also copy p[0..n-1] back into c[0..n-1]*/
+    }
+    p [n] = nz ;
+    return (CS_REAL (nz2)) ;		    /* return sum (c [0..n-1]) */
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Source/cs_dfs.cpp SuiteSparse/CXSparse-C++/Source/cs_dfs.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Source/cs_dfs.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Source/cs_dfs.cpp	2006-08-25 08:04:44.000000000 +0200
@@ -0,0 +1,36 @@
+#include "cs.h"
+/* depth-first-search of the graph of a matrix, starting at node j */
+CS_INT cs_dfs (CS_INT j, cs *G, CS_INT top, CS_INT *xi, CS_INT *pstack, const CS_INT *pinv)
+{
+    CS_INT i, p, p2, done, jnew, head = 0, *Gp, *Gi ;
+    if (!CS_CSC (G) || !xi || !pstack) return (-1) ;	/* check inputs */
+    Gp = G->p ; Gi = G->i ;
+    xi [0] = j ;		/* initialize the recursion stack */
+    while (head >= 0)
+    {
+	j = xi [head] ;		/* get j from the top of the recursion stack */
+	jnew = pinv ? (pinv [j]) : j ;
+	if (!CS_MARKED (Gp, j))
+	{
+	    CS_MARK (Gp, j) ;	    /* mark node j as visited */
+	    pstack [head] = (jnew < 0) ? 0 : CS_UNFLIP (Gp [jnew]) ;
+	}
+	done = 1 ;		    /* node j done if no unvisited neighbors */
+	p2 = (jnew < 0) ? 0 : CS_UNFLIP (Gp [jnew+1]) ;
+	for (p = pstack [head] ; p < p2 ; p++)  /* examine all neighbors of j */
+	{
+	    i = Gi [p] ;	    /* consider neighbor node i */
+	    if (CS_MARKED (Gp, i)) continue ;	/* skip visited node i */
+	    pstack [head] = p ;	    /* pause depth-first search of node j */
+	    xi [++head] = i ;	    /* start dfs at node i */
+	    done = 0 ;		    /* node j is not done */
+	    break ;		    /* break, to start dfs (i) */
+	}
+	if (done)		/* depth-first search at node j is done */
+	{
+	    head-- ;		/* remove j from the recursion stack */
+	    xi [--top] = j ;	/* and place in the output stack */
+	}
+    }
+    return (top) ;
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Source/cs_dmperm.cpp SuiteSparse/CXSparse-C++/Source/cs_dmperm.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Source/cs_dmperm.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Source/cs_dmperm.cpp	2006-08-25 08:04:44.000000000 +0200
@@ -0,0 +1,144 @@
+#include "cs.h"
+/* breadth-first search for coarse decomposition (C0,C1,R1 or R0,R3,C3) */
+static CS_INT cs_bfs (const cs *A, CS_INT n, CS_INT *wi, CS_INT *wj, CS_INT *queue,
+    const CS_INT *imatch, const CS_INT *jmatch, CS_INT mark)
+{
+    CS_INT *Ap, *Ai, head = 0, tail = 0, j, i, p, j2 ;
+    cs *C ;
+    for (j = 0 ; j < n ; j++)		/* place all unmatched nodes in queue */
+    {
+	if (imatch [j] >= 0) continue ;	/* skip j if matched */
+	wj [j] = 0 ;			/* j in set C0 (R0 if transpose) */
+	queue [tail++] = j ;		/* place unmatched col j in queue */
+    }
+    if (tail == 0) return (1) ;		/* quick return if no unmatched nodes */
+    C = (mark == 1) ? ((cs *) A) : cs_transpose (A, 0) ;
+    if (!C) return (0) ;		/* bfs of C=A' to find R3,C3 from R0 */
+    Ap = C->p ; Ai = C->i ;
+    while (head < tail)			/* while queue is not empty */
+    {
+	j = queue [head++] ;		/* get the head of the queue */
+	for (p = Ap [j] ; p < Ap [j+1] ; p++)
+	{
+	    i = Ai [p] ;
+	    if (wi [i] >= 0) continue ;	/* skip if i is marked */
+	    wi [i] = mark ;		/* i in set R1 (C3 if transpose) */
+	    j2 = jmatch [i] ;		/* traverse alternating path to j2 */
+	    if (wj [j2] >= 0) continue ;/* skip j2 if it is marked */
+	    wj [j2] = mark ;		/* j2 in set C1 (R3 if transpose) */
+	    queue [tail++] = j2 ;	/* add j2 to queue */
+	}
+    }
+    if (mark != 1) cs_spfree (C) ;	/* free A' if it was created */
+    return (1) ;
+}
+
+/* collect matched rows and columns into p and q */
+static void cs_matched (CS_INT n, const CS_INT *wj, const CS_INT *imatch, CS_INT *p, CS_INT *q,
+    CS_INT *cc, CS_INT *rr, CS_INT set, CS_INT mark)
+{
+    CS_INT kc = cc [set], j ;
+    CS_INT kr = rr [set-1] ;
+    for (j = 0 ; j < n ; j++)
+    {
+	if (wj [j] != mark) continue ;	    /* skip if j is not in C set */
+	p [kr++] = imatch [j] ;
+	q [kc++] = j ;
+    }
+    cc [set+1] = kc ;
+    rr [set] = kr ;
+}
+
+/* collect unmatched rows into the permutation vector p */
+static void cs_unmatched (CS_INT m, const CS_INT *wi, CS_INT *p, CS_INT *rr, CS_INT set)
+{
+    CS_INT i, kr = rr [set] ;
+    for (i = 0 ; i < m ; i++) if (wi [i] == 0) p [kr++] = i ;
+    rr [set+1] = kr ;
+}
+
+/* return 1 if row i is in R2 */
+static CS_INT cs_rprune (CS_INT i, CS_INT j, CS_ENTRY aij, void *other)
+{
+    CS_INT *rr = (CS_INT *) other ;
+    return (i >= rr [1] && i < rr [2]) ;
+}
+
+/* Given A, compute coarse and then fine dmperm */
+csd *cs_dmperm (const cs *A, CS_INT seed)
+{
+    CS_INT m, n, i, j, k, cnz, nc, *jmatch, *imatch, *wi, *wj, *pinv, *Cp, *Ci,
+	*ps, *rs, nb1, nb2, *p, *q, *cc, *rr, *r, *s, ok ;
+    cs *C ;
+    csd *D, *scc ;
+    /* --- Maximum matching ------------------------------------------------- */
+    if (!CS_CSC (A)) return (NULL) ;		/* check inputs */
+    m = A->m ; n = A->n ;
+    D = cs_dalloc (m, n) ;			/* allocate result */
+    if (!D) return (NULL) ;
+    p = D->p ; q = D->q ; r = D->r ; s = D->s ; cc = D->cc ; rr = D->rr ;
+    jmatch = cs_maxtrans (A, seed) ;		/* max transversal */
+    imatch = jmatch + m ;			/* imatch = inverse of jmatch */
+    if (!jmatch) return (cs_ddone (D, NULL, jmatch, 0)) ;
+    /* --- Coarse decomposition --------------------------------------------- */
+    wi = r ; wj = s ;				/* use r and s as workspace */
+    for (j = 0 ; j < n ; j++) wj [j] = -1 ;	/* unmark all cols for bfs */
+    for (i = 0 ; i < m ; i++) wi [i] = -1 ;	/* unmark all rows for bfs */
+    cs_bfs (A, n, wi, wj, q, imatch, jmatch, 1) ;	/* find C1, R1 from C0*/
+    ok = cs_bfs (A, m, wj, wi, p, jmatch, imatch, 3) ;	/* find R3, C3 from R0*/
+    if (!ok) return (cs_ddone (D, NULL, jmatch, 0)) ;
+    cs_unmatched (n, wj, q, cc, 0) ;			/* unmatched set C0 */
+    cs_matched (n, wj, imatch, p, q, cc, rr, 1, 1) ;	/* set R1 and C1 */
+    cs_matched (n, wj, imatch, p, q, cc, rr, 2, -1) ;	/* set R2 and C2 */
+    cs_matched (n, wj, imatch, p, q, cc, rr, 3, 3) ;	/* set R3 and C3 */
+    cs_unmatched (m, wi, p, rr, 3) ;			/* unmatched set R0 */
+    cs_free (jmatch) ;
+    /* --- Fine decomposition ----------------------------------------------- */
+    pinv = cs_pinv (p, m) ;	    /* pinv=p' */
+    if (!pinv) return (cs_ddone (D, NULL, NULL, 0)) ;
+    C = cs_permute (A, pinv, q, 0) ;/* C=A(p,q) (it will hold A(R2,C2)) */
+    cs_free (pinv) ;
+    if (!C) return (cs_ddone (D, NULL, NULL, 0)) ;
+    Cp = C->p ;
+    nc = cc [3] - cc [2] ;	    /* delete cols C0, C1, and C3 from C */
+    if (cc [2] > 0) for (j = cc [2] ; j <= cc [3] ; j++) Cp [j-cc[2]] = Cp [j] ;
+    C->n = nc ;
+    if (rr [2] - rr [1] < m)	    /* delete rows R0, R1, and R3 from C */
+    {
+	cs_fkeep (C, cs_rprune, rr) ;
+	cnz = Cp [nc] ;
+	Ci = C->i ;
+	if (rr [1] > 0) for (k = 0 ; k < cnz ; k++) Ci [k] -= rr [1] ;
+    }
+    C->m = nc ;
+    scc = cs_scc (C) ;		    /* find strongly connected components of C*/
+    if (!scc) return (cs_ddone (D, C, NULL, 0)) ;
+    /* --- Combine coarse and fine decompositions --------------------------- */
+    ps = scc->p ;		    /* C(ps,ps) is the permuted matrix */
+    rs = scc->r ;		    /* kth block is rs[k]..rs[k+1]-1 */
+    nb1 = scc->nb  ;		    /* # of blocks of A(R2,C2) */
+    for (k = 0 ; k < nc ; k++) wj [k] = q [ps [k] + cc [2]] ;
+    for (k = 0 ; k < nc ; k++) q [k + cc [2]] = wj [k] ;
+    for (k = 0 ; k < nc ; k++) wi [k] = p [ps [k] + rr [1]] ;
+    for (k = 0 ; k < nc ; k++) p [k + rr [1]] = wi [k] ;
+    nb2 = 0 ;			    /* create the fine block partitions */
+    r [0] = s [0] = 0 ;
+    if (cc [2] > 0) nb2++ ;	    /* leading coarse block A (R1, [C0 C1]) */
+    for (k = 0 ; k < nb1 ; k++)	    /* coarse block A (R2,C2) */
+    {
+	r [nb2] = rs [k] + rr [1] ; /* A (R2,C2) splits into nb1 fine blocks */
+	s [nb2] = rs [k] + cc [2] ;
+	nb2++ ;
+    }
+    if (rr [2] < m)
+    {
+	r [nb2] = rr [2] ;	    /* trailing coarse block A ([R3 R0], C3) */
+	s [nb2] = cc [3] ;
+	nb2++ ;
+    }
+    r [nb2] = m ;
+    s [nb2] = n ;
+    D->nb = nb2 ;
+    cs_dfree (scc) ;
+    return (cs_ddone (D, C, NULL, 1)) ;
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Source/cs_droptol.cpp SuiteSparse/CXSparse-C++/Source/cs_droptol.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Source/cs_droptol.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Source/cs_droptol.cpp	2006-08-25 08:04:44.000000000 +0200
@@ -0,0 +1,9 @@
+#include "cs.h"
+static CS_INT cs_tol (CS_INT i, CS_INT j, CS_ENTRY aij, void *tol)
+{
+    return (CS_ABS (aij) > *((double *) tol)) ;
+}
+CS_INT cs_droptol (cs *A, double tol)
+{
+    return (cs_fkeep (A, &cs_tol, &tol)) ;    /* keep all large entries */
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Source/cs_dropzeros.cpp SuiteSparse/CXSparse-C++/Source/cs_dropzeros.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Source/cs_dropzeros.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Source/cs_dropzeros.cpp	2006-11-24 16:15:48.000000000 +0100
@@ -0,0 +1,9 @@
+#include "cs.h"
+static CS_INT cs_nonzero (CS_INT i, CS_INT j, CS_ENTRY aij, void *other)
+{
+    return (aij != CS_ENTRY(0)) ;
+}
+CS_INT cs_dropzeros (cs *A)
+{
+    return (cs_fkeep (A, &cs_nonzero, NULL)) ;	/* keep all nonzero entries */
+} 
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Source/cs_dupl.cpp SuiteSparse/CXSparse-C++/Source/cs_dupl.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Source/cs_dupl.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Source/cs_dupl.cpp	2006-11-24 15:57:34.000000000 +0100
@@ -0,0 +1,34 @@
+#include "cs.h"
+/* remove duplicate entries from A */
+CS_INT cs_dupl (cs *A)
+{
+    CS_INT i, j, p, q, nz = 0, n, m, *Ap, *Ai, *w ;
+    CS_ENTRY *Ax ;
+    if (!CS_CSC (A)) return (0) ;		/* check inputs */
+    m = A->m ; n = A->n ; Ap = A->p ; Ai = A->i ; Ax = A->x ;
+    w = (CS_INT *)cs_malloc (m, sizeof (CS_INT)) ;		/* get workspace */
+    if (!w) return (0) ;			/* out of memory */
+    for (i = 0 ; i < m ; i++) w [i] = -1 ;	/* row i not yet seen */
+    for (j = 0 ; j < n ; j++)
+    {
+	q = nz ;				/* column j will start at q */
+	for (p = Ap [j] ; p < Ap [j+1] ; p++)
+	{
+	    i = Ai [p] ;			/* A(i,j) is nonzero */
+	    if (w [i] >= q)
+	    {
+		Ax [w [i]] += Ax [p] ;		/* A(i,j) is a duplicate */
+	    }
+	    else
+	    {
+		w [i] = nz ;			/* record where row i occurs */
+		Ai [nz] = i ;			/* keep A(i,j) */
+		Ax [nz++] = Ax [p] ;
+	    }
+	}
+	Ap [j] = q ;				/* record start of column j */
+    }
+    Ap [n] = nz ;				/* finalize A */
+    cs_free (w) ;				/* free workspace */
+    return (cs_sprealloc (A, 0)) ;		/* remove extra space from A */
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Source/cs_entry.cpp SuiteSparse/CXSparse-C++/Source/cs_entry.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Source/cs_entry.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Source/cs_entry.cpp	2006-08-25 08:04:44.000000000 +0200
@@ -0,0 +1,13 @@
+#include "cs.h"
+/* add an entry to a triplet matrix; return 1 if ok, 0 otherwise */
+CS_INT cs_entry (cs *T, CS_INT i, CS_INT j, CS_ENTRY x)
+{
+    if (!CS_TRIPLET (T) || i < 0 || j < 0) return (0) ;	    /* check inputs */
+    if (T->nz >= T->nzmax && !cs_sprealloc (T,2*(T->nzmax))) return (0) ;
+    if (T->x) T->x [T->nz] = x ;
+    T->i [T->nz] = i ;
+    T->p [T->nz++] = j ;
+    T->m = CS_MAX (T->m, i+1) ;
+    T->n = CS_MAX (T->n, j+1) ;
+    return (1) ;
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Source/cs_ereach.cpp SuiteSparse/CXSparse-C++/Source/cs_ereach.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Source/cs_ereach.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Source/cs_ereach.cpp	2006-08-25 08:04:46.000000000 +0200
@@ -0,0 +1,23 @@
+#include "cs.h"
+/* find nonzero pattern of Cholesky L(k,1:k-1) using etree and triu(A(:,k)) */
+CS_INT cs_ereach (const cs *A, CS_INT k, const CS_INT *parent, CS_INT *s, CS_INT *w)
+{
+    CS_INT i, p, n, len, top, *Ap, *Ai ;
+    if (!CS_CSC (A) || !parent || !s || !w) return (-1) ;   /* check inputs */
+    top = n = A->n ; Ap = A->p ; Ai = A->i ;
+    CS_MARK (w, k) ;		    /* mark node k as visited */
+    for (p = Ap [k] ; p < Ap [k+1] ; p++)
+    {
+	i = Ai [p] ;		    /* A(i,k) is nonzero */
+	if (i > k) continue ;	    /* only use upper triangular part of A */
+	for (len = 0 ; !CS_MARKED (w,i) ; i = parent [i]) /* traverse up etree*/
+	{
+	    s [len++] = i ;	    /* L(k,i) is nonzero */
+	    CS_MARK (w, i) ;	    /* mark i as visited */
+	}
+	while (len > 0) s [--top] = s [--len] ; /* push path onto stack */
+    }
+    for (p = top ; p < n ; p++) CS_MARK (w, s [p]) ;	/* unmark all nodes */
+    CS_MARK (w, k) ;		    /* unmark node k */
+    return (top) ;		    /* s [top..n-1] contains pattern of L(k,:)*/
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Source/cs_etree.cpp SuiteSparse/CXSparse-C++/Source/cs_etree.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Source/cs_etree.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Source/cs_etree.cpp	2006-11-24 15:57:54.000000000 +0100
@@ -0,0 +1,30 @@
+#include "cs.h"
+/* compute the etree of A (using triu(A), or A'A without forming A'A */
+CS_INT *cs_etree (const cs *A, CS_INT ata)
+{
+    CS_INT i, k, p, m, n, inext, *Ap, *Ai, *w, *parent, *ancestor, *prev ;
+    if (!CS_CSC (A)) return (NULL) ;	    /* check inputs */
+    m = A->m ; n = A->n ; Ap = A->p ; Ai = A->i ;
+    parent = (CS_INT *)cs_malloc (n, sizeof (CS_INT)) ;		/* allocate result */
+    w = (CS_INT *)cs_malloc (n + (ata ? m : 0), sizeof (CS_INT)) ;	/* get workspace */
+    if (!w || !parent) return (cs_idone (parent, NULL, w, 0)) ;
+    ancestor = w ; prev = w + n ;
+    if (ata) for (i = 0 ; i < m ; i++) prev [i] = -1 ;
+    for (k = 0 ; k < n ; k++)
+    {
+	parent [k] = -1 ;		    /* node k has no parent yet */
+	ancestor [k] = -1 ;		    /* nor does k have an ancestor */
+	for (p = Ap [k] ; p < Ap [k+1] ; p++)
+	{
+	    i = ata ? (prev [Ai [p]]) : (Ai [p]) ;
+	    for ( ; i != -1 && i < k ; i = inext)   /* traverse from i to k */
+	    {
+		inext = ancestor [i] ;		    /* inext = ancestor of i */
+		ancestor [i] = k ;		    /* path compression */
+		if (inext == -1) parent [i] = k ;   /* no anc., parent is k */
+	    }
+	    if (ata) prev [Ai [p]] = k ;
+	}
+    }
+    return (cs_idone (parent, NULL, w, 1)) ;
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Source/cs_fkeep.cpp SuiteSparse/CXSparse-C++/Source/cs_fkeep.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Source/cs_fkeep.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Source/cs_fkeep.cpp	2006-08-25 08:04:44.000000000 +0200
@@ -0,0 +1,25 @@
+#include "cs.h"
+/* drop entries for which fkeep(A(i,j)) is false; return nz if OK, else -1 */
+CS_INT cs_fkeep (cs *A, CS_INT (*fkeep) (CS_INT, CS_INT, CS_ENTRY, void *), void *other)
+{
+    CS_INT j, p, nz = 0, n, *Ap, *Ai ;
+    CS_ENTRY *Ax ;
+    if (!CS_CSC (A) || !fkeep) return (-1) ;	/* check inputs */
+    n = A->n ; Ap = A->p ; Ai = A->i ; Ax = A->x ;
+    for (j = 0 ; j < n ; j++)
+    {
+	p = Ap [j] ;			    /* get current location of col j */
+	Ap [j] = nz ;			    /* record new location of col j */
+	for ( ; p < Ap [j+1] ; p++)
+	{
+	    if (fkeep (Ai [p], j, Ax ? Ax [p] : 1, other))
+	    {
+		if (Ax) Ax [nz] = Ax [p] ;  /* keep A(i,j) */
+		Ai [nz++] = Ai [p] ;
+	    }
+	}
+    }
+    Ap [n] = nz ;			    /* finalize A */
+    cs_sprealloc (A, 0) ;		    /* remove extra space from A */
+    return (nz) ;
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Source/cs_gaxpy.cpp SuiteSparse/CXSparse-C++/Source/cs_gaxpy.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Source/cs_gaxpy.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Source/cs_gaxpy.cpp	2006-08-25 08:04:44.000000000 +0200
@@ -0,0 +1,17 @@
+#include "cs.h"
+/* y = A*x+y */
+CS_INT cs_gaxpy (const cs *A, const CS_ENTRY *x, CS_ENTRY *y)
+{
+    CS_INT p, j, n, *Ap, *Ai ;
+    CS_ENTRY *Ax ;
+    if (!CS_CSC (A) || !x || !y) return (0) ;	    /* check inputs */
+    n = A->n ; Ap = A->p ; Ai = A->i ; Ax = A->x ;
+    for (j = 0 ; j < n ; j++)
+    {
+	for (p = Ap [j] ; p < Ap [j+1] ; p++)
+	{
+	    y [Ai [p]] += Ax [p] * x [j] ;
+	}
+    }
+    return (1) ;
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Source/cs_happly.cpp SuiteSparse/CXSparse-C++/Source/cs_happly.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Source/cs_happly.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Source/cs_happly.cpp	2006-08-25 08:04:44.000000000 +0200
@@ -0,0 +1,19 @@
+#include "cs.h"
+/* apply the ith Householder vector to x */
+CS_INT cs_happly (const cs *V, CS_INT i, CS_ENTRY beta, CS_ENTRY *x)
+{
+    CS_INT p, *Vp, *Vi ;
+    CS_ENTRY *Vx, tau = 0 ;
+    if (!CS_CSC (V) || !x) return (0) ;	    /* check inputs */
+    Vp = V->p ; Vi = V->i ; Vx = V->x ;
+    for (p = Vp [i] ; p < Vp [i+1] ; p++)   /* tau = v'*x */
+    {
+	tau += CS_CONJ (Vx [p]) * x [Vi [p]] ;
+    }
+    tau *= beta ;			    /* tau = beta*(v'*x) */
+    for (p = Vp [i] ; p < Vp [i+1] ; p++)   /* x = x - v*tau */
+    {
+	x [Vi [p]] -= Vx [p] * tau ;
+    }
+    return (1) ;
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Source/cs_house.cpp SuiteSparse/CXSparse-C++/Source/cs_house.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Source/cs_house.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Source/cs_house.cpp	2006-11-24 16:16:46.000000000 +0100
@@ -0,0 +1,28 @@
+#include "cs.h"
+/* create a Householder reflection [v,beta,s]=house(x), overwrite x with v,
+ * where (I-beta*v*v')*x = s*e1 and e1 = [1 0 ... 0]'.
+ * Note that this CXSparse version is different than CSparse. */
+CS_ENTRY cs_house (CS_ENTRY *x, CS_ENTRY *beta, CS_INT n)
+{
+    CS_ENTRY s = 0 ;
+    CS_INT i ;
+    if (!x || !beta) return (-1) ;	    /* check inputs */
+    for (i = 0 ; i < n ; i++) s += x [i] * CS_CONJ (x [i]) ;
+    s = sqrt (s) ;
+    if (s == CS_ENTRY(0))
+    {
+	(*beta) = 0 ;
+	x [0] = 1 ;
+    }
+    else
+    {
+	if (x [0] != CS_ENTRY(0))
+	{
+	    s *= x [0] / CS_ABS (x [0]) ;
+	}
+	s = -s ;
+	x [0] -= s ;
+	(*beta) = -1. / (CS_CONJ (s) * x [0]) ;
+    }
+    return (s) ;
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Source/cs_ipvec.cpp SuiteSparse/CXSparse-C++/Source/cs_ipvec.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Source/cs_ipvec.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Source/cs_ipvec.cpp	2006-08-25 08:04:44.000000000 +0200
@@ -0,0 +1,9 @@
+#include "cs.h"
+/* x(p) = b, for dense vectors x and b; p=NULL denotes identity */
+CS_INT cs_ipvec (const CS_INT *p, const CS_ENTRY *b, CS_ENTRY *x, CS_INT n)
+{
+    CS_INT k ;
+    if (!x || !b) return (0) ;				    /* check inputs */
+    for (k = 0 ; k < n ; k++) x [p ? p [k] : k] = b [k] ;
+    return (1) ;
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Source/cs_leaf.cpp SuiteSparse/CXSparse-C++/Source/cs_leaf.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Source/cs_leaf.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Source/cs_leaf.cpp	2006-08-25 08:04:46.000000000 +0200
@@ -0,0 +1,22 @@
+#include "cs.h"
+/* consider A(i,j), node j in ith row subtree and return lca(jprev,j) */
+CS_INT cs_leaf (CS_INT i, CS_INT j, const CS_INT *first, CS_INT *maxfirst, CS_INT *prevleaf,
+    CS_INT *ancestor, CS_INT *jleaf)
+{
+    CS_INT q, s, sparent, jprev ;
+    if (!first || !maxfirst || !prevleaf || !ancestor || !jleaf) return (-1) ;
+    *jleaf = 0 ;
+    if (i <= j || first [j] <= maxfirst [i]) return (-1) ;  /* j not a leaf */
+    maxfirst [i] = first [j] ;	    /* update max first[j] seen so far */
+    jprev = prevleaf [i] ;	    /* jprev = previous leaf of ith subtree */
+    prevleaf [i] = j ;
+    *jleaf = (jprev == -1) ? 1: 2 ; /* j is first or subsequent leaf */
+    if (*jleaf == 1) return (i) ;   /* if 1st leaf, q = root of ith subtree */
+    for (q = jprev ; q != ancestor [q] ; q = ancestor [q]) ;
+    for (s = jprev ; s != q ; s = sparent)
+    {
+	sparent = ancestor [s] ;    /* path compression */
+	ancestor [s] = q ;
+    }
+    return (q) ;		    /* q = least common ancester (jprev,j) */
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Source/cs_load.cpp SuiteSparse/CXSparse-C++/Source/cs_load.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Source/cs_load.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Source/cs_load.cpp	2006-08-25 08:04:44.000000000 +0200
@@ -0,0 +1,26 @@
+#include "cs.h"
+/* load a triplet matrix from a file */
+cs *cs_load (FILE *f)
+{
+    CS_INT i, j ;
+    double x ;
+#ifdef CS_COMPLEX
+    double xi ;
+#endif
+    cs *T ;
+    if (!f) return (NULL) ;				/* check inputs */
+    T = cs_spalloc (0, 0, 1, 1, 1) ;			/* allocate result */
+#ifdef CS_COMPLEX
+    while (fscanf (f, ""CS_ID" "CS_ID" %lg %lg\n", &i, &j, &x, &xi) == 4)
+#else
+    while (fscanf (f, ""CS_ID" "CS_ID" %lg\n", &i, &j, &x) == 3)
+#endif
+    {
+#ifdef CS_COMPLEX
+	if (!cs_entry (T, i, j, x + xi*I)) return (cs_spfree (T)) ;
+#else
+	if (!cs_entry (T, i, j, x)) return (cs_spfree (T)) ;
+#endif
+    }
+    return (T) ;
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Source/cs_lsolve.cpp SuiteSparse/CXSparse-C++/Source/cs_lsolve.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Source/cs_lsolve.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Source/cs_lsolve.cpp	2006-08-25 08:04:44.000000000 +0200
@@ -0,0 +1,18 @@
+#include "cs.h"
+/* solve Lx=b where x and b are dense.  x=b on input, solution on output. */
+CS_INT cs_lsolve (const cs *L, CS_ENTRY *x)
+{
+    CS_INT p, j, n, *Lp, *Li ;
+    CS_ENTRY *Lx ;
+    if (!CS_CSC (L) || !x) return (0) ;			    /* check inputs */
+    n = L->n ; Lp = L->p ; Li = L->i ; Lx = L->x ;
+    for (j = 0 ; j < n ; j++)
+    {
+	x [j] /= Lx [Lp [j]] ;
+	for (p = Lp [j]+1 ; p < Lp [j+1] ; p++)
+	{
+	    x [Li [p]] -= Lx [p] * x [j] ;
+	}
+    }
+    return (1) ;
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Source/cs_ltsolve.cpp SuiteSparse/CXSparse-C++/Source/cs_ltsolve.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Source/cs_ltsolve.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Source/cs_ltsolve.cpp	2006-08-25 08:04:44.000000000 +0200
@@ -0,0 +1,18 @@
+#include "cs.h"
+/* solve L'x=b where x and b are dense.  x=b on input, solution on output. */
+CS_INT cs_ltsolve (const cs *L, CS_ENTRY *x)
+{
+    CS_INT p, j, n, *Lp, *Li ;
+    CS_ENTRY *Lx ;
+    if (!CS_CSC (L) || !x) return (0) ;			    /* check inputs */
+    n = L->n ; Lp = L->p ; Li = L->i ; Lx = L->x ;
+    for (j = n-1 ; j >= 0 ; j--)
+    {
+	for (p = Lp [j]+1 ; p < Lp [j+1] ; p++)
+	{
+	    x [j] -= CS_CONJ (Lx [p]) * x [Li [p]] ;
+	}
+	x [j] /= CS_CONJ (Lx [Lp [j]]) ;
+    }
+    return (1) ;
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Source/cs_lu.cpp SuiteSparse/CXSparse-C++/Source/cs_lu.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Source/cs_lu.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Source/cs_lu.cpp	2006-11-24 15:58:48.000000000 +0100
@@ -0,0 +1,87 @@
+#include "cs.h"
+/* [L,U,pinv]=lu(A, [q lnz unz]). lnz and unz can be guess */
+csn *cs_lu (const cs *A, const css *S, double tol)
+{
+    cs *L, *U ;
+    csn *N ;
+    CS_ENTRY pivot, *Lx, *Ux, *x ;
+    double a, t ;
+    CS_INT *Lp, *Li, *Up, *Ui, *pinv, *xi, *q, n, ipiv, k, top, p, i, col, lnz,unz;
+    if (!CS_CSC (A) || !S) return (NULL) ;	    /* check inputs */
+    n = A->n ;
+    q = S->q ; lnz = S->lnz ; unz = S->unz ;
+    x = (CS_ENTRY *)cs_malloc (n, sizeof (CS_ENTRY)) ;	    /* get CS_ENTRY workspace */
+    xi = (CS_INT *)cs_malloc (2*n, sizeof (CS_INT)) ;	    /* get CS_INT workspace */
+    N = (csn *)cs_calloc (1, sizeof (csn)) ;		    /* allocate result */
+    if (!x || !xi || !N) return (cs_ndone (N, NULL, xi, x, 0)) ;
+    N->L = L = cs_spalloc (n, n, lnz, 1, 0) ;	    /* allocate result L */
+    N->U = U = cs_spalloc (n, n, unz, 1, 0) ;	    /* allocate result U */
+    N->pinv = pinv = (CS_INT *)cs_malloc (n, sizeof (CS_INT)) ;  /* allocate result pinv */
+    if (!L || !U || !pinv) return (cs_ndone (N, NULL, xi, x, 0)) ;
+    Lp = L->p ; Up = U->p ;
+    for (i = 0 ; i < n ; i++) x [i] = 0 ;	    /* clear workspace */
+    for (i = 0 ; i < n ; i++) pinv [i] = -1 ;	    /* no rows pivotal yet */
+    for (k = 0 ; k <= n ; k++) Lp [k] = 0 ;	    /* no cols of L yet */
+    lnz = unz = 0 ;
+    for (k = 0 ; k < n ; k++)	    /* compute L(:,k) and U(:,k) */
+    {
+	/* --- Triangular solve --------------------------------------------- */
+	Lp [k] = lnz ;		    /* L(:,k) starts here */
+	Up [k] = unz ;		    /* U(:,k) starts here */
+	if ((lnz + n > L->nzmax && !cs_sprealloc (L, 2*L->nzmax + n)) ||
+	    (unz + n > U->nzmax && !cs_sprealloc (U, 2*U->nzmax + n)))
+	{
+	    return (cs_ndone (N, NULL, xi, x, 0)) ;
+	}
+	Li = L->i ; Lx = L->x ; Ui = U->i ; Ux = U->x ;
+	col = q ? (q [k]) : k ;
+	top = cs_spsolve (L, A, col, xi, x, pinv, 1) ;	/* x = L\A(:,col) */
+	/* --- Find pivot --------------------------------------------------- */
+	ipiv = -1 ;
+	a = -1 ;
+	for (p = top ; p < n ; p++)
+	{
+	    i = xi [p] ;	    /* x(i) is nonzero */
+	    if (pinv [i] < 0)	    /* row i is not yet pivotal */
+	    {
+		if ((t = CS_ABS (x [i])) > a)
+		{
+		    a = t ;	    /* largest pivot candidate so far */
+		    ipiv = i ;
+		}
+	    }
+	    else		    /* x(i) is the entry U(pinv[i],k) */
+	    {
+		Ui [unz] = pinv [i] ;
+		Ux [unz++] = x [i] ;
+	    }
+	}
+	if (ipiv == -1 || a <= 0) return (cs_ndone (N, NULL, xi, x, 0)) ;
+	if (pinv [col] < 0 && CS_ABS (x [col]) >= a*tol) ipiv = col ;
+	/* --- Divide by pivot ---------------------------------------------- */
+	pivot = x [ipiv] ;	    /* the chosen pivot */
+	Ui [unz] = k ;		    /* last entry in U(:,k) is U(k,k) */
+	Ux [unz++] = pivot ;
+	pinv [ipiv] = k ;	    /* ipiv is the kth pivot row */
+	Li [lnz] = ipiv ;	    /* first entry in L(:,k) is L(k,k) = 1 */
+	Lx [lnz++] = 1 ;
+	for (p = top ; p < n ; p++) /* L(k+1:n,k) = x / pivot */
+	{
+	    i = xi [p] ;
+	    if (pinv [i] < 0)	    /* x(i) is an entry in L(:,k) */
+	    {
+		Li [lnz] = i ;	    /* save unpermuted row in L */
+		Lx [lnz++] = x [i] / pivot ;	/* scale pivot column */
+	    }
+	    x [i] = 0 ;		    /* x [0..n-1] = 0 for next k */
+	}
+    }
+    /* --- Finalize L and U ------------------------------------------------- */
+    Lp [n] = lnz ;
+    Up [n] = unz ;
+    Li = L->i ;			    /* fix row indices of L for final pinv */
+    for (p = 0 ; p < lnz ; p++) Li [p] = pinv [Li [p]] ;
+    cs_sprealloc (L, 0) ;	    /* remove extra space from L and U */
+    cs_sprealloc (U, 0) ;
+    return (cs_ndone (N, NULL, xi, x, 1)) ;	/* success */
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Source/cs_lusol.cpp SuiteSparse/CXSparse-C++/Source/cs_lusol.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Source/cs_lusol.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Source/cs_lusol.cpp	2006-11-24 15:59:02.000000000 +0100
@@ -0,0 +1,26 @@
+#include "cs.h"
+/* x=A\b where A is unsymmetric; b overwritten with solution */
+CS_INT cs_lusol (CS_INT order, const cs *A, CS_ENTRY *b, double tol)
+{
+    CS_ENTRY *x ;
+    css *S ;
+    csn *N ;
+    CS_INT n, ok ;
+    if (!CS_CSC (A) || !b) return (0) ;	    /* check inputs */
+    n = A->n ;
+    S = cs_sqr (order, A, 0) ;		    /* ordering and symbolic analysis */
+    N = cs_lu (A, S, tol) ;		    /* numeric LU factorization */
+    x = (CS_ENTRY *)cs_malloc (n, sizeof (CS_ENTRY)) ;    /* get workspace */
+    ok = (S && N && x) ;
+    if (ok)
+    {
+	cs_ipvec (N->pinv, b, x, n) ;	    /* x = b(p) */
+	cs_lsolve (N->L, x) ;		    /* x = L\x */
+	cs_usolve (N->U, x) ;		    /* x = U\x */
+	cs_ipvec (S->q, x, b, n) ;	    /* b(q) = x */
+    }
+    cs_free (x) ;
+    cs_sfree (S) ;
+    cs_nfree (N) ;
+    return (ok) ;
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Source/cs_malloc.cpp SuiteSparse/CXSparse-C++/Source/cs_malloc.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Source/cs_malloc.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Source/cs_malloc.cpp	2006-08-25 08:04:44.000000000 +0200
@@ -0,0 +1,35 @@
+#include "cs.h"
+#ifdef MATLAB_MEX_FILE
+#define malloc mxMalloc
+#define free mxFree
+#define realloc mxRealloc
+#define calloc mxCalloc
+#endif
+
+/* wrapper for malloc */
+void *cs_malloc (CS_INT n, size_t size)
+{
+    return (malloc (CS_MAX (n,1) * size)) ;
+}
+
+/* wrapper for calloc */
+void *cs_calloc (CS_INT n, size_t size)
+{
+    return (calloc (CS_MAX (n,1), size)) ;
+}
+
+/* wrapper for free */
+void *cs_free (void *p)
+{
+    if (p) free (p) ;	    /* free p if it is not already NULL */
+    return (NULL) ;	    /* return NULL to simplify the use of cs_free */
+}
+
+/* wrapper for realloc */
+void *cs_realloc (void *p, CS_INT n, size_t size, CS_INT *ok)
+{
+    void *pnew ;
+    pnew = realloc (p, CS_MAX (n,1) * size) ; /* realloc the block */
+    *ok = (pnew != NULL) ;		    /* realloc fails if pnew is NULL */
+    return ((*ok) ? pnew : p) ;		    /* return original p if failure */
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Source/cs_maxtrans.cpp SuiteSparse/CXSparse-C++/Source/cs_maxtrans.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Source/cs_maxtrans.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Source/cs_maxtrans.cpp	2006-11-24 16:06:36.000000000 +0100
@@ -0,0 +1,92 @@
+#include "cs.h"
+/* find an augmenting path starting at column k and extend the match if found */
+static void cs_augment (CS_INT k, const cs *A, CS_INT *jmatch, CS_INT *cheap, CS_INT *w,
+	CS_INT *js, CS_INT *is, CS_INT *ps)
+{
+    CS_INT found = 0, p, i = -1, *Ap = A->p, *Ai = A->i, head = 0, j ;
+    js [0] = k ;			/* start with just node k in jstack */
+    while (head >= 0)
+    {
+	/* --- Start (or continue) depth-first-search at node j ------------- */
+	j = js [head] ;			/* get j from top of jstack */
+	if (w [j] != k)			/* 1st time j visited for kth path */
+	{
+	    w [j] = k ;			/* mark j as visited for kth path */
+	    for (p = cheap [j] ; p < Ap [j+1] && !found ; p++)
+	    {
+		i = Ai [p] ;		/* try a cheap assignment (i,j) */
+		found = (jmatch [i] == -1) ;
+	    }
+	    cheap [j] = p ;		/* start here next time j is traversed*/
+	    if (found)
+	    {
+		is [head] = i ;		/* column j matched with row i */
+		break ;			/* end of augmenting path */
+	    }
+	    ps [head] = Ap [j] ;	/* no cheap match: start dfs for j */
+	}
+	/* --- Depth-first-search of neighbors of j ------------------------- */
+	for (p = ps [head] ; p < Ap [j+1] ; p++)
+	{
+	    i = Ai [p] ;		/* consider row i */
+	    if (w [jmatch [i]] == k) continue ;	/* skip jmatch [i] if marked */
+	    ps [head] = p + 1 ;		/* pause dfs of node j */
+	    is [head] = i ;		/* i will be matched with j if found */
+	    js [++head] = jmatch [i] ;	/* start dfs at column jmatch [i] */
+	    break ;
+	}
+	if (p == Ap [j+1]) head-- ;	/* node j is done; pop from stack */
+    }					/* augment the match if path found: */
+    if (found) for (p = head ; p >= 0 ; p--) jmatch [is [p]] = js [p] ;
+}
+
+/* find a maximum transveral */
+CS_INT *cs_maxtrans (const cs *A, CS_INT seed)  /*[jmatch [0..m-1]; imatch [0..n-1]]*/
+{
+    CS_INT i, j, k, n, m, p, n2 = 0, m2 = 0, *Ap, *jimatch, *w, *cheap, *js, *is,
+	*ps, *Ai, *Cp, *jmatch, *imatch, *q ;
+    cs *C ;
+    if (!CS_CSC (A)) return (NULL) ;		    /* check inputs */
+    n = A->n ; m = A->m ; Ap = A->p ; Ai = A->i ;
+    w = jimatch = (CS_INT *)cs_calloc (m+n, sizeof (CS_INT)) ;   /* allocate result */
+    if (!jimatch) return (NULL) ;
+    for (k = 0, j = 0 ; j < n ; j++)	/* count nonempty rows and columns */
+    {
+	n2 += (Ap [j] < Ap [j+1]) ;
+	for (p = Ap [j] ; p < Ap [j+1] ; p++)
+	{
+	    w [Ai [p]] = 1 ;
+	    k += (j == Ai [p]) ;	/* count entries already on diagonal */
+	}
+    }
+    if (k == CS_MIN (m,n))		/* quick return if diagonal zero-free */
+    {
+	jmatch = jimatch ; imatch = jimatch + m ;
+	for (i = 0 ; i < k ; i++) jmatch [i] = i ;
+	for (      ; i < m ; i++) jmatch [i] = -1 ;
+	for (j = 0 ; j < k ; j++) imatch [j] = j ;
+	for (      ; j < n ; j++) imatch [j] = -1 ;
+	return (cs_idone (jimatch, NULL, NULL, 1)) ;
+    }
+    for (i = 0 ; i < m ; i++) m2 += w [i] ;
+    C = (m2 < n2) ? cs_transpose (A,0) : ((cs *) A) ; /* transpose if needed */
+    if (!C) return (cs_idone (jimatch, (m2 < n2) ? C : NULL, NULL, 0)) ;
+    n = C->n ; m = C->m ; Cp = C->p ;
+    jmatch = (m2 < n2) ? jimatch + n : jimatch ;
+    imatch = (m2 < n2) ? jimatch : jimatch + m ;
+    w = (CS_INT *)cs_malloc (5*n, sizeof (CS_INT)) ;		    /* get workspace */
+    if (!w) return (cs_idone (jimatch, (m2 < n2) ? C : NULL, w, 0)) ;
+    cheap = w + n ; js = w + 2*n ; is = w + 3*n ; ps = w + 4*n ;
+    for (j = 0 ; j < n ; j++) cheap [j] = Cp [j] ;  /* for cheap assignment */
+    for (j = 0 ; j < n ; j++) w [j] = -1 ;	    /* all columns unflagged */
+    for (i = 0 ; i < m ; i++) jmatch [i] = -1 ;	    /* nothing matched yet */
+    q = cs_randperm (n, seed) ;			    /* q = random permutation */
+    for (k = 0 ; k < n ; k++)	/* augment, starting at column q[k] */
+    {
+	cs_augment (q ? q [k]: k, C, jmatch, cheap, w, js, is, ps) ;
+    }
+    cs_free (q) ;
+    for (j = 0 ; j < n ; j++) imatch [j] = -1 ;	    /* find row match */
+    for (i = 0 ; i < m ; i++) if (jmatch [i] >= 0) imatch [jmatch [i]] = i ;
+    return (cs_idone (jimatch, (m2 < n2) ? C : NULL, w, 1)) ;
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Source/cs_multiply.cpp SuiteSparse/CXSparse-C++/Source/cs_multiply.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Source/cs_multiply.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Source/cs_multiply.cpp	2006-11-24 16:02:38.000000000 +0100
@@ -0,0 +1,34 @@
+#include "cs.h"
+/* C = A*B */
+cs *cs_multiply (const cs *A, const cs *B)
+{
+    CS_INT p, j, nz = 0, anz, *Cp, *Ci, *Bp, m, n, bnz, *w, values, *Bi ;
+    CS_ENTRY *x, *Bx, *Cx ;
+    cs *C ;
+    if (!CS_CSC (A) || !CS_CSC (B)) return (NULL) ;	 /* check inputs */
+    m = A->m ; anz = A->p [A->n] ;
+    n = B->n ; Bp = B->p ; Bi = B->i ; Bx = B->x ; bnz = Bp [n] ;
+    w = (CS_INT *)cs_calloc (m, sizeof (CS_INT)) ;			 /* get workspace */
+    values = (A->x != NULL) && (Bx != NULL) ;
+    x = (CS_ENTRY *) (values ? cs_malloc (m, sizeof (CS_ENTRY)) : NULL) ; /* get workspace */
+    C = cs_spalloc (m, n, anz + bnz, values, 0) ;	 /* allocate result */
+    if (!C || !w || (values && !x)) return (cs_done (C, w, x, 0)) ;
+    Cp = C->p ;
+    for (j = 0 ; j < n ; j++)
+    {
+	if (nz + m > C->nzmax && !cs_sprealloc (C, 2*(C->nzmax)+m))
+	{
+	    return (cs_done (C, w, x, 0)) ;		/* out of memory */
+	} 
+	Ci = C->i ; Cx = C->x ;		/* C->i and C->x may be reallocated */
+	Cp [j] = nz ;			/* column j of C starts here */
+	for (p = Bp [j] ; p < Bp [j+1] ; p++)
+	{
+	    nz = cs_scatter (A, Bi [p], Bx ? Bx [p] : 1, w, x, j+1, C, nz) ;
+	}
+	if (values) for (p = Cp [j] ; p < nz ; p++) Cx [p] = x [Ci [p]] ;
+    }
+    Cp [n] = nz ;			/* finalize the last column of C */
+    cs_sprealloc (C, 0) ;		/* remove extra space from C */
+    return (cs_done (C, w, x, 1)) ;	/* success; free workspace, return C */
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Source/cs_norm.cpp SuiteSparse/CXSparse-C++/Source/cs_norm.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Source/cs_norm.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Source/cs_norm.cpp	2006-08-25 08:04:44.000000000 +0200
@@ -0,0 +1,16 @@
+#include "cs.h"
+/* 1-norm of a sparse matrix = max (sum (abs (A))), largest column sum */
+double cs_norm (const cs *A)
+{
+    CS_INT p, j, n, *Ap ;
+    CS_ENTRY *Ax ;
+    double norm = 0, s ;
+    if (!CS_CSC (A) || !A->x) return (-1) ;		/* check inputs */
+    n = A->n ; Ap = A->p ; Ax = A->x ;
+    for (j = 0 ; j < n ; j++)
+    {
+	for (s = 0, p = Ap [j] ; p < Ap [j+1] ; p++) s += CS_ABS (Ax [p]) ;
+	norm = CS_MAX (norm, s) ;
+    }
+    return (norm) ;
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Source/cs_permute.cpp SuiteSparse/CXSparse-C++/Source/cs_permute.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Source/cs_permute.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Source/cs_permute.cpp	2006-08-25 08:04:44.000000000 +0200
@@ -0,0 +1,25 @@
+#include "cs.h"
+/* C = A(p,q) where p and q are permutations of 0..m-1 and 0..n-1. */
+cs *cs_permute (const cs *A, const CS_INT *pinv, const CS_INT *q, CS_INT values)
+{
+    CS_INT t, j, k, nz = 0, m, n, *Ap, *Ai, *Cp, *Ci ;
+    CS_ENTRY *Cx, *Ax ;
+    cs *C ;
+    if (!CS_CSC (A)) return (NULL) ;	/* check inputs */
+    m = A->m ; n = A->n ; Ap = A->p ; Ai = A->i ; Ax = A->x ;
+    C = cs_spalloc (m, n, Ap [n], values && Ax != NULL, 0) ;  /* alloc result */
+    if (!C) return (cs_done (C, NULL, NULL, 0)) ;   /* out of memory */
+    Cp = C->p ; Ci = C->i ; Cx = C->x ;
+    for (k = 0 ; k < n ; k++)
+    {
+	Cp [k] = nz ;			/* column k of C is column q[k] of A */
+	j = q ? (q [k]) : k ;
+	for (t = Ap [j] ; t < Ap [j+1] ; t++)
+	{
+	    if (Cx) Cx [nz] = Ax [t] ;	/* row i of A is row pinv[i] of C */
+	    Ci [nz++] = pinv ? (pinv [Ai [t]]) : Ai [t] ;
+	}
+    }
+    Cp [n] = nz ;			/* finalize the last column of C */
+    return (cs_done (C, NULL, NULL, 1)) ;
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Source/cs_pinv.cpp SuiteSparse/CXSparse-C++/Source/cs_pinv.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Source/cs_pinv.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Source/cs_pinv.cpp	2006-11-24 16:02:54.000000000 +0100
@@ -0,0 +1,11 @@
+#include "cs.h"
+/* pinv = p', or p = pinv' */
+CS_INT *cs_pinv (CS_INT const *p, CS_INT n)
+{
+    CS_INT k, *pinv ;
+    if (!p) return (NULL) ;			/* p = NULL denotes identity */
+    pinv = (CS_INT *)cs_malloc (n, sizeof (CS_INT)) ;	/* allocate result */
+    if (!pinv) return (NULL) ;			/* out of memory */
+    for (k = 0 ; k < n ; k++) pinv [p [k]] = k ;/* invert the permutation */
+    return (pinv) ;				/* return result */
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Source/cs_post.cpp SuiteSparse/CXSparse-C++/Source/cs_post.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Source/cs_post.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Source/cs_post.cpp	2006-11-24 16:03:12.000000000 +0100
@@ -0,0 +1,24 @@
+#include "cs.h"
+/* post order a forest */
+CS_INT *cs_post (const CS_INT *parent, CS_INT n)
+{
+    CS_INT j, k = 0, *post, *w, *head, *next, *stack ;
+    if (!parent) return (NULL) ;			/* check inputs */
+    post = (CS_INT *)cs_malloc (n, sizeof (CS_INT)) ;		/* allocate result */
+    w = (CS_INT *)cs_malloc (3*n, sizeof (CS_INT)) ;			/* get workspace */
+    if (!w || !post) return (cs_idone (post, NULL, w, 0)) ;
+    head = w ; next = w + n ; stack = w + 2*n ;
+    for (j = 0 ; j < n ; j++) head [j] = -1 ;		/* empty linked lists */
+    for (j = n-1 ; j >= 0 ; j--)	    /* traverse nodes in reverse order*/
+    {
+	if (parent [j] == -1) continue ;    /* j is a root */
+	next [j] = head [parent [j]] ;	    /* add j to list of its parent */
+	head [parent [j]] = j ;
+    }
+    for (j = 0 ; j < n ; j++)
+    {
+	if (parent [j] != -1) continue ;    /* skip j if it is not a root */
+	k = cs_tdfs (j, k, head, next, post, stack) ;
+    }
+    return (cs_idone (post, NULL, w, 1)) ;  /* success; free w, return post */
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Source/cs_print.cpp SuiteSparse/CXSparse-C++/Source/cs_print.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Source/cs_print.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Source/cs_print.cpp	2006-08-25 08:04:44.000000000 +0200
@@ -0,0 +1,46 @@
+#include "cs.h"
+/* print a sparse matrix */
+CS_INT cs_print (const cs *A, CS_INT brief)
+{
+    CS_INT p, j, m, n, nzmax, nz, *Ap, *Ai ;
+    CS_ENTRY *Ax ;
+    if (!A) { printf ("(null)\n") ; return (0) ; }
+    m = A->m ; n = A->n ; Ap = A->p ; Ai = A->i ; Ax = A->x ;
+    nzmax = A->nzmax ; nz = A->nz ;
+    printf ("CXSparse Version %d.%d.%d, %s.  %s\n", CS_VER, CS_SUBVER,
+	CS_SUBSUB, CS_DATE, CS_COPYRIGHT) ;
+    if (nz < 0)
+    {
+	printf (""CS_ID"-by-"CS_ID", nzmax: "CS_ID" nnz: "CS_ID", 1-norm: %g\n", m, n, nzmax,
+		Ap [n], cs_norm (A)) ;
+	for (j = 0 ; j < n ; j++)
+	{
+	    printf ("    col "CS_ID" : locations "CS_ID" to "CS_ID"\n", j, Ap [j], Ap [j+1]-1);
+	    for (p = Ap [j] ; p < Ap [j+1] ; p++)
+	    {
+#ifdef CS_COMPLEX
+		printf ("      "CS_ID" : (%g, %g)\n", Ai [p], 
+		    Ax ? CS_REAL (Ax [p]) : 1, Ax ? CS_IMAG (Ax [p]) : 0) ;
+#else
+		printf ("      "CS_ID" : %g\n", Ai [p], Ax ? Ax [p] : 1) ;
+#endif
+		if (brief && p > 20) { printf ("  ...\n") ; return (1) ; }
+	    }
+	}
+    }
+    else
+    {
+	printf ("triplet: "CS_ID"-by-"CS_ID", nzmax: "CS_ID" nnz: "CS_ID"\n", m, n, nzmax, nz) ;
+	for (p = 0 ; p < nz ; p++)
+	{
+#ifdef CS_COMPLEX
+	    printf ("    "CS_ID" "CS_ID" : (%g, %g)\n", Ai [p], Ap [p], 
+		    Ax ? CS_REAL (Ax [p]) : 1, Ax ? CS_IMAG (Ax [p]) : 0) ;
+#else
+	    printf ("    "CS_ID" "CS_ID" : %g\n", Ai [p], Ap [p], Ax ? Ax [p] : 1) ;
+#endif
+	    if (brief && p > 20) { printf ("  ...\n") ; return (1) ; }
+	}
+    }
+    return (1) ;
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Source/cs_pvec.cpp SuiteSparse/CXSparse-C++/Source/cs_pvec.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Source/cs_pvec.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Source/cs_pvec.cpp	2006-08-25 08:04:44.000000000 +0200
@@ -0,0 +1,9 @@
+#include "cs.h"
+/* x = b(p), for dense vectors x and b; p=NULL denotes identity */
+CS_INT cs_pvec (const CS_INT *p, const CS_ENTRY *b, CS_ENTRY *x, CS_INT n)
+{
+    CS_INT k ;
+    if (!x || !b) return (0) ;				    /* check inputs */
+    for (k = 0 ; k < n ; k++) x [k] = b [p ? p [k] : k] ;
+    return (1) ;
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Source/cs_qr.cpp SuiteSparse/CXSparse-C++/Source/cs_qr.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Source/cs_qr.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Source/cs_qr.cpp	2006-11-24 16:04:02.000000000 +0100
@@ -0,0 +1,73 @@
+#include "cs.h"
+/* sparse QR factorization [V,beta,pinv,R] = qr (A) */
+csn *cs_qr (const cs *A, const css *S)
+{
+    CS_ENTRY *Rx, *Vx, *Ax, *Beta, *x ;
+    CS_INT i, k, p, m, n, vnz, p1, top, m2, len, col, rnz, *s, *leftmost, *Ap, *Ai,
+	*parent, *Rp, *Ri, *Vp, *Vi, *w, *pinv, *q ;
+    cs *R, *V ;
+    csn *N ;
+    if (!CS_CSC (A) || !S) return (NULL) ;
+    m = A->m ; n = A->n ; Ap = A->p ; Ai = A->i ; Ax = A->x ;
+    q = S->q ; parent = S->parent ; pinv = S->pinv ; m2 = S->m2 ;
+    vnz = S->lnz ; rnz = S->unz ; leftmost = S->leftmost ;
+    w = (CS_INT *)cs_malloc (m2+n, sizeof (CS_INT)) ;	    /* get CS_INT workspace */
+    x = (CS_ENTRY *)cs_malloc (m2, sizeof (CS_ENTRY)) ;	    /* get CS_ENTRY workspace */
+    N = (csn *)cs_calloc (1, sizeof (csn)) ;		    /* allocate result */
+    if (!w || !x || !N) return (cs_ndone (N, NULL, w, x, 0)) ;
+    s = w + m2 ;				    /* s is size n */
+    for (k = 0 ; k < m2 ; k++) x [k] = 0 ;	    /* clear workspace x */
+    N->L = V = cs_spalloc (m2, n, vnz, 1, 0) ;	    /* allocate result V */
+    N->U = R = cs_spalloc (m2, n, rnz, 1, 0) ;	    /* allocate result R */
+    N->B = Beta = (CS_ENTRY *)cs_malloc (n, sizeof (CS_ENTRY)) ;  /* allocate result Beta */
+    if (!R || !V || !Beta) return (cs_ndone (N, NULL, w, x, 0)) ;
+    Rp = R->p ; Ri = R->i ; Rx = R->x ;
+    Vp = V->p ; Vi = V->i ; Vx = V->x ;
+    for (i = 0 ; i < m2 ; i++) w [i] = -1 ; /* clear w, to mark nodes */
+    rnz = 0 ; vnz = 0 ;
+    for (k = 0 ; k < n ; k++)		    /* compute V and R */
+    {
+	Rp [k] = rnz ;			    /* R(:,k) starts here */
+	Vp [k] = p1 = vnz ;		    /* V(:,k) starts here */
+	w [k] = k ;			    /* add V(k,k) to pattern of V */
+	Vi [vnz++] = k ;
+	top = n ;
+	col = q ? q [k] : k ;
+	for (p = Ap [col] ; p < Ap [col+1] ; p++)   /* find R(:,k) pattern */
+	{
+	    i = leftmost [Ai [p]] ;	    /* i = min(find(A(i,q))) */
+	    for (len = 0 ; w [i] != k ; i = parent [i])	/* traverse up to k */
+	    {
+		s [len++] = i ;
+		w [i] = k ;
+	    }
+	    while (len > 0) s [--top] = s [--len] ; /* push path on stack */
+	    i = pinv [Ai [p]] ;		    /* i = permuted row of A(:,col) */
+	    x [i] = Ax [p] ;		    /* x (i) = A(:,col) */
+	    if (i > k && w [i] < k)	    /* pattern of V(:,k) = x (k+1:m) */
+	    {
+		Vi [vnz++] = i ;	    /* add i to pattern of V(:,k) */
+		w [i] = k ;
+	    }
+	}
+	for (p = top ; p < n ; p++) /* for each i in pattern of R(:,k) */
+	{
+	    i = s [p] ;			    /* R(i,k) is nonzero */
+	    cs_happly (V, i, Beta [i], x) ; /* apply (V(i),Beta(i)) to x */
+	    Ri [rnz] = i ;		    /* R(i,k) = x(i) */
+	    Rx [rnz++] = x [i] ;
+	    x [i] = 0 ;
+	    if (parent [i] == k) vnz = cs_scatter (V, i, 0, w, NULL, k, V, vnz);
+	}
+	for (p = p1 ; p < vnz ; p++)	    /* gather V(:,k) = x */
+	{
+	    Vx [p] = x [Vi [p]] ;
+	    x [Vi [p]] = 0 ;
+	}
+	Ri [rnz] = k ;			   /* R(k,k) = norm (x) */
+	Rx [rnz++] = cs_house (Vx+p1, Beta+k, vnz-p1) ;	/* [v,beta]=house(x) */
+    }
+    Rp [n] = rnz ;			    /* finalize R */
+    Vp [n] = vnz ;			    /* finalize V */
+    return (cs_ndone (N, NULL, w, x, 1)) ;  /* success */
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Source/cs_qrsol.cpp SuiteSparse/CXSparse-C++/Source/cs_qrsol.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Source/cs_qrsol.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Source/cs_qrsol.cpp	2006-11-24 16:04:24.000000000 +0100
@@ -0,0 +1,53 @@
+#include "cs.h"
+/* x=A\b where A can be rectangular; b overwritten with solution */
+CS_INT cs_qrsol (CS_INT order, const cs *A, CS_ENTRY *b)
+{
+    CS_ENTRY *x ;
+    css *S ;
+    csn *N ;
+    cs *AT = NULL ;
+    CS_INT k, m, n, ok ;
+    if (!CS_CSC (A) || !b) return (0) ;	/* check inputs */
+    n = A->n ;
+    m = A->m ;
+    if (m >= n)
+    {
+	S = cs_sqr (order, A, 1) ;	    /* ordering and symbolic analysis */
+	N = cs_qr (A, S) ;		    /* numeric QR factorization */
+	x = (CS_ENTRY *)cs_calloc (S ? S->m2 : 1, sizeof (CS_ENTRY)) ;    /* get workspace */
+	ok = (S && N && x) ;
+	if (ok)
+	{
+	    cs_ipvec (S->pinv, b, x, m) ;   /* x(0:m-1) = b(p(0:m-1) */
+	    for (k = 0 ; k < n ; k++)	    /* apply Householder refl. to x */
+	    {
+		cs_happly (N->L, k, N->B [k], x) ;
+	    }
+	    cs_usolve (N->U, x) ;	    /* x = R\x */
+	    cs_ipvec (S->q, x, b, n) ;	    /* b(q(0:n-1)) = x(0:n-1) */
+	}
+    }
+    else
+    {
+	AT = cs_transpose (A, 1) ;	    /* Ax=b is underdetermined */
+	S = cs_sqr (order, AT, 1) ;	    /* ordering and symbolic analysis */
+	N = cs_qr (AT, S) ;		    /* numeric QR factorization of A' */
+	x = (CS_ENTRY *)cs_calloc (S ? S->m2 : 1, sizeof (CS_ENTRY)) ;    /* get workspace */
+	ok = (AT && S && N && x) ;
+	if (ok)
+	{
+	    cs_pvec (S->q, b, x, m) ;	    /* x(q(0:m-1)) = b(0:m-1) */
+	    cs_utsolve (N->U, x) ;	    /* x = R'\x */
+	    for (k = m-1 ; k >= 0 ; k--)    /* apply Householder refl. to x */
+	    {
+		cs_happly (N->L, k, CS_CONJ (N->B [k]), x) ;
+	    }
+	    cs_pvec (S->pinv, x, b, n) ;    /* b(0:n-1) = x(p(0:n-1)) */
+	}
+    }
+    cs_free (x) ;
+    cs_sfree (S) ;
+    cs_nfree (N) ;
+    cs_spfree (AT) ;
+    return (ok) ;
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Source/cs_randperm.cpp SuiteSparse/CXSparse-C++/Source/cs_randperm.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Source/cs_randperm.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Source/cs_randperm.cpp	2006-11-24 16:07:20.000000000 +0100
@@ -0,0 +1,22 @@
+#include "cs.h"
+/* return a random permutation vector, the identity perm, or p = n-1:-1:0.
+ * seed = -1 means p = n-1:-1:0.  seed = 0 means p = identity.  otherwise
+ * p = random permutation.  */
+CS_INT *cs_randperm (CS_INT n, CS_INT seed)
+{
+    CS_INT *p, k, j, t ;
+    if (seed == 0) return (NULL) ;	/* return p = NULL (identity) */
+    p = (CS_INT *)cs_malloc (n, sizeof (CS_INT)) ;	/* allocate result */
+    if (!p) return (NULL) ;		/* out of memory */
+    for (k = 0 ; k < n ; k++) p [k] = n-k-1 ;
+    if (seed == -1) return (p) ;	/* return reverse permutation */
+    srand (seed) ;			/* get new random number seed */
+    for (k = 0 ; k < n ; k++)
+    {
+	j = k + (rand ( ) % (n-k)) ;    /* j = rand CS_INT in range k to n-1 */
+	t = p [j] ;			/* swap p[k] and p[j] */
+	p [j] = p [k] ;
+	p [k] = t ;
+    }
+    return (p) ;
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Source/cs_reach.cpp SuiteSparse/CXSparse-C++/Source/cs_reach.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Source/cs_reach.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Source/cs_reach.cpp	2006-08-25 08:04:46.000000000 +0200
@@ -0,0 +1,19 @@
+#include "cs.h"
+/* xi [top...n-1] = nodes reachable from graph of G*P' via nodes in B(:,k).
+ * xi [n...2n-1] used as workspace */
+CS_INT cs_reach (cs *G, const cs *B, CS_INT k, CS_INT *xi, const CS_INT *pinv)
+{
+    CS_INT p, n, top, *Bp, *Bi, *Gp ;
+    if (!CS_CSC (G) || !CS_CSC (B) || !xi) return (-1) ;    /* check inputs */
+    n = G->n ; Bp = B->p ; Bi = B->i ; Gp = G->p ;
+    top = n ;
+    for (p = Bp [k] ; p < Bp [k+1] ; p++)
+    {
+	if (!CS_MARKED (Gp, Bi [p]))	/* start a dfs at unmarked node i */
+	{
+	    top = cs_dfs (Bi [p], G, top, xi, xi+n, pinv) ;
+	}
+    }
+    for (p = top ; p < n ; p++) CS_MARK (Gp, xi [p]) ;	/* restore G */
+    return (top) ;
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Source/cs_scatter.cpp SuiteSparse/CXSparse-C++/Source/cs_scatter.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Source/cs_scatter.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Source/cs_scatter.cpp	2006-08-25 08:04:44.000000000 +0200
@@ -0,0 +1,22 @@
+#include "cs.h"
+/* x = x + beta * A(:,j), where x is a dense vector and A(:,j) is sparse */
+CS_INT cs_scatter (const cs *A, CS_INT j, CS_ENTRY beta, CS_INT *w, CS_ENTRY *x, CS_INT mark,
+    cs *C, CS_INT nz)
+{
+    CS_INT i, p, *Ap, *Ai, *Ci ;
+    CS_ENTRY *Ax ;
+    if (!CS_CSC (A) || !w || !CS_CSC (C)) return (-1) ;	    /* check inputs */
+    Ap = A->p ; Ai = A->i ; Ax = A->x ; Ci = C->i ;
+    for (p = Ap [j] ; p < Ap [j+1] ; p++)
+    {
+	i = Ai [p] ;				/* A(i,j) is nonzero */
+	if (w [i] < mark)
+	{
+	    w [i] = mark ;			/* i is new entry in column j */
+	    Ci [nz++] = i ;			/* add i to pattern of C(:,j) */
+	    if (x) x [i] = beta * Ax [p] ;	/* x(i) = beta*A(i,j) */
+	}
+	else if (x) x [i] += beta * Ax [p] ;	/* i exists in C(:,j) already */
+    }
+    return (nz) ;
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Source/cs_scc.cpp SuiteSparse/CXSparse-C++/Source/cs_scc.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Source/cs_scc.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Source/cs_scc.cpp	2006-11-24 16:06:14.000000000 +0100
@@ -0,0 +1,41 @@
+#include "cs.h"
+/* find the strongly connected components of a square matrix */
+csd *cs_scc (cs *A)	/* matrix A temporarily modified, then restored */
+{
+    CS_INT n, i, k, b, nb = 0, top, *xi, *pstack, *p, *r, *Ap, *ATp, *rcopy, *Blk ;
+    cs *AT ;
+    csd *D ;
+    if (!CS_CSC (A)) return (NULL) ;		    /* check inputs */
+    n = A->n ; Ap = A->p ;
+    D = cs_dalloc (n, 0) ;			    /* allocate result */
+    AT = cs_transpose (A, 0) ;			    /* AT = A' */
+    xi = (CS_INT *)cs_malloc (2*n+1, sizeof (CS_INT)) ;	    /* get workspace */
+    if (!D || !AT || !xi) return (cs_ddone (D, AT, xi, 0)) ;
+    Blk = xi ; rcopy = pstack = xi + n ;
+    p = D->p ; r = D->r ; ATp = AT->p ;
+    top = n ;
+    for (i = 0 ; i < n ; i++)	/* first dfs(A) to find finish times (xi) */
+    {
+	if (!CS_MARKED (Ap, i)) top = cs_dfs (i, A, top, xi, pstack, NULL) ;
+    }
+    for (i = 0 ; i < n ; i++) CS_MARK (Ap, i) ;	/* restore A; unmark all nodes*/
+    top = n ;
+    nb = n ;
+    for (k = 0 ; k < n ; k++)	/* dfs(A') to find strongly connnected comp */
+    {
+	i = xi [k] ;		/* get i in reverse order of finish times */
+	if (CS_MARKED (ATp, i)) continue ;  /* skip node i if already ordered */
+	r [nb--] = top ;	/* node i is the start of a component in p */
+	top = cs_dfs (i, AT, top, p, pstack, NULL) ;
+    }
+    r [nb] = 0 ;		/* first block starts at zero; shift r up */
+    for (k = nb ; k <= n ; k++) r [k-nb] = r [k] ;
+    D->nb = nb = n-nb ;		/* nb = # of strongly connected components */
+    for (b = 0 ; b < nb ; b++)	/* sort each block in natural order */
+    {
+	for (k = r [b] ; k < r [b+1] ; k++) Blk [p [k]] = b ;
+    }
+    for (b = 0 ; b <= nb ; b++) rcopy [b] = r [b] ;
+    for (i = 0 ; i < n ; i++) p [rcopy [Blk [i]]++] = i ;
+    return (cs_ddone (D, AT, xi, 1)) ;
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Source/cs_schol.cpp SuiteSparse/CXSparse-C++/Source/cs_schol.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Source/cs_schol.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Source/cs_schol.cpp	2006-11-24 16:04:46.000000000 +0100
@@ -0,0 +1,26 @@
+#include "cs.h"
+/* ordering and symbolic analysis for a Cholesky factorization */
+css *cs_schol (CS_INT order, const cs *A)
+{
+    CS_INT n, *c, *post, *P ;
+    cs *C ;
+    css *S ;
+    if (!CS_CSC (A)) return (NULL) ;	    /* check inputs */
+    n = A->n ;
+    S = (css *)cs_calloc (1, sizeof (css)) ;	    /* allocate result S */
+    if (!S) return (NULL) ;		    /* out of memory */
+    P = cs_amd (order, A) ;		    /* P = amd(A+A'), or natural */
+    S->pinv = cs_pinv (P, n) ;		    /* find inverse permutation */
+    cs_free (P) ;
+    if (order && !S->pinv) return (cs_sfree (S)) ;
+    C = cs_symperm (A, S->pinv, 0) ;	    /* C = spones(triu(A(P,P))) */
+    S->parent = cs_etree (C, 0) ;	    /* find etree of C */
+    post = cs_post (S->parent, n) ;	    /* postorder the etree */
+    c = cs_counts (C, S->parent, post, 0) ; /* find column counts of chol(C) */
+    cs_free (post) ;
+    cs_spfree (C) ;
+    S->cp = (CS_INT *)cs_malloc (n+1, sizeof (CS_INT)) ; /* allocate result S->cp */
+    S->unz = S->lnz = cs_cumsum (S->cp, c, n) ; /* find column pointers for L */
+    cs_free (c) ;
+    return ((S->lnz >= 0) ? S : cs_sfree (S)) ;
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Source/cs_spsolve.cpp SuiteSparse/CXSparse-C++/Source/cs_spsolve.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Source/cs_spsolve.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Source/cs_spsolve.cpp	2006-08-25 08:04:46.000000000 +0200
@@ -0,0 +1,28 @@
+#include "cs.h"
+/* solve Gx=b(:,k), where G is either upper (lo=0) or lower (lo=1) triangular */
+CS_INT cs_spsolve (cs *G, const cs *B, CS_INT k, CS_INT *xi, CS_ENTRY *x, const CS_INT *pinv,
+    CS_INT lo)
+{
+    CS_INT j, J, p, q, px, top, n, *Gp, *Gi, *Bp, *Bi ;
+    CS_ENTRY *Gx, *Bx ;
+    if (!CS_CSC (G) || !CS_CSC (B) || !xi || !x) return (-1) ;
+    Gp = G->p ; Gi = G->i ; Gx = G->x ; n = G->n ;
+    Bp = B->p ; Bi = B->i ; Bx = B->x ;
+    top = cs_reach (G, B, k, xi, pinv) ;	/* xi[top..n-1]=Reach(B(:,k)) */
+    for (p = top ; p < n ; p++) x [xi [p]] = 0 ;    /* clear x */
+    for (p = Bp [k] ; p < Bp [k+1] ; p++) x [Bi [p]] = Bx [p] ;	/* scatter B */
+    for (px = top ; px < n ; px++)
+    {
+	j = xi [px] ;				    /* x(j) is nonzero */
+	J = pinv ? (pinv [j]) : j ;		    /* j maps to col J of G */
+	if (J < 0) continue ;			    /* column J is empty */
+	x [j] /= Gx [lo ? (Gp [J]) : (Gp [J+1]-1)] ;/* x(j) /= G(j,j) */
+	p = lo ? (Gp [J]+1) : (Gp [J]) ;	    /* lo: L(j,j) 1st entry */
+	q = lo ? (Gp [J+1]) : (Gp [J+1]-1) ;	    /* up: U(j,j) last entry */
+	for ( ; p < q ; p++)
+	{
+	    x [Gi [p]] -= Gx [p] * x [j] ;	    /* x(i) -= G(i,j) * x(j) */
+	}
+    }
+    return (top) ;				    /* return top of stack */
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Source/cs_sqr.cpp SuiteSparse/CXSparse-C++/Source/cs_sqr.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Source/cs_sqr.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Source/cs_sqr.cpp	2006-11-24 16:05:12.000000000 +0100
@@ -0,0 +1,88 @@
+#include "cs.h"
+/* compute nnz(V) = S->lnz, S->pinv, S->leftmost, S->m2 from A and S->parent */
+static CS_INT cs_vcount (const cs *A, css *S)
+{
+    CS_INT i, k, p, pa, n = A->n, m = A->m, *Ap = A->p, *Ai = A->i, *next, *head,
+	*tail, *nque, *pinv, *leftmost, *w, *parent = S->parent ;
+    S->pinv = pinv = (CS_INT *)cs_malloc (m+n, sizeof (CS_INT)) ;	    /* allocate pinv, */
+    S->leftmost = leftmost = (CS_INT *)cs_malloc (m, sizeof (CS_INT)) ;  /* and leftmost */
+    w = (CS_INT *)cs_malloc (m+3*n, sizeof (CS_INT)) ;   /* get workspace */
+    if (!pinv || !w || !leftmost)
+    {
+	cs_free (w) ;			    /* pinv and leftmost freed later */
+	return (0) ;			    /* out of memory */
+    }
+    next = w ; head = w + m ; tail = w + m + n ; nque = w + m + 2*n ;
+    for (k = 0 ; k < n ; k++) head [k] = -1 ;	/* queue k is empty */
+    for (k = 0 ; k < n ; k++) tail [k] = -1 ;
+    for (k = 0 ; k < n ; k++) nque [k] = 0 ;
+    for (i = 0 ; i < m ; i++) leftmost [i] = -1 ;
+    for (k = n-1 ; k >= 0 ; k--)
+    {
+	for (p = Ap [k] ; p < Ap [k+1] ; p++)
+	{
+	    leftmost [Ai [p]] = k ;	    /* leftmost[i] = min(find(A(i,:)))*/
+	}
+    }
+    for (i = m-1 ; i >= 0 ; i--)	    /* scan rows in reverse order */
+    {
+	pinv [i] = -1 ;			    /* row i is not yet ordered */
+	k = leftmost [i] ;
+	if (k == -1) continue ;		    /* row i is empty */
+	if (nque [k]++ == 0) tail [k] = i ; /* first row in queue k */
+	next [i] = head [k] ;		    /* put i at head of queue k */
+	head [k] = i ;
+    }
+    S->lnz = 0 ;
+    S->m2 = m ;
+    for (k = 0 ; k < n ; k++)		    /* find row permutation and nnz(V)*/
+    {
+	i = head [k] ;			    /* remove row i from queue k */
+	S->lnz++ ;			    /* count V(k,k) as nonzero */
+	if (i < 0) i = S->m2++ ;	    /* add a fictitious row */
+	pinv [i] = k ;			    /* associate row i with V(:,k) */
+	if (--nque [k] <= 0) continue ;	    /* skip if V(k+1:m,k) is empty */
+	S->lnz += nque [k] ;		    /* nque [k] is nnz (V(k+1:m,k)) */
+	if ((pa = parent [k]) != -1)	    /* move all rows to parent of k */
+	{
+	    if (nque [pa] == 0) tail [pa] = tail [k] ;
+	    next [tail [k]] = head [pa] ;
+	    head [pa] = next [i] ;
+	    nque [pa] += nque [k] ;
+	}
+    }
+    for (i = 0 ; i < m ; i++) if (pinv [i] < 0) pinv [i] = k++ ;
+    cs_free (w) ;
+    return (1) ;
+}
+
+/* symbolic ordering and analysis for QR or LU */
+css *cs_sqr (CS_INT order, const cs *A, CS_INT qr)
+{
+    CS_INT n, k, ok = 1, *post ;
+    css *S ;
+    if (!CS_CSC (A)) return (NULL) ;	    /* check inputs */
+    n = A->n ;
+    S = (css *)cs_calloc (1, sizeof (css)) ;	    /* allocate result S */
+    if (!S) return (NULL) ;		    /* out of memory */
+    S->q = cs_amd (order, A) ;		    /* fill-reducing ordering */
+    if (order && !S->q) return (cs_sfree (S)) ;
+    if (qr)				    /* QR symbolic analysis */
+    {
+	cs *C = order ? cs_permute (A, NULL, S->q, 0) : ((cs *) A) ;
+	S->parent = cs_etree (C, 1) ;	    /* etree of C'*C, where C=A(:,q) */
+	post = cs_post (S->parent, n) ;
+	S->cp = cs_counts (C, S->parent, post, 1) ;  /* col counts chol(C'*C) */
+	cs_free (post) ;
+	ok = C && S->parent && S->cp && cs_vcount (C, S) ;
+	if (ok) for (S->unz = 0, k = 0 ; k < n ; k++) S->unz += S->cp [k] ;
+	ok = ok && S->lnz >= 0 && S->unz >= 0 ;	    /* CS_INT overflow guard */
+	if (order) cs_spfree (C) ;
+    }
+    else
+    {
+	S->unz = 4*(A->p [n]) + n ;	    /* for LU factorization only, */
+	S->lnz = S->unz ;		    /* guess nnz(L) and nnz(U) */
+    }
+    return (ok ? S : cs_sfree (S)) ;	    /* return result S */
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Source/cs_symperm.cpp SuiteSparse/CXSparse-C++/Source/cs_symperm.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Source/cs_symperm.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Source/cs_symperm.cpp	2006-11-24 16:05:28.000000000 +0100
@@ -0,0 +1,39 @@
+#include "cs.h"
+/* C = A(p,p) where A and C are symmetric the upper part stored; pinv not p */
+cs *cs_symperm (const cs *A, const CS_INT *pinv, CS_INT values)
+{
+    CS_INT i, j, p, q, i2, j2, n, *Ap, *Ai, *Cp, *Ci, *w ;
+    CS_ENTRY *Cx, *Ax ;
+    cs *C ;
+    if (!CS_CSC (A)) return (NULL) ;			/* check inputs */
+    n = A->n ; Ap = A->p ; Ai = A->i ; Ax = A->x ;
+    C = cs_spalloc (n, n, Ap [n], values && (Ax != NULL), 0) ; /* alloc result*/
+    w = (CS_INT *)cs_calloc (n, sizeof (CS_INT)) ;			/* get workspace */
+    if (!C || !w) return (cs_done (C, w, NULL, 0)) ;	/* out of memory */
+    Cp = C->p ; Ci = C->i ; Cx = C->x ;
+    for (j = 0 ; j < n ; j++)		/* count entries in each column of C */
+    {
+	j2 = pinv ? pinv [j] : j ;	/* column j of A is column j2 of C */
+	for (p = Ap [j] ; p < Ap [j+1] ; p++)
+	{
+	    i = Ai [p] ;
+	    if (i > j) continue ;	/* skip lower triangular part of A */
+	    i2 = pinv ? pinv [i] : i ;	/* row i of A is row i2 of C */
+	    w [CS_MAX (i2, j2)]++ ;	/* column count of C */
+	}
+    }
+    cs_cumsum (Cp, w, n) ;		/* compute column pointers of C */
+    for (j = 0 ; j < n ; j++)
+    {
+	j2 = pinv ? pinv [j] : j ;	/* column j of A is column j2 of C */
+	for (p = Ap [j] ; p < Ap [j+1] ; p++)
+	{
+	    i = Ai [p] ;
+	    if (i > j) continue ;	/* skip lower triangular part of A*/
+	    i2 = pinv ? pinv [i] : i ;	/* row i of A is row i2 of C */
+	    Ci [q = w [CS_MAX (i2, j2)]++] = CS_MIN (i2, j2) ;
+	    if (Cx) Cx [q] = Ax [p] ;
+	}
+    }
+    return (cs_done (C, w, NULL, 1)) ;	/* success; free workspace, return C */
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Source/cs_tdfs.cpp SuiteSparse/CXSparse-C++/Source/cs_tdfs.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Source/cs_tdfs.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Source/cs_tdfs.cpp	2006-08-25 08:04:46.000000000 +0200
@@ -0,0 +1,24 @@
+#include "cs.h"
+/* depth-first search and postorder of a tree rooted at node j */
+CS_INT cs_tdfs (CS_INT j, CS_INT k, CS_INT *head, const CS_INT *next, CS_INT *post, CS_INT *stack)
+{
+    CS_INT i, p, top = 0 ;
+    if (!head || !next || !post || !stack) return (-1) ;    /* check inputs */
+    stack [0] = j ;		    /* place j on the stack */
+    while (top >= 0)		    /* while (stack is not empty) */
+    {
+	p = stack [top] ;	    /* p = top of stack */
+	i = head [p] ;		    /* i = youngest child of p */
+	if (i == -1)
+	{
+	    top-- ;		    /* p has no unordered children left */
+	    post [k++] = p ;	    /* node p is the kth postordered node */
+	}
+	else
+	{
+	    head [p] = next [i] ;   /* remove i from children of p */
+	    stack [++top] = i ;	    /* start dfs on child node i */
+	}
+    }
+    return (k) ;
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Source/cs_transpose.cpp SuiteSparse/CXSparse-C++/Source/cs_transpose.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Source/cs_transpose.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Source/cs_transpose.cpp	2006-11-24 16:05:42.000000000 +0100
@@ -0,0 +1,25 @@
+#include "cs.h"
+/* C = A' */
+cs *cs_transpose (const cs *A, CS_INT values)
+{
+    CS_INT p, q, j, *Cp, *Ci, n, m, *Ap, *Ai, *w ;
+    CS_ENTRY *Cx, *Ax ;
+    cs *C ;
+    if (!CS_CSC (A)) return (NULL) ;	/* check inputs */
+    m = A->m ; n = A->n ; Ap = A->p ; Ai = A->i ; Ax = A->x ;
+    C = cs_spalloc (n, m, Ap [n], values && Ax, 0) ;	   /* allocate result */
+    w = (CS_INT *)cs_calloc (m, sizeof (CS_INT)) ;			   /* get workspace */
+    if (!C || !w) return (cs_done (C, w, NULL, 0)) ;	   /* out of memory */
+    Cp = C->p ; Ci = C->i ; Cx = C->x ;
+    for (p = 0 ; p < Ap [n] ; p++) w [Ai [p]]++ ;	   /* row counts */
+    cs_cumsum (Cp, w, m) ;				   /* row pointers */
+    for (j = 0 ; j < n ; j++)
+    {
+	for (p = Ap [j] ; p < Ap [j+1] ; p++)
+	{
+	    Ci [q = w [Ai [p]]++] = j ;	/* place A(i,j) as entry C(j,i) */
+	    if (Cx) Cx [q] = (values > 0) ? CS_CONJ (Ax [p]) : Ax [p] ;
+	}
+    }
+    return (cs_done (C, w, NULL, 1)) ;	/* success; free w and return C */
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Source/cs_updown.cpp SuiteSparse/CXSparse-C++/Source/cs_updown.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Source/cs_updown.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Source/cs_updown.cpp	2006-11-24 16:20:44.000000000 +0100
@@ -0,0 +1,38 @@
+#include "cs.h"
+/* sparse Cholesky update/downdate, L*L' + sigma*w*w' (sigma = +1 or -1) */
+CS_INT cs_updown (cs *L, CS_INT sigma, const cs *C, const CS_INT *parent)
+{
+    CS_INT p, f, j, *Lp, *Li, *Cp, *Ci ;
+    CS_ENTRY *Lx, *Cx, alpha, beta = 1, delta, gamma, w1, w2, *w, n ;
+    double beta2 = 1 ;
+    if (!CS_CSC (L) || !CS_CSC (C) || !parent) return (0) ;  /* check inputs */
+    Lp = L->p ; Li = L->i ; Lx = L->x ; n = L->n ;
+    Cp = C->p ; Ci = C->i ; Cx = C->x ;
+    if ((p = Cp [0]) >= Cp [1]) return (1) ;	    /* return if C empty */
+    w = (CS_ENTRY *)cs_malloc (CS_REAL(n), sizeof (CS_ENTRY)) ;	    /* get workspace */
+    if (!w) return (0) ;			    /* out of memory */
+    f = Ci [p] ;
+    for ( ; p < Cp [1] ; p++) f = CS_MIN (f, Ci [p]) ;	/* f = min (find (C)) */
+    for (j = f ; j != -1 ; j = parent [j]) w [j] = 0 ;	/* clear workspace w */
+    for (p = Cp [0] ; p < Cp [1] ; p++) w [Ci [p]] = Cx [p] ; /* w = C */
+    for (j = f ; j != -1 ; j = parent [j])	    /* walk path f up to root */
+    {
+	p = Lp [j] ;
+	alpha = w [j] / Lx [p] ;		    /* alpha = w(j) / L(j,j) */
+	beta2 = CS_REAL (CS_ENTRY(beta)*CS_CONJ(beta) + CS_ENTRY(sigma)*alpha*CS_CONJ(alpha)) ;
+	if (beta2 <= 0) break ;			    /* not positive definite */
+	beta2 = sqrt (beta2) ;
+	delta = (sigma > 0) ? (beta / beta2) : (beta2 / beta) ;
+	gamma = CS_ENTRY(sigma) * alpha / (beta2 * beta) ;
+	Lx [p] = delta * Lx [p] + ((sigma > 0) ? (gamma * w [j]) : 0) ;
+	beta = beta2 ;
+	for (p++ ; p < Lp [j+1] ; p++)
+	{
+	    w1 = w [Li [p]] ;
+	    w [Li [p]] = w2 = w1 - alpha * Lx [p] ;
+	    Lx [p] = delta * Lx [p] + gamma * ((sigma > 0) ? w1 : w2) ;
+	}
+    }
+    cs_free (w) ;
+    return (beta2 > 0) ;
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Source/cs_usolve.cpp SuiteSparse/CXSparse-C++/Source/cs_usolve.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Source/cs_usolve.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Source/cs_usolve.cpp	2006-08-25 08:04:46.000000000 +0200
@@ -0,0 +1,18 @@
+#include "cs.h"
+/* solve Ux=b where x and b are dense.  x=b on input, solution on output. */
+CS_INT cs_usolve (const cs *U, CS_ENTRY *x)
+{
+    CS_INT p, j, n, *Up, *Ui ;
+    CS_ENTRY *Ux ;
+    if (!CS_CSC (U) || !x) return (0) ;			    /* check inputs */
+    n = U->n ; Up = U->p ; Ui = U->i ; Ux = U->x ;
+    for (j = n-1 ; j >= 0 ; j--)
+    {
+	x [j] /= Ux [Up [j+1]-1] ;
+	for (p = Up [j] ; p < Up [j+1]-1 ; p++)
+	{
+	    x [Ui [p]] -= Ux [p] * x [j] ;
+	}
+    }
+    return (1) ;
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Source/cs_util.cpp SuiteSparse/CXSparse-C++/Source/cs_util.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Source/cs_util.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Source/cs_util.cpp	2006-11-24 16:02:04.000000000 +0100
@@ -0,0 +1,119 @@
+#include "cs.h"
+/* allocate a sparse matrix (triplet form or compressed-column form) */
+cs *cs_spalloc (CS_INT m, CS_INT n, CS_INT nzmax, CS_INT values, CS_INT triplet)
+{
+    cs *A = (cs *)cs_calloc (1, sizeof (cs)) ;    /* allocate the cs struct */
+    if (!A) return (NULL) ;		    /* out of memory */
+    A->m = m ;				    /* define dimensions and nzmax */
+    A->n = n ;
+    A->nzmax = nzmax = CS_MAX (nzmax, 1) ;
+    A->nz = triplet ? 0 : -1 ;		    /* allocate triplet or comp.col */
+    A->p = (CS_INT *)cs_malloc (triplet ? nzmax : n+1, sizeof (CS_INT)) ;
+    A->i = (CS_INT *)cs_malloc (nzmax, sizeof (CS_INT)) ;
+    A->x = (CS_ENTRY *) (values ? cs_malloc (nzmax, sizeof (CS_ENTRY)) : NULL) ;
+    return ((!A->p || !A->i || (values && !A->x)) ? cs_spfree (A) : A) ;
+}
+
+/* change the max # of entries sparse matrix */
+CS_INT cs_sprealloc (cs *A, CS_INT nzmax)
+{
+    CS_INT ok, oki, okj = 1, okx = 1 ;
+    if (!A) return (0) ;
+    if (nzmax <= 0) nzmax = (CS_CSC (A)) ? (A->p [A->n]) : A->nz ;
+    A->i = (CS_INT *)cs_realloc (A->i, nzmax, sizeof (CS_INT), &oki) ;
+    if (CS_TRIPLET (A)) A->p = (CS_INT *)cs_realloc (A->p, nzmax, sizeof (CS_INT), &okj) ;
+    if (A->x) A->x = (CS_ENTRY *)cs_realloc (A->x, nzmax, sizeof (CS_ENTRY), &okx) ;
+    ok = (oki && okj && okx) ;
+    if (ok) A->nzmax = nzmax ;
+    return (ok) ;
+}
+
+/* free a sparse matrix */
+cs *cs_spfree (cs *A)
+{
+    if (!A) return (NULL) ;	/* do nothing if A already NULL */
+    cs_free (A->p) ;
+    cs_free (A->i) ;
+    cs_free (A->x) ;
+    return (cs *)(cs_free (A)) ;	/* free the cs struct and return NULL */
+}
+
+/* free a numeric factorization */
+csn *cs_nfree (csn *N)
+{
+    if (!N) return (NULL) ;	/* do nothing if N already NULL */
+    cs_spfree (N->L) ;
+    cs_spfree (N->U) ;
+    cs_free (N->pinv) ;
+    cs_free (N->B) ;
+    return (csn *)(cs_free (N)) ;	/* free the csn struct and return NULL */
+}
+
+/* free a symbolic factorization */
+css *cs_sfree (css *S)
+{
+    if (!S) return (NULL) ;	/* do nothing if S already NULL */
+    cs_free (S->pinv) ;
+    cs_free (S->q) ;
+    cs_free (S->parent) ;
+    cs_free (S->cp) ;
+    cs_free (S->leftmost) ;
+    return (css *)(cs_free (S)) ;	/* free the css struct and return NULL */
+}
+
+/* allocate a cs_dmperm or cs_scc result */
+csd *cs_dalloc (CS_INT m, CS_INT n)
+{
+    csd *D ;
+    D = (csd *)cs_calloc (1, sizeof (csd)) ;
+    if (!D) return (NULL) ;
+    D->p = (CS_INT *)cs_malloc (m, sizeof (CS_INT)) ;
+    D->r = (CS_INT *)cs_malloc (m+6, sizeof (CS_INT)) ;
+    D->q = (CS_INT *)cs_malloc (n, sizeof (CS_INT)) ;
+    D->s = (CS_INT *)cs_malloc (n+6, sizeof (CS_INT)) ;
+    return ((!D->p || !D->r || !D->q || !D->s) ? cs_dfree (D) : D) ;
+}
+
+/* free a cs_dmperm or cs_scc result */
+csd *cs_dfree (csd *D)
+{
+    if (!D) return (NULL) ;	/* do nothing if D already NULL */
+    cs_free (D->p) ;
+    cs_free (D->q) ;
+    cs_free (D->r) ;
+    cs_free (D->s) ;
+    return (csd *)(cs_free (D)) ;
+}
+
+/* free workspace and return a sparse matrix result */
+cs *cs_done (cs *C, void *w, void *x, CS_INT ok)
+{
+    cs_free (w) ;			/* free workspace */
+    cs_free (x) ;
+    return (ok ? C : cs_spfree (C)) ;	/* return result if OK, else free it */
+}
+
+/* free workspace and return CS_INT array result */
+CS_INT *cs_idone (CS_INT *p, cs *C, void *w, CS_INT ok)
+{
+    cs_spfree (C) ;			/* free temporary matrix */
+    cs_free (w) ;			/* free workspace */
+    return (ok ? p : (CS_INT *)cs_free (p)) ;	/* return result if OK, else free it */
+}
+
+/* free workspace and return a numeric factorization (Cholesky, LU, or QR) */
+csn *cs_ndone (csn *N, cs *C, void *w, void *x, CS_INT ok)
+{
+    cs_spfree (C) ;			/* free temporary matrix */
+    cs_free (w) ;			/* free workspace */
+    cs_free (x) ;
+    return (ok ? N : cs_nfree (N)) ;	/* return result if OK, else free it */
+}
+
+/* free workspace and return a csd result */
+csd *cs_ddone (csd *D, cs *C, void *w, CS_INT ok)
+{
+    cs_spfree (C) ;			/* free temporary matrix */
+    cs_free (w) ;			/* free workspace */
+    return (ok ? D : cs_dfree (D)) ;	/* return result if OK, else free it */
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Source/cs_utsolve.cpp SuiteSparse/CXSparse-C++/Source/cs_utsolve.cpp
--- original-libraries/SuiteSparse/CXSparse-C++/Source/cs_utsolve.cpp	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Source/cs_utsolve.cpp	2006-08-25 08:04:46.000000000 +0200
@@ -0,0 +1,18 @@
+#include "cs.h"
+/* solve U'x=b where x and b are dense.  x=b on input, solution on output. */
+CS_INT cs_utsolve (const cs *U, CS_ENTRY *x)
+{
+    CS_INT p, j, n, *Up, *Ui ;
+    CS_ENTRY *Ux ;
+    if (!CS_CSC (U) || !x) return (0) ;			    /* check inputs */
+    n = U->n ; Up = U->p ; Ui = U->i ; Ux = U->x ;
+    for (j = 0 ; j < n ; j++)
+    {
+	for (p = Up [j] ; p < Up [j+1]-1 ; p++)
+	{
+	    x [j] -= CS_CONJ (Ux [p]) * x [Ui [p]] ;
+	}
+	x [j] /= CS_CONJ (Ux [Up [j+1]-1]) ;
+    }
+    return (1) ;
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Tcov/Makefile SuiteSparse/CXSparse-C++/Tcov/Makefile
--- original-libraries/SuiteSparse/CXSparse-C++/Tcov/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Tcov/Makefile	2006-08-24 21:19:06.000000000 +0200
@@ -0,0 +1,306 @@
+
+# To run with valgrind:
+V =
+# V = valgrind -q
+
+# Linux test coverage
+CC = gcc
+CFLAGS = -O -g -fprofile-arcs -ftest-coverage \
+    	-Wall -W -Wshadow -Wmissing-prototypes -Wstrict-prototypes \
+    	-Wredundant-decls -Wnested-externs -Wdisabled-optimization -ansi \
+	-Wno-unused-parameter -Werror -I../Source -I../Demo -I../../UFconfig
+
+run: all run_convert run_di run_dl run_ci run_cl
+	./covall
+
+all:	cs_demo1_di cs_demo2_di cs_demo3_di cstcov_test_di \
+	cs_demo1_dl cs_demo2_dl cs_demo3_dl cstcov_test_dl \
+	cs_demo1_ci cs_demo2_ci cs_demo3_ci cstcov_test_ci \
+	cs_demo1_cl cs_demo2_cl cs_demo3_cl cstcov_test_cl \
+	cs_idemo cs_ldemo
+
+CS_DI = cs_add_di.o cs_amd_di.o cs_chol_di.o cs_cholsol_di.o cs_counts_di.o \
+	cs_cumsum_di.o cs_droptol_di.o cs_dropzeros_di.o cs_dupl_di.o \
+	cs_entry_di.o cs_etree_di.o cs_fkeep_di.o cs_gaxpy_di.o cs_happly_di.o \
+	cs_house_di.o cs_ipvec_di.o cs_lsolve_di.o cs_ltsolve_di.o cs_lu_di.o \
+	cs_lusol_di.o cs_util_di.o cs_multiply_di.o cs_permute_di.o \
+	cs_pinv_di.o cs_post_di.o cs_pvec_di.o cs_qr_di.o cs_qrsol_di.o \
+	cs_scatter_di.o cs_schol_di.o cs_sqr_di.o cs_symperm_di.o cs_tdfs_di.o \
+	cs_transpose_di.o cs_compress_di.o cs_usolve_di.o cs_scc_di.o \
+	cs_maxtrans_di.o cs_dmperm_di.o cs_updown_di.o cs_print_di.o \
+	cs_norm_di.o cs_load_di.o cs_dfs_di.o cstcov_malloc_test_di.o \
+	cs_utsolve_di.o cs_reach_di.o cs_spsolve_di.o \
+	cs_leaf_di.o cs_ereach_di.o cs_randperm_di.o
+
+CS_DL = cs_add_dl.o cs_amd_dl.o cs_chol_dl.o cs_cholsol_dl.o cs_counts_dl.o \
+	cs_cumsum_dl.o cs_droptol_dl.o cs_dropzeros_dl.o cs_dupl_dl.o \
+	cs_entry_dl.o cs_etree_dl.o cs_fkeep_dl.o cs_gaxpy_dl.o cs_happly_dl.o \
+	cs_house_dl.o cs_ipvec_dl.o cs_lsolve_dl.o cs_ltsolve_dl.o cs_lu_dl.o \
+	cs_lusol_dl.o cs_util_dl.o cs_multiply_dl.o cs_permute_dl.o \
+	cs_pinv_dl.o cs_post_dl.o cs_pvec_dl.o cs_qr_dl.o cs_qrsol_dl.o \
+	cs_scatter_dl.o cs_schol_dl.o cs_sqr_dl.o cs_symperm_dl.o cs_tdfs_dl.o \
+	cs_transpose_dl.o cs_compress_dl.o cs_usolve_dl.o cs_scc_dl.o \
+	cs_maxtrans_dl.o cs_dmperm_dl.o cs_updown_dl.o cs_print_dl.o \
+	cs_norm_dl.o cs_load_dl.o cs_dfs_dl.o cstcov_malloc_test_dl.o \
+	cs_utsolve_dl.o cs_reach_dl.o cs_spsolve_dl.o \
+	cs_leaf_dl.o cs_ereach_dl.o cs_randperm_dl.o
+
+CS_CI = cs_add_ci.o cs_amd_ci.o cs_chol_ci.o cs_cholsol_ci.o cs_counts_ci.o \
+	cs_cumsum_ci.o cs_droptol_ci.o cs_dropzeros_ci.o cs_dupl_ci.o \
+	cs_entry_ci.o cs_etree_ci.o cs_fkeep_ci.o cs_gaxpy_ci.o cs_happly_ci.o \
+	cs_house_ci.o cs_ipvec_ci.o cs_lsolve_ci.o cs_ltsolve_ci.o cs_lu_ci.o \
+	cs_lusol_ci.o cs_util_ci.o cs_multiply_ci.o cs_permute_ci.o \
+	cs_pinv_ci.o cs_post_ci.o cs_pvec_ci.o cs_qr_ci.o cs_qrsol_ci.o \
+	cs_scatter_ci.o cs_schol_ci.o cs_sqr_ci.o cs_symperm_ci.o cs_tdfs_ci.o \
+	cs_transpose_ci.o cs_compress_ci.o cs_usolve_ci.o cs_scc_ci.o \
+	cs_maxtrans_ci.o cs_dmperm_ci.o cs_updown_ci.o cs_print_ci.o \
+	cs_norm_ci.o cs_load_ci.o cs_dfs_ci.o cstcov_malloc_test_ci.o \
+	cs_utsolve_ci.o cs_reach_ci.o cs_spsolve_ci.o \
+	cs_leaf_ci.o cs_ereach_ci.o cs_randperm_ci.o
+
+CS_CL = cs_add_cl.o cs_amd_cl.o cs_chol_cl.o cs_cholsol_cl.o cs_counts_cl.o \
+	cs_cumsum_cl.o cs_droptol_cl.o cs_dropzeros_cl.o cs_dupl_cl.o \
+	cs_entry_cl.o cs_etree_cl.o cs_fkeep_cl.o cs_gaxpy_cl.o cs_happly_cl.o \
+	cs_house_cl.o cs_ipvec_cl.o cs_lsolve_cl.o cs_ltsolve_cl.o cs_lu_cl.o \
+	cs_lusol_cl.o cs_util_cl.o cs_multiply_cl.o cs_permute_cl.o \
+	cs_pinv_cl.o cs_post_cl.o cs_pvec_cl.o cs_qr_cl.o cs_qrsol_cl.o \
+	cs_scatter_cl.o cs_schol_cl.o cs_sqr_cl.o cs_symperm_cl.o cs_tdfs_cl.o \
+	cs_transpose_cl.o cs_compress_cl.o cs_usolve_cl.o cs_scc_cl.o \
+	cs_maxtrans_cl.o cs_dmperm_cl.o cs_updown_cl.o cs_print_cl.o \
+	cs_norm_cl.o cs_load_cl.o cs_dfs_cl.o cstcov_malloc_test_cl.o \
+	cs_utsolve_cl.o cs_reach_cl.o cs_spsolve_cl.o \
+	cs_leaf_cl.o cs_ereach_cl.o cs_randperm_cl.o
+
+OBJ = $(CS_DI) $(CS_DL) $(CS_CI) $(CS_CL) cs_convert.o
+
+$(OBJ): ../Source/cs.h cstcov_malloc_test.h Makefile
+
+
+.PRECIOUS: %demo.c %demo1.c %demo2.c %demo3.c cs_%.c cs_%_ci.c cs_%_cl.c cs_%_di.c cs_%_dl.c cstcov_%.c
+
+
+%demo.c:
+	- ln -s ../Demo/$*demo.c
+
+%demo1.c:
+	- ln -s ../Demo/$*demo1.c
+
+%demo2.c:
+	- ln -s ../Demo/$*demo2.c
+
+%demo3.c:
+	- ln -s ../Demo/$*demo3.c
+
+
+cstcov_%.c:
+	- ln -s cstcov_malloc_test.c cstcov_$*.c
+
+cs_convert.c:
+	- ln -s ../Source/cs_convert.c
+
+cs_%_ci.c:
+	- ln -s ../Source/cs_$*.c cs_$*_ci.c
+
+cs_%_di.c:
+	- ln -s ../Source/cs_$*.c cs_$*_di.c
+
+cs_%_dl.c:
+	- ln -s ../Source/cs_$*.c cs_$*_dl.c
+
+cs_%_cl.c:
+	- ln -s ../Source/cs_$*.c cs_$*_cl.c
+
+
+%_di.o: %_di.c
+	$(CC) $(CFLAGS) -c $<
+
+%_dl.o: %_dl.c
+	$(CC) $(CFLAGS) -DCS_LONG -c $<
+
+%_ci.o: %_ci.c
+	$(CC) $(CFLAGS) -DCS_COMPLEX -c $<
+
+%_cl.o: %_cl.c
+	$(CC) $(CFLAGS) -DCS_LONG -DCS_COMPLEX -c $<
+
+
+cs_idemo: $(OBJ) cs_idemo.c
+	$(CC) $(CFLAGS) -o cs_idemo cs_idemo.c $(OBJ) -lm
+
+cs_ldemo: $(OBJ) cs_ldemo.c
+	$(CC) $(CFLAGS) -o cs_ldemo cs_ldemo.c $(OBJ) -lm
+
+
+cs_demo1_di: $(CS_DI) cs_di_demo1.c
+	$(CC) $(CFLAGS) -o cs_demo1_di cs_di_demo1.c $(CS_DI) -lm
+
+cs_demo2_di: $(CS_DI) cs_di_demo2.c cs_di_demo.c
+	$(CC) $(CFLAGS) -o cs_demo2_di cs_di_demo2.c cs_di_demo.c $(CS_DI) -lm
+
+cs_demo3_di: $(CS_DI) cs_di_demo3.c cs_di_demo.c
+	$(CC) $(CFLAGS) -o cs_demo3_di cs_di_demo3.c cs_di_demo.c $(CS_DI) -lm
+
+cstcov_test_di: $(CS_DI) cstcov_test.c cs_di_demo.c
+	$(CC) $(CFLAGS) -o cstcov_test_di cstcov_test.c cs_di_demo.c $(CS_DI) -lm
+
+
+cs_demo1_dl: $(CS_DL) cs_dl_demo1.c
+	$(CC) $(CFLAGS) -DCS_LONG -o cs_demo1_dl cs_dl_demo1.c $(CS_DL) -lm
+
+cs_demo2_dl: $(CS_DL) cs_dl_demo2.c cs_dl_demo.c
+	$(CC) $(CFLAGS) -DCS_LONG -o cs_demo2_dl cs_dl_demo2.c cs_dl_demo.c $(CS_DL) -lm
+
+cs_demo3_dl: $(CS_DL) cs_dl_demo3.c cs_dl_demo.c
+	$(CC) $(CFLAGS) -DCS_LONG -o cs_demo3_dl cs_dl_demo3.c cs_dl_demo.c $(CS_DL) -lm
+
+cstcov_test_dl: $(CS_DL) cstcov_test.c cs_dl_demo.c
+	$(CC) $(CFLAGS) -DCS_LONG -o cstcov_test_dl cstcov_test.c cs_dl_demo.c $(CS_DL) -lm
+
+
+cs_demo1_ci: $(CS_CI) cs_ci_demo1.c
+	$(CC) $(CFLAGS) -DCS_COMPLEX -o cs_demo1_ci cs_ci_demo1.c $(CS_CI) -lm
+
+cs_demo2_ci: $(CS_CI) cs_ci_demo2.c cs_ci_demo.c
+	$(CC) $(CFLAGS) -DCS_COMPLEX -o cs_demo2_ci cs_ci_demo2.c cs_ci_demo.c $(CS_CI) -lm
+
+cs_demo3_ci: $(CS_CI) cs_ci_demo3.c cs_ci_demo.c
+	$(CC) $(CFLAGS) -DCS_COMPLEX -o cs_demo3_ci cs_ci_demo3.c cs_ci_demo.c $(CS_CI) -lm
+
+cstcov_test_ci: $(CS_CI) cstcov_test.c cs_ci_demo.c
+	$(CC) $(CFLAGS) -DCS_COMPLEX -o cstcov_test_ci cstcov_test.c cs_ci_demo.c $(CS_CI) -lm
+
+
+cs_demo1_cl: $(CS_CL) cs_cl_demo1.c
+	$(CC) $(CFLAGS) -DCS_LONG -DCS_COMPLEX -o cs_demo1_cl cs_cl_demo1.c $(CS_CL) -lm
+
+cs_demo2_cl: $(CS_CL) cs_cl_demo2.c cs_cl_demo.c
+	$(CC) $(CFLAGS) -DCS_LONG -DCS_COMPLEX -o cs_demo2_cl cs_cl_demo2.c cs_cl_demo.c $(CS_CL) -lm
+
+cs_demo3_cl: $(CS_CL) cs_cl_demo3.c cs_cl_demo.c
+	$(CC) $(CFLAGS) -DCS_LONG -DCS_COMPLEX -o cs_demo3_cl cs_cl_demo3.c cs_cl_demo.c $(CS_CL) -lm
+
+cstcov_test_cl: $(CS_CL) cstcov_test.c cs_cl_demo.c
+	$(CC) $(CFLAGS) -DCS_LONG -DCS_COMPLEX -o cstcov_test_cl cstcov_test.c cs_cl_demo.c $(CS_CL) -lm
+
+
+run_convert: cs_idemo cs_ldemo
+	- $(V) ./cs_idemo < ../Matrix/t2
+	- $(V) ./cs_ldemo < ../Matrix/t2
+
+run_di: cs_demo1_di cs_demo2_di cs_demo3_di cstcov_test_di
+	- $(V) ./cs_demo1_di < ../Matrix/t1
+	- $(V) ./cs_demo1_di < nil
+	- $(V) ./cs_demo1_di < zero
+	- $(V) ./cs_demo2_di < nil
+	- $(V) ./cs_demo2_di < zero
+	- $(V) ./cs_demo2_di < ../Matrix/t1
+	- $(V) ./cs_demo2_di < ../Matrix/bcsstk01
+	- $(V) ./cs_demo2_di < ../Matrix/fs_183_1
+	- $(V) ./cs_demo2_di < ../Matrix/west0067
+	- $(V) ./cs_demo2_di < ../Matrix/lp_afiro
+	- $(V) ./cs_demo2_di < ../Matrix/ash219
+	- $(V) ./cs_demo2_di < ../Matrix/mbeacxc
+	- $(V) ./cs_demo2_di < ../Matrix/bcsstk16
+	- $(V) ./cs_demo3_di < nil
+	- $(V) ./cs_demo3_di < ../Matrix/bcsstk01
+	- $(V) ./cs_demo3_di < ../Matrix/bcsstk16
+	- $(V) ./cstcov_test_di nil > test_di_nil.out
+	- $(V) ./cstcov_test_di zero > test_di_zero.out
+	- $(V) ./cstcov_test_di ../Matrix/t1 > test_di_t1.out
+	- $(V) ./cstcov_test_di ../Matrix/bcsstk01 > test_di_k1.out
+	- $(V) ./cstcov_test_di ../Matrix/fs_183_1 > test_di_fs.out
+	- $(V) ./cstcov_test_di ../Matrix/west0067 > test_di_we.out
+	- $(V) ./cstcov_test_di ../Matrix/ash219 > test_di_ash.out
+	- $(V) ./cstcov_test_di ../Matrix/lp_afiro > test_di_afiro.out
+
+run_dl: cs_demo1_dl cs_demo2_dl cs_demo3_dl cstcov_test_dl
+	- $(V) ./cs_demo1_dl < ../Matrix/t1
+	- $(V) ./cs_demo1_dl < nil
+	- $(V) ./cs_demo1_dl < zero
+	- $(V) ./cs_demo2_dl < nil
+	- $(V) ./cs_demo2_dl < zero
+	- $(V) ./cs_demo2_dl < ../Matrix/t1
+	- $(V) ./cs_demo2_dl < ../Matrix/bcsstk01
+	- $(V) ./cs_demo2_dl < ../Matrix/fs_183_1
+	- $(V) ./cs_demo2_dl < ../Matrix/west0067
+	- $(V) ./cs_demo2_dl < ../Matrix/lp_afiro
+	- $(V) ./cs_demo2_dl < ../Matrix/ash219
+	- $(V) ./cs_demo2_dl < ../Matrix/mbeacxc
+	- $(V) ./cs_demo2_dl < ../Matrix/bcsstk16
+	- $(V) ./cs_demo3_dl < nil
+	- $(V) ./cs_demo3_dl < ../Matrix/bcsstk01
+	- $(V) ./cs_demo3_dl < ../Matrix/bcsstk16
+	- $(V) ./cstcov_test_dl nil > test_dl_nil.out
+	- $(V) ./cstcov_test_dl zero > test_dl_zero.out
+	- $(V) ./cstcov_test_dl ../Matrix/t1 > test_dl_t1.out
+	- $(V) ./cstcov_test_dl ../Matrix/bcsstk01 > test_dl_k1.out
+	- $(V) ./cstcov_test_dl ../Matrix/fs_183_1 > test_dl_fs.out
+	- $(V) ./cstcov_test_dl ../Matrix/west0067 > test_dl_we.out
+	- $(V) ./cstcov_test_dl ../Matrix/ash219 > test_dl_ash.out
+	- $(V) ./cstcov_test_dl ../Matrix/lp_afiro > test_dl_afiro.out
+
+run_ci: cs_demo1_ci cs_demo2_ci cs_demo3_ci cstcov_test_ci
+	- $(V) ./cs_demo1_ci < ../Matrix/t2
+	- $(V) ./cs_demo2_ci < ../Matrix/t2
+	- $(V) ./cs_demo1_ci < czero
+	- $(V) ./cs_demo2_ci < czero
+	- $(V) ./cs_demo1_ci < ../Matrix/t3
+	- $(V) ./cs_demo2_ci < ../Matrix/t3
+	- $(V) ./cs_demo1_ci < ../Matrix/t4
+	- $(V) ./cs_demo2_ci < ../Matrix/t4
+	- $(V) ./cs_demo2_ci < ../Matrix/c_west0067
+	- $(V) ./cs_demo2_ci < ../Matrix/c_mbeacxc
+	- $(V) ./cs_demo2_ci < ../Matrix/young1c
+	- $(V) ./cs_demo2_ci < ../Matrix/qc324
+	- $(V) ./cs_demo2_ci < ../Matrix/neumann
+	- $(V) ./cs_demo2_ci < ../Matrix/mhd1280b
+	- $(V) ./cs_demo3_ci < ../Matrix/mhd1280b
+	- $(V) ./cstcov_test_ci ../Matrix/t2 > test_ci_t2.out
+	- $(V) ./cstcov_test_ci ../Matrix/young1c > test_ci_young1c.out
+	- $(V) ./cstcov_test_ci ../Matrix/qc324 > test_ci_qc324.out
+	- $(V) ./cstcov_test_ci ../Matrix/neumann > test_ci_neumann.out
+	- $(V) ./cstcov_test_ci ../Matrix/mhd1280b > test_ci_mhd1280b.out
+
+run_cl: cs_demo1_cl cs_demo2_cl cs_demo3_cl cstcov_test_cl
+	- $(V) ./cs_demo1_cl < ../Matrix/t2
+	- $(V) ./cs_demo2_cl < ../Matrix/t2
+	- $(V) ./cs_demo1_cl < czero
+	- $(V) ./cs_demo2_cl < czero
+	- $(V) ./cs_demo1_cl < ../Matrix/t3
+	- $(V) ./cs_demo2_cl < ../Matrix/t3
+	- $(V) ./cs_demo1_cl < ../Matrix/t4
+	- $(V) ./cs_demo2_cl < ../Matrix/t4
+	- $(V) ./cs_demo2_cl < ../Matrix/c_west0067
+	- $(V) ./cs_demo2_cl < ../Matrix/c_mbeacxc
+	- $(V) ./cs_demo2_cl < ../Matrix/young1c
+	- $(V) ./cs_demo2_cl < ../Matrix/qc324
+	- $(V) ./cs_demo2_cl < ../Matrix/neumann
+	- $(V) ./cs_demo2_cl < ../Matrix/mhd1280b
+	- $(V) ./cs_demo3_cl < ../Matrix/mhd1280b
+	- $(V) ./cstcov_test_cl ../Matrix/t2 > test_cl_t2.out
+	- $(V) ./cstcov_test_cl ../Matrix/young1c > test_cl_young1c.out
+	- $(V) ./cstcov_test_cl ../Matrix/qc324 > test_cl_qc324.out
+	- $(V) ./cstcov_test_cl ../Matrix/neumann > test_cl_neumann.out
+	- $(V) ./cstcov_test_cl ../Matrix/mhd1280b > test_cl_mhd1280b.out
+
+
+readhb: readhb.f
+	f77 -o readhb readhb.f
+
+readhb.f:
+	- ln -s ../Demo/readhb.f
+
+clean:
+	rm -f *.o *.bbg *.da *.gcov *.gcda *.gcno
+
+purge: distclean
+
+distclean: clean
+	rm -f readhb *.out *.a cov.sort
+	rm -f cs_demo1_di cs_demo2_di cs_demo3_di cstcov_test_di
+	rm -f cs_demo1_dl cs_demo2_dl cs_demo3_dl cstcov_test_dl
+	rm -f cs_demo1_ci cs_demo2_ci cs_demo3_ci cstcov_test_ci
+	rm -f cs_demo1_cl cs_demo2_cl cs_demo3_cl cstcov_test_cl
+	rm -f cs_idemo cs_ldemo
+	rm -f cs_*.c
+	rm -f cs*_di.c cs*_dl.c cs*_ci.c cs*_cl.c
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Tcov/README.txt SuiteSparse/CXSparse-C++/Tcov/README.txt
--- original-libraries/SuiteSparse/CXSparse-C++/Tcov/README.txt	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Tcov/README.txt	2006-02-20 12:27:32.000000000 +0100
@@ -0,0 +1,13 @@
+CXSparse/Tcov:  comprehensive test coverage for CXSparse.  Requires Linux.
+Type "make" to compile, and then "make run" to run the tests.
+The test coverage is in cover.out.  The test output is
+printed on stdout, except for cs_test (which prints its output in various
+*.out files).
+
+If the test is successful, the last line printed should be
+"statements not yet tested: 0", and all printed residuals should be small.
+
+Note that you will get warnings about unused parameters for some functions.
+These warnings can be safely ignored.  They are parameters for functions that
+are passed to cs_fkeep, and all functions used in this manner must have the
+same calling sequence, even if some of the parameters are not used.
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Tcov/cov.awk SuiteSparse/CXSparse-C++/Tcov/cov.awk
--- original-libraries/SuiteSparse/CXSparse-C++/Tcov/cov.awk	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Tcov/cov.awk	2005-10-20 11:56:30.000000000 +0200
@@ -0,0 +1,17 @@
+/cannot/
+
+/function/ { f = $8 }
+
+/file/ { f = $8 }
+
+/lines/ {
+
+    k = match ($1, "%") ;
+    p = substr ($1, 1, k-1) ;
+
+    if ((p+0) != 100)
+    {
+	printf "%8s %s\n", p, f
+    }
+}
+
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Tcov/covall SuiteSparse/CXSparse-C++/Tcov/covall
--- original-libraries/SuiteSparse/CXSparse-C++/Tcov/covall	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Tcov/covall	2005-10-20 14:43:02.000000000 +0200
@@ -0,0 +1,7 @@
+#!/bin/csh
+	./gcovs cs*.c |& awk -f cov.awk | sort -n > cov.out
+	sort -n cov.out > cov.sort
+	./covs > covs.out
+	echo -n "statments not yet tested: "
+	grep "#####" *gcov | wc -l
+	./cover *v > cover.out
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Tcov/covall.linux SuiteSparse/CXSparse-C++/Tcov/covall.linux
--- original-libraries/SuiteSparse/CXSparse-C++/Tcov/covall.linux	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Tcov/covall.linux	2005-11-15 18:47:42.000000000 +0100
@@ -0,0 +1,7 @@
+#!/bin/csh
+	./gcovs cs*.c |& awk -f cov.awk | sort -n > cov.out
+	sort -n cov.out > cov.sort
+	./covs > covs.out
+	echo -n "statments not yet tested: "
+	grep "#####" *gcov | wc -l
+	./cover *v > cover.out
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Tcov/covall.sol SuiteSparse/CXSparse-C++/Tcov/covall.sol
--- original-libraries/SuiteSparse/CXSparse-C++/Tcov/covall.sol	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Tcov/covall.sol	2005-11-15 18:48:12.000000000 +0100
@@ -0,0 +1,5 @@
+#!/bin/csh
+	tcov -x cm.profile cs*.c >& /dev/null
+	echo -n "statments not yet tested: "
+	./covs > covs.out
+	grep "#####" *tcov | wc -l
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Tcov/cover SuiteSparse/CXSparse-C++/Tcov/cover
--- original-libraries/SuiteSparse/CXSparse-C++/Tcov/cover	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Tcov/cover	2005-10-20 11:56:30.000000000 +0200
@@ -0,0 +1,9 @@
+#!/bin/csh
+# usage: cover files
+echo '================================================================='
+foreach file ($argv[1-])
+	echo $file
+	echo '================================================================='
+	grep "#####" -A5 -B5 $file
+	echo '================================================================='
+	end
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Tcov/covs SuiteSparse/CXSparse-C++/Tcov/covs
--- original-libraries/SuiteSparse/CXSparse-C++/Tcov/covs	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Tcov/covs	2005-11-15 18:48:30.000000000 +0100
@@ -0,0 +1,7 @@
+#!/bin/csh
+echo '================================================================='
+foreach file (*.?cov)
+	echo $file
+	grep "#####" $file
+	echo '================================================================='
+	end
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Tcov/cstcov_malloc_test.c SuiteSparse/CXSparse-C++/Tcov/cstcov_malloc_test.c
--- original-libraries/SuiteSparse/CXSparse-C++/Tcov/cstcov_malloc_test.c	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Tcov/cstcov_malloc_test.c	2006-08-24 21:14:20.000000000 +0200
@@ -0,0 +1,34 @@
+#include "cstcov_malloc_test.h"
+int malloc_count = INT_MAX ;
+
+/* wrapper for malloc */
+void *cs_malloc (CS_INT n, size_t size)
+{
+    if (--malloc_count < 0) return (NULL) ; /* pretend to fail */
+    return (malloc (CS_MAX (n,1) * size)) ;
+}
+
+/* wrapper for calloc */
+void *cs_calloc (CS_INT n, size_t size)
+{
+    if (--malloc_count < 0) return (NULL) ; /* pretend to fail */
+    return (calloc (CS_MAX (n,1), size)) ;
+}
+
+/* wrapper for free */
+void *cs_free (void *p)
+{
+    if (p) free (p) ;	    /* free p if it is not already NULL */
+    return (NULL) ;	    /* return NULL to simplify the use of cs_free */
+}
+
+/* wrapper for realloc */
+void *cs_realloc (void *p, CS_INT n, size_t size, CS_INT *ok)
+{
+    void *pnew ;
+    *ok = 0 ;
+    if (--malloc_count < 0) return (p) ;    /* pretend to fail */
+    pnew = realloc (p, CS_MAX (n,1) * size) ; /* realloc the block */
+    *ok = (pnew != NULL) ;
+    return ((*ok) ? pnew : p) ;		    /* return original p if failure */
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Tcov/cstcov_malloc_test.h SuiteSparse/CXSparse-C++/Tcov/cstcov_malloc_test.h
--- original-libraries/SuiteSparse/CXSparse-C++/Tcov/cstcov_malloc_test.h	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Tcov/cstcov_malloc_test.h	2006-08-24 21:14:20.000000000 +0200
@@ -0,0 +1,7 @@
+#include "cs.h"
+#define malloc_count CS_NAME (_malloc_count)
+#ifndef EXTERN
+#define EXTERN extern
+#endif
+EXTERN int malloc_count ;
+
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Tcov/cstcov_test.c SuiteSparse/CXSparse-C++/Tcov/cstcov_test.c
--- original-libraries/SuiteSparse/CXSparse-C++/Tcov/cstcov_test.c	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Tcov/cstcov_test.c	2006-08-23 12:38:38.000000000 +0200
@@ -0,0 +1,30 @@
+#include "cs_demo.h"
+/* cs_test: read a matrix and run cs_demo2 and cs_demo3, using malloc tests. */
+
+#include "cstcov_malloc_test.h"
+
+int main (int argc, char **argv)
+{
+    FILE *f ;
+    problem *Prob ;
+    int trials, ok, demo ;
+    if (argc < 2) return (-1) ;
+    printf ("cs_test, file: %s\n", argv [1]) ;
+    for (demo = 2 ; demo <= 3 ; demo++)
+    {
+	printf ("demo: %d\n", demo) ;
+	for (trials = 0 ; trials < 4000 ; trials++)
+	{
+	    malloc_count = trials ;
+	    f = fopen (argv [1], "r") ;
+	    if (!f) return (-1) ;
+	    Prob = get_problem (f, (demo == 2) ? 1e-14 : 0) ;
+	    fclose (f) ;
+	    if (Prob) ok = (demo == 2) ? demo2 (Prob) : demo3 (Prob) ;
+	    free_problem (Prob) ;
+	    if (malloc_count > 0) break ;
+	}
+	printf ("demo %d # trials: %d\n", demo, trials) ;
+    }
+    return (0) ;
+}
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Tcov/czero SuiteSparse/CXSparse-C++/Tcov/czero
--- original-libraries/SuiteSparse/CXSparse-C++/Tcov/czero	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Tcov/czero	2006-02-20 12:08:26.000000000 +0100
@@ -0,0 +1 @@
+0 0 0 0
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Tcov/gcovs SuiteSparse/CXSparse-C++/Tcov/gcovs
--- original-libraries/SuiteSparse/CXSparse-C++/Tcov/gcovs	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Tcov/gcovs	2005-10-20 11:55:40.000000000 +0200
@@ -0,0 +1,6 @@
+# usage: gcovs files
+echo '================================================================='
+foreach file ($argv[1-])
+	gcov -f $file
+	echo '================================================================='
+	end
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/Tcov/zero SuiteSparse/CXSparse-C++/Tcov/zero
--- original-libraries/SuiteSparse/CXSparse-C++/Tcov/zero	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/Tcov/zero	2006-02-17 17:11:30.000000000 +0100
@@ -0,0 +1 @@
+0 0 0
diff -urN -x metis-4.0 original-libraries/SuiteSparse/CXSparse-C++/lesser.txt SuiteSparse/CXSparse-C++/lesser.txt
--- original-libraries/SuiteSparse/CXSparse-C++/lesser.txt	1970-01-01 01:00:00.000000000 +0100
+++ SuiteSparse/CXSparse-C++/lesser.txt	2005-12-09 09:53:20.000000000 +0100
@@ -0,0 +1,504 @@
+		  GNU LESSER GENERAL PUBLIC LICENSE
+		       Version 2.1, February 1999
+
+ Copyright (C) 1991, 1999 Free Software Foundation, Inc.
+     51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+[This is the first released version of the Lesser GPL.  It also counts
+ as the successor of the GNU Library Public License, version 2, hence
+ the version number 2.1.]
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+Licenses are intended to guarantee your freedom to share and change
+free software--to make sure the software is free for all its users.
+
+  This license, the Lesser General Public License, applies to some
+specially designated software packages--typically libraries--of the
+Free Software Foundation and other authors who decide to use it.  You
+can use it too, but we suggest you first think carefully about whether
+this license or the ordinary General Public License is the better
+strategy to use in any particular case, based on the explanations below.
+
+  When we speak of free software, we are referring to freedom of use,
+not price.  Our General Public Licenses are designed to make sure that
+you have the freedom to distribute copies of free software (and charge
+for this service if you wish); that you receive source code or can get
+it if you want it; that you can change the software and use pieces of
+it in new free programs; and that you are informed that you can do
+these things.
+
+  To protect your rights, we need to make restrictions that forbid
+distributors to deny you these rights or to ask you to surrender these
+rights.  These restrictions translate to certain responsibilities for
+you if you distribute copies of the library or if you modify it.
+
+  For example, if you distribute copies of the library, whether gratis
+or for a fee, you must give the recipients all the rights that we gave
+you.  You must make sure that they, too, receive or can get the source
+code.  If you link other code with the library, you must provide
+complete object files to the recipients, so that they can relink them
+with the library after making changes to the library and recompiling
+it.  And you must show them these terms so they know their rights.
+
+  We protect your rights with a two-step method: (1) we copyright the
+library, and (2) we offer you this license, which gives you legal
+permission to copy, distribute and/or modify the library.
+
+  To protect each distributor, we want to make it very clear that
+there is no warranty for the free library.  Also, if the library is
+modified by someone else and passed on, the recipients should know
+that what they have is not the original version, so that the original
+author's reputation will not be affected by problems that might be
+introduced by others.
+
+  Finally, software patents pose a constant threat to the existence of
+any free program.  We wish to make sure that a company cannot
+effectively restrict the users of a free program by obtaining a
+restrictive license from a patent holder.  Therefore, we insist that
+any patent license obtained for a version of the library must be
+consistent with the full freedom of use specified in this license.
+
+  Most GNU software, including some libraries, is covered by the
+ordinary GNU General Public License.  This license, the GNU Lesser
+General Public License, applies to certain designated libraries, and
+is quite different from the ordinary General Public License.  We use
+this license for certain libraries in order to permit linking those
+libraries into non-free programs.
+
+  When a program is linked with a library, whether statically or using
+a shared library, the combination of the two is legally speaking a
+combined work, a derivative of the original library.  The ordinary
+General Public License therefore permits such linking only if the
+entire combination fits its criteria of freedom.  The Lesser General
+Public License permits more lax criteria for linking other code with
+the library.
+
+  We call this license the "Lesser" General Public License because it
+does Less to protect the user's freedom than the ordinary General
+Public License.  It also provides other free software developers Less
+of an advantage over competing non-free programs.  These disadvantages
+are the reason we use the ordinary General Public License for many
+libraries.  However, the Lesser license provides advantages in certain
+special circumstances.
+
+  For example, on rare occasions, there may be a special need to
+encourage the widest possible use of a certain library, so that it becomes
+a de-facto standard.  To achieve this, non-free programs must be
+allowed to use the library.  A more frequent case is that a free
+library does the same job as widely used non-free libraries.  In this
+case, there is little to gain by limiting the free library to free
+software only, so we use the Lesser General Public License.
+
+  In other cases, permission to use a particular library in non-free
+programs enables a greater number of people to use a large body of
+free software.  For example, permission to use the GNU C Library in
+non-free programs enables many more people to use the whole GNU
+operating system, as well as its variant, the GNU/Linux operating
+system.
+
+  Although the Lesser General Public License is Less protective of the
+users' freedom, it does ensure that the user of a program that is
+linked with the Library has the freedom and the wherewithal to run
+that program using a modified version of the Library.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.  Pay close attention to the difference between a
+"work based on the library" and a "work that uses the library".  The
+former contains code derived from the library, whereas the latter must
+be combined with the library in order to run.
+
+		  GNU LESSER GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License Agreement applies to any software library or other
+program which contains a notice placed by the copyright holder or
+other authorized party saying it may be distributed under the terms of
+this Lesser General Public License (also called "this License").
+Each licensee is addressed as "you".
+
+  A "library" means a collection of software functions and/or data
+prepared so as to be conveniently linked with application programs
+(which use some of those functions and data) to form executables.
+
+  The "Library", below, refers to any such software library or work
+which has been distributed under these terms.  A "work based on the
+Library" means either the Library or any derivative work under
+copyright law: that is to say, a work containing the Library or a
+portion of it, either verbatim or with modifications and/or translated
+straightforwardly into another language.  (Hereinafter, translation is
+included without limitation in the term "modification".)
+
+  "Source code" for a work means the preferred form of the work for
+making modifications to it.  For a library, complete source code means
+all the source code for all modules it contains, plus any associated
+interface definition files, plus the scripts used to control compilation
+and installation of the library.
+
+  Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running a program using the Library is not restricted, and output from
+such a program is covered only if its contents constitute a work based
+on the Library (independent of the use of the Library in a tool for
+writing it).  Whether that is true depends on what the Library does
+and what the program that uses the Library does.
+  
+  1. You may copy and distribute verbatim copies of the Library's
+complete source code as you receive it, in any medium, provided that
+you conspicuously and appropriately publish on each copy an
+appropriate copyright notice and disclaimer of warranty; keep intact
+all the notices that refer to this License and to the absence of any
+warranty; and distribute a copy of this License along with the
+Library.
+
+  You may charge a fee for the physical act of transferring a copy,
+and you may at your option offer warranty protection in exchange for a
+fee.
+
+  2. You may modify your copy or copies of the Library or any portion
+of it, thus forming a work based on the Library, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) The modified work must itself be a software library.
+
+    b) You must cause the files modified to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    c) You must cause the whole of the work to be licensed at no
+    charge to all third parties under the terms of this License.
+
+    d) If a facility in the modified Library refers to a function or a
+    table of data to be supplied by an application program that uses
+    the facility, other than as an argument passed when the facility
+    is invoked, then you must make a good faith effort to ensure that,
+    in the event an application does not supply such function or
+    table, the facility still operates, and performs whatever part of
+    its purpose remains meaningful.
+
+    (For example, a function in a library to compute square roots has
+    a purpose that is entirely well-defined independent of the
+    application.  Therefore, Subsection 2d requires that any
+    application-supplied function or table used by this function must
+    be optional: if the application does not supply it, the square
+    root function must still compute square roots.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Library,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Library, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote
+it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Library.
+
+In addition, mere aggregation of another work not based on the Library
+with the Library (or with a work based on the Library) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may opt to apply the terms of the ordinary GNU General Public
+License instead of this License to a given copy of the Library.  To do
+this, you must alter all the notices that refer to this License, so
+that they refer to the ordinary GNU General Public License, version 2,
+instead of to this License.  (If a newer version than version 2 of the
+ordinary GNU General Public License has appeared, then you can specify
+that version instead if you wish.)  Do not make any other change in
+these notices.
+
+  Once this change is made in a given copy, it is irreversible for
+that copy, so the ordinary GNU General Public License applies to all
+subsequent copies and derivative works made from that copy.
+
+  This option is useful when you wish to copy part of the code of
+the Library into a program that is not a library.
+
+  4. You may copy and distribute the Library (or a portion or
+derivative of it, under Section 2) in object code or executable form
+under the terms of Sections 1 and 2 above provided that you accompany
+it with the complete corresponding machine-readable source code, which
+must be distributed under the terms of Sections 1 and 2 above on a
+medium customarily used for software interchange.
+
+  If distribution of object code is made by offering access to copy
+from a designated place, then offering equivalent access to copy the
+source code from the same place satisfies the requirement to
+distribute the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  5. A program that contains no derivative of any portion of the
+Library, but is designed to work with the Library by being compiled or
+linked with it, is called a "work that uses the Library".  Such a
+work, in isolation, is not a derivative work of the Library, and
+therefore falls outside the scope of this License.
+
+  However, linking a "work that uses the Library" with the Library
+creates an executable that is a derivative of the Library (because it
+contains portions of the Library), rather than a "work that uses the
+library".  The executable is therefore covered by this License.
+Section 6 states terms for distribution of such executables.
+
+  When a "work that uses the Library" uses material from a header file
+that is part of the Library, the object code for the work may be a
+derivative work of the Library even though the source code is not.
+Whether this is true is especially significant if the work can be
+linked without the Library, or if the work is itself a library.  The
+threshold for this to be true is not precisely defined by law.
+
+  If such an object file uses only numerical parameters, data
+structure layouts and accessors, and small macros and small inline
+functions (ten lines or less in length), then the use of the object
+file is unrestricted, regardless of whether it is legally a derivative
+work.  (Executables containing this object code plus portions of the
+Library will still fall under Section 6.)
+
+  Otherwise, if the work is a derivative of the Library, you may
+distribute the object code for the work under the terms of Section 6.
+Any executables containing that work also fall under Section 6,
+whether or not they are linked directly with the Library itself.
+
+  6. As an exception to the Sections above, you may also combine or
+link a "work that uses the Library" with the Library to produce a
+work containing portions of the Library, and distribute that work
+under terms of your choice, provided that the terms permit
+modification of the work for the customer's own use and reverse
+engineering for debugging such modifications.
+
+  You must give prominent notice with each copy of the work that the
+Library is used in it and that the Library and its use are covered by
+this License.  You must supply a copy of this License.  If the work
+during execution displays copyright notices, you must include the
+copyright notice for the Library among them, as well as a reference
+directing the user to the copy of this License.  Also, you must do one
+of these things:
+
+    a) Accompany the work with the complete corresponding
+    machine-readable source code for the Library including whatever
+    changes were used in the work (which must be distributed under
+    Sections 1 and 2 above); and, if the work is an executable linked
+    with the Library, with the complete machine-readable "work that
+    uses the Library", as object code and/or source code, so that the
+    user can modify the Library and then relink to produce a modified
+    executable containing the modified Library.  (It is understood
+    that the user who changes the contents of definitions files in the
+    Library will not necessarily be able to recompile the application
+    to use the modified definitions.)
+
+    b) Use a suitable shared library mechanism for linking with the
+    Library.  A suitable mechanism is one that (1) uses at run time a
+    copy of the library already present on the user's computer system,
+    rather than copying library functions into the executable, and (2)
+    will operate properly with a modified version of the library, if
+    the user installs one, as long as the modified version is
+    interface-compatible with the version that the work was made with.
+
+    c) Accompany the work with a written offer, valid for at
+    least three years, to give the same user the materials
+    specified in Subsection 6a, above, for a charge no more
+    than the cost of performing this distribution.
+
+    d) If distribution of the work is made by offering access to copy
+    from a designated place, offer equivalent access to copy the above
+    specified materials from the same place.
+
+    e) Verify that the user has already received a copy of these
+    materials or that you have already sent this user a copy.
+
+  For an executable, the required form of the "work that uses the
+Library" must include any data and utility programs needed for
+reproducing the executable from it.  However, as a special exception,
+the materials to be distributed need not include anything that is
+normally distributed (in either source or binary form) with the major
+components (compiler, kernel, and so on) of the operating system on
+which the executable runs, unless that component itself accompanies
+the executable.
+
+  It may happen that this requirement contradicts the license
+restrictions of other proprietary libraries that do not normally
+accompany the operating system.  Such a contradiction means you cannot
+use both them and the Library together in an executable that you
+distribute.
+
+  7. You may place library facilities that are a work based on the
+Library side-by-side in a single library together with other library
+facilities not covered by this License, and distribute such a combined
+library, provided that the separate distribution of the work based on
+the Library and of the other library facilities is otherwise
+permitted, and provided that you do these two things:
+
+    a) Accompany the combined library with a copy of the same work
+    based on the Library, uncombined with any other library
+    facilities.  This must be distributed under the terms of the
+    Sections above.
+
+    b) Give prominent notice with the combined library of the fact
+    that part of it is a work based on the Library, and explaining
+    where to find the accompanying uncombined form of the same work.
+
+  8. You may not copy, modify, sublicense, link with, or distribute
+the Library except as expressly provided under this License.  Any
+attempt otherwise to copy, modify, sublicense, link with, or
+distribute the Library is void, and will automatically terminate your
+rights under this License.  However, parties who have received copies,
+or rights, from you under this License will not have their licenses
+terminated so long as such parties remain in full compliance.
+
+  9. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Library or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Library (or any work based on the
+Library), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Library or works based on it.
+
+  10. Each time you redistribute the Library (or any work based on the
+Library), the recipient automatically receives a license from the
+original licensor to copy, distribute, link with or modify the Library
+subject to these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties with
+this License.
+
+  11. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Library at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Library by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Library.
+
+If any portion of this section is held invalid or unenforceable under any
+particular circumstance, the balance of the section is intended to apply,
+and the section as a whole is intended to apply in other circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  12. If the distribution and/or use of the Library is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Library under this License may add
+an explicit geographical distribution limitation excluding those countries,
+so that distribution is permitted only in or among countries not thus
+excluded.  In such case, this License incorporates the limitation as if
+written in the body of this License.
+
+  13. The Free Software Foundation may publish revised and/or new
+versions of the Lesser General Public License from time to time.
+Such new versions will be similar in spirit to the present version,
+but may differ in detail to address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Library
+specifies a version number of this License which applies to it and
+"any later version", you have the option of following the terms and
+conditions either of that version or of any later version published by
+the Free Software Foundation.  If the Library does not specify a
+license version number, you may choose any version ever published by
+the Free Software Foundation.
+
+  14. If you wish to incorporate parts of the Library into other free
+programs whose distribution conditions are incompatible with these,
+write to the author to ask for permission.  For software which is
+copyrighted by the Free Software Foundation, write to the Free
+Software Foundation; we sometimes make exceptions for this.  Our
+decision will be guided by the two goals of preserving the free status
+of all derivatives of our free software and of promoting the sharing
+and reuse of software generally.
+
+			    NO WARRANTY
+
+  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
+WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
+EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
+OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
+KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
+LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
+THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
+WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
+AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
+FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
+CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
+LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
+RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
+FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
+SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+           How to Apply These Terms to Your New Libraries
+
+  If you develop a new library, and you want it to be of the greatest
+possible use to the public, we recommend making it free software that
+everyone can redistribute and change.  You can do so by permitting
+redistribution under these terms (or, alternatively, under the terms of the
+ordinary General Public License).
+
+  To apply these terms, attach the following notices to the library.  It is
+safest to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least the
+"copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the library's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+Also add information on how to contact you by electronic and paper mail.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the library, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the
+  library `Frob' (a library for tweaking knobs) written by James Random Hacker.
+
+  <signature of Ty Coon>, 1 April 1990
+  Ty Coon, President of Vice
+
+That's all there is to it!
+
+
diff -urN -x metis-4.0 original-libraries/SuiteSparse/KLU/Demo/Makefile SuiteSparse/KLU/Demo/Makefile
--- original-libraries/SuiteSparse/KLU/Demo/Makefile	2006-05-11 14:18:22.000000000 +0200
+++ SuiteSparse/KLU/Demo/Makefile	2006-12-15 18:01:08.000000000 +0100
@@ -5,22 +5,22 @@
 
 include ../../UFconfig/UFconfig.mk
 
-all: kludemo
+all: kludemo$(EXEEXT)
 
 I = -I../Include -I../../AMD/Include -I../../COLAMD -I../../BTF/Include \
 	-I../User -I../../CHOLMOD/Include -I$(METIS_PATH) -I../../CCOLAMD \
 	-I../../CAMD -I../../UFconfig
 
-LIBS = ../Lib/libklu.a ../../AMD/Lib/libamd.a ../../COLAMD/libcolamd.a \
-	../../BTF/Lib/libbtf.a ../User/libklu_cholmod.a \
-	../../CHOLMOD/Lib/libcholmod.a ../../CCOLAMD/libccolamd.a \
-	../../CAMD/Lib/libcamd.a $(METIS) $(LIB)
+LIBS = ../Lib/$(LIBPRE)klu.$(LIBEXT) ../../AMD/Lib/$(LIBPRE)amd.$(LIBEXT) ../../COLAMD/$(LIBPRE)colamd.$(LIBEXT) \
+	../../BTF/Lib/$(LIBPRE)btf.$(LIBEXT) ../User/$(LIBPRE)klu_cholmod.$(LIBEXT) \
+	../../CHOLMOD/Lib/$(LIBPRE)cholmod.$(LIBEXT) ../../CCOLAMD/$(LIBPRE)ccolamd.$(LIBEXT) \
+	../../CAMD/Lib/$(LIBPRE)camd.$(LIBEXT) $(METIS) $(CLIB)
 
-kludemo: library kludemo.c
-	$(CC) $(CFLAGS) $(I) kludemo.c dsecnd.c -o kludemo $(LIBS)
+kludemo$(EXEEXT): library kludemo.c
+	$(CC) $(CFLAGS) $(I) kludemo.c dsecnd.c -o kludemo$(EXEEXT) $(LIBS)
 
 purge: clean
-	- $(RM) kludemo
+	- $(RM) kludemo$(EXEEXT)
 
 distclean: purge
 
diff -urN -x metis-4.0 original-libraries/SuiteSparse/KLU/Lib/Makefile SuiteSparse/KLU/Lib/Makefile
--- original-libraries/SuiteSparse/KLU/Lib/Makefile	2006-06-24 23:16:06.000000000 +0200
+++ SuiteSparse/KLU/Lib/Makefile	2006-12-15 17:59:54.000000000 +0100
@@ -16,7 +16,7 @@
 
 all: library
 
-library: libklu.a
+library: $(LIBPRE)klu.$(LIBEXT)
 
 KLU_D = klu_d.o klu_d_kernel.o klu_d_dump.o \
     klu_d_factor.o klu_d_free_numeric.o klu_d_solve.o \
@@ -33,9 +33,9 @@
 
 OBJ = $(COMMON) $(KLU_D) $(KLU_Z)
 
-libklu.a: $(OBJ)
-	$(AR) libklu.a $(OBJ)
-	$(RANLIB) libklu.a
+$(LIBPRE)klu.$(LIBEXT): $(OBJ)
+	$(AR) $(LIBPRE)klu.$(LIBEXT) $(OBJ)
+	$(RANLIB) $(LIBPRE)klu.$(LIBEXT)
 
 $(OBJ): $(INC)
 
@@ -135,7 +135,7 @@
 purge: distclean
 
 distclean: clean
-	- $(RM) libklu.a 
+	- $(RM) $(LIBPRE)klu.$(LIBEXT) 
 
 clean:
 	- $(RM) $(CLEAN)
diff -urN -x metis-4.0 original-libraries/SuiteSparse/KLU/User/Makefile SuiteSparse/KLU/User/Makefile
--- original-libraries/SuiteSparse/KLU/User/Makefile	2006-05-11 14:18:54.000000000 +0200
+++ SuiteSparse/KLU/User/Makefile	2006-12-15 22:39:04.000000000 +0100
@@ -2,19 +2,19 @@
 
 include ../../UFconfig/UFconfig.mk
 
-all: libklu_cholmod.a
+all: $(LIBPRE)klu_cholmod.$(LIBEXT)
 
 I = -I../../CHOLMOD/Include -I../../UFconfig
 
-libklu_cholmod.a:  library klu_cholmod.c klu_cholmod.h
+$(LIBPRE)klu_cholmod.$(LIBEXT):  library klu_cholmod.c klu_cholmod.h
 	$(CC) $(CFLAGS) $(I) -c klu_cholmod.c
-	$(AR) libklu_cholmod.a klu_cholmod.o
-	$(RANLIB) libklu_cholmod.a
+	$(AR) $(LIBPRE)klu_cholmod.$(LIBEXT) klu_cholmod.o
+	$(RANLIB) $(LIBPRE)klu_cholmod.$(LIBEXT)
 
 distclean: purge
 
 purge: clean
-	- $(RM) *.o *.a
+	- $(RM) *.o *.$(LIBEXT)
 
 clean:
 	- $(RM) $(CLEAN)
diff -urN -x metis-4.0 original-libraries/SuiteSparse/LDL/Makefile SuiteSparse/LDL/Makefile
--- original-libraries/SuiteSparse/LDL/Makefile	2006-09-11 13:59:14.000000000 +0200
+++ SuiteSparse/LDL/Makefile	2006-12-15 22:42:08.000000000 +0100
@@ -8,7 +8,7 @@
 
 C = $(CC) $(CFLAGS)
 
-all: intro libldl.a ldlsimple ldlmain ldlamd
+all: intro $(LIBPRE)ldl.$(LIBEXT) ldlsimple$(EXEEXT) ldlmain$(EXEEXT) ldlamd$(EXEEXT)
 
 intro:
 	@echo " "
@@ -24,38 +24,38 @@
 # the ldl library:
 #-------------------------------------------------------------------------------
 
-libldl.a: ldl.c ldl.h
+$(LIBPRE)ldl.$(LIBEXT): ldl.c ldl.h
 	$(C) -c ldl.c -o ldl.o
-	$(AR) libldl.a ldl.o
-	- $(RANLIB) libldl.a
+	$(AR) $(LIBPRE)ldl.$(LIBEXT) ldl.o
+	- $(RANLIB) $(LIBPRE)ldl.$(LIBEXT)
 
 #-------------------------------------------------------------------------------
 # stand-alone C programs:
 #-------------------------------------------------------------------------------
 
-ldlmain:  ldlmain.c libldl.a
-	$(C) ldlmain.c libldl.a -o ldlmain -lm
+ldlmain$(EXEEXT):  ldlmain.c $(LIBPRE)ldl.$(LIBEXT)
+	$(C) ldlmain.c $(LIBPRE)ldl.$(LIBEXT) -o ldlmain$(EXEEXT) $(CLIB)
 	- ./ldlmain > my_ldlmain.out
-	- diff ldlmain.out my_ldlmain.out
+	- diff -b ldlmain.out my_ldlmain.out
 
-ldlsimple:  ldlsimple.c libldl.a
-	$(C) ldlsimple.c libldl.a -o ldlsimple -lm
+ldlsimple$(EXEEXT):  ldlsimple.c $(LIBPRE)ldl.$(LIBEXT)
+	$(C) ldlsimple.c $(LIBPRE)ldl.$(LIBEXT) -o ldlsimple$(EXEEXT) $(CLIB)
 	- ./ldlsimple > my_ldlsimple.out
-	- diff ldlsimple.out my_ldlsimple.out
+	- diff -b ldlsimple.out my_ldlsimple.out
 
-ldlamd:  ldlmain.c libldl.a
+ldlamd$(EXEEXT):  ldlmain.c $(LIBPRE)ldl.$(LIBEXT)
 	- (cd ../AMD ; $(MAKE))
-	- $(C) -I../AMD/Include -I../UFconfig -L../AMD/Lib -DUSE_AMD ldlmain.c -lamd libldl.a -o ldlamd -lm
+	- $(C) -I../AMD/Include -I../UFconfig -L../AMD/Lib -DUSE_AMD ldlmain.c -lamd $(LIBPRE)ldl.$(LIBEXT) -o ldlamd$(EXEEXT) $(CLIB)
 	- ./ldlamd > my_ldlamd.out
-	- diff ldlamd.out my_ldlamd.out
+	- diff -b ldlamd.out my_ldlamd.out
 
 run:
 	- ./ldlamd > my_ldlamd.out
-	- diff ldlamd.out my_ldlamd.out
+	- diff -b ldlamd.out my_ldlamd.out
 	- ./ldlsimple > my_ldlsimple.out
-	- diff ldlsimple.out my_ldlsimple.out
+	- diff -b ldlsimple.out my_ldlsimple.out
 	- ./ldlmain > my_ldlmain.out
-	- diff ldlmain.out my_ldlmain.out
+	- diff -b ldlmain.out my_ldlmain.out
 
 #-------------------------------------------------------------------------------
 # LDL mexFunctions for use in MATLAB:
@@ -74,7 +74,7 @@
 distclean: purge
 
 purge: clean
-	- $(RM) ldlsparse.mex* ldl.dll libldl.a ldlmain ldlamd ldlsimple
+	- $(RM) ldlsparse.mex* ldl.dll $(LIBPRE)ldl.$(LIBEXT) ldlmain$(EXEEXT) ldlamd$(EXEEXT) ldlsimple$(EXEEXT)
 	- $(RM) my_ldlmain.out my_ldlamd.out my_ldlsimple.out
 	- $(RM) ldlmain.mex* ldlamd.mex* ldlmain.dll ldlamd.dll
 	- $(RM) ldlsymbol.mex* ldlsymbol.dll
diff -urN -x metis-4.0 original-libraries/SuiteSparse/Makefile SuiteSparse/Makefile
--- original-libraries/SuiteSparse/Makefile	2006-12-01 17:31:30.000000000 +0100
+++ SuiteSparse/Makefile	2007-01-31 15:27:49.654795800 +0100
@@ -7,7 +7,7 @@
 # Compile the default rules for each package
 default:
 	( cd UFconfig/xerbla ; $(MAKE) )
-	( cd metis-4.0 ; $(MAKE) )
+#	( cd metis-4.0 ; $(MAKE) )
 	( cd AMD ; $(MAKE) )
 	( cd CAMD ; $(MAKE) )
 	( cd COLAMD ; $(MAKE) )
@@ -18,7 +18,7 @@
 	( cd UMFPACK ; $(MAKE) )
 	( cd CHOLMOD ; $(MAKE) )
 	( cd CSparse ; $(MAKE) )
-	( cd CXSparse ; $(MAKE) )
+	( cd CXSparse-C++ ; $(MAKE) )
 #	( cd LPDASA ; $(MAKE) )
 #	( cd PARAKLETE ; $(MAKE) )
 
@@ -42,7 +42,7 @@
 # Remove all files not in the original distribution
 purge:
 	( cd UFconfig/xerbla ; $(MAKE) purge )
-	( cd metis-4.0 ; $(MAKE) realclean )
+#	( cd metis-4.0 ; $(MAKE) realclean )
 	( cd AMD ; $(MAKE) purge )
 	( cd CAMD ; $(MAKE) purge )
 	( cd COLAMD ; $(MAKE) purge )
@@ -53,7 +53,7 @@
 	( cd UMFPACK ; $(MAKE) purge )
 	( cd CHOLMOD ; $(MAKE) purge )
 	( cd CSparse ; $(MAKE) purge )
-	( cd CXSparse ; $(MAKE) purge )
+	( cd CXSparse-C++ ; $(MAKE) purge )
 	( cd RBio ; $(MAKE) purge )
 	( cd UFcollection ; $(MAKE) purge )
 #	( cd LPDASA ; $(MAKE) purge )
@@ -62,7 +62,7 @@
 # Remove all files not in the original distribution, but keep the libraries
 clean:
 	( cd UFconfig/xerbla ; $(MAKE) clean )
-	( cd metis-4.0 ; $(MAKE) clean )
+#	( cd metis-4.0 ; $(MAKE) clean )
 	( cd AMD ; $(MAKE) clean )
 	( cd CAMD ; $(MAKE) clean )
 	( cd COLAMD ; $(MAKE) clean )
@@ -73,7 +73,7 @@
 	( cd UMFPACK ; $(MAKE) clean )
 	( cd CHOLMOD ; $(MAKE) clean )
 	( cd CSparse ; $(MAKE) clean )
-	( cd CXSparse ; $(MAKE) clean )
+	( cd CXSparse-C++ ; $(MAKE) clean )
 	( cd RBio ; $(MAKE) clean )
 	( cd UFcollection ; $(MAKE) clean )
 #	( cd LPDASA ; $(MAKE) clean )
diff -urN -x metis-4.0 original-libraries/SuiteSparse/UFconfig/UFconfig.mk SuiteSparse/UFconfig/UFconfig.mk
--- original-libraries/SuiteSparse/UFconfig/UFconfig.mk	2006-11-29 06:18:52.000000000 +0100
+++ SuiteSparse/UFconfig/UFconfig.mk	2006-12-19 10:54:11.920108700 +0100
@@ -31,12 +31,12 @@
 # C compiler and compiler flags:  These will normally not give you optimal
 # performance.  You should select the optimization parameters that are best
 # for your system.  On Linux, use "CFLAGS = -O3 -fexceptions" for example.
-CC = cc
-CFLAGS = -O
+CC = cc-msvc
+CFLAGS = -MD -O2
 
 # ranlib, and ar, for generating libraries
-RANLIB = ranlib
-AR = ar cr
+RANLIB = ranlib-msvc
+AR = ar-msvc cr
 
 # delete and rename a file
 RM = rm -f
@@ -48,7 +48,7 @@
 F77LIB =
 
 # C and Fortran libraries
-LIB = -lm
+CLIB =
 
 # For compiling MATLAB mexFunctions
 MEX = mex -O
@@ -57,6 +57,10 @@
 # MAKE = make
 # MAKE = gmake
 
+LIBPRE =
+LIBEXT = lib
+EXEEXT = .exe
+
 #------------------------------------------------------------------------------
 # BLAS and LAPACK configuration:
 #------------------------------------------------------------------------------
@@ -73,7 +77,7 @@
 # These settings will probably not work, since there is no fixed convention for
 # naming the BLAS and LAPACK library (*.a or *.so) files.  Assume the Goto
 # BLAS are available.
-BLAS = -lgoto -lgfortran -lgfortranbegin
+BLAS = -lblas
 LAPACK = -llapack
 
 # The BLAS might not contain xerbla, an error-handling routine for LAPACK and
@@ -102,13 +106,13 @@
 # The path is relative to where it is used, in CHOLMOD/Lib, CHOLMOD/MATLAB, etc.
 # You may wish to use an absolute path.  METIS is optional.  Compile
 # CHOLMOD with -DNPARTITION if you do not wish to use METIS.
-METIS_PATH = ../../metis-4.0
-METIS = ../../metis-4.0/libmetis.a
+# METIS_PATH = ../../metis-4.0
+# METIS = ../../metis-4.0/$(LIBPRE)metis.$(LIBEXT)
 
 # If you use CHOLMOD_CONFIG = -DNPARTITION then you must use the following
 # options:
-# METIS_PATH =
-# METIS =
+METIS_PATH =
+METIS =
 
 #------------------------------------------------------------------------------
 # UMFPACK configuration:
@@ -126,7 +130,7 @@
 # -DNRECIPROCAL	do not multiply by the reciprocal
 # -DNO_DIVIDE_BY_ZERO	do not divide by zero
 
-UMFPACK_CONFIG = 
+UMFPACK_CONFIG = -DBLAS_UNDERSCORE
 
 #------------------------------------------------------------------------------
 # CHOLMOD configuration
@@ -164,7 +168,7 @@
 # -DNSUNPERF	    for Solaris only.  If defined, do not use the Sun
 #			Performance Library
 
-CHOLMOD_CONFIG =
+CHOLMOD_CONFIG = -DNPARTITION -DBLAS_UNDERSCORE
 
 #------------------------------------------------------------------------------
 # Linux
@@ -181,7 +185,7 @@
 # CFLAGS = -O3 -fexceptions \
    	-Wall -W -Werror -Wshadow -Wmissing-prototypes -Wstrict-prototypes \
     	-Wredundant-decls -Wnested-externs -Wdisabled-optimization -ansi
-CFLAGS = -O3 -fexceptions
+# CFLAGS = -O3 -fexceptions
 # CFLAGS = -O3
 
 # consider:
@@ -295,4 +299,4 @@
 # remove object files and profile output
 #------------------------------------------------------------------------------
 
-CLEAN = *.o *.obj *.ln *.bb *.bbg *.da *.tcov *.gcov gmon.out *.bak *.d
+CLEAN = *.o *.obj *.ln *.bb *.bbg *.da *.tcov *.gcov gmon.out *.bak *.d *.exe *.lib *.ilk *.exp
diff -urN -x metis-4.0 original-libraries/SuiteSparse/UFconfig/xerbla/Makefile SuiteSparse/UFconfig/xerbla/Makefile
--- original-libraries/SuiteSparse/UFconfig/xerbla/Makefile	2006-01-30 11:50:58.000000000 +0100
+++ SuiteSparse/UFconfig/xerbla/Makefile	2006-12-15 17:37:12.000000000 +0100
@@ -4,22 +4,22 @@
 
 include ../UFconfig.mk
 
-ccode: libcerbla.a
+ccode: $(LIBPRE)cerbla.$(LIBEXT)
 
-fortran: libxerbla.a 
+fortran: $(LIBPRE)xerbla.$(LIBEXT) 
 
-all: libxerbla.a libcerbla.a
+all: $(LIBPRE)xerbla.$(LIBEXT) $(LIBPRE)cerbla.$(LIBEXT)
 
 # Fortran version:
-libxerbla.a: xerbla.f
+$(LIBPRE)xerbla.$(LIBEXT): xerbla.f
 	$(F77) $(F77FLAGS) -c xerbla.f
-	$(AR) libxerbla.a xerbla.o
+	$(AR) $(LIBPRE)xerbla.$(LIBEXT) xerbla.o
 	- $(RM) xerbla.o
 
 # C version:
-libcerbla.a: xerbla.c xerbla.h
+$(LIBPRE)cerbla.$(LIBEXT): xerbla.c xerbla.h
 	$(CC) $(CFLAGS) -c xerbla.c
-	$(AR) libcerbla.a xerbla.o
+	$(AR) $(LIBPRE)cerbla.$(LIBEXT) xerbla.o
 	- $(RM) xerbla.o
 
 distclean: purge
diff -urN -x metis-4.0 original-libraries/SuiteSparse/UMFPACK/Demo/Makefile SuiteSparse/UMFPACK/Demo/Makefile
--- original-libraries/SuiteSparse/UMFPACK/Demo/Makefile	2006-05-02 09:46:22.000000000 +0200
+++ SuiteSparse/UMFPACK/Demo/Makefile	2006-12-15 23:02:26.000000000 +0100
@@ -5,25 +5,25 @@
 # UMFPACK Version 4.4, Copyright (c) 2005 by Timothy A. Davis.
 # All Rights Reserved.  See ../Doc/License for License.
 
-default: libs umfpack_di_demo umfpack_zi_demo umfpack_dl_demo umfpack_zl_demo \
-	umfpack_simple
-
 include ../../UFconfig/UFconfig.mk
 
+default: libs umfpack_di_demo$(EXEEXT) umfpack_zi_demo$(EXEEXT) umfpack_dl_demo$(EXEEXT) umfpack_zl_demo$(EXEEXT) \
+	umfpack_simple$(EXEEXT)
+
 C = $(CC) $(CFLAGS) $(UMFPACK_CONFIG) -I../Include -I../../AMD/Include \
     -I../../UFconfig
 
 INC = ../Include/umfpack.h ../../AMD/Include/amd.h ../../UFconfig/UFconfig.h
 
-LIBS = $(BLAS) $(XERBLA) $(LIB)
+LIBS = $(BLAS) $(XERBLA) $(CLIB)
 
-../Lib/libumfpack.a:
+../Lib/$(LIBPRE)umfpack.$(LIBEXT):
 	( cd ../Source ; $(MAKE) )
 
-../../AMD/Lib/libamd.a:
+../../AMD/Lib/$(LIBPRE)amd.$(LIBEXT):
 	( cd ../../AMD/Source ; $(MAKE) )
 
-UMFPACK = ../Lib/libumfpack.a ../../AMD/Lib/libamd.a
+UMFPACK = ../Lib/$(LIBPRE)umfpack.$(LIBEXT) ../../AMD/Lib/$(LIBPRE)amd.$(LIBEXT)
 
 libs:
 	( cd ../Source ; $(MAKE) )
@@ -35,8 +35,8 @@
 
 dist: umfpack_di_demo.c umfpack_dl_demo.c umfpack_zi_demo.c umfpack_zl_demo.c
 
-umfpack_simple: umfpack_simple.c $(INC) $(UMFPACK)
-	$(C) -o umfpack_simple umfpack_simple.c $(UMFPACK) $(LIBS)
+umfpack_simple$(EXEEXT): umfpack_simple.c $(INC) $(UMFPACK)
+	$(C) -o umfpack_simple$(EXEEXT) umfpack_simple.c $(UMFPACK) $(LIBS)
 	./umfpack_simple
 
 # the GNU rules are simpler:
@@ -53,44 +53,44 @@
 umfpack_di_demo.c: umfpack_xx_demo.c umfpack_di_demo.sed
 	- sed -f umfpack_di_demo.sed < umfpack_xx_demo.c > umfpack_di_demo.c
 
-umfpack_di_demo: umfpack_di_demo.c $(INC) $(UMFPACK)
-	$(C) -o umfpack_di_demo umfpack_di_demo.c $(UMFPACK) $(LIBS)
+umfpack_di_demo$(EXEEXT): umfpack_di_demo.c $(INC) $(UMFPACK)
+	$(C) -o umfpack_di_demo$(EXEEXT) umfpack_di_demo.c $(UMFPACK) $(LIBS)
 	./umfpack_di_demo > my_umfpack_di_demo.out
-	- diff umfpack_di_demo.out my_umfpack_di_demo.out
+	- diff -b umfpack_di_demo.out my_umfpack_di_demo.out
 
 # double-precision, UF_long verion:
 umfpack_dl_demo.c: umfpack_xx_demo.c umfpack_dl_demo.sed
 	- sed -f umfpack_dl_demo.sed < umfpack_xx_demo.c > umfpack_dl_demo.c
 
-umfpack_dl_demo: umfpack_dl_demo.c $(INC) $(UMFPACK)
-	$(C) -o umfpack_dl_demo umfpack_dl_demo.c $(UMFPACK) $(LIBS)
+umfpack_dl_demo$(EXEEXT): umfpack_dl_demo.c $(INC) $(UMFPACK)
+	$(C) -o umfpack_dl_demo$(EXEEXT) umfpack_dl_demo.c $(UMFPACK) $(LIBS)
 	./umfpack_dl_demo > my_umfpack_dl_demo.out
-	- diff umfpack_dl_demo.out my_umfpack_dl_demo.out
+	- diff -b umfpack_dl_demo.out my_umfpack_dl_demo.out
 
 # complex, int verion:
 umfpack_zi_demo.c: umfpack_xx_demo.c umfpack_zi_demo.sed
 	- sed -f umfpack_zi_demo.sed < umfpack_xx_demo.c > umfpack_zi_demo.c
 
-umfpack_zi_demo: umfpack_zi_demo.c $(INC) $(UMFPACK)
-	$(C) -o umfpack_zi_demo umfpack_zi_demo.c $(UMFPACK) $(LIBS)
+umfpack_zi_demo$(EXEEXT): umfpack_zi_demo.c $(INC) $(UMFPACK)
+	$(C) -o umfpack_zi_demo$(EXEEXT) umfpack_zi_demo.c $(UMFPACK) $(LIBS)
 	./umfpack_zi_demo > my_umfpack_zi_demo.out
-	- diff umfpack_zi_demo.out my_umfpack_zi_demo.out
+	- diff -b umfpack_zi_demo.out my_umfpack_zi_demo.out
 
 # complex, UF_long verion:
 umfpack_zl_demo.c: umfpack_xx_demo.c umfpack_zl_demo.sed
 	- sed -f umfpack_zl_demo.sed < umfpack_xx_demo.c > umfpack_zl_demo.c
 
-umfpack_zl_demo: umfpack_zl_demo.c $(INC) $(UMFPACK)
-	$(C) -o umfpack_zl_demo umfpack_zl_demo.c $(UMFPACK) $(LIBS)
+umfpack_zl_demo$(EXEEXT): umfpack_zl_demo.c $(INC) $(UMFPACK)
+	$(C) -o umfpack_zl_demo$(EXEEXT) umfpack_zl_demo.c $(UMFPACK) $(LIBS)
 	./umfpack_zl_demo > my_umfpack_zl_demo.out
-	- diff umfpack_zl_demo.out my_umfpack_zl_demo.out
+	- diff -b umfpack_zl_demo.out my_umfpack_zl_demo.out
 
 #-------------------------------------------------------------------------------
 # create a demo program that reads in Harwell/Boeing matrices, and run it
 #-------------------------------------------------------------------------------
 
 # the output of "make hb" is in the file umf4.out
-hb: $(UMFPACK) umf4 readhb readhb_nozeros readhb_size
+hb: $(UMFPACK) umf4 readhb$(EXEEXT) readhb_nozeros$(EXEEXT) readhb_size$(EXEEXT)
 	- ./readhb_nozeros < HB/can_24.psa > tmp/A
 	- ./readhb_size    < HB/can_24.psa > tmp/Asize
 	- ./umf4
@@ -113,17 +113,17 @@
 	- ./readhb_size    < HB/arc130.rua > tmp/Asize
 	- ./umf4 a 1e-6
 
-umf4: umf4.c $(UMFPACK)
-	$(C) -o umf4 umf4.c $(UMFPACK) $(LIBS)
+umf4$(EXEEXT): umf4.c $(UMFPACK)
+	$(C) -o umf4$(EXEEXT) umf4.c $(UMFPACK) $(LIBS)
 
-readhb:  readhb.f
-	$(F77) $(F77FLAGS) -o readhb readhb.f $(F77LIB)
+readhb$(EXEEXT):  readhb.f
+	$(F77) $(F77FLAGS) -o readhb$(EXEEXT) readhb.f $(F77LIB)
 
-readhb_size:  readhb_size.f
-	$(F77) $(F77FLAGS) -o readhb_size readhb_size.f $(F77LIB)
+readhb_size$(EXEEXT):  readhb_size.f
+	$(F77) $(F77FLAGS) -o readhb_size$(EXEEXT) readhb_size.f $(F77LIB)
 
-readhb_nozeros:  readhb_nozeros.f
-	$(F77) $(F77FLAGS) -o readhb_nozeros readhb_nozeros.f $(F77LIB)
+readhb_nozeros$(EXEEXT):  readhb_nozeros.f
+	$(F77) $(F77FLAGS) -o readhb_nozeros$(EXEEXT) readhb_nozeros.f $(F77LIB)
 
 #-------------------------------------------------------------------------------
 # compile the FORTRAN interface and demo
@@ -162,14 +162,14 @@
 #-------------------------------------------------------------------------------
 
 purge: clean
-	- $(RM) umfpack_simple a.out
-	- $(RM) umfpack_di_demo my_umfpack_di_demo.out
-	- $(RM) umfpack_dl_demo my_umfpack_dl_demo.out
-	- $(RM) umfpack_zi_demo my_umfpack_zi_demo.out
-	- $(RM) umfpack_zl_demo my_umfpack_zl_demo.out
+	- $(RM) umfpack_simple$(EXEEXT) a.out
+	- $(RM) umfpack_di_demo$(EXEEXT) my_umfpack_di_demo.out
+	- $(RM) umfpack_dl_demo$(EXEEXT) my_umfpack_dl_demo.out
+	- $(RM) umfpack_zi_demo$(EXEEXT) my_umfpack_zi_demo.out
+	- $(RM) umfpack_zl_demo$(EXEEXT) my_umfpack_zl_demo.out
 	- $(RM) umf4hb umf4zhb *.umf my_umf4hb.out
 	- $(RM) umf4hb64 my_umf4hb64.out my_umf4zhb.out
-	- $(RM) umf4 readhb readhb_nozeros readhb_size tmp/*
+	- $(RM) umf4$(EXEEXT) readhb$(EXEEXT) readhb_nozeros$(EXEEXT) readhb_size$(EXEEXT) tmp/*
 
 clean:
 	- $(RM) $(CLEAN)
diff -urN -x metis-4.0 original-libraries/SuiteSparse/UMFPACK/Source/GNUmakefile SuiteSparse/UMFPACK/Source/GNUmakefile
--- original-libraries/SuiteSparse/UMFPACK/Source/GNUmakefile	2006-05-02 10:36:46.000000000 +0200
+++ SuiteSparse/UMFPACK/Source/GNUmakefile	2006-12-15 22:45:34.000000000 +0100
@@ -2,10 +2,10 @@
 # UMFPACK Makefile for compiling on Unix systems (for GNU Make)
 #-------------------------------------------------------------------------------
 
-default: ../Lib/libumfpack.a
-
 include ../../UFconfig/UFconfig.mk
 
+default: ../Lib/$(LIBPRE)umfpack.$(LIBEXT)
+
 C = $(CC) $(CFLAGS) $(UMFPACK_CONFIG) \
     -I../Include -I../../AMD/Include -I../../UFconfig
 
@@ -242,16 +242,16 @@
 # Create the libumfpack.a library
 #-------------------------------------------------------------------------------
 
-../Lib/libumfpack.a: $(II) $(LL) $(GN) $(DI) $(DL) $(ZI) $(ZL)
-	$(AR) ../Lib/libumfpack.a $^
-	- $(RANLIB) ../Lib/libumfpack.a
+../Lib/$(LIBPRE)umfpack.$(LIBEXT): $(II) $(LL) $(GN) $(DI) $(DL) $(ZI) $(ZL)
+	$(AR) ../Lib/$(LIBPRE)umfpack.$(LIBEXT) $^
+	- $(RANLIB) ../Lib/$(LIBPRE)umfpack.$(LIBEXT)
 
 #-------------------------------------------------------------------------------
 # Remove all but the files in the original distribution
 #-------------------------------------------------------------------------------
 
 purge: clean
-	- $(RM) ../Lib/libumfpack.a
+	- $(RM) ../Lib/$(LIBPRE)umfpack.$(LIBEXT)
 
 clean:
 	- $(RM) $(CLEAN)
diff -urN -x metis-4.0 original-libraries/SuiteSparse/UMFPACK/Source/cholmod_blas.h SuiteSparse/UMFPACK/Source/cholmod_blas.h
--- original-libraries/SuiteSparse/UMFPACK/Source/cholmod_blas.h	2006-08-27 16:30:22.000000000 +0200
+++ SuiteSparse/UMFPACK/Source/cholmod_blas.h	2006-12-15 22:51:18.000000000 +0100
@@ -48,8 +48,10 @@
 #define CHOLMOD_CYGWIN
 #else
 #define CHOLMOD_WINDOWS
+#ifndef BLAS_UNDERSCORE
 #define BLAS_NO_UNDERSCORE
 #endif
+#endif
 #define CHOLMOD_ARCHITECTURE "Microsoft Windows"
 
 #elif defined (__hppa) || defined (__hpux) || defined (MHPUX) || defined (ARCH_HPUX)
