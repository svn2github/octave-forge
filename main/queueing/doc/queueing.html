<html lang="en">
<head>
<title>queueing</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="User manual for the queueing toolbox, a GNU Octave package for queueing networks and Markov chains analysis. This package supports single-station queueing systems, queueing networks and Markov chains. The queueing toolbox implements, among others, the Mean Value Analysis (MVA) and convolution algorithms for product-form queueing networks. Transient and steady-state analysis of Markov chains is also implemented.">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="top" href="#Top">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
Copyright &copy; 2008, 2009, 2010, 2011, 2012 Moreno Marzolla.

   <p>Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

   <p>Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that
the entire resulting derived work is distributed under the terms of
a permission notice identical to this one.

   <p>Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for
modified versions.

<div class="contents">
<h2>Table of Contents</h2>
<ul>
<li><a name="toc_Top" href="#Top">queueing</a>
<li><a name="toc_Summary" href="#Summary">1 Summary</a>
<li><a name="toc_Installation" href="#Installation">2 Installing the queueing toolbox</a>
<ul>
<li><a href="#Installation-through-Octave-package-management-system">2.1 Installation through Octave package management system</a>
<li><a href="#Manual-installation">2.2 Manual installation</a>
<li><a href="#Content-of-the-source-distribution">2.3 Content of the source distribution</a>
<li><a href="#Using-the-queueing-toolbox">2.4 Using the queueing toolbox</a>
</li></ul>
<li><a name="toc_Getting-Started" href="#Getting-Started">3 Introduction and Getting Started</a>
<ul>
<li><a href="#Analysis-of-Closed-Networks">3.1 Analysis of Closed Networks</a>
<li><a href="#Analysis-of-Open-Networks">3.2 Analysis of Open Networks</a>
</li></ul>
<li><a name="toc_Markov-Chains" href="#Markov-Chains">4 Markov Chains</a>
<ul>
<li><a href="#Discrete_002dTime-Markov-Chains">4.1 Discrete-Time Markov Chains</a>
<ul>
<li><a href="#DTMC-Stationary-Probability">4.1.1 Stationary Probability</a>
<li><a href="#DTMC-First-Passage-Times">4.1.2 First Passage Times</a>
</li></ul>
<li><a href="#Continuous_002dTime-Markov-Chains">4.2 Continuous-Time Markov Chains</a>
<ul>
<li><a href="#CTMC-Stationary-Probability">4.2.1 Stationary Probability</a>
<li><a href="#Birth_002dDeath-process">4.2.2 Birth-Death process</a>
<li><a href="#Expected-Sojourn-Time">4.2.3 Expected Sojourn Time</a>
<li><a href="#Time_002dAveraged-Expected-Sojourn-Time">4.2.4 Time-Averaged Expected Sojourn Time</a>
<li><a href="#Expected-Time-to-Absorption">4.2.5 Expected Time to Absorption</a>
<li><a href="#CTMC-First-Passage-Times">4.2.6 First Passage Times</a>
</li></ul>
</li></ul>
<li><a name="toc_Single-Station-Queueing-Systems" href="#Single-Station-Queueing-Systems">5 Single Station Queueing Systems</a>
<ul>
<li><a href="#The-M_002fM_002f1-System">5.1 The M/M/1 System</a>
<li><a href="#The-M_002fM_002fm-System">5.2 The M/M/m System</a>
<li><a href="#The-M_002fM_002finf-System">5.3 The M/M/inf System</a>
<li><a href="#The-M_002fM_002f1_002fK-System">5.4 The M/M/1/K System</a>
<li><a href="#The-M_002fM_002fm_002fK-System">5.5 The M/M/m/K System</a>
<li><a href="#The-Asymmetric-M_002fM_002fm-System">5.6 The Asymmetric M/M/m System</a>
<li><a href="#The-M_002fG_002f1-System">5.7 The M/G/1 System</a>
<li><a href="#The-M_002fHm_002f1-System">5.8 The M/H_m/1 System</a>
</li></ul>
<li><a name="toc_Queueing-Networks" href="#Queueing-Networks">6 Queueing Networks</a>
<ul>
<li><a href="#Introduction-to-QNs">6.1 Introduction to QNs</a>
<ul>
<li><a href="#Introduction-to-QNs">6.1.1 Single class models</a>
<li><a href="#Introduction-to-QNs">6.1.2 Multiple class models</a>
</li></ul>
<li><a href="#Generic-Algorithms">6.2 Generic Algorithms</a>
<li><a href="#Algorithms-for-Product_002dForm-QNs">6.3 Algorithms for Product-Form QNs</a>
<ul>
<li><a href="#Algorithms-for-Product_002dForm-QNs">6.3.1 Jackson Networks</a>
<li><a href="#Algorithms-for-Product_002dForm-QNs">6.3.2 The Convolution Algorithm</a>
<li><a href="#Algorithms-for-Product_002dForm-QNs">6.3.3 Open networks</a>
<li><a href="#Algorithms-for-Product_002dForm-QNs">6.3.4 Closed Networks</a>
<li><a href="#Algorithms-for-Product_002dForm-QNs">6.3.5 Mixed Networks</a>
</li></ul>
<li><a href="#Algorithms-for-non-Product_002dform-QNs">6.4 Algorithms for non Product-Form QNs</a>
<li><a href="#Bounds-on-performance">6.5 Bounds on performance</a>
<li><a href="#Utility-functions">6.6 Utility functions</a>
<ul>
<li><a href="#Utility-functions">6.6.1 Open or closed networks</a>
<li><a href="#Utility-functions">6.6.2 Computation of the visit counts</a>
<li><a href="#Utility-functions">6.6.3 Other utility functions</a>
</li></ul>
</li></ul>
<li><a name="toc_Contributing-Guidelines" href="#Contributing-Guidelines">Appendix A Contributing Guidelines</a>
<li><a name="toc_Acknowledgements" href="#Acknowledgements">Appendix B Acknowledgements</a>
<li><a name="toc_Copying" href="#Copying">Appendix C GNU GENERAL PUBLIC LICENSE</a>
<li><a name="toc_Concept-Index" href="#Concept-Index">Concept Index</a>
<li><a name="toc_Function-Index" href="#Function-Index">Function Index</a>
<li><a name="toc_Author-Index" href="#Author-Index">Author Index</a>
</li></ul>
</div>

<div class="node">
<a name="Top"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Summary">Summary</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dir">(dir)</a>

</div>

<h2 class="unnumbered">queueing</h2>

<p>This manual documents how to install and run the Queueing Toolbox. 
It corresponds to version 1.0.0 of the package.

<!--  -->
<ul class="menu">
<li><a accesskey="1" href="#Summary">Summary</a>
<li><a accesskey="2" href="#Installation">Installation</a>:                 Installation of the queueing toolbox. 
<li><a accesskey="3" href="#Getting-Started">Getting Started</a>:              Getting started with the queueing toolbox. 
<li><a accesskey="4" href="#Markov-Chains">Markov Chains</a>:                Functions for Markov Chains. 
<li><a accesskey="5" href="#Single-Station-Queueing-Systems">Single Station Queueing Systems</a>:  Functions for single-station queueing systems. 
<li><a accesskey="6" href="#Queueing-Networks">Queueing Networks</a>:            Functions for queueing networks. 
<li><a accesskey="7" href="#Contributing-Guidelines">Contributing Guidelines</a>:      How to contribute. 
<li><a accesskey="8" href="#Acknowledgements">Acknowledgements</a>:             People who contributed to the queueing toolbox. 
<li><a accesskey="9" href="#Copying">Copying</a>:                      The GNU General Public License. 
<li><a href="#Concept-Index">Concept Index</a>:                An item for each concept. 
<li><a href="#Function-Index">Function Index</a>:               An item for each function. 
<li><a href="#Author-Index">Author Index</a>:                 An item for each author. 
</ul>

<!--  -->
<!-- DO NOT EDIT!  Generated automatically by munge-texi. -->
<!-- *- texinfo -*- -->
<!-- Copyright (C) 2008, 2009, 2010, 2011, 2012 Moreno Marzolla -->
<!-- This file is part of the queueing toolbox, a Queueing Networks -->
<!-- analysis package for GNU Octave. -->
<!-- The queueing toolbox is free software; you can redistribute it -->
<!-- and/or modify it under the terms of the GNU General Public License -->
<!-- as published by the Free Software Foundation; either version 3 of -->
<!-- the License, or (at your option) any later version. -->
<!-- The queueing toolbox is distributed in the hope that it will be -->
<!-- useful, but WITHOUT ANY WARRANTY; without even the implied warranty -->
<!-- of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the -->
<!-- GNU General Public License for more details. -->
<!-- You should have received a copy of the GNU General Public License -->
<!-- along with the queueing toolbox; see the file COPYING.  If not, see -->
<!-- <http://www.gnu.org/licenses/>. -->
<div class="node">
<a name="Summary"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Installation">Installation</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Top">Top</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">1 Summary</h2>

<p>This document describes the <code>queueing</code> toolbox for GNU Octave
(<code>queueing</code> in short). The <code>queueing</code> toolbox, previously
known as <code>qnetworks</code>, is a collection of functions written in GNU
Octave for analyzing queueing networks and Markov
chains. Specifically, <code>queueing</code> contains functions for analyzing
Jackson networks, open, closed or mixed product-form BCMP networks,
and computation of performance bounds. The following algorithms have
been implemented

     <ul>
<li>Convolution for closed, single-class product-form networks
with load-dependent service centers;

     <li>Exact and approximate Mean Value Analysis (MVA) for single and
multiple class product-form closed networks;

     <li>MVA for mixed, multiple class product-form networks
with load-independent service centers;

     <li>Approximate MVA for closed, single-class networks with blocking
(MVABLO algorithm by F. Akyildiz);

     <li>Computation of Asymptotic Bounds, Balanced System Bounds
and Geometric Bounds;

   </ul>

<p class="noindent"><code>queueing</code>
provides functions for analyzing the following kind of single-station
queueing systems:

     <ul>
<li>M/M/1
<li>M/M/m
<li>M/M/\infty
<li>M/M/1/k single-server, finite capacity system
<li>M/M/m/k multiple-server, finite capacity system
<li>Asymmetric M/M/m
<li>M/G/1 (general service time distribution)
<li>M/H_m/1 (Hyperexponential service time distribution)
</ul>

   <p>Functions for Markov chain analysis are also provided (discrete and
continuous time Markov chains are supported):

     <ul>
<li>Birth-death process;
<li>Computation of transient and steady-state occupancy probabilities;
<li>Computation of mean time to absorption;
<li>Computation of time-averages sojourn time. 
<li>Computation of mean passage times

   </ul>

   <p>The <code>queueing</code> toolbox is distributed under the terms of the GNU
General Public License (GPL), version 3 or later
(see <a href="#Copying">Copying</a>). You are encouraged to share this software with
others, and make this package more useful by contributing additional
functions and reporting problems. See <a href="#Contributing-Guidelines">Contributing Guidelines</a>.

   <p>If you use the <code>queueing</code> toolbox in a technical paper, please
cite it as:

   <blockquote>
Moreno Marzolla, <em>The qnetworks Toolbox: A Software Package for
Queueing Networks Analysis</em>. Khalid Al-Begain, Dieter Fiems and
William J. Knottenbelt, Editors, Proceedings 17th International
Conference on Analytical and Stochastic Modeling Techniques and
Applications (ASMTA 2010) Cardiff, UK, June 14&ndash;16, 2010, volume 6148
of Lecture Notes in Computer Science, Springer, pp. 102&ndash;116, ISBN
978-3-642-13567-5
</blockquote>

   <p>If you use BibTeX, this is the citation block:

<pre class="verbatim">@inproceedings{queueing,
  author    = {Moreno Marzolla},
  title     = {The qnetworks Toolbox: A Software Package for Queueing 
               Networks Analysis},
  booktitle = {Analytical and Stochastic Modeling Techniques and 
               Applications, 17th International Conference, 
               ASMTA 2010, Cardiff, UK, June 14-16, 2010. Proceedings},
  editor    = {Khalid Al-Begain and Dieter Fiems and William J. Knottenbelt},
  year      = {2010},
  publisher = {Springer},
  series    = {Lecture Notes in Computer Science},
  volume    = {6148},
  pages     = {102--116},
  ee        = {http://dx.doi.org/10.1007/978-3-642-13568-2_8},
  isbn      = {978-3-642-13567-5}
}
</pre>

   <p>An early draft of the paper above is available as Technical Report
<a href="http://www.informatica.unibo.it/ricerca/ublcs/2010/UBLCS-2010-04">UBLCS-2010-04</a>, February 2010, Department of Computer Science,
University of Bologna, Italy.

<!-- DO NOT EDIT!  Generated automatically by munge-texi. -->
<!-- *- texinfo -*- -->
<!-- Copyright (C) 2008, 2009, 2010, 2011, 2012 Moreno Marzolla -->
<!-- This file is part of the queueing toolbox, a Queueing Networks -->
<!-- analysis package for GNU Octave. -->
<!-- The queueing toolbox is free software; you can redistribute it -->
<!-- and/or modify it under the terms of the GNU General Public License -->
<!-- as published by the Free Software Foundation; either version 3 of -->
<!-- the License, or (at your option) any later version. -->
<!-- The queueing toolbox is distributed in the hope that it will be -->
<!-- useful, but WITHOUT ANY WARRANTY; without even the implied warranty -->
<!-- of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the -->
<!-- GNU General Public License for more details. -->
<!-- You should have received a copy of the GNU General Public License -->
<!-- along with the queueing toolbox; see the file COPYING.  If not, see -->
<!-- <http://www.gnu.org/licenses/>. -->
<div class="node">
<a name="Installation"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Getting-Started">Getting Started</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Summary">Summary</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">2 Installing the queueing toolbox</h2>

<ul class="menu">
<li><a accesskey="1" href="#Installation-through-Octave-package-management-system">Installation through Octave package management system</a>
<li><a accesskey="2" href="#Manual-installation">Manual installation</a>
<li><a accesskey="3" href="#Content-of-the-source-distribution">Content of the source distribution</a>
<li><a accesskey="4" href="#Using-the-queueing-toolbox">Using the queueing toolbox</a>
</ul>

<div class="node">
<a name="Installation-through-Octave-package-management-system"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Manual-installation">Manual installation</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Installation">Installation</a>

</div>

<h3 class="section">2.1 Installation through Octave package management system</h3>

<p>The most recent version of <code>queueing</code> is 1.0.0 and can
be downloaded from

   <p><a href="http://www.moreno.marzolla.name/software/queueing/queueing-1.0.0.tar.gz">http://www.moreno.marzolla.name/software/queueing/queueing-1.0.0.tar.gz</a>

   <p>To install <code>queueing</code> in the system-wide location, such that all
functions are automatically available when Octave starts, you can use
&lsquo;<samp><span class="samp">pkg install</span></samp>&rsquo; command. At the Octave prompt, type the following:

<pre class="example">     octave:1&gt; <kbd>pkg install queueing-1.0.0.tar.gz</kbd>
</pre>
   <p>(Note: you may need to start Octave as root in order to allow the
installation to copy the files to the target locations). After this,
all functions will be readily available each time Octave starts,
without the need to tweak the search path. To uninstall
<code>queueing</code>, use the &lsquo;<samp><span class="samp">pkg uninstall queueing</span></samp>&rsquo; command.

   <p>If you do not have root access, you can do a local installation by
issuing the following command at the Octave prompt:

<pre class="example">     octave:1&gt; <kbd>pkg install -local queueing-1.0.0.tar.gz</kbd>
</pre>
   <p>This will install <code>queueing</code> within the user's home directory,
and the package will be available to that user only. <strong>Note:</strong>
Octave version 3.2.3 as shipped with Ubuntu 10.04 seems to ignore
<code>-local</code> and always tries to install the package on the system
directory.

<div class="node">
<a name="Manual-installation"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Content-of-the-source-distribution">Content of the source distribution</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Installation-through-Octave-package-management-system">Installation through Octave package management system</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Installation">Installation</a>

</div>

<h3 class="section">2.2 Manual installation</h3>

<p>If you want to install <code>queueing</code> in a custom location, you can
download the source tarball from the URL above, and unpack it
somewhere:

<pre class="example">     <kbd>tar xfz queueing-1.0.0.tar.gz</kbd>
     <kbd>cd queueing-1.0.0/</kbd>
</pre>
   <p>Copy all <code>.m</code> files from the <samp><span class="file">inst/</span></samp> directory to some
target location. Then, you can start Octave with the <samp><span class="option">-p</span></samp>
option to add the target location to the search path, so that Octave
will find all <code>queueing</code> functions automatically:

<pre class="example">     <kbd>octave -p </kbd><em>/path/to/queueing</em>
</pre>
   <p>For example, if all <code>queueing</code> m-files are in
<samp><span class="file">/usr/local/queueing</span></samp>, you can start Octave as follows:

<pre class="example">     <kbd>octave -p </kbd><samp><span class="file">/usr/local/queueing</span></samp>
</pre>
   <p>If you want, you can add the following line to <samp><span class="file">~/.octaverc</span></samp>:

<pre class="example">     <kbd>addpath("</kbd><em>/path/to/queueing</em><kbd>");</kbd>
</pre>
   <p class="noindent">so that the path <samp><span class="file">/usr/local/queueing</span></samp> is automatically
added to the search path each time Octave is started, and you no
longer need to specify the <samp><span class="option">-p</span></samp> option on the command line.

<div class="node">
<a name="Content-of-the-source-distribution"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Using-the-queueing-toolbox">Using the queueing toolbox</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Manual-installation">Manual installation</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Installation">Installation</a>

</div>

<h3 class="section">2.3 Content of the source distribution</h3>

<p>The <code>queueing</code> source distribution contains the following
subdirectories:

     <dl>
<dt><samp><span class="file">doc/</span></samp><dd>Documentation source. Most of the documentation is extracted from the
comment blocks of individual function files from the <samp><span class="file">inst/</span></samp>
directory.

     <br><dt><samp><span class="file">inst/</span></samp><dd>This directory contains the <tt>m</tt>-files which implement the
various Queueing Network algorithms provided by <code>queueing</code>. As a
notational convention, the names of source files containing functions
for Queueing Networks start with the &lsquo;<samp><span class="samp">qn</span></samp>&rsquo; prefix; the name of
source files containing functions for Continuous-Time Markov Chains
(CTMSs) start with the &lsquo;<samp><span class="samp">ctmc</span></samp>&rsquo; prefix, and the names of files
containing functions for Discrete-Time Markov Chains (DTMCs) start
with the &lsquo;<samp><span class="samp">dtmc</span></samp>&rsquo; prefix.

     <br><dt><samp><span class="file">test/</span></samp><dd>This directory contains the test functions used to invoke all tests on
all function files.

     <br><dt><samp><span class="file">scripts/</span></samp><dd>This directory contains some utility scripts mostly from GNU Octave,
which extract the documentation from the specially-formatted comments
in the <tt>m</tt>-files.

     <br><dt><samp><span class="file">examples/</span></samp><dd>This directory contains examples which are automatically extracted
from the &lsquo;<samp><span class="samp">demo</span></samp>&rsquo; blocks of the function files.

     <br><dt><samp><span class="file">broken/</span></samp><dd>This directory contains function files which are either not working
properly, or need additional testing before they can be moved to the
<samp><span class="file">inst/</span></samp> directory.

   </dl>

   <p>The <code>queueing</code> package ships with a Makefile which can be used
to produce the documentation (in PDF and HTML format), and
automatically execute all function tests. Specifically, the following
targets are defined:

     <dl>
<dt><code>all</code><dd>Running &lsquo;<samp><span class="samp">make</span></samp>&rsquo; (or &lsquo;<samp><span class="samp">make all</span></samp>&rsquo;) on the top-level directory
builds the programs used to extract the documentation from the
comments embedded in the <tt>m</tt>-files, and then produce the
documentation in PDF and HTML format (<samp><span class="file">doc/queueing.pdf</span></samp> and
<samp><span class="file">doc/queueing.html</span></samp>, respectively).

     <br><dt><code>check</code><dd>Running &lsquo;<samp><span class="samp">make check</span></samp>&rsquo; will execute all tests contained in the
<tt>m</tt>-files. If you modify the code of any function in the
<samp><span class="file">inst/</span></samp> directory, you should run the tests to ensure that no
errors have been introduced. You are also encouraged to contribute new
tests, especially for functions which are not adequately validated.

     <br><dt><code>clean</code><dt><code>distclean</code><dt><code>dist</code><dd>The &lsquo;<samp><span class="samp">make clean</span></samp>&rsquo;, &lsquo;<samp><span class="samp">make distclean</span></samp>&rsquo; and &lsquo;<samp><span class="samp">make dist</span></samp>&rsquo;
commands are used to clean up the source directory and prepare the
distribution archive in compressed tar format.

   </dl>

<div class="node">
<a name="Using-the-queueing-toolbox"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Content-of-the-source-distribution">Content of the source distribution</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Installation">Installation</a>

</div>

<h3 class="section">2.4 Using the queueing toolbox</h3>

<p>You can use all functions by simply invoking their name with the
appropriate parameters; the <code>queueing</code> package should display an
error message in case of missing/wrong parameters. You can display the
help text for any function using the <samp><span class="command">help</span></samp> command. For
example:

<pre class="example">     octave:2&gt; <kbd>help qnmvablo</kbd>
</pre>
   <p>prints the documentation for the <samp><span class="command">qnmvablo</span></samp> function. 
Additional information can be found in the <code>queueing</code> manual,
which is available in PDF format in <samp><span class="file">doc/queueing.pdf</span></samp> and in
HTML format in <samp><span class="file">doc/queueing.html</span></samp>.

   <p>Within GNU Octave, you can also run the test and demo blocks
associated to the functions, using the <samp><span class="command">test</span></samp> and
<samp><span class="command">demo</span></samp> commands respectively. To run all the tests of, say,
the <samp><span class="command">qnmvablo</span></samp> function:

<pre class="example">     octave:3&gt; <kbd>test qnmvablo</kbd>
     -| PASSES 4 out of 4 tests
</pre>
   <p>To execute the demos of the <samp><span class="command">qnclosed</span></samp> function, use the
following:

<pre class="example">     octave:4&gt; <kbd>demo qnclosed</kbd>
</pre>
   <!-- DO NOT EDIT!  Generated automatically by munge-texi. -->
<!-- *- texinfo -*- -->
<!-- Copyright (C) 2008, 2009, 2010, 2011, 2012 Moreno Marzolla -->
<!-- This file is part of the queueing toolbox, a Queueing Networks -->
<!-- analysis package for GNU Octave. -->
<!-- The queueing toolbox is free software; you can redistribute it -->
<!-- and/or modify it under the terms of the GNU General Public License -->
<!-- as published by the Free Software Foundation; either version 3 of -->
<!-- the License, or (at your option) any later version. -->
<!-- The queueing toolbox is distributed in the hope that it will be -->
<!-- useful, but WITHOUT ANY WARRANTY; without even the implied warranty -->
<!-- of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the -->
<!-- GNU General Public License for more details. -->
<!-- You should have received a copy of the GNU General Public License -->
<!-- along with the queueing toolbox; see the file COPYING.  If not, see -->
<!-- <http://www.gnu.org/licenses/>. -->
<div class="node">
<a name="Getting-Started"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Markov-Chains">Markov Chains</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Installation">Installation</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">3 Introduction and Getting Started</h2>

<ul class="menu">
<li><a accesskey="1" href="#Analysis-of-Closed-Networks">Analysis of Closed Networks</a>
<li><a accesskey="2" href="#Analysis-of-Open-Networks">Analysis of Open Networks</a>
</ul>

<p>In this chapter we give some usage examples of the <code>queueing</code>
package. The reader is assumed to be familiar with Queueing Networks
(although some basic terminology and notation will be given
here). Additional usage examples are embedded in most of the function
files; to display and execute the demos associated with function
<em>fname</em> you can type <samp><span class="command">demo </span><em>fname</em></samp> at the Octave
prompt. For example

<pre class="example">     <kbd>demo qnclosed</kbd>
</pre>
   <p class="noindent">executes all demos (if any) for the <samp><span class="command">qnclosed</span></samp> function.

<div class="node">
<a name="Analysis-of-Closed-Networks"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Analysis-of-Open-Networks">Analysis of Open Networks</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Getting-Started">Getting Started</a>

</div>

<h3 class="section">3.1 Analysis of Closed Networks</h3>

<p>Let us consider a simple closed network with K=3 service
centers. Each center is of type M/M/1&ndash;FCFS. We denote with
S_i the average service time at center i, i=1, 2,
3. Let S_1 = 1.0, S_2 = 2.0 and S_3 = 0.8. The
routing of jobs within the network is described with a <em>routing
probability matrix</em> P. Specifically, a request completing
service at center i is enqueued at center j with
probability P_ij.  Let us assume the following routing
probability matrix:

<pre class="example">         [ 0  0.3  0.7 ]
     P = [ 1  0    0   ]
         [ 1  0    0   ]
</pre>
   <p>For example, according to matric P a job completing service at
center 1 is routed to center 2 with probability 0.3, and is routed to
center 3 with probability 0.7.

   <p>The network above can be analyzed with the <samp><span class="command">qnclosed</span></samp>
function; if there is just a single class of requests, as in the
example above, <samp><span class="command">qnclosed</span></samp> calls <samp><span class="command">qnclosedsinglemva</span></samp>
which implements the Mean Value Analysys (MVA) algorithm for
single-class, product-form network.

   <p><samp><span class="command">qnclosed</span></samp> requires the following parameters:

     <dl>
<dt><var>N</var><dd>Number of requests in the network (since we are considering a closed
network, the number of requests is fixed)

     <br><dt><var>S</var><dd>Array of average service times at the centers: <var>S</var><code>(k)</code> is
the average service time at center k.

     <br><dt><var>V</var><dd>Array of visit ratios: <var>V</var><code>(k)</code> is the average number of
visits to center k.

   </dl>

   <p>As can be seen, we must compute the <em>visit ratios</em> (or visit
counts) V_k for each center k. The visit counts satisfy
the following equations:

<pre class="example">     V_j = sum_i V_i P_ij
</pre>
   <p>We can compute V_k from the routing probability matrix
P_ij using the <samp><span class="command">qnvisits</span></samp> function:

<pre class="example">     <kbd>P = [0 0.3 0.7; 1 0 0; 1 0 0];</kbd>
     <kbd>V = qnvisits(P)</kbd>
        &rArr; V = 1.00000 0.30000 0.70000
</pre>
   <p>We can check that the computed values satisfy the above equation by
evaluating the following expression:

<pre class="example">     <kbd>V*P</kbd>
          &rArr; ans = 1.00000 0.30000 0.70000
</pre>
   <p class="noindent">which is equal to V. 
Hence, we can analyze the network for a given population size N
(for example, N=10) as follows:

<pre class="example">     <kbd>N = 10;</kbd>
     <kbd>S = [1 2 0.8];</kbd>
     <kbd>P = [0 0.3 0.7; 1 0 0; 1 0 0];</kbd>
     <kbd>V = qnvisits(P);</kbd>
     <kbd>[U R Q X] = qnclosed( N, S, V )</kbd>
        &rArr; U = 0.99139 0.59483 0.55518
        &rArr; R = 7.4360  4.7531  1.7500
        &rArr; Q = 7.3719  1.4136  1.2144
        &rArr; X = 0.99139 0.29742 0.69397
</pre>
   <p>The output of <samp><span class="command">qnclosed</span></samp> includes the vector of utilizations
U_k at center k, response time R_k, average
number of customers Q_k and throughput X_k. In our
example, the throughput of center 1 is X_1 = 0.99139, and the
average number of requests in center 3 is Q_3 = 1.2144. The
utilization of center 1 is U_1 = 0.99139, which is the higher
value among the service centers. Tus, center 1 is the <em>bottleneck
device</em>.

   <p>This network can also be analyzed with the <samp><span class="command">qnsolve</span></samp>
function. <samp><span class="command">qnsolve</span></samp> can handle open, closed or mixed networks,
and allows the network to be described in a very flexible way.  First,
let <var>Q1</var>, <var>Q2</var> and <var>Q3</var> be the variables describing the
service centers. Each variable is instantiated with the
<samp><span class="command">qnmknode</span></samp> function.

<pre class="example">     <kbd>Q1 = qnmknode( "m/m/m-fcfs", 1 );</kbd>
     <kbd>Q2 = qnmknode( "m/m/m-fcfs", 2 );</kbd>
     <kbd>Q3 = qnmknode( "m/m/m-fcfs", 0.8 );</kbd>
</pre>
   <p>The first parameter of <samp><span class="command">qnmknode</span></samp> is a string describing the
type of the node. Here we use <code>"m/m/m-fcfs"</code> to denote a
M/M/m&ndash;FCFS center. The second parameter gives the average
service time. An optional third parameter can be used to specify the
number m of service centers. If omitted, it is assumed
m=1 (single-server node).

   <p>Now, the network can be analyzed as follows:

<pre class="example">     <kbd>N = 10;</kbd>
     <kbd>V = [1 0.3 0.7];</kbd>
     <kbd>[U R Q X] = qnsolve( "closed", N, { Q1, Q2, Q3 }, V )</kbd>
        &rArr; U = 0.99139 0.59483 0.55518
        &rArr; R = 7.4360  4.7531  1.7500
        &rArr; Q = 7.3719  1.4136  1.2144
        &rArr; X = 0.99139 0.29742 0.69397
</pre>
   <p>Of course, we get exactly the same results. Other functions can be used
for closed networks, see <a href="#Algorithms-for-Product_002dForm-QNs">Algorithms for Product-Form QNs</a>.

<div class="node">
<a name="Analysis-of-Open-Networks"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Analysis-of-Closed-Networks">Analysis of Closed Networks</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Getting-Started">Getting Started</a>

</div>

<h3 class="section">3.2 Analysis of Open Networks</h3>

<p>Open networks can be analyzed in a similar way. Let us consider
an open network with K=3 service centers, and routing
probability matrix as follows:

<pre class="example">         [ 0  0.3  0.5 ]
     P = [ 1  0    0   ]
         [ 1  0    0   ]
</pre>
   <p>In this network, requests can leave the system from center 1 with
probability (1-(0.3+0.5) = 0.2. We suppose that external jobs
arrive at center 1 with rate \lambda_1 = 0.15; there are no
arrivals at centers 2 and 3.

   <p>Similarly to closed networks, we first need to compute the visit
counts V_k to center k. Again, we use the
<samp><span class="command">qnvisits</span></samp> function as follows:

<pre class="example">     <kbd>P = [0 0.3 0.5; 1 0 0; 1 0 0];</kbd>
     <kbd>lambda = [0.15 0 0];</kbd>
     <kbd>V = qnvisits(P, lambda)</kbd>
        &rArr; V = 5.00000 1.50000 2.50000
</pre>
   <p class="noindent">where <var>lambda</var><code>(k)</code> is the arrival rate at center k,
and <var>P</var> is the routing matrix. The visit counts V_k for
open networks satisfy the following equation:

<pre class="example">     V_j = sum_i V_i P_ij
</pre>
   <p>where P_0j is the probability of an external arrival to
center j. This can be computed as:

   <p>Assuming the same service times as in the previous example, the
network can be analyzed with the <samp><span class="command">qnopen</span></samp> function, as
follows:

<pre class="example">     <kbd>S = [1 2 0.8];</kbd>
     <kbd>[U R Q X] = qnopen( sum(lambda), S, V )</kbd>
        &rArr; U = 0.75000 0.45000 0.30000
        &rArr; R = 4.0000  3.6364  1.1429
        &rArr; Q = 3.00000 0.81818 0.42857
        &rArr; X = 0.75000 0.22500 0.37500
</pre>
   <p>The first parameter of the <samp><span class="command">qnopen</span></samp> function is the (scalar)
aggregate arrival rate.

   <p>Again, it is possible to use the <samp><span class="command">qnsolve</span></samp> high-level function:

<pre class="example">     <kbd>Q1 = qnmknode( "m/m/m-fcfs", 1 );</kbd>
     <kbd>Q2 = qnmknode( "m/m/m-fcfs", 2 );</kbd>
     <kbd>Q3 = qnmknode( "m/m/m-fcfs", 0.8 );</kbd>
     <kbd>lambda = [0.15 0 0];</kbd>
     <kbd>[U R Q X] = qnsolve( "open", sum(lambda), { Q1, Q2, Q3 }, V )</kbd>
        &rArr; U = 0.75000 0.45000 0.30000
        &rArr; R = 4.0000  3.6364  1.1429
        &rArr; Q = 3.00000 0.81818 0.42857
        &rArr; X = 0.75000 0.22500 0.37500
</pre>
   <!-- @node Markov Chains Analysis -->
<!-- @section Markov Chains Analysis -->
<!-- @subsection Discrete-Time Markov Chains -->
<!-- (TODO) -->
<!-- @subsection Continuous-Time Markov Chains -->
<!-- (TODO) -->
<!-- DO NOT EDIT!  Generated automatically by munge-texi. -->
<!-- *- texinfo -*- -->
<!-- Copyright (C) 2008, 2009, 2010, 2011, 2012 Moreno Marzolla -->
<!-- This file is part of the queueing toolbox, a Queueing Networks -->
<!-- analysis package for GNU Octave. -->
<!-- The queueing toolbox is free software; you can redistribute it -->
<!-- and/or modify it under the terms of the GNU General Public License -->
<!-- as published by the Free Software Foundation; either version 3 of -->
<!-- the License, or (at your option) any later version. -->
<!-- The queueing toolbox is distributed in the hope that it will be -->
<!-- useful, but WITHOUT ANY WARRANTY; without even the implied warranty -->
<!-- of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the -->
<!-- GNU General Public License for more details. -->
<!-- You should have received a copy of the GNU General Public License -->
<!-- along with the queueing toolbox; see the file COPYING.  If not, see -->
<!-- <http://www.gnu.org/licenses/>. -->
<div class="node">
<a name="Markov-Chains"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Single-Station-Queueing-Systems">Single Station Queueing Systems</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Getting-Started">Getting Started</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">4 Markov Chains</h2>

<ul class="menu">
<li><a accesskey="1" href="#Discrete_002dTime-Markov-Chains">Discrete-Time Markov Chains</a>
<li><a accesskey="2" href="#Continuous_002dTime-Markov-Chains">Continuous-Time Markov Chains</a>
</ul>

<div class="node">
<a name="Discrete-Time-Markov-Chains"></a>
<a name="Discrete_002dTime-Markov-Chains"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Continuous_002dTime-Markov-Chains">Continuous-Time Markov Chains</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Markov-Chains">Markov Chains</a>

</div>

<h3 class="section">4.1 Discrete-Time Markov Chains</h3>

<ul class="menu">
<li><a accesskey="1" href="#DTMC-Stationary-Probability">DTMC Stationary Probability</a>
<li><a accesskey="2" href="#DTMC-First-Passage-Times">DTMC First Passage Times</a>
</ul>

<div class="node">
<a name="DTMC-Stationary-Probability"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#DTMC-First-Passage-Times">DTMC First Passage Times</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Discrete_002dTime-Markov-Chains">Discrete-Time Markov Chains</a>

</div>

<h4 class="subsection">4.1.1 Stationary Probability</h4>

<p><a name="doc_002ddtmc"></a>

<div class="defun">
&mdash; Function File: <var>p</var> = <b>dtmc</b> (<var>P</var>)<var><a name="index-dtmc-1"></a></var><br>
&mdash; Function File: <var>p</var> = <b>dtmc</b> (<var>P, n, p0</var>)<var><a name="index-dtmc-2"></a></var><br>
<blockquote>
        <p><a name="index-Markov-chain_002c-discrete-time-3"></a><a name="index-Discrete-time-Markov-chain-4"></a><a name="index-Markov-chain_002c-stationary-probabilities-5"></a><a name="index-Stationary-probabilities-6"></a>
With a single argument, compute the steady-state probability vector
<var>p</var><code>(1), ..., </code><var>p</var><code>(N)</code> for a
Discrete-Time Markov Chain given the N \times N transition
probability matrix <var>P</var>. With three arguments, compute the
probability vector <var>p</var><code>(1), ..., </code><var>p</var><code>(N)</code>
after <var>n</var> steps, given initial probability vector <var>p0</var> at
time 0.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>P</var><dd><var>P</var><code>(i,j)</code> is the transition probability from state i
to state j. <var>P</var> must be an irreducible stochastic matrix,
which means that the sum of each row must be 1 (\sum_j=1^N P_i j = 1), and the rank of
<var>P</var> must be equal to its dimension.

          <br><dt><var>n</var><dd>Step at which to compute the transient probability

          <br><dt><var>p0</var><dd><var>p0</var><code>(i)</code> is the probability that at step 0 the system
is in state i.

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>p</var><dd>If this function is invoked with a single argument,
<var>p</var><code>(i)</code> is the steady-state probability that the system is
in state i. <var>p</var> satisfies the equations p = p\bf P and \sum_i=1^N p_i = 1. If this function is invoked
with three arguments, <var>p</var><code>(i)</code> is the marginal probability
that the system is in state i at step <var>n</var>,
given the initial probabilities <var>p0</var><code>(i)</code> that the initial state is
i.

        </dl>

        </blockquote></div>

<div class="node">
<a name="DTMC-First-Passage-Times"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#DTMC-Stationary-Probability">DTMC Stationary Probability</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Discrete_002dTime-Markov-Chains">Discrete-Time Markov Chains</a>

</div>

<h4 class="subsection">4.1.2 First Passage Times</h4>

<p>The First Passage Time M_i j is defined as the average
number of transitions needed to visit state j for the first
time, starting from state i. Matrix \bf M satisfies the
property that

<pre class="example">                ___
               \
     M_ij = 1 + &gt;   P_ij * M_kj
               /___
               k!=j
</pre>
   <p><a name="doc_002ddtmc_005ffpt"></a>

<div class="defun">
&mdash; Function File: <var>M</var> = <b>dtmc_fpt</b> (<var>P</var>)<var><a name="index-dtmc_005ffpt-7"></a></var><br>
&mdash; Function File: <var>m</var> = <b>dtmc_fpt</b> (<var>P, i, j</var>)<var><a name="index-dtmc_005ffpt-8"></a></var><br>
<blockquote>
        <p><a name="index-Markov-chain_002c-discrete-time-9"></a><a name="index-First-passage-times-10"></a>
If called with a single argument, computes the mean first passage
times <var>M</var><code>(i,j)</code>, that are the average number of transitions before
state <var>j</var> is reached, starting from state <var>i</var>, for all
1 \leq i, j \leq N. If called with three arguments, returns
the single value <var>m</var><code> = </code><var>M</var><code>(i,j)</code>.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>P</var><dd><var>P</var><code>(i,j)</code> is the transition probability from state i
to state j. <var>P</var> must be an irreducible stochastic matrix,
which means that the sum of each row must be 1 (\sum_j=1^N
P_i j = 1), and the rank of <var>P</var> must be equal to its
dimension.

          <br><dt><var>i</var><dd>Initial state.

          <br><dt><var>j</var><dd>Destination state. If <var>j</var> is a vector, returns the mean first passage
time to any state in <var>j</var>.

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>M</var><dd>If this function is called with a single argument, the result
<var>M</var><code>(i,j)</code> is the average number of transitions before state
<var>j</var> is reached for the first time, starting from state <var>i</var>.

          <br><dt><var>m</var><dd>If this function is called with three arguments, the result <var>m</var>
is the average number of transitions before state <var>j</var> is visited
for the first time, starting from state <var>i</var>.

        </dl>

        </blockquote></div>

<div class="node">
<a name="Continuous-Time-Markov-Chains"></a>
<a name="Continuous_002dTime-Markov-Chains"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Discrete_002dTime-Markov-Chains">Discrete-Time Markov Chains</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Markov-Chains">Markov Chains</a>

</div>

<h3 class="section">4.2 Continuous-Time Markov Chains</h3>

<ul class="menu">
<li><a accesskey="1" href="#CTMC-Stationary-Probability">CTMC Stationary Probability</a>
<li><a accesskey="2" href="#Birth_002dDeath-process">Birth-Death process</a>
<li><a accesskey="3" href="#Expected-Sojourn-Time">Expected Sojourn Time</a>
<li><a accesskey="4" href="#Time_002dAveraged-Expected-Sojourn-Time">Time-Averaged Expected Sojourn Time</a>
<li><a accesskey="5" href="#Expected-Time-to-Absorption">Expected Time to Absorption</a>
<li><a accesskey="6" href="#CTMC-First-Passage-Times">CTMC First Passage Times</a>
</ul>

<div class="node">
<a name="CTMC-Stationary-Probability"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Birth_002dDeath-process">Birth-Death process</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Continuous_002dTime-Markov-Chains">Continuous-Time Markov Chains</a>

</div>

<h4 class="subsection">4.2.1 Stationary Probability</h4>

<p><a name="doc_002dctmc"></a>

<div class="defun">
&mdash; Function File: <var>p</var> = <b>ctmc</b> (<var>Q</var>)<var><a name="index-ctmc-11"></a></var><br>
&mdash; Function File: <var>p</var> = <b>ctmc</b> (<var>Q, t. q0</var>)<var><a name="index-ctmc-12"></a></var><br>
<blockquote>
        <p><a name="index-Markov-chain_002c-continuous-time-13"></a><a name="index-Continuous-time-Markov-chain-14"></a><a name="index-Markov-chain_002c-state-occupancy-probabilities-15"></a><a name="index-Stationary-probabilities-16"></a>
With a single argument, compute the stationary state occupancy
probability vector <var>p</var>(1), <small class="dots">...</small>, <var>p</var>(N) for a
Continuous-Time Markov Chain with infinitesimal generator matrix
<var>Q</var> of size  N \times N. With three arguments, compute the
state occupancy probabilities <var>p</var>(1), <small class="dots">...</small>, <var>p</var>(N) at time
<var>t</var>, given initial state occupancy probabilities <var>p0</var> at time
0.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>Q</var><dd>Infinitesimal generator matrix. <var>Q</var> is a N \times N square
matrix where <var>Q</var><code>(i,j)</code> is the transition rate from state
i to state j, for 1 &le; i \neq j &le; N. 
Transition rates must be nonnegative, and \sum_j=1^N Q_i j = 0

          <br><dt><var>t</var><dd>Time at which to compute the transient probability

          <br><dt><var>p0</var><dd><var>p0</var><code>(i)</code> is the probability that the system
is in state i at time 0 .

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>p</var><dd>If this function is invoked with a single argument,
<var>p</var><code>(i)</code> is the steady-state probability that the system is
in state i, i = 1, <small class="dots">...</small>, N. The vector <var>p</var>
satisfies the equation p\bf Q = 0 and \sum_i=1^N p_i = 1. 
If this function is invoked with three arguments, <var>p</var><code>(i)</code>
is the probability that the system is in state i at time <var>t</var>,
given the initial occupancy probabilities <var>q0</var>.

        </dl>

        </blockquote></div>

<p class="noindent"><strong>EXAMPLE</strong>

   <p>Consider a two-state CTMC such that transition rates between states
are equal to 1. This can be solved as follows:

<pre class="example"><pre class="verbatim">      Q = [ -1  1; \
             1 -1  ];
      q = ctmc(Q)</pre>    &rArr; q = 0.50000   0.50000
</pre>
   <div class="node">
<a name="Birth-Death-process"></a>
<a name="Birth_002dDeath-process"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Expected-Sojourn-Time">Expected Sojourn Time</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#CTMC-Stationary-Probability">CTMC Stationary Probability</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Continuous_002dTime-Markov-Chains">Continuous-Time Markov Chains</a>

</div>

<h4 class="subsection">4.2.2 Birth-Death process</h4>

<p><a name="doc_002dctmc_005fbd"></a>

<div class="defun">
&mdash; Function File: <var>p</var> = <b>ctmc_bd</b> (<var>birth, death</var>)<var><a name="index-ctmc_005fbd-17"></a></var><br>
<blockquote>
        <p><a name="index-Markov-chain_002c-continuous-time-18"></a><a name="index-Birth_002ddeath-process-19"></a>
Compute the steady-state solution of a birth-death process with state
space (1, <small class="dots">...</small>, N).

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>birth</var><dd>Vector with N-1 elements, where <var>birth</var><code>(i)</code> is the
transition rate from state i to state i+1.

          <br><dt><var>death</var><dd>Vector with N-1 elements, where <var>death</var><code>(i)</code> is the
transition rate from state i+1 to state i.

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>p</var><dd><var>p</var><code>(i)</code> is the steady-state probability that the system is
in state i, i=1, <small class="dots">...</small>, N.

        </dl>

        </blockquote></div>

<div class="node">
<a name="Expected-Sojourn-Time"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Time_002dAveraged-Expected-Sojourn-Time">Time-Averaged Expected Sojourn Time</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Birth_002dDeath-process">Birth-Death process</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Continuous_002dTime-Markov-Chains">Continuous-Time Markov Chains</a>

</div>

<h4 class="subsection">4.2.3 Expected Sojourn Time</h4>

<p>Given a N state continuous-time Markov Chain with infinitesimal
generator matrix \bf Q, we define the vector \bf L(t) =
(L_1(t), L_2(t), \ldots L_N(t)) such that L_i(t) is the
expected sojourn time in state i during the interval
[0,t), assuming that the initial occupancy probability at time
0 was \bf \pi(0). Then, \bf L(t) is the solution of
the following differential equation:

<pre class="example">      dL
      --(t) = L(t) Q + pi(0),    L(0) = 0
      dt
</pre>
   <p>The function <code>ctmc_exps</code> can be used to compute \bf
L(t), by using the <code>lsode</code> Octave function to solve the above
linear differential equation.

   <p><a name="doc_002dctmc_005fexps"></a>

<div class="defun">
&mdash; Function File: <var>L</var> = <b>ctmc_exps</b> (<var>Q, tt, p</var>)<var><a name="index-ctmc_005fexps-20"></a></var><br>
<blockquote>
        <p><a name="index-Markov-chain_002c-continuous-time-21"></a><a name="index-Expected-sojourn-time-22"></a>
Compute the expected total time <var>L</var><code>(t,j)</code> spent in state
j during the time interval <code>[0,</code><var>tt</var><code>(t))</code>, assuming
that at time 0 the state occupancy probability was <var>p</var>.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>Q</var><dd>Infinitesimal generator matrix. <var>Q</var><code>(i,j)</code> is the transition
rate from state i to state j,
1 &le; i \neq j &le; N. The matrix <var>Q</var> must also satisfy the
condition <code>sum(</code><var>Q</var><code>,2) == 0</code>

          <br><dt><var>tt</var><dd>This parameter is a vector used for numerical integration. The first
element <var>tt</var><code>(1)</code> must be 0, and the last element
<var>tt</var><code>(end)</code> must be the upper bound of the interval
[0,t) of interest (<var>tt</var><code>(end) == t</code>).

          <br><dt><var>p</var><dd><var>p</var><code>(i)</code> is the probability that at time 0 the system was in
state i, for all i = 1, <small class="dots">...</small>, N

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>L</var><dd><var>L</var><code>(t,j)</code> is the expected time spent in state j
during the interval <code>[0,</code><var>tt</var><code>(t))</code>. <code>1 &le; </code><var>t</var><code> &le; length(</code><var>tt</var><code>)</code>

        </dl>

        </blockquote></div>

<p class="noindent"><strong>EXAMPLE</strong>

   <p>Let us consider a pure-birth, 4-states CTMC such that the transition
rate from state i to state i+1 is \lambda_i = i
\lambda (i=1, 2, 3), with \lambda = 0.5. The following
code computes the expected sojourn time in state i,
given the initial occupancy probability p_0=(1,0,0,0).

<pre class="example"><pre class="verbatim">      lambda = 0.5;
      N = 4;
      birth = lambda*linspace(1,N-1,N-1);
      death = zeros(1,N-1);
      Q = diag(birth,1)+diag(death,-1);
      Q -= diag(sum(Q,2));
      tt = linspace(0,10,100);
      p0 = zeros(1,N); p0(1)=1;
      L = ctmc_exps(Q,tt,p0);
      plot( tt, L(:,1), ";State 1;", "linewidth", 2, \
            tt, L(:,2), ";State 2;", "linewidth", 2, \
            tt, L(:,3), ";State 3;", "linewidth", 2, \
            tt, L(:,4), ";State 4 (absorbing);", "linewidth", 2);
      legend("location","northwest");
      xlabel("Time");
      ylabel("Expected sojourn time");</pre>
</pre>
   <div class="node">
<a name="Time-Averaged-Expected-Sojourn-Time"></a>
<a name="Time_002dAveraged-Expected-Sojourn-Time"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Expected-Time-to-Absorption">Expected Time to Absorption</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Expected-Sojourn-Time">Expected Sojourn Time</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Continuous_002dTime-Markov-Chains">Continuous-Time Markov Chains</a>

</div>

<h4 class="subsection">4.2.4 Time-Averaged Expected Sojourn Time</h4>

<p><a name="doc_002dctmc_005ftaexps"></a>

<div class="defun">
&mdash; Function File: <var>M</var> = <b>ctmc_taexps</b> (<var>Q, tt, p</var>)<var><a name="index-ctmc_005ftaexps-23"></a></var><br>
<blockquote>
        <p><a name="index-Markov-chain_002c-continuous-time-24"></a><a name="index-Time_002dalveraged-sojourn-time-25"></a>
Compute the <em>time-averaged sojourn time</em> <var>M</var><code>(t,j)</code>,
defined as the fraction of the time interval <code>[0,</code><var>tt</var><code>(t))</code> spent in
state j, assuming that at time 0 the state occupancy
probability was <var>p</var>.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>Q</var><dd>Infinitesimal generator matrix. <var>Q</var><code>(i,j)</code> is the transition
rate from state i to state j,
1 &le; i \neq j &le; N. The
matrix <var>Q</var> must also satisfy the condition <code>sum(</code><var>Q</var><code>,2) == 0</code>

          <br><dt><var>tt</var><dd>This parameter is a vector used for numerical integration of the
sujourn time. The first element <var>tt</var><code>(1)</code> must be slightly
larger than 0, and the
last element <var>tt</var><code>(end)</code> must be the upper limit of the
interval [0,t) of interest (<var>tt</var><code>(end) == t</code>). 
This vector is used by the ODE solver to compute the solution
<var>M</var>.

          <br><dt><var>p</var><dd><var>p</var><code>(i)</code> is the probability that, at time 0, the system was in
state i, for all i = 1, <small class="dots">...</small>, N

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>M</var><dd><var>M</var><code>(t,j)</code> is the expected fraction of time spent in state
j during the interval [0,tt(t)) assuming that the state
occupancy probability at time zero was <var>p</var>. <code>1 &le;
</code><var>t</var><code> &le; length(</code><var>tt</var><code>)</code>

        </dl>

        </blockquote></div>

<p class="noindent"><strong>EXAMPLE</strong>

<pre class="example"><pre class="verbatim">      lambda = 0.5;
      N = 4;
      birth = lambda*linspace(1,N-1,N-1);
      death = zeros(1,N-1);
      Q = diag(birth,1)+diag(death,-1);
      Q -= diag(sum(Q,2));
      t = linspace(1e-3,50,500);
      p = zeros(1,N); p(1)=1;
      M = ctmc_taexps(Q,t,p);
      plot(t, M(:,1), ";State 1;", "linewidth", 2, \
           t, M(:,2), ";State 2;", "linewidth", 2, \
           t, M(:,3), ";State 3;", "linewidth", 2, \
           t, M(:,4), ";State 4 (absorbing);", "linewidth", 2 );
      legend("location","east");
      xlabel("Time");
      ylabel("Time-averaged Expected sojourn time");</pre>
</pre>
   <div class="node">
<a name="Expected-Time-to-Absorption"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#CTMC-First-Passage-Times">CTMC First Passage Times</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Time_002dAveraged-Expected-Sojourn-Time">Time-Averaged Expected Sojourn Time</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Continuous_002dTime-Markov-Chains">Continuous-Time Markov Chains</a>

</div>

<h4 class="subsection">4.2.5 Expected Time to Absorption</h4>

<p>If we consider a Markov Chain with absorbing states, it is possible to
define the <em>expected time to absorption</em> as the expected time
until the system goes into an absorbing state. More specifically, let
us suppose that A is the set of transient (i.e., non-absorbing)
states of a CTMC with N states and infinitesimal generator
matrix \bf Q. The expected time to absorption \bf
L_A(\infty) is defined as the solution of the following equation:

<pre class="example">     L_A( inf ) Q_A = -pi_A(0)
</pre>
   <p class="noindent">where \bf Q_A is the restriction of matrix \bf Q to
only states in A, and \bf \pi_A(0) is the initial
state occupancy probability at time 0, restricted to states in
A.

   <p><a name="doc_002dctmc_005fmtta"></a>

<div class="defun">
&mdash; Function File: <var>t</var> = <b>ctmc_mtta</b> (<var>Q, p</var>)<var><a name="index-ctmc_005fmtta-26"></a></var><br>
<blockquote>
        <p><a name="index-Markov-chain_002c-continuous-time-27"></a><a name="index-Mean-time-to-absorption-28"></a>
Compute the Mean-Time to Absorption (MTTA) starting from initial
occupancy probability <var>p</var> at time 0. If there are no absorbing
states, this function fails with an error.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>Q</var><dd>N \times N infinitesimal generator matrix. <var>Q</var><code>(i,j)</code>
is the transition rate from state i to state j, i
\neq j. The matrix <var>Q</var> must satisfy the condition
\sum_j=1^N Q_i j = 0

          <br><dt><var>p</var><dd><var>p</var><code>(i)</code> is the probability that the system is in state i
at time 0, for each i=1, <small class="dots">...</small>, N

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>t</var><dd>Mean time to absorption of the process represented by matrix <var>Q</var>. 
If there are no absorbing states, this function fails.

        </dl>

        </blockquote></div>

<p class="noindent"><strong>EXAMPLE</strong>

   <p>Let us consider a simple model of a redundant disk array. We assume
that the array is made of 5 independent disks, such that the array can
tolerate up to 2 disk failures without losing data. If three or more
disks break, the array is dead and unrecoverable. We want to estimate
the Mean-Time-To-Failure (MTTF) of the disk array.

   <p>We model this system as a 4 states Markov chain with state space
\ 2, 3, 4, 5 \. State i denotes the fact that exactly
i disks are active; state 2 is absorbing. Let \mu
be the failure rate of a single disk. The system starts in state
5 (all disks are operational). We use a pure death process,
with death rate from state i to state i-1 is \mu
i, for i = 3, 4, 5).

   <p>The MTTF of the disk array is the MTTA of the Markov Chain, and can be
computed with the following expression:

<pre class="example"><pre class="verbatim">      mu = 0.01;
      death = [ 3 4 5 ] * mu;
      Q = diag(death,-1);
      Q -= diag(sum(Q,2));
      t = ctmc_mtta(Q,[0 0 0 1])</pre>    &rArr; t = 78.333
</pre>
   <p class="noindent"><strong>REFERENCES</strong>

   <p>G. Bolch, S. Greiner, H. de Meer and
K. Trivedi, <cite>Queueing Networks and Markov Chains: Modeling and
Performance Evaluation with Computer Science Applications</cite>, Wiley,
1998.

   <p><a name="index-Bolch_002c-G_002e-29"></a><a name="index-Greiner_002c-S_002e-30"></a><a name="index-de-Meer_002c-H_002e-31"></a><a name="index-Trivedi_002c-K_002e-32"></a>
<div class="node">
<a name="CTMC-First-Passage-Times"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Expected-Time-to-Absorption">Expected Time to Absorption</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Continuous_002dTime-Markov-Chains">Continuous-Time Markov Chains</a>

</div>

<h4 class="subsection">4.2.6 First Passage Times</h4>

<p><a name="doc_002dctmc_005ffpt"></a>

<div class="defun">
&mdash; Function File: <var>M</var> = <b>ctmc_fpt</b> (<var>Q</var>)<var><a name="index-ctmc_005ffpt-33"></a></var><br>
&mdash; Function File: <var>m</var> = <b>ctmc_fpt</b> (<var>Q, i, j</var>)<var><a name="index-ctmc_005ffpt-34"></a></var><br>
<blockquote>
        <p><a name="index-Markov-chain_002c-continuous-time-35"></a><a name="index-First-passage-times-36"></a>
If called with a single argument, computes the mean first passage
times <var>M</var><code>(i,j)</code>, the average times before state <var>j</var> is
reached, starting from state <var>i</var>, for all 1 \leq i, j \leq
N. If called with three arguments, returns the single value
<var>m</var><code> = </code><var>M</var><code>(i,j)</code>.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>Q</var><dd>Infinitesimal generator matrix. <var>Q</var> is a N \times N square
matrix where <var>Q</var><code>(i,j)</code> is the transition rate from state
i to state j, for 1 &le; i \neq j &le; N. 
Transition rates must be nonnegative, and \sum_j=1^N Q_i j = 0

          <br><dt><var>i</var><dd>Initial state.

          <br><dt><var>j</var><dd>Destination state. If <var>j</var> is a vector, returns the mean first passage
time to any state in <var>j</var>.

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>M</var><dd>If this function is called with a single argument, the result
<var>M</var><code>(i,j)</code> is the average time before state
<var>j</var> is visited for the first time, starting from state <var>i</var>.

          <br><dt><var>m</var><dd>If this function is called with three arguments, the result
<var>m</var> is the average time before state <var>j</var> is visited for the first
time, starting from state <var>i</var>.

        </dl>

        </blockquote></div>

<!-- DO NOT EDIT!  Generated automatically by munge-texi. -->
<!-- *- texinfo -*- -->
<!-- Copyright (C) 2008, 2009, 2010, 2011, 2012 Moreno Marzolla -->
<!-- This file is part of the queueing toolbox, a Queueing Networks -->
<!-- analysis package for GNU Octave. -->
<!-- The queueing toolbox is free software; you can redistribute it -->
<!-- and/or modify it under the terms of the GNU General Public License -->
<!-- as published by the Free Software Foundation; either version 3 of -->
<!-- the License, or (at your option) any later version. -->
<!-- The queueing toolbox is distributed in the hope that it will be -->
<!-- useful, but WITHOUT ANY WARRANTY; without even the implied warranty -->
<!-- of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the -->
<!-- GNU General Public License for more details. -->
<!-- You should have received a copy of the GNU General Public License -->
<!-- along with the queueing toolbox; see the file COPYING.  If not, see -->
<!-- <http://www.gnu.org/licenses/>. -->
<div class="node">
<a name="Single-Station-Queueing-Systems"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Queueing-Networks">Queueing Networks</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Markov-Chains">Markov Chains</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">5 Single Station Queueing Systems</h2>

<p>Single Station Queueing Systems contain a single station, and are thus
quite easy to analyze. The <code>queueing</code> package contains functions
for handling the following types of queues:

<ul class="menu">
<li><a accesskey="1" href="#The-M_002fM_002f1-System">The M/M/1 System</a>:     Single-server queueing station. 
<li><a accesskey="2" href="#The-M_002fM_002fm-System">The M/M/m System</a>:     Multiple-server queueing station. 
<li><a accesskey="3" href="#The-M_002fM_002finf-System">The M/M/inf System</a>:   Infinite-server (delay center) station. 
<li><a accesskey="4" href="#The-M_002fM_002f1_002fK-System">The M/M/1/K System</a>:   Single-server, finite-capacity queueing station. 
<li><a accesskey="5" href="#The-M_002fM_002fm_002fK-System">The M/M/m/K System</a>:   Multiple-server, finite-capacity queueing station. 
<li><a accesskey="6" href="#The-Asymmetric-M_002fM_002fm-System">The Asymmetric M/M/m System</a>:   Asymmetric multiple-server queueing station. 
<li><a accesskey="7" href="#The-M_002fG_002f1-System">The M/G/1 System</a>:  Single-server with general service time distribution. 
<li><a accesskey="8" href="#The-M_002fHm_002f1-System">The M/Hm/1 System</a>:  Single-server with hyperexponential service time distribution. 
</ul>

   <p>The functions which analyze the queues above can be used as building
blocks for analyzing Queueing Networks. For example, Jackson networks
can be solved by computing the aggregate arrival rates to each node,
and then solving each node in isolation as if it were a single station
queueing system.

<!-- M/M/1 -->
<div class="node">
<a name="The-M%2fM%2f1-System"></a>
<a name="The-M_002fM_002f1-System"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#The-M_002fM_002fm-System">The M/M/m System</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Single-Station-Queueing-Systems">Single Station Queueing Systems</a>

</div>

<h3 class="section">5.1 The M/M/1 System</h3>

<p>The M/M/1 system is made of a single server connected to an
unlimited FCFS queue. The mean arrival rate is Poisson with arrival
rate \lambda; the service time is exponentially distributed
with average service rate \mu. The system is stable if
\lambda &lt; \mu.

   <p><a name="doc_002dqnmm1"></a>

<div class="defun">
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>, <var>p0</var>] = <b>qnmm1</b> (<var>lambda, mu</var>)<var><a name="index-qnmm1-37"></a></var><br>
<blockquote>
        <p><a name="index-g_t_0040math_007bM_002fM_002f1_007d-system-38"></a>
Compute utilization, response time, average number of requests
and throughput for a M/M/1 queue.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>lambda</var><dd>Arrival rate (<var>lambda</var><code> &gt; 0</code>).

          <br><dt><var>mu</var><dd>Service rate (<var>mu</var><code> &gt; </code><var>lambda</var>).

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>U</var><dd>Server utilization

          <br><dt><var>R</var><dd>Service center response time

          <br><dt><var>Q</var><dd>Average number of requests in the system

          <br><dt><var>X</var><dd>Service center throughput. If the system is ergodic,
we will always have <var>X</var><code> = </code><var>lambda</var>

          <br><dt><var>p0</var><dd>Steady-state probability that there are no requests in the system.

        </dl>

        <p><var>lambda</var> and <var>mu</var> can be vectors of the same size. In this
case, the results will be vectors as well.

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qnmmm, qnmminf, qnmmmk.

        </blockquote></div>

<p class="noindent"><strong>REFERENCES</strong>

<p class="noindent">G. Bolch, S. Greiner, H. de Meer and K. Trivedi, <cite>Queueing Networks
and Markov Chains: Modeling and Performance Evaluation with Computer
Science Applications</cite>, Wiley, 1998, Section 6.3.

   <p><a name="index-Bolch_002c-G_002e-39"></a><a name="index-Greiner_002c-S_002e-40"></a><a name="index-de-Meer_002c-H_002e-41"></a><a name="index-Trivedi_002c-K_002e-42"></a>
<!-- M/M/m -->
<div class="node">
<a name="The-M%2fM%2fm-System"></a>
<a name="The-M_002fM_002fm-System"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#The-M_002fM_002finf-System">The M/M/inf System</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-M_002fM_002f1-System">The M/M/1 System</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Single-Station-Queueing-Systems">Single Station Queueing Systems</a>

</div>

<h3 class="section">5.2 The M/M/m System</h3>

<p>The M/M/m system is similar to the M/M/1 system, except
that there are m \geq 1 identical servers connected to a single
queue. Thus, at most m requests can be served at the same
time. The M/M/m system can be seen as a single server with
load-dependent service rate \mu(n), which is a function of the
number n of nodes in the center:

<pre class="example">     <code>mu(n) = min(m,n)*mu</code>
</pre>
   <p><a name="doc_002dqnmmm"></a>

<div class="defun">
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>, <var>p0</var>, <var>pm</var>] = <b>qnmmm</b> (<var>lambda, mu</var>)<var><a name="index-qnmmm-43"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>, <var>p0</var>, <var>pm</var>] = <b>qnmmm</b> (<var>lambda, mu, m</var>)<var><a name="index-qnmmm-44"></a></var><br>
<blockquote>
        <p><a name="index-g_t_0040math_007bM_002fM_002fm_007d-system-45"></a>
Compute utilization, response time, average number of requests in
service and throughput for a M/M/m queue, a queueing
system with m identical service centers connected to a single queue.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>lambda</var><dd>Arrival rate (<var>lambda</var><code>&gt;0</code>).

          <br><dt><var>mu</var><dd>Service rate (<var>mu</var><code>&gt;</code><var>lambda</var>).

          <br><dt><var>m</var><dd>Number of servers (<var>m</var><code> &ge; 1</code>). 
If omitted, it is assumed <var>m</var><code>=1</code>.

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>U</var><dd>Service center utilization, U = \lambda / (m \mu).

          <br><dt><var>R</var><dd>Service center response time

          <br><dt><var>Q</var><dd>Average number of requests in the system

          <br><dt><var>X</var><dd>Service center throughput. If the system is ergodic,
we will always have <var>X</var><code> = </code><var>lambda</var>

          <br><dt><var>p0</var><dd>Steady-state probability that there are 0 requests in the system

          <br><dt><var>pm</var><dd>Steady-state probability that an arriving request has to wait in the
queue

        </dl>

        <p><var>lambda</var>, <var>mu</var> and <var>m</var> can be vectors of the same size. In this
case, the results will be vectors as well.

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qnmm1,qnmminf,qnmmmk.

        </blockquote></div>

<p class="noindent"><strong>REFERENCES</strong>

<p class="noindent">G. Bolch, S. Greiner, H. de Meer and K. Trivedi, <cite>Queueing Networks
and Markov Chains: Modeling and Performance Evaluation with Computer
Science Applications</cite>, Wiley, 1998, Section 6.5.

   <p><a name="index-Bolch_002c-G_002e-46"></a><a name="index-Greiner_002c-S_002e-47"></a><a name="index-de-Meer_002c-H_002e-48"></a><a name="index-Trivedi_002c-K_002e-49"></a>
<!-- M/M/inf -->
<div class="node">
<a name="The-M%2fM%2finf-System"></a>
<a name="The-M_002fM_002finf-System"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#The-M_002fM_002f1_002fK-System">The M/M/1/K System</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-M_002fM_002fm-System">The M/M/m System</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Single-Station-Queueing-Systems">Single Station Queueing Systems</a>

</div>

<h3 class="section">5.3 The M/M/inf System</h3>

<p>The M/M/\infty system is similar to the M/M/m system,
except that there are infinitely many identical servers (that is,
m = \infty). Each new request is assigned to a new server, so
that queueing never occurs. The M/M/\infty system is always
stable.

   <p><a name="doc_002dqnmminf"></a>

<div class="defun">
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>, <var>p0</var>] = <b>qnmminf</b> (<var>lambda, mu</var>)<var><a name="index-qnmminf-50"></a></var><br>
<blockquote>
        <p>Compute utilization, response time, average number of requests and
throughput for a M/M/\infty queue. This is a system with an
infinite number of identical servers. Note that a M/M/\infty
system is always stable, regardless the values of the arrival and
service rates.

        <p><a name="index-g_t_0040math_007bM_002fM_002f_007dinf-system-51"></a>

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>lambda</var><dd>Arrival rate (<var>lambda</var><code>&gt;0</code>).

          <br><dt><var>mu</var><dd>Service rate (<var>mu</var><code>&gt;0</code>).

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>U</var><dd>Traffic intensity (defined as \lambda/\mu). Note that this is
different from the utilization, which in the case of M/M/\infty
centers is always zero.

          <p><a name="index-traffic-intensity-52"></a>
<br><dt><var>R</var><dd>Service center response time.

          <br><dt><var>Q</var><dd>Average number of requests in the system (which is equal to the
traffic intensity \lambda/\mu).

          <br><dt><var>X</var><dd>Throughput (which is always equal to <var>X</var><code> = </code><var>lambda</var>).

          <br><dt><var>p0</var><dd>Steady-state probability that there are no requests in the system

        </dl>

        <p><var>lambda</var> and <var>mu</var> can be vectors of the same size. In this
case, the results will be vectors as well.

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qnmm1,qnmmm,qnmmmk.

        </blockquote></div>

<p class="noindent"><strong>REFERENCES</strong>

<p class="noindent">G. Bolch, S. Greiner, H. de Meer and K. Trivedi, <cite>Queueing Networks
and Markov Chains: Modeling and Performance Evaluation with Computer
Science Applications</cite>, Wiley, 1998, Section 6.4.

   <p><a name="index-Bolch_002c-G_002e-53"></a><a name="index-Greiner_002c-S_002e-54"></a><a name="index-de-Meer_002c-H_002e-55"></a><a name="index-Trivedi_002c-K_002e-56"></a>
<!-- M/M/1/k -->
<div class="node">
<a name="The-M%2fM%2f1%2fK-System"></a>
<a name="The-M_002fM_002f1_002fK-System"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#The-M_002fM_002fm_002fK-System">The M/M/m/K System</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-M_002fM_002finf-System">The M/M/inf System</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Single-Station-Queueing-Systems">Single Station Queueing Systems</a>

</div>

<h3 class="section">5.4 The M/M/1/K System</h3>

<p>In a M/M/1/K finite capacity system there can be at most
k jobs at any time. If a new request tries to join the system
when there are already K other requests, the arriving request
is lost. The queue has K-1 slots. The M/M/1/K system is
always stable, regardless of the arrival and service rates
\lambda and \mu.

   <p><a name="doc_002dqnmm1k"></a>

<div class="defun">
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>, <var>p0</var>, <var>pK</var>] = <b>qnmm1k</b> (<var>lambda, mu, K</var>)<var><a name="index-qnmm1k-57"></a></var><br>
<blockquote>
        <p><a name="index-g_t_0040math_007bM_002fM_002f1_002fK_007d-system-58"></a>
Compute utilization, response time, average number of requests and
throughput for a M/M/1/K finite capacity system. In a
M/M/1/K queue there is a single server; the maximum number of
requests in the system is K, and the maximum queue length is
K-1.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>lambda</var><dd>Arrival rate (<var>lambda</var><code>&gt;0</code>).

          <br><dt><var>mu</var><dd>Service rate (<var>mu</var><code>&gt;0</code>).

          <br><dt><var>K</var><dd>Maximum number of requests allowed in the system (<var>K</var><code> &ge; 1</code>).

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>U</var><dd>Service center utilization, which is defined as <var>U</var><code> = 1-</code><var>p0</var>

          <br><dt><var>R</var><dd>Service center response time

          <br><dt><var>Q</var><dd>Average number of requests in the system

          <br><dt><var>X</var><dd>Service center throughput

          <br><dt><var>p0</var><dd>Steady-state probability that there are no requests in the system

          <br><dt><var>pK</var><dd>Steady-state probability that there are K requests in the system
(i.e., that the system is full)

        </dl>

        <p><var>lambda</var>, <var>mu</var> and <var>K</var> can be vectors of the
same size. In this case, the results will be vectors as well.

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qnmm1,qnmminf,qnmmm.

        </blockquote></div>

<!-- M/M/m/k -->
<div class="node">
<a name="The-M%2fM%2fm%2fK-System"></a>
<a name="The-M_002fM_002fm_002fK-System"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#The-Asymmetric-M_002fM_002fm-System">The Asymmetric M/M/m System</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-M_002fM_002f1_002fK-System">The M/M/1/K System</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Single-Station-Queueing-Systems">Single Station Queueing Systems</a>

</div>

<h3 class="section">5.5 The M/M/m/K System</h3>

<p>The M/M/m/K finite capacity system is similar to the
M/M/1/k system except that the number of servers is m,
where 1 \leq m \leq K. The queue is made of K-m
slots. The M/M/m/K system is always stable.

   <p><a name="doc_002dqnmmmk"></a>

<div class="defun">
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>, <var>p0</var>, <var>pK</var>] = <b>qnmmmk</b> (<var>lambda, mu, m, K</var>)<var><a name="index-qnmmmk-59"></a></var><br>
<blockquote>
        <p><a name="index-g_t_0040math_007bM_002fM_002fm_002fK_007d-system-60"></a>
Compute utilization, response time, average number of requests and
throughput for a M/M/m/K finite capacity system. In a
M/M/m/K system there are m \geq 1 identical service
centers sharing a fixed-capacity queue. At any time, at most K &ge; m requests can be in the system. The maximum queue length
is K-m. This function generates and
solves the underlying CTMC.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>lambda</var><dd>Arrival rate (<var>lambda</var><code>&gt;0</code>).

          <br><dt><var>mu</var><dd>Service rate (<var>mu</var><code>&gt;0</code>).

          <br><dt><var>m</var><dd>Number of servers (<var>m</var><code> &ge; 1</code>).

          <br><dt><var>K</var><dd>Maximum number of requests allowed in the system,
including those inside the service centers
(<var>K</var><code> &ge; </code><var>m</var>).

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>U</var><dd>Service center utilization

          <br><dt><var>R</var><dd>Service center response time

          <br><dt><var>Q</var><dd>Average number of requests in the system

          <br><dt><var>X</var><dd>Service center throughput

          <br><dt><var>p0</var><dd>Steady-state probability that there are no requests in the system.

          <br><dt><var>pK</var><dd>Steady-state probability that there are <var>K</var> requests in the system
(i.e., probability that the system is full).

        </dl>

        <p><var>lambda</var>, <var>mu</var>, <var>m</var> and <var>K</var> can be either scalars, or
vectors of the  same size. In this case, the results will be vectors
as well.

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qnmm1,qnmminf,qnmmm.

        </blockquote></div>

<p class="noindent"><strong>REFERENCES</strong>

<p class="noindent">G. Bolch, S. Greiner, H. de Meer and K. Trivedi, <cite>Queueing Networks
and Markov Chains: Modeling and Performance Evaluation with Computer
Science Applications</cite>, Wiley, 1998, Section 6.6.

   <p><a name="index-Bolch_002c-G_002e-61"></a><a name="index-Greiner_002c-S_002e-62"></a><a name="index-de-Meer_002c-H_002e-63"></a><a name="index-Trivedi_002c-K_002e-64"></a>

<!-- Approximate M/M/m -->
<div class="node">
<a name="The-Asymmetric-M%2fM%2fm-System"></a>
<a name="The-Asymmetric-M_002fM_002fm-System"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#The-M_002fG_002f1-System">The M/G/1 System</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-M_002fM_002fm_002fK-System">The M/M/m/K System</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Single-Station-Queueing-Systems">Single Station Queueing Systems</a>

</div>

<h3 class="section">5.6 The Asymmetric M/M/m System</h3>

<p>The Asymmetric M/M/m system contains m servers connected
to a single queue. Differently from the M/M/m system, in the
asymmetric M/M/m each server may have a different service time.

   <p><a name="doc_002dqnammm"></a>

<div class="defun">
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qnammm</b> (<var>lambda, mu</var>)<var><a name="index-qnammm-65"></a></var><br>
<blockquote>
        <p><a name="index-Asymmetric-_0040math_007bM_002fM_002fm_007d-system-66"></a>
Compute <em>approximate</em> utilization, response time, average number
of requests in service and throughput for an asymmetric  M/M/m
queue. In this system there are m different service centers
connected to a single queue. Each server has its own (possibly different)
service rate. If there is more than one server available, requests
are routed to a randomly-chosen one.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>lambda</var><dd>Arrival rate (<var>lambda</var><code>&gt;0</code>).

          <br><dt><var>mu</var><dd><var>mu</var><code>(i)</code> is the service rate of server
i, 1 &le; i &le; m. 
The system must be ergodic (<var>lambda</var><code> &lt; sum(</code><var>mu</var><code>)</code>).

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>U</var><dd>Approximate service center utilization,
U = \lambda / ( \sum_i \mu_i ).

          <br><dt><var>R</var><dd>Approximate service center response time

          <br><dt><var>Q</var><dd>Approximate number of requests in the system

          <br><dt><var>X</var><dd>Approximate service center throughput. If the system is ergodic,
we will always have <var>X</var><code> = </code><var>lambda</var>

        </dl>

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qnmmm.

        </blockquote></div>

<p class="noindent"><strong>REFERENCES</strong>

<p class="noindent">G. Bolch, S. Greiner, H. de Meer and K. Trivedi, <cite>Queueing Networks
and Markov Chains: Modeling and Performance Evaluation with Computer
Science Applications</cite>, Wiley, 1998

   <p><a name="index-Bolch_002c-G_002e-67"></a><a name="index-Greiner_002c-S_002e-68"></a><a name="index-de-Meer_002c-H_002e-69"></a><a name="index-Trivedi_002c-K_002e-70"></a>
<div class="node">
<a name="The-M%2fG%2f1-System"></a>
<a name="The-M_002fG_002f1-System"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#The-M_002fHm_002f1-System">The M/Hm/1 System</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-Asymmetric-M_002fM_002fm-System">The Asymmetric M/M/m System</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Single-Station-Queueing-Systems">Single Station Queueing Systems</a>

</div>

<h3 class="section">5.7 The M/G/1 System</h3>

<p><a name="doc_002dqnmg1"></a>

<div class="defun">
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>, <var>p0</var>] = <b>qnmg1</b> (<var>lambda, xavg, x2nd</var>)<var><a name="index-qnmg1-71"></a></var><br>
<blockquote>
        <p><a name="index-g_t_0040math_007bM_002fG_002f1_007d-system-72"></a>
Compute utilization, response time, average number of requests and
throughput for a M/G/1 system. The service time distribution
is described by its mean <var>xavg</var>, and by its second moment
<var>x2nd</var>. The computations are based on results from L. Kleinrock,
<cite>Queuing Systems</cite>, Wiley, Vol 2, and Pollaczek-Khinchine formula.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>lambda</var><dd>Arrival rate.

          <br><dt><var>xavg</var><dd>Average service time

          <br><dt><var>x2nd</var><dd>Second moment of service time distribution

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>U</var><dd>Service center utilization

          <br><dt><var>R</var><dd>Service center response time

          <br><dt><var>Q</var><dd>Average number of requests in the system

          <br><dt><var>X</var><dd>Service center throughput

          <br><dt><var>p0</var><dd>probability that there is not any request at system

        </dl>

        <p><var>lambda</var>, <var>xavg</var>, <var>t2nd</var> can be vectors of the
same size. In this case, the results will be vectors as well.

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qnmh1.

        </blockquote></div>

<div class="node">
<a name="The-M%2fHm%2f1-System"></a>
<a name="The-M_002fHm_002f1-System"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-M_002fG_002f1-System">The M/G/1 System</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Single-Station-Queueing-Systems">Single Station Queueing Systems</a>

</div>

<h3 class="section">5.8 The M/H_m/1 System</h3>

<p><a name="doc_002dqnmh1"></a>

<div class="defun">
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>, <var>p0</var>] = <b>qnmh1</b> (<var>lambda, mu, alpha</var>)<var><a name="index-qnmh1-73"></a></var><br>
<blockquote>
        <p><a name="index-g_t_0040math_007bM_002fH_005fm_002f1_007d-system-74"></a>
Compute utilization, response time, average number of requests and
throughput for a M/H_m/1 system. In this system, the customer
service times have hyper-exponential distribution:

     <pre class="example">                 ___ m
                 \
          B(x) =  &gt;  alpha(j) * (1-exp(-mu(j)*x))   x&gt;0
                 /__
                     j=1
</pre>
        <p>where \alpha_j is the probability that the request is served
at phase j, in which case the average service rate is
\mu_j. After completing service at phase j, for
some j, the request exits the system.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>lambda</var><dd>Arrival rate.

          <br><dt><var>mu</var><dd><var>mu</var><code>(j)</code> is the phase j service rate. The total
number of phases m is <code>length(</code><var>mu</var><code>)</code>.

          <br><dt><var>alpha</var><dd><var>alpha</var><code>(j)</code> is the probability that a request
is served at phase j. <var>alpha</var> must have the same size
as <var>mu</var>.

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>U</var><dd>Service center utilization

          <br><dt><var>R</var><dd>Service center response time

          <br><dt><var>Q</var><dd>Average number of requests in the system

          <br><dt><var>X</var><dd>Service center throughput

        </dl>

     <!-- @seealso{qnmhr1} -->
        </blockquote></div>

<!-- DO NOT EDIT!  Generated automatically by munge-texi. -->
<!-- *- texinfo -*- -->
<!-- Copyright (C) 2008, 2009, 2010, 2011, 2012 Moreno Marzolla -->
<!-- This file is part of the queueing toolbox, a Queueing Networks -->
<!-- analysis package for GNU Octave. -->
<!-- The queueing toolbox is free software; you can redistribute it -->
<!-- and/or modify it under the terms of the GNU General Public License -->
<!-- as published by the Free Software Foundation; either version 3 of -->
<!-- the License, or (at your option) any later version. -->
<!-- The queueing toolbox is distributed in the hope that it will be -->
<!-- useful, but WITHOUT ANY WARRANTY; without even the implied warranty -->
<!-- of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the -->
<!-- GNU General Public License for more details. -->
<!-- You should have received a copy of the GNU General Public License -->
<!-- along with the queueing toolbox; see the file COPYING.  If not, see -->
<!-- <http://www.gnu.org/licenses/>. -->
<div class="node">
<a name="Queueing-Networks"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Contributing-Guidelines">Contributing Guidelines</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Single-Station-Queueing-Systems">Single Station Queueing Systems</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">6 Queueing Networks</h2>

<ul class="menu">
<li><a accesskey="1" href="#Introduction-to-QNs">Introduction to QNs</a>:                  A brief introduction to Queueing Networks. 
<li><a accesskey="2" href="#Generic-Algorithms">Generic Algorithms</a>:                   High-level functions for QN analysis
<li><a accesskey="3" href="#Algorithms-for-Product_002dForm-QNs">Algorithms for Product-Form QNs</a>:      Functions to analyze product-form QNs
<li><a accesskey="4" href="#Algorithms-for-non-Product_002dform-QNs">Algorithms for non Product-form QNs</a>:  Functions to analyze non product-form QNs
<li><a accesskey="5" href="#Bounds-on-performance">Bounds on performance</a>:                Functions to compute performance bounds
<li><a accesskey="6" href="#Utility-functions">Utility functions</a>:                    Utility functions to compute miscellaneous quantities
</ul>

<p><a name="index-queueing-networks-75"></a>
<!-- INTRODUCTION -->
<div class="node">
<a name="Introduction-to-QNs"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Generic-Algorithms">Generic Algorithms</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Queueing-Networks">Queueing Networks</a>

</div>

<h3 class="section">6.1 Introduction to QNs</h3>

<p>Queueing Networks (QN) are a very simple yet powerful modeling tool
which is used to analyze many kind of systems. In its simplest form, a
QN is made of K service centers. Each service center i
has a queue, which is connected to m_i (generally identical)
<em>servers</em>. Customers (or requests) arrive at the service center,
and join the queue if there is a slot available. Then, requests are
served according to a (de)queueing policy. After service completes,
the requests leave the service center.

   <p>The service centers for which m_i = \infty are called
<em>delay centers</em> or <em>infinite servers</em>. If a service center
has infinite servers, of course each new request will find one server
available, so there will never be queueing.

   <p>Requests join the queue according to a <em>queueing policy</em>, such as:

     <dl>
<dt><strong>FCFS</strong><dd>First-Come-First-Served

     <br><dt><strong>LCFS-PR</strong><dd>Last-Come-First-Served, Preemptive Resume

     <br><dt><strong>PS</strong><dd>Processor Sharing

     <br><dt><strong>IS</strong><dd>Infinite Server, there is an infinite number of identical servers so
that each request always finds a server available, and there is no
queueing

   </dl>

   <p>A population of <em>requests</em> or <em>customers</em> arrives to the
system system, requesting service to the service centers.  The request
population may be <em>open</em> or <em>closed</em>. In open systems there
is an infinite population of requests. New customers arrive from
outside the system, and eventually leave the system. In closed systems
there is a fixed population of request which continuously interacts
with the system.

   <p>There might be a single class of requests, meaning that all requests
behave in the same way (e.g., they spend the same average time on each
particular server), or there might be multiple classes of requests.

<h4 class="subsection">6.1.1 Single class models</h4>

<p>In single class models, all requests are indistinguishable and belong to
the same class. This means that every request has the same average
service time, and all requests move through the system with the same
routing probabilities.

<p class="noindent"><strong>Model Inputs</strong>

     <dl>
<dt>\lambda_i<dd>External arrival rate to service center i.

     <br><dt>\lambda<dd>Overall external arrival rate to the whole system: \lambda =
\sum_i \lambda_i.

     <br><dt>S_i<dd>Average service time. S_i is the average service time on service
center i. In other words, S_i is the average time from the
instant in which a request is extracted from the queue and starts being
service, and the instant at which service finishes and the request moves
to another queue (or exits the system).

     <br><dt>P_ij<dd>Routing probability matrix. \bf P = P_ij is a K \times
K matrix such that P_ij is the probability that a request
completing service at server i will move directly to server
j, The probability that a request leaves the system after service
at service center i is 1-\sum_j=1^K P_ij.

     <br><dt>V_i<dd>Average number of visits. V_i is the average number of visits to
the service center i. This quantity will be described shortly.

   </dl>

<p class="noindent"><strong>Model Outputs</strong>

     <dl>
<dt>U_i<dd>Service center utilization. U_i is the utilization of service
center i. The utilization is defined as the fraction of time in
which the resource is busy (i.e., the server is processing requests).

     <br><dt>R_i<dd>Average response time. R_i is the average response time of
service center i. The average response time is defined as the
average time between the arrival of a customer in the queue, and the
completion of service.

     <br><dt>Q_i<dd>Average number of customers. Q_i is the average number of
requests in service center i. This includes both the requests in
the queue, and the request being served.

     <br><dt>X_i<dd>Throughput. X_i is the throughput of service center i. 
The throughput is defined as the ratio of job completions (i.e., average
number of jobs completed over a fixed interval of time).

   </dl>

<p class="noindent">Given these output parameters, additional performance measures can
be computed as follows:

     <dl>
<dt>X<dd>System throughput, X = X_1 / V_1

     <br><dt>R<dd>System response time, R = \sum_k=1^K R_k V_k

     <br><dt>Q<dd>Average number of requests in the system, Q = N-XZ

   </dl>

   <p>For open, single-class models, the scalar \lambda denotes the
external arrival rate of requests to the system. The average number of
visits satisfy the following equation:

<pre class="example">     V == P0 + V*P;
</pre>
   <p class="noindent">where P_0 j is the probability that an external
arrival goes to service center j. If \lambda_j is the
external arrival rate to service center j, and \lambda =
\sum_j \lambda_j is the overall external arrival rate, then
P_0 j = \lambda_j / \lambda.

   <p>For closed models, the visit ratios satisfy the following equation:

<pre class="example">     V(1) == 1 &amp;&amp; V == V*P;
</pre>
   <h4 class="subsection">6.1.2 Multiple class models</h4>

<p>In multiple class QN models, we assume that there exist C
different classes of requests. Each request from class c spends
on average time S_ck in service at service center k. For
open models, we denote with \bf \lambda = \lambda_ck the
arrival rates, where \lambda_ck is the external arrival rate of
class c customers at service center k. For closed models,
we denote with \bf N = (N_1, N_2, \ldots N_C) the population
vector, where N_c is the number of class c requests in the
system.

   <p>The transition probability matrix for these kind of networks will be a
C \times K \times C \times K matrix \bf P =
P_risj such that P_risj is the probability that a
class r request which completes service at center i will
join server j as a class s request.

   <p>Model input and outputs can be adjusted by adding additional
indexes for the customer classes.

<p class="noindent"><strong>Model Inputs</strong>

     <dl>
<dt>\lambda_ci<dd>External arrival rate of class-c requests to service center i

     <br><dt>\lambda<dd>Overall external arrival rate to the whole system: \lambda = \sum_c \sum_i \lambda_ci

     <br><dt>S_ci<dd>Average service time. S_ci is the average service time on service
center i for class c requests.

     <br><dt>P_risj<dd>Routing probability matrix. \bf P = P_risj is a C
\times K \times C \times K matrix such that P_risj is the
probability that a class r request which completes service at
server i will move to server j as a class s
request.

     <br><dt>V_ci<dd>Average number of visits. V_ci is the average number of visits
of class c requests to the service center i.

   </dl>

<p class="noindent"><strong>Model Outputs</strong>

     <dl>
<dt>U_ci<dd>Utilization of service center i by class c requests. The
utilization is defined as the fraction of time in which the resource is
busy (i.e., the server is processing requests).

     <br><dt>R_ci<dd>Average response time experienced by class c requests on service
center i. The average response time is defined as the average
time between the arrival of a customer in the queue, and the completion
of service.

     <br><dt>Q_ci<dd>Average number of class c requests on service center
i. This includes both the requests in the queue, and the request
being served.

     <br><dt>X_ci<dd>Throughput of service center i for class c requests.  The
throughput is defined as the rate of completion of class c
requests.

   </dl>

<p class="noindent">It is possible to define aggregate performance measures as follows:

     <dl>
<dt>U_i<dd>Utilization of service center i:
<code>Ui = sum(U,1);</code>

     <br><dt>R_c<dd>System response time for class c requests:
<code>Rc = sum( V.*R, 1 );</code>

     <br><dt>Q_c<dd>Average number of class c requests in the system:
<code>Qc = sum( Q, 2 );</code>

     <br><dt>X_c<dd>Class c throughput:
<code>Xc = X(:,1) ./ V(:,1);</code>

   </dl>

   <p>We can define the visit ratios V_sj for class s
customers at service center j as follows:

   <p>V_sj = sum_r sum_i V_ri P_risj, for all s,j

<p class="noindent">while for open networks:

   <p>V_sj = P_0sj + sum_r sum_i V_ri P_risj, for all s,j

<p class="noindent">where P_0sj is the probability that an external
arrival goes to service center j as a class-s request. 
If \lambda_sj is the external arrival rate of class s
requests to service center j, and \lambda = \sum_s \sum_j
\lambda_sj is the overall external arrival rate to the whole system,
then P_0sj = \lambda_sj / \lambda.

<div class="node">
<a name="Generic-Algorithms"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Algorithms-for-Product_002dForm-QNs">Algorithms for Product-Form QNs</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Introduction-to-QNs">Introduction to QNs</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Queueing-Networks">Queueing Networks</a>

</div>

<h3 class="section">6.2 Generic Algorithms</h3>

<p>The <code>queueing</code> package provides a couple of high-level functions
for defining and solving QN models. These functions can be used to
define a open or closed QN model (with single or multiple job
classes), with arbitrary configuration and queueing disciplines. At
the moment only product-form networks can be solved, See <a href="#Algorithms-for-Product_002dForm-QNs">Algorithms for Product-Form QNs</a>.

   <p>The network is defined by two parameters. The first one is the list of
nodes, encoded as an Octave <em>cell array</em>. The second parameter is
the visit ration <var>V</var>, which can be either a vector (for
single-class models) or a two-dimensional matrix (for multiple-class
models).

   <p>Individual nodes in the network are structures build using the
<code>qnmknode</code> function.

   <p><a name="doc_002dqnmknode"></a>

<div class="defun">
&mdash; Function File: <var>Q</var> = <b>qnmknode</b> (<var>"m/m/m-fcfs", S</var>)<var><a name="index-qnmknode-76"></a></var><br>
&mdash; Function File: <var>Q</var> = <b>qnmknode</b> (<var>"m/m/m-fcfs", S, m</var>)<var><a name="index-qnmknode-77"></a></var><br>
&mdash; Function File: <var>Q</var> = <b>qnmknode</b> (<var>"m/m/1-lcfs-pr", S</var>)<var><a name="index-qnmknode-78"></a></var><br>
&mdash; Function File: <var>Q</var> = <b>qnmknode</b> (<var>"-/g/1-ps", S</var>)<var><a name="index-qnmknode-79"></a></var><br>
&mdash; Function File: <var>Q</var> = <b>qnmknode</b> (<var>"-/g/1-ps", S, s2</var>)<var><a name="index-qnmknode-80"></a></var><br>
&mdash; Function File: <var>Q</var> = <b>qnmknode</b> (<var>"-/g/inf", S</var>)<var><a name="index-qnmknode-81"></a></var><br>
&mdash; Function File: <var>Q</var> = <b>qnmknode</b> (<var>"-/g/inf", S, s2</var>)<var><a name="index-qnmknode-82"></a></var><br>
<blockquote>
        <p>Creates a node; this function can be used together with
<code>qnsolve</code>. It is possible to create either single-class nodes
(where there is only one customer class), or multiple-class nodes
(where the service time is given per-class). Furthermore, it is
possible to specify load-dependent service times.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>S</var><dd>Average service time. S can be either a scalar, a row vector,
a column vector or a two-dimensional matrix.

               <ul>
<li>If S is a scalar,
it is assumed to be a load-independent, class-independent service time.

               <li>If S is a column vector, then <var>S</var><code>(c)</code> is assumed to
the the load-independent service time for class c customers.

               <li>If S is a row vector, then <var>S</var><code>(n)</code> is assumed to be
the class-independent service time at the node, when there are n
requests.

               <li>Finally, if <var>S</var> is a two-dimensional matrix, then
<var>S</var><code>(c,n)</code> is assumed to be the class c service time
when there are n requests at the node.

          </ul>

          <br><dt><var>m</var><dd>Number of identical servers at the node. Default is <var>m</var><code>=1</code>.

          <br><dt><var>s2</var><dd>Squared coefficient of variation for the service time. Default is 1.0.

        </dl>

        <p>The returned struct <var>Q</var> should be considered opaque to the client.

     <!-- The returned struct @var{Q} has the following fields: -->
     <!-- @table @var -->
     <!-- @item Q.node -->
     <!-- (String) type of the node; valid values are @code{"m/m/m-fcfs"}, -->
     <!-- @code{"-/g/1-lcfs-pr"}, @code{"-/g/1-ps"} (Processor-Sharing) -->
     <!-- and @code{"-/g/inf"} (Infinite Server, or delay center). -->
     <!-- @item Q.S -->
     <!-- Average service time. If @code{@var{Q}.S} is a vector, then -->
     <!-- @code{@var{Q}.S(i)} is the average service time at that node -->
     <!-- if there are @math{i} requests. -->
     <!-- @item Q.m -->
     <!-- Number of identical servers at a @code{"m/m/m-fcfs"}. Default is 1. -->
     <!-- @item Q.c -->
     <!-- Number of customer classes. Default is 1. -->
     <!-- @end table -->
        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qnsolve.

        </blockquote></div>

   <p>After the network has been defined, it is possible to solve it using
the <code>qnsolve</code> function. Note that this function is somewhat less
efficient than those described in later sections, but
generally easier to use.

   <p><a name="doc_002dqnsolve"></a>

<div class="defun">
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qnsolve</b> (<var>"closed", N, QQ, V</var>)<var><a name="index-qnsolve-83"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qnsolve</b> (<var>"closed", N, QQ, V, Z</var>)<var><a name="index-qnsolve-84"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qnsolve</b> (<var>"open", lambda, QQ, V</var>)<var><a name="index-qnsolve-85"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qnsolve</b> (<var>"mixed", lambda, N, QQ, V</var>)<var><a name="index-qnsolve-86"></a></var><br>
<blockquote>
        <p>General evaluator of QN models. Networks can be open,
closed or mixed; single as well as multiclass networks are supported.

          <ul>
<li>For <strong>closed</strong> networks, the following server types are
supported: M/M/m&ndash;FCFS, -/G/\infty, -/G/1&ndash;LCFS-PR,
-/G/1&ndash;PS and load-dependent variants.

          <li>For <strong>open</strong> networks, the following server types are supported:
M/M/m&ndash;FCFS, -/G/\infty and -/G/1&ndash;PS. General
load-dependent nodes are <em>not</em> supported. Multiclass open networks
do not support multiple server M/M/m nodes, but only
single server M/M/1&ndash;FCFS.

          <li>For <strong>mixed</strong> networks, the following server types are supported:
M/M/1&ndash;FCFS, -/G/\infty and -/G/1&ndash;PS. General
load-dependent nodes are <em>not</em> supported.

        </ul>

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>N</var><dd>Number of requests in the system for closed networks. For
single-class networks, <var>N</var> must be a scalar. For multiclass
networks, <var>N</var><code>(c)</code> is the population size of closed class
c.

          <br><dt><var>lambda</var><dd>External arrival rate (scalar) for open networks. For single-class
networks, <var>lambda</var> must be a scalar. For multiclass networks,
<var>lambda</var><code>(c)</code> is the class c overall arrival rate.

          <br><dt><var>QQ</var><dd>List of queues in the network. This must be a cell array
with N elements, such that <var>QQ</var><code>{i}</code> is
a struct produced by the <code>qnmknode</code> function.

          <br><dt><var>Z</var><dd>External delay ("think time") for closed networks. Default 0.

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>U</var><dd>If i is a FCFS node, then <var>U</var><code>(i)</code> is the utilization
of service center i. If i is an IS node, then
<var>U</var><code>(i)</code> is the <em>traffic intensity</em> defined as
<var>X</var><code>(i)*</code><var>S</var><code>(i)</code>.

          <br><dt><var>R</var><dd><var>R</var><code>(i)</code> is the average response time of service center i.

          <br><dt><var>Q</var><dd><var>Q</var><code>(i)</code> is the average number of customers in service center
i.

          <br><dt><var>X</var><dd><var>X</var><code>(i)</code> is the throughput of service center i.

        </dl>

        <p>Note that for multiclass networks, the computed results are per-class
utilization, response time, number of customers and throughput:
<var>U</var><code>(c,k)</code>, <var>R</var><code>(c,k)</code>, <var>Q</var><code>(c,k)</code>,
<var>X</var><code>(c,k)</code>,

        </blockquote></div>

<p class="noindent"><strong>EXAMPLE</strong>

   <p>Let us consider a closed, multiclass network with C=2 classes
and K=3 service center. Let the population be M=(2, 1)
(class 1 has 2 requests, and class 2 has 1 request). The nodes are as
follows:

     <ul>
<li>Node 1 is a M/M/1&ndash;FCFS node, with load-dependent service
times. Service times are class-independent, and are defined by the
matrix <code>[0.2 0.1 0.1; 0.2 0.1 0.1]</code>. Thus, <var>S</var><code>(1,2) =
0.2</code> means that service time for class 1 customers where there are 2
requests in 0.2. Note that service times are class-independent;

     <li>Node 2 is a -/G/1&ndash;PS node, with service times
S_12 = 0.4 for class 1, and S_22 = 0.6 for class 2
requests;

     <li>Node 3 is a -/G/\infty node (delay center), with service
times S_13=1 and S_23=2 for class 1 and 2
respectively.

   </ul>

   <p>After defining the per-class visit count <var>V</var> such that
<var>V</var><code>(c,k)</code> is the visit count of class c requests to
service center k.  We can define and solve the model as
follows:

<pre class="example"><pre class="verbatim">      QQ = { qnmknode( "m/m/m-fcfs", [0.2 0.1 0.1; 0.2 0.1 0.1] ), \
             qnmknode( "-/g/1-ps", [0.4; 0.6] ), \
             qnmknode( "-/g/inf", [1; 2] ) };
      V = [ 1 0.6 0.4; \
            1 0.3 0.7 ];
      N = [ 2 1 ];
      [U R Q X] = qnsolve( "closed", N, QQ, V );</pre></pre>
   <div class="node">
<a name="Algorithms-for-Product-Form-QNs"></a>
<a name="Algorithms-for-Product_002dForm-QNs"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Algorithms-for-non-Product_002dform-QNs">Algorithms for non Product-form QNs</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Generic-Algorithms">Generic Algorithms</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Queueing-Networks">Queueing Networks</a>

</div>

<h3 class="section">6.3 Algorithms for Product-Form QNs</h3>

<p>Product-form queueing networks fulfill the following assumptions:

     <ul>
<li>The network can consist of open and closed job classes.

     <li>The following queueing disciplines are allowed: FCFS, PS, LCFS-PR and IS.

     <li>Service times for FCFS nodes must be exponentially distributed and
class-independent. Service centers at PS, LCFS-PR and IS nodes can
have any kind of service time distribution with a rational Laplace
transform.  Furthermore, for PS, LCFS-PR and IS nodes, different
classes of customers can have different service times.

     <li>The service rate of an FCFS node is only allowed to depend on the
number of jobs at this node; in a PS, LCFS-PR and IS node the service
rate for a particular job class can also depend on the number of jobs
of that class at the node.

     <li>In open networks two kinds of arrival processes are allowed: i) the
arrival process is Poisson, with arrival rate \lambda which can
depend on the number of jobs in the network. ii) the arrival process
consists of U independent Poisson arrival streams where the
U job sources are assigned to the U chains; the arrival
rate can be load dependent.

   </ul>

<!-- Jackson Networks -->
<h4 class="subsection">6.3.1 Jackson Networks</h4>

<p>Jackson networks satisfy the following conditions:

     <ul>
<li>There is only one job class in the network; the overall number of jobs
in the system is unlimited.

     <li>There are N service centers in the network. Each service center
may have Poisson arrivals from outside the system. A job can leave
the system from any node.

     <li>Arrival rates as well as routing probabilities are independent from
the number of nodes in the network.

     <li>External arrivals and service times at the service centers are
exponentially distributed, and in general can be load-dependent.

     <li>Service discipline at each node is FCFS

   </ul>

   <p>We define the <em>joint probability vector</em> \pi(k_1, k_2,
\ldots k_N) as the steady-state probability that there are k_i
requests at service center i, for all i=1,2, \ldots N. 
Jackson networks have the property that the joint probability is the
product of the marginal probabilities \pi_i:

<pre class="example">     <var>joint_prob</var> = prod( <var>pi</var> )
</pre>
   <p class="noindent">where \pi_i(k_i) is the steady-state probability
that there are k_i requests at service center i.

   <p><a name="doc_002dqnjackson"></a>

<div class="defun">
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qnjackson</b> (<var>lambda, S, P </var>)<var><a name="index-qnjackson-87"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qnjackson</b> (<var>lambda, S, P, m </var>)<var><a name="index-qnjackson-88"></a></var><br>
&mdash; Function File: <var>pr</var> = <b>qnjackson</b> (<var>lambda, S, P, m, k</var>)<var><a name="index-qnjackson-89"></a></var><br>
<blockquote>
        <p><a name="index-open-network_002c-single-class-90"></a><a name="index-Jackson-network-91"></a>
With three or four input parameters, this function computes the
steady-state occupancy probabilities for a Jackson network. With five
input parameters, this function computes the steady-state probability
<var>pi</var><code>(j)</code> that there are <var>k</var><code>(j)</code> requests at
service center j.

        <p>This function solves a subset of Jackson networks, with the
following constraints:

          <ul>
<li>External arrival rates are load-independent.

          <li>Service center i consists either of <var>m</var><code>(i) &ge;
1</code> identical servers with individual average service time
<var>S</var><code>(i)</code>, or of an Infinite Server (IS) node.

        </ul>

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>lambda</var><dd><var>lambda</var><code>(i)</code> is
the external arrival rate to service center i. <var>lambda</var>
must be a vector of length N, <var>lambda</var><code>(i) &ge; 0</code>.

          <br><dt><var>S</var><dd><var>S</var><code>(i)</code> is the average service time on service center i
<var>S</var> must be a vector of length N, <var>S</var><code>(i)&gt;0</code>.

          <br><dt><var>P</var><dd><var>P</var><code>(i,j)</code> is the probability
that a job which completes service at service center i proceeds
to service center j. <var>P</var> must be a matrix of size
N \times N.

          <br><dt><var>m</var><dd><var>m</var><code>(i)</code> is the number of servers at service center
i. If <var>m</var><code>(i) &lt; 1</code>, service center i is an
infinite-server node. Otherwise, it is a regular FCFS queueing center with
<var>m</var><code>(i)</code> servers. If this parameter is omitted, default is
<var>m</var><code>(i) = 1</code> for all i. If this parameter is a scalar,
it will be promoted to a vector with the same size as <var>lambda</var>. 
Otherwise, <var>m</var> must be a vector of length N.

          <br><dt><var>k</var><dd>Compute the steady-state probability that there are <var>k</var><code>(i)</code>
requests at service center i. <var>k</var> must have the same length
as <var>lambda</var>, with <var>k</var><code>(i) &ge; 0</code>.

        </dl>

        <p><strong>OUTPUT</strong>

          <dl>
<dt><var>U</var><dd>If i is a FCFS node, then
<var>U</var><code>(i)</code> is the utilization of service center i. 
If i is an IS node, then <var>U</var><code>(i)</code> is the
<em>traffic intensity</em> defined as <var>X</var><code>(i)*</code><var>S</var><code>(i)</code>.

          <br><dt><var>R</var><dd><var>R</var><code>(i)</code> is the average response time of service center i.

          <br><dt><var>Q</var><dd><var>Q</var><code>(i)</code> is the average number of customers in service center
i.

          <br><dt><var>X</var><dd><var>X</var><code>(i)</code> is the throughput of service center i.

          <br><dt><var>pr</var><dd><var>pr</var><code>(i)</code> is the steady state probability
that there are <var>k</var><code>(i)</code> requests at service center i.

        </dl>

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qnopen.

        </blockquote></div>

<p class="noindent"><strong>REFERENCES</strong>

   <p>This implementation is based on G. Bolch, S. Greiner, H. de Meer and
K. Trivedi, <cite>Queueing Networks and Markov Chains: Modeling and
Performance Evaluation with Computer Science Applications</cite>, Wiley,
1998, pp. 284&ndash;287.

   <p><a name="index-Bolch_002c-G_002e-92"></a><a name="index-Greiner_002c-S_002e-93"></a><a name="index-de-Meer_002c-H_002e-94"></a><a name="index-Trivedi_002c-K_002e-95"></a>

<h4 class="subsection">6.3.2 The Convolution Algorithm</h4>

<p>According to the BCMP theorem, the state probability of a closed
single class queueing network with K nodes and N requests
can be expressed as:

<pre class="example">     k = [k1, k2, ... kn]; <span class="roman">population vector</span>
     p = 1/G(N+1) \prod F(i,k);
</pre>
   <p>Here \pi(k_1, k_2, \ldots k_K) is the joint probability of
having k_i requests at node i, for all i=1,2,
\ldots K.

   <p>The <em>convolution algorithms</em> computes the normalization constants
G = (G(0), G(1), \ldots G(N)) for single-class, closed networks
with N requests.  The normalization constants are returned as
vector <var>G</var><code>=[</code><var>G</var><code>(1), </code><var>G</var><code>(2), ... </code><var>G</var><code>(N+1)]</code> where
<var>G</var><code>(i+1)</code> is the value of G(i) (remember that Octave
uses 1-base vectors). The normalization constant can be used to
compute all performance measures of interest (utilization, average
response time and so on).

   <p><code>queueing</code> implements the convolution algorithm, in the function
<code>qnconvolution</code> and <code>qnconvolutionld</code>. The first one
supports single-station nodes, multiple-station nodes and IS nodes. 
The second one supports networks with general load-dependent service
centers.

<!-- The Convolution Algorithm -->
   <p><a name="doc_002dqnconvolution"></a>

<div class="defun">
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>, <var>G</var>] = <b>qnconvolution</b> (<var>N, S, V</var>)<var><a name="index-qnconvolution-96"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>, <var>G</var>] = <b>qnconvolution</b> (<var>N, S, V, m</var>)<var><a name="index-qnconvolution-97"></a></var><br>
<blockquote>
        <p><a name="index-closed-network-98"></a><a name="index-normalization-constant-99"></a><a name="index-convolution-algorithm-100"></a>
This function implements the <em>convolution algorithm</em> for
computing steady-state performance measures of product-form,
single-class closed queueing networks. Load-independent service
centers, multiple servers (M/M/m queues) and IS nodes are
supported. For general load-dependent service centers, use the
<code>qnconvolutionld</code> function instead.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>N</var><dd>Number of requests in the system (<var>N</var><code>&gt;0</code>).

          <br><dt><var>S</var><dd><var>S</var><code>(k)</code> is the average service time on center k
(<var>S</var><code>(k) &ge; 0</code>).

          <br><dt><var>V</var><dd><var>V</var><code>(k)</code> is the visit count of service center k
(<var>V</var><code>(k) &ge; 0</code>).

          <br><dt><var>m</var><dd><var>m</var><code>(k)</code> is the number of servers at center
k. If <var>m</var><code>(k) &lt; 1</code>, center k is a delay center (IS);
if <var>m</var><code>(k) &ge; 1</code>, center k
it is a regular M/M/m queueing center with <var>m</var><code>(k)</code>
identical servers. Default is <var>m</var><code>(k) = 1</code> for all k.

        </dl>

        <p><strong>OUTPUT</strong>

          <dl>
<dt><var>U</var><dd><var>U</var><code>(k)</code> is the utilization of center k. 
For IS nodes, <var>U</var><code>(k)</code> is the <em>traffic intensity</em>.

          <br><dt><var>R</var><dd><var>R</var><code>(k)</code> is the average response time of center k.

          <br><dt><var>Q</var><dd><var>Q</var><code>(k)</code> is the average number of customers at center
k.

          <br><dt><var>X</var><dd><var>X</var><code>(k)</code> is the throughput of center k.

          <br><dt><var>G</var><dd>Vector of normalization constants. <var>G</var><code>(n+1)</code> contains the value of
the normalization constant with n requests
G(n), n=0, <small class="dots">...</small>, N.

        </dl>

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qnconvolutionld.

        </blockquote></div>

<p class="noindent"><strong>EXAMPLE</strong>

   <p>The normalization constant G can be used to compute the
steady-state probabilities for a closed single class product-form
Queueing Network with K nodes. Let <var>k</var><code>=[k_1,
k_2, ... k_K]</code> be a valid population vector. Then, the
steady-state probability <var>p</var><code>(i)</code> to have <var>k</var><code>(i)</code>
requests at service center i can be computed as:

<pre class="example"><pre class="verbatim">      k = [1 2 0];
      K = sum(k); # Total population size
      S = [ 1/0.8 1/0.6 1/0.4 ];
      m = [ 2 3 1 ];
      V = [ 1 .667 .2 ];
      [U R Q X G] = qnconvolution( K, S, V, m );
      p = [0 0 0]; # initialize p
      # Compute the probability to have k(i) jobs at service center i
      for i=1:3
        p(i) = (V(i)*S(i))^k(i) / G(K+1) * \
               (G(K-k(i)+1) - V(i)*S(i)*G(K-k(i)) );
        printf("k(%d)=%d prob=%f\n", i, k(i), p(i) );
      endfor</pre>-| k(1)=1 prob=0.17975
     -| k(2)=2 prob=0.48404
     -| k(3)=0 prob=0.52779
</pre>
   <p class="noindent"><strong>NOTE</strong>

   <p>For a network with K service centers and N requests,
this implementation of the convolution algorithm has time and space
complexity O(NK).

<p class="noindent"><strong>REFERENCES</strong>

   <p>Jeffrey P. Buzen, <cite>Computational Algorithms for Closed Queueing
Networks with Exponential Servers</cite>, Communications of the ACM, volume
16, number 9, september 1973,
pp. 527&ndash;531. <a href="http://doi.acm.org/10.1145/362342.362345">http://doi.acm.org/10.1145/362342.362345</a>

   <p><a name="index-Buzen_002c-J_002e-P_002e-101"></a>
This implementation is based on G. Bolch, S. Greiner, H. de Meer and
K. Trivedi, <cite>Queueing Networks and Markov Chains: Modeling and
Performance Evaluation with Computer Science Applications</cite>, Wiley,
1998, pp. 313&ndash;317.

   <p><a name="index-Bolch_002c-G_002e-102"></a><a name="index-Greiner_002c-S_002e-103"></a><a name="index-de-Meer_002c-H_002e-104"></a><a name="index-Trivedi_002c-K_002e-105"></a>
<!-- Convolution for load-dependent service centers -->
<a name="doc_002dqnconvolutionld"></a>

<div class="defun">
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>, <var>G</var>] = <b>qnconvolutionld</b> (<var>N, S, V</var>)<var><a name="index-qnconvolutionld-106"></a></var><br>
<blockquote>
        <p><a name="index-closed-network-107"></a><a name="index-normalization-constant-108"></a><a name="index-convolution-algorithm-109"></a><a name="index-load_002ddependent-service-center-110"></a>
This function implements the <em>convolution algorithm</em> for
product-form, single-class closed queueing networks with general
load-dependent service centers.

        <p>This function computes steady-state performance measures for
single-class, closed networks with load-dependent service centers
using the convolution algorithm; the normalization constants are also
computed. The normalization constants are returned as vector
<var>G</var><code>=[</code><var>G</var><code>(1), ..., </code><var>G</var><code>(N+1)]</code> where
<var>G</var><code>(i+1)</code> is the value of G(i).

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>N</var><dd>Number of requests in the system (<var>N</var><code>&gt;0</code>).

          <br><dt><var>S</var><dd><var>S</var><code>(k,n)</code> is the mean service time at center k
where there are n requests, 1 &le; n
&le; N. <var>S</var><code>(k,n)</code> = 1 / \mu_k,n,
where \mu_k,n is the service rate of center k
when there are n requests.

          <br><dt><var>V</var><dd><var>V</var><code>(k)</code> is the visit count of service center k
(<var>V</var><code>(k) &ge; 0</code>). The length of <var>V</var> is the number of
servers K in the network.

        </dl>

        <p><strong>OUTPUT</strong>

          <dl>
<dt><var>U</var><dd><var>U</var><code>(k)</code> is the utilization of center k.

          <br><dt><var>R</var><dd><var>R</var><code>(k)</code> is the average response time at center k.

          <br><dt><var>Q</var><dd><var>Q</var><code>(k)</code> is the average number of customers in center k.

          <br><dt><var>X</var><dd><var>X</var><code>(k)</code> is the throughput of center k.

          <br><dt><var>G</var><dd>Normalization constants (vector). <var>G</var><code>(n+1)</code>
corresponds to G(n), as array indexes in Octave start
from 1.

        </dl>

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qnconvolution.

        </blockquote></div>

<p class="noindent"><strong>REFERENCES</strong>

   <p>Herb Schwetman, <cite>Some Computational Aspects of Queueing Network
Models</cite>, Technical Report CSD-TR-354, Department of Computer Sciences,
Purdue University, feb, 1981 (revised). 
<a href="http://www.cs.purdue.edu/research/technical_reports/1980/TR%2080-354.pdf">http://www.cs.purdue.edu/research/technical_reports/1980/TR%2080-354.pdf</a>

   <p><a name="index-Schwetman_002c-H_002e-111"></a>
M. Reiser, H. Kobayashi, <cite>On The Convolution Algorithm for
Separable Queueing Networks</cite>, In Proceedings of the 1976 ACM
SIGMETRICS Conference on Computer Performance Modeling Measurement and
Evaluation (Cambridge, Massachusetts, United States, March 29&ndash;31,
1976). SIGMETRICS '76. ACM, New York, NY,
pp. 109&ndash;117. <a href="http://doi.acm.org/10.1145/800200.806187">http://doi.acm.org/10.1145/800200.806187</a>

   <p><a name="index-Reiser_002c-M_002e-112"></a><a name="index-Kobayashi_002c-H_002e-113"></a>
This implementation is based on G. Bolch, S. Greiner, H. de Meer and
K. Trivedi, <cite>Queueing Networks and Markov Chains: Modeling and
Performance Evaluation with Computer Science Applications</cite>, Wiley,
1998, pp. 313&ndash;317. Function <code>qnconvolutionld</code> is slightly
different from the version described in Bolch et al. because it
supports general load-dependent centers (while the version in the book
does not). The modification is in the definition of function
<code>F()</code> in <code>qnconvolutionld</code> which has been made similar to
function f_i defined in Schwetman, <code>Some Computational
Aspects of Queueing Network Models</code>.

   <p><a name="index-Bolch_002c-G_002e-114"></a><a name="index-Greiner_002c-S_002e-115"></a><a name="index-de-Meer_002c-H_002e-116"></a><a name="index-Trivedi_002c-K_002e-117"></a>

<h4 class="subsection">6.3.3 Open networks</h4>

<!-- Open networks with single class -->
<p><a name="doc_002dqnopensingle"></a>

<div class="defun">
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qnopensingle</b> (<var>lambda, S, V</var>)<var><a name="index-qnopensingle-118"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qnopensingle</b> (<var>lambda, S, V, m</var>)<var><a name="index-qnopensingle-119"></a></var><br>
<blockquote>
        <p><a name="index-open-network_002c-single-class-120"></a><a name="index-BCMP-network-121"></a>
Analyze open, single class BCMP queueing networks.

        <p>This function works for a subset of BCMP single-class open networks
satisfying the following properties:

          <ul>
<li>The allowed service disciplines at network nodes are: FCFS,
PS, LCFS-PR, IS (infinite server);

          <li>Service times are exponentially distributed and
load-independent;

          <li>Service center i can consist of <var>m</var><code>(i) &ge; 1</code>
identical servers.

          <li>Routing is load-independent

        </ul>

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>lambda</var><dd>Overall external arrival rate (<var>lambda</var><code>&gt;0</code>).

          <br><dt><var>S</var><dd><var>S</var><code>(k)</code> is the average service time at center
i (<var>S</var><code>(k)&gt;0</code>).

          <br><dt><var>V</var><dd><var>V</var><code>(k)</code> is the average number of visits to center
k (<var>V</var><code>(k) &ge; 0</code>).

          <br><dt><var>m</var><dd><var>m</var><code>(k)</code> is the number of servers at center i. If
<var>m</var><code>(k) &lt; 1</code>, then service center k is a delay center
(IS); otherwise it is a regular queueing center with
<var>m</var><code>(k)</code> servers. Default is <var>m</var><code>(k) = 1</code> for each
k.

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>U</var><dd>If k is a queueing center,
<var>U</var><code>(k)</code> is the utilization of center k. 
If k is an IS node, then <var>U</var><code>(k)</code> is the
<em>traffic intensity</em> defined as <var>X</var><code>(k)*</code><var>S</var><code>(k)</code>.

          <br><dt><var>R</var><dd><var>R</var><code>(k)</code> is the average response time of center k.

          <br><dt><var>Q</var><dd><var>Q</var><code>(k)</code> is the average number of requests at center
k.

          <br><dt><var>X</var><dd><var>X</var><code>(k)</code> is the throughput of center k.

        </dl>

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qnopen,qnclosed,qnvisits.

        </blockquote></div>

   <p>From the results computed by this function, it is possible to derive
other quantities of interest as follows:

     <ul>
<li><strong>System Response Time</strong>: The overall system response time
can be computed as
<code>R_s = dot(V,R);</code>

     <li><strong>Average number of requests</strong>: The average number of requests
in the system can be computed as:
<code>Q_s = sum(Q)</code>

   </ul>

<p class="noindent"><strong>EXAMPLE</strong>

<pre class="example"><pre class="verbatim">      lambda = 3;
      V = [16 7 8];
      S = [0.01 0.02 0.03];
      [U R Q X] = qnopensingle( lambda, S, V );
      R_s = dot(R,V) # System response time
      N = sum(Q) # Average number in system</pre>-| R_s =  1.4062
     -| N =  4.2186
</pre>
   <p class="noindent"><strong>REFERENCES</strong>

   <p>G. Bolch, S. Greiner, H. de Meer and K. Trivedi, <cite>Queueing
Networks and Markov Chains: Modeling and Performance Evaluation with
Computer Science Applications</cite>, Wiley, 1998.

   <p><a name="index-Bolch_002c-G_002e-122"></a><a name="index-Greiner_002c-S_002e-123"></a><a name="index-de-Meer_002c-H_002e-124"></a><a name="index-Trivedi_002c-K_002e-125"></a>

<!-- Open network with multiple classes -->
   <p><a name="doc_002dqnopenmulti"></a>

<div class="defun">
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qnopenmulti</b> (<var>lambda, S, V</var>)<var><a name="index-qnopenmulti-126"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qnopenmulti</b> (<var>lambda, S, V, m</var>)<var><a name="index-qnopenmulti-127"></a></var><br>
<blockquote>
        <p><a name="index-open-network_002c-multiple-classes-128"></a>
Exact analysis of open, multiple-class BCMP networks. The network can
be made of <em>single-server</em> queueing centers (FCFS, LCFS-PR or
PS) or delay centers (IS). This function assumes a network with
K service centers and C customer classes.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>lambda</var><dd><var>lambda</var><code>(c)</code> is the external
arrival rate of class c customers (<var>lambda</var><code>(c)&gt;0</code>).

          <br><dt><var>S</var><dd><var>S</var><code>(c,k)</code> is the mean service time of class c
customers on the service center k (<var>S</var><code>(c,k)&gt;0</code>). 
For FCFS nodes, average service times must be class-independent.

          <br><dt><var>V</var><dd><var>V</var><code>(c,k)</code> is the average number of visits of class c
customers to service center k (<var>V</var><code>(c,k) &ge; 0 </code>).

          <br><dt><var>m</var><dd><var>m</var><code>(k)</code> is the number of servers at service center
k. Valid values are <var>m</var><code>(k) &lt; 1</code> to denote a delay
center (-/G/\infty), and <var>m</var><code>(k)==1</code> to denote
a single server queueing center (M/M/1&ndash;FCFS,
-/G/1&ndash;LCFS-PR or -/G/1&ndash;PS).

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>U</var><dd>If k is a queueing center, then <var>U</var><code>(c,k)</code> is the
class c utilization of center k. If k is
an IS node, then <var>U</var><code>(c,k)</code> is the
class c <em>traffic intensity</em>
defined as <var>X</var><code>(c,k)*</code><var>S</var><code>(c,k)</code>.

          <br><dt><var>R</var><dd><var>R</var><code>(c,k)</code> is the class c response time at
center k. The system response time for
class c requests can be computed
as <code>dot(</code><var>R</var><code>, </code><var>V</var><code>, 2)</code>.

          <br><dt><var>Q</var><dd><var>Q</var><code>(c,k)</code> is the average number of class c requests
at center k. The average number of class c requests
in the system <var>Qc</var> can be computed as <code>Qc = sum(</code><var>Q</var><code>, 2)</code>

          <br><dt><var>X</var><dd><var>X</var><code>(c,k)</code> is the class c throughput
at center k.

        </dl>

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qnopen,qnopensingle,qnvisits.

        </blockquote></div>

<p class="noindent"><strong>REFERENCES</strong>

   <p>Edward D. Lazowska, John Zahorjan, G. Scott Graham, and Kenneth C. 
Sevcik, <cite>Quantitative System Performance: Computer System
Analysis Using Queueing Network Models</cite>, Prentice Hall,
1984. <a href="http://www.cs.washington.edu/homes/lazowska/qsp/">http://www.cs.washington.edu/homes/lazowska/qsp/</a>. In
particular, see section 7.4.1 ("Open Model Solution Techniques").

   <p><a name="index-Lazowska_002c-E_002e-D_002e-129"></a><a name="index-Zahorjan_002c-J_002e-130"></a><a name="index-Graham_002c-G_002e-S_002e-131"></a><a name="index-Sevcik_002c-K_002e-C_002e-132"></a>

<h4 class="subsection">6.3.4 Closed Networks</h4>

<!-- MVA for single class, closed networks -->
<p><a name="doc_002dqnclosedsinglemva"></a>

<div class="defun">
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>, <var>G</var>] = <b>qnclosedsinglemva</b> (<var>N, S, V</var>)<var><a name="index-qnclosedsinglemva-133"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>, <var>G</var>] = <b>qnclosedsinglemva</b> (<var>N, S, V, m</var>)<var><a name="index-qnclosedsinglemva-134"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>, <var>G</var>] = <b>qnclosedsinglemva</b> (<var>N, S, V, m, Z</var>)<var><a name="index-qnclosedsinglemva-135"></a></var><br>
<blockquote>
        <p><a name="index-Mean-Value-Analysys-_0028MVA_0029-136"></a><a name="index-closed-network_002c-single-class-137"></a><a name="index-normalization-constant-138"></a>
Analyze closed, single class queueing networks using the exact Mean
Value Analysis (MVA) algorithm. The following queueing disciplines
are supported: FCFS, LCFS-PR, PS and IS (Infinite Server). This
function supports fixed-rate service centers or multiple server
nodes. For general load-dependent service centers, use the function
<code>qnclosedsinglemvald</code> instead.

        <p>Additionally, the normalization constant G(n), n=0,
<small class="dots">...</small>, N is computed; G(n) can be used in conjunction with
the BCMP theorem to compute steady-state probabilities.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>N</var><dd>Population size (number of requests in the system, <var>N</var><code> &ge; 0</code>). 
If <var>N</var><code> == 0</code>, this function returns
<var>U</var><code> = </code><var>R</var><code> = </code><var>Q</var><code> = </code><var>X</var><code> = 0</code>

          <br><dt><var>S</var><dd><var>S</var><code>(k)</code> is the mean service time on server k
(<var>S</var><code>(k)&gt;0</code>).

          <br><dt><var>V</var><dd><var>V</var><code>(k)</code> is the average number of visits to service center
k (<var>V</var><code>(k) &ge; 0</code>).

          <br><dt><var>Z</var><dd>External delay for customers (<var>Z</var><code> &ge; 0</code>). Default is 0.

          <br><dt><var>m</var><dd><var>m</var><code>(k)</code> is the number of servers at center k
(if <var>m</var> is a scalar, all centers have that number of servers). If
<var>m</var><code>(k) &lt; 1</code>, center k is a delay center (IS);
otherwise it is a regular queueing center (FCFS, LCFS-PR or PS) with
<var>m</var><code>(k)</code> servers. Default is <var>m</var><code>(k) = 1</code> for all
k (each service center has a single server).

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>U</var><dd>If k is a FCFS, LCFS-PR or PS node (<var>m</var><code>(k) == 1</code>),
then <var>U</var><code>(k)</code> is the utilization of center k. If
k is an IS node (<var>m</var><code>(k) &lt; 1</code>), then
<var>U</var><code>(k)</code> is the <em>traffic intensity</em> defined as
<var>X</var><code>(k)*</code><var>S</var><code>(k)</code>.

          <br><dt><var>R</var><dd><var>R</var><code>(k)</code> is the response time at center k. 
The system response time <var>Rsys</var>
can be computed as <var>Rsys</var><code> = </code><var>N</var><code>/</code><var>Xsys</var><code> - Z</code>

          <br><dt><var>Q</var><dd><var>Q</var><code>(k)</code> is the average number of requests at center
k. The number of requests in the system can be computed
either as <code>sum(</code><var>Q</var><code>)</code>, or using the formula
<var>N</var><code>-</code><var>Xsys</var><code>*</code><var>Z</var>.

          <br><dt><var>X</var><dd><var>X</var><code>(k)</code> is the throughput of center k. The
system throughput <var>Xsys</var> can be computed as
<var>Xsys</var><code> = </code><var>X</var><code>(1) / </code><var>V</var><code>(1)</code>

          <br><dt><var>G</var><dd>Normalization constants. <var>G</var><code>(n+1)</code> corresponds to the value
of the normalization constant G(n), n=0, <small class="dots">...</small>, N as
array indexes in Octave start from 1. G(n) can be used in
conjunction with the BCMP theorem to compute steady-state
probabilities.

        </dl>

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qnclosedsinglemvald.

        </blockquote></div>

   <p>From the results provided by this function, it is possible to derive
other quantities of interest as follows:

<p class="noindent"><strong>EXAMPLE</strong>

<pre class="example"><pre class="verbatim">      S = [ 0.125 0.3 0.2 ];
      V = [ 16 10 5 ];
      N = 20;
      m = ones(1,3);
      Z = 4;
      [U R Q X] = qnclosedsinglemva(N,S,V,m,Z);
      X_s = X(1)/V(1); # System throughput
      R_s = dot(R,V); # System response time
      printf("\t    Util      Qlen     RespT      Tput\n");
      printf("\t--------  --------  --------  --------\n");
      for k=1:length(S)
        printf("Dev%d\t%8.4f  %8.4f  %8.4f  %8.4f\n", k, U(k), Q(k), R(k), X(k) );
      endfor
      printf("\nSystem\t          %8.4f  %8.4f  %8.4f\n\n", N-X_s*Z, R_s, X_s );</pre></pre>
   <p class="noindent"><strong>REFERENCES</strong>

   <p>M. Reiser and S. S. Lavenberg, <cite>Mean-Value Analysis of Closed
Multichain Queuing Networks</cite>, Journal of the ACM, vol. 27, n. 2, April
1980, pp. 313&ndash;322. <a href="http://doi.acm.org/10.1145/322186.322195">http://doi.acm.org/10.1145/322186.322195</a>

   <p><a name="index-Reiser_002c-M_002e-139"></a><a name="index-Lavenberg_002c-S_002e-S_002e-140"></a>
This implementation is described in R. Jain , <cite>The Art of Computer
Systems Performance Analysis</cite>, Wiley, 1991, p. 577.  Multi-server nodes
<!-- and the computation of @math{G(N)}, -->
are treated according to G. Bolch, S. Greiner, H. de Meer and
K. Trivedi, <cite>Queueing Networks and Markov Chains: Modeling and
Performance Evaluation with Computer Science Applications</cite>, Wiley,
1998, Section 8.2.1, "Single Class Queueing Networks".

   <p><a name="index-Jain_002c-R_002e-141"></a><a name="index-Bolch_002c-G_002e-142"></a><a name="index-Greiner_002c-S_002e-143"></a><a name="index-de-Meer_002c-H_002e-144"></a><a name="index-Trivedi_002c-K_002e-145"></a>
<!-- MVA for single class, closed networks with load dependent servers -->
<a name="doc_002dqnclosedsinglemvald"></a>

<div class="defun">
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qnclosedsinglemvald</b> (<var>N, S, V</var>)<var><a name="index-qnclosedsinglemvald-146"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qnclosedsinglemvald</b> (<var>N, S, V, Z</var>)<var><a name="index-qnclosedsinglemvald-147"></a></var><br>
<blockquote>
        <p><a name="index-Mean-Value-Analysys-_0028MVA_0029-148"></a><a name="index-closed-network_002c-single-class-149"></a><a name="index-load_002ddependent-service-center-150"></a>
Exact MVA algorithm for closed, single class queueing networks
with load-dependent service centers. This function supports
FCFS, LCFS-PR, PS and IS nodes. For networks with only fixed-rate
service centers and multiple-server nodes, the function
<code>qnclosedsinglemva</code> is more efficient.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>N</var><dd>Population size (number of requests in the system, <var>N</var><code> &ge; 0</code>). 
If <var>N</var><code> == 0</code>, this function returns <var>U</var><code> = </code><var>R</var><code> = </code><var>Q</var><code> = </code><var>X</var><code> = 0</code>

          <br><dt><var>S</var><dd><var>S</var><code>(k,n)</code> is the mean service time at center k
where there are n requests, 1 &le; n
&le; N. <var>S</var><code>(k,n)</code> = 1 / \mu_k,n,
where \mu_k,n is the service rate of center k
when there are n requests.

          <br><dt><var>V</var><dd><var>V</var><code>(k)</code> is the average number
of visits to service center k (<var>V</var><code>(k) &ge; 0</code>).

          <br><dt><var>Z</var><dd>external delay ("think time", <var>Z</var><code> &ge; 0</code>); default 0.

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>U</var><dd><var>U</var><code>(k)</code> is the utilization of service center k. The
utilization is defined as the probability that service center
k is not empty, that is, U_k = 1-\pi_k(0) where
\pi_k(0) is the steady-state probability that there are 0
jobs at service center k.

          <br><dt><var>R</var><dd><var>R</var><code>(k)</code> is the response time on service center k.

          <br><dt><var>Q</var><dd><var>Q</var><code>(k)</code> is the average number of requests in service center
k.

          <br><dt><var>X</var><dd><var>X</var><code>(k)</code> is the throughput of service center k.

        </dl>

        </blockquote></div>

<p class="noindent"><strong>REFERENCES</strong>

   <p>M. Reiser and S. S. Lavenberg, <cite>Mean-Value Analysis of Closed
Multichain Queuing Networks</cite>, Journal of the ACM, vol. 27, n. 2,
April 1980, pp. 313&ndash;322. <a href="http://doi.acm.org/10.1145/322186.322195">http://doi.acm.org/10.1145/322186.322195</a>

   <p>This implementation is described in G. Bolch, S. Greiner, H. de Meer
and K. Trivedi, <cite>Queueing Networks and Markov Chains: Modeling
and Performance Evaluation with Computer Science Applications</cite>, Wiley,
1998, Section 8.2.4.1, &ldquo;Networks with Load-Deèpendent Service: Closed
Networks&rdquo;.

   <p><a name="index-Bolch_002c-G_002e-151"></a><a name="index-Greiner_002c-S_002e-152"></a><a name="index-de-Meer_002c-H_002e-153"></a><a name="index-Trivedi_002c-K_002e-154"></a>
<!-- CMVA for single class, closed networks with a single load dependent servers -->
<a name="doc_002dqncmva"></a>

<div class="defun">
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qncmva</b> (<var>N, S, Sld, V</var>)<var><a name="index-qncmva-155"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qncmva</b> (<var>N, S, Sld, V, Z</var>)<var><a name="index-qncmva-156"></a></var><br>
<blockquote>
        <p><a name="index-Mean-Value-Analysys-_0028MVA_0029-157"></a><a name="index-CMVA-158"></a>
Implementation of the Conditional MVA (CMVA) algorithm, a numerically
stable variant of MVA for load-dependent servers. CMVA is described
in G. Casale, <cite>A Note on Stable Flow-Equivalent Aggregation in
Closed Networks</cite>. The network is made of M service centers and
a delay center. Servers 1, \ldots, M-1 are load-independent;
server M is load-dependent.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>N</var><dd>Population size (number of requests in the system, <var>N</var><code> &ge; 0</code>). 
If <var>N</var><code> == 0</code>, this function returns
<var>U</var><code> = </code><var>R</var><code> = </code><var>Q</var><code> = </code><var>X</var><code> = 0</code>

          <br><dt><var>S</var><dd><var>S</var><code>(k)</code> is the mean service time on server k = 1, <small class="dots">...</small>, M-1
(<var>S</var><code>(k) &gt; 0</code>).

          <br><dt><var>Sld</var><dd><var>Sld</var><code>(n)</code> is the mean service time on server M
when there are n requests, n=1, <small class="dots">...</small>, N. 
<var>Sld</var><code>(n) = </code> 1 / \mu(n), where \mu(n) is the
service rate at center N when there are n requests.

          <br><dt><var>V</var><dd><var>V</var><code>(k)</code> is the average number of visits to service center
k= 1, <small class="dots">...</small>, M (<var>V</var><code>(k) &ge; 0</code>).

          <br><dt><var>Z</var><dd>External delay for customers (<var>Z</var><code> &ge; 0</code>). Default is 0.

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>U</var><dd><var>U</var><code>(k)</code> is the utilization of center k=1, <small class="dots">...</small>, M

          <br><dt><var>R</var><dd><var>R</var><code>(k)</code> is the response time at center k=1, <small class="dots">...</small>, M. 
The system response time <var>Rsys</var>
can be computed as <var>Rsys</var><code> = </code><var>N</var><code>/</code><var>Xsys</var><code> - Z</code>

          <br><dt><var>Q</var><dd><var>Q</var><code>(k)</code> is the average number of requests at center
k=1, <small class="dots">...</small>, M.

          <br><dt><var>X</var><dd><var>X</var><code>(k)</code> is the throughput of center k=1, <small class="dots">...</small>, M.

        </dl>

        </blockquote></div>

<p class="noindent"><strong>REFERENCES</strong>

   <p>G. Casale. <cite>A note on stable flow-equivalent aggregation in
closed networks</cite>. Queueing Syst. Theory Appl., 60:193–202, December
2008.

   <p><a name="index-Casale_002c-G_002e-159"></a>
<!-- Approximate MVA for single class, closed networks -->

   <p><a name="doc_002dqnclosedsinglemvaapprox"></a>

<div class="defun">
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qnclosedsinglemvaapprox</b> (<var>N, S, V</var>)<var><a name="index-qnclosedsinglemvaapprox-160"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qnclosedsinglemvaapprox</b> (<var>N, S, V, m</var>)<var><a name="index-qnclosedsinglemvaapprox-161"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qnclosedsinglemvaapprox</b> (<var>N, S, V, m, Z</var>)<var><a name="index-qnclosedsinglemvaapprox-162"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qnclosedsinglemvaapprox</b> (<var>N, S, V, m, Z, tol</var>)<var><a name="index-qnclosedsinglemvaapprox-163"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qnclosedsinglemvaapprox</b> (<var>N, S, V, m, Z, tol, iter_max</var>)<var><a name="index-qnclosedsinglemvaapprox-164"></a></var><br>
<blockquote>
        <p><a name="index-Mean-Value-Analysys-_0028MVA_0029_002c-approximate-165"></a><a name="index-Approximate-MVA-166"></a><a name="index-Closed-network_002c-single-class-167"></a><a name="index-Closed-network_002c-approximate-analysis-168"></a>
Analyze closed, single class queueing networks using the Approximate
Mean Value Analysis (MVA) algorithm. This function is based on
approximating the number of customers seen at center k when a
new request arrives as Q_k(N) \times (N-1)/N. This function
only handles single-server and delay centers; if your network
contains general load-dependent service centers, use the function
<code>qnclosedsinglemvald</code> instead.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>N</var><dd>Population size (number of requests in the system, <var>N</var><code> &gt; 0</code>).

          <br><dt><var>S</var><dd><var>S</var><code>(k)</code> is the mean service time on server k
(<var>S</var><code>(k)&gt;0</code>).

          <br><dt><var>V</var><dd><var>V</var><code>(k)</code> is the average number of visits to service center
k (<var>V</var><code>(k) &ge; 0</code>).

          <br><dt><var>m</var><dd><var>m</var><code>(k)</code> is the number of servers at center k
(if <var>m</var> is a scalar, all centers have that number of servers). If
<var>m</var><code>(k) &lt; 1</code>, center k is a delay center (IS); if
<var>m</var><code>(k) == 1</code>, center k is a regular queueing
center (FCFS, LCFS-PR or PS) with one server (default). This function
does not support multiple server nodes (<var>m</var><code>(k) &gt; 1</code>).

          <br><dt><var>Z</var><dd>External delay for customers (<var>Z</var><code> &ge; 0</code>). Default is 0.

          <br><dt><var>tol</var><dd>Stopping tolerance. The algorithm stops when the maximum relative difference
between the new and old value of the queue lengths <var>Q</var> becomes
less than the tolerance. Default is 10^-5.

          <br><dt><var>iter_max</var><dd>Maximum number of iterations (<var>iter_max</var><code>&gt;0</code>. 
The function aborts if convergenge is not reached within the maximum
number of iterations. Default is 100.

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>U</var><dd>If k is a FCFS, LCFS-PR or PS node (<var>m</var><code>(k) == 1</code>),
then <var>U</var><code>(k)</code> is the utilization of center k. If
k is an IS node (<var>m</var><code>(k) &lt; 1</code>), then
<var>U</var><code>(k)</code> is the <em>traffic intensity</em> defined as
<var>X</var><code>(k)*</code><var>S</var><code>(k)</code>.

          <br><dt><var>R</var><dd><var>R</var><code>(k)</code> is the response time at center k. 
The system response time <var>Rsys</var>
can be computed as <var>Rsys</var><code> = </code><var>N</var><code>/</code><var>Xsys</var><code> - Z</code>

          <br><dt><var>Q</var><dd><var>Q</var><code>(k)</code> is the average number of requests at center
k. The number of requests in the system can be computed
either as <code>sum(</code><var>Q</var><code>)</code>, or using the formula
<var>N</var><code>-</code><var>Xsys</var><code>*</code><var>Z</var>.

          <br><dt><var>X</var><dd><var>X</var><code>(k)</code> is the throughput of center k. The
system throughput <var>Xsys</var> can be computed as
<var>Xsys</var><code> = </code><var>X</var><code>(1) / </code><var>V</var><code>(1)</code>

        </dl>

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qnclosedsinglemva,qnclosedsinglemvald.

        </blockquote></div>

<p class="noindent"><strong>REFERENCES</strong>

   <p>This implementation is based on Edward D. Lazowska, John Zahorjan,
G. Scott Graham, and Kenneth C. Sevcik, <cite>Quantitative System
Performance: Computer System Analysis Using Queueing Network Models</cite>,
Prentice Hall,
1984. <a href="http://www.cs.washington.edu/homes/lazowska/qsp/">http://www.cs.washington.edu/homes/lazowska/qsp/</a>. In
particular, see section 6.4.2.2 ("Approximate Solution Techniques").

   <p><a name="index-Lazowska_002c-E_002e-D_002e-169"></a><a name="index-Zahorjan_002c-J_002e-170"></a><a name="index-Graham_002c-G_002e-S_002e-171"></a><a name="index-Sevcik_002c-K_002e-C_002e-172"></a>

<!-- MVA for multiple class, closed networks -->
   <p><a name="doc_002dqnclosedmultimva"></a>

<div class="defun">
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qnclosedmultimva</b> (<var>N, S </var>)<var><a name="index-qnclosedmultimva-173"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qnclosedmultimva</b> (<var>N, S, V</var>)<var><a name="index-qnclosedmultimva-174"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qnclosedmultimva</b> (<var>N, S, V, m</var>)<var><a name="index-qnclosedmultimva-175"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qnclosedmultimva</b> (<var>N, S, V, m, Z</var>)<var><a name="index-qnclosedmultimva-176"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qnclosedmultimva</b> (<var>N, S, P</var>)<var><a name="index-qnclosedmultimva-177"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qnclosedmultimva</b> (<var>N, S, P, m</var>)<var><a name="index-qnclosedmultimva-178"></a></var><br>
<blockquote>
        <p><a name="index-Mean-Value-Analysys-_0028MVA_0029-179"></a><a name="index-closed-network_002c-multiple-classes-180"></a>
Analyze closed, multiclass queueing networks with K service
centers and C independent customer classes (chains) using the
Mean Value Analysys (MVA) algorithm.

        <p>Queueing policies at service centers can be any of the following:

          <dl>
<dt><strong>FCFS</strong><dd>(First-Come-First-Served) customers are served in order of arrival;
multiple servers are allowed. For this kind of queueing discipline,
average service times must be class-independent.

          <br><dt><strong>PS</strong><dd>(Processor Sharing) customers are served in parallel by a single
server, each customer receiving an equal share of the service rate.

          <br><dt><strong>LCFS-PR</strong><dd>(Last-Come-First-Served, Preemptive Resume) customers are served in
reverse order of arrival by a single server and the last arrival
preempts the customer in service who will later resume service at the
point of interruption.

          <br><dt><strong>IS</strong><dd>(Infinite Server) customers are delayed independently of other
customers at the service center (there is effectively an infinite
number of servers).

        </dl>

        <blockquote>
<b>Note:</b> If this function is called specifying the visit ratios
<var>V</var>, class switching is <strong>not</strong> allowed.

        <p>If this function is called specifying the routing probability matrix
<var>P</var>, then class switching <strong>is</strong> allowed; however, in this
case all nodes are restricted to be fixed rate service centers or
delay centers: multiple-server and general load-dependent
centers are not supported.</blockquote>

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>N</var><dd><var>N</var><code>(c)</code> is the number of class c requests in the
system; <var>N</var><code>(c) &ge; 0</code>. If class c has
no requests (<var>N</var><code>(c) = 0</code>), then
<var>U</var><code>(c,k) = </code><var>R</var><code>(c,k) = </code><var>Q</var><code>(c,k) = </code><var>X</var><code>(c,k) = 0</code>
for all <var>k</var>.

          <br><dt><var>S</var><dd><var>S</var><code>(c,k)</code> is the mean service time for class c
customers at center k (<var>S</var><code>(c,k) &ge; 0</code>). 
If service time at center k is class-dependent,
then center #mathk is assumed to be of type -/G/1&ndash;PS
(Processor Sharing). 
If center k is a FCFS node (<var>m</var><code>(k)&gt;1</code>), then the
service times <strong>must</strong> be class-independent.

          <br><dt><var>V</var><dd><var>V</var><code>(c,k)</code> is the average number of visits of class c
customers to service center k; <var>V</var><code>(c,k) &ge; 0</code>,
default is 1. 
<strong>If you pass this parameter, no class switching is not
allowed</strong>

          <br><dt><var>P</var><dd><var>P</var><code>(r,i,s,j)</code> is the probability that a class r
job completing service at center i is routed to center j
as a class s job. <strong>If you pass this parameter,
class switching is allowed</strong>.

          <br><dt><var>m</var><dd>If <var>m</var><code>(k)&lt;1</code>, then center k is assumed to be a delay
center (IS node -/G/\infty). If <var>m</var><code>(k)==1</code>, then
service center k is a regular queueing center
(M/M/1&ndash;FCFS, -/G/1&ndash;LCFS-PR or -/G/1&ndash;PS). 
Finally, if <var>m</var><code>(k)&gt;1</code>, center k is a
M/M/m&ndash;FCFS center with <var>m</var><code>(k)</code> identical servers. 
Default is <var>m</var><code>(k)=1</code> for each k.

          <br><dt><var>Z</var><dd><var>Z</var><code>(c)</code> is the class c external delay (think time);
<var>Z</var><code>(c) &ge; 0</code>. Default is 0.

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>U</var><dd>If k is a FCFS, LCFS-PR or PS node, then <var>U</var><code>(c,k)</code>
is the class c utilization at center
k. If k is an IS node, then <var>U</var><code>(c,k)</code> is the
class c <em>traffic intensity</em> at center k,
defined as <var>U</var><code>(c,k) = </code><var>X</var><code>(c,k)*</code><var>S</var><code>(c,k)</code>.

          <br><dt><var>R</var><dd><var>R</var><code>(c,k)</code> is the class c response time at
center k. The total class c system response time
can be computed as <code>dot(</code><var>R</var><code>, </code><var>V</var><code>, 2)</code>.

          <br><dt><var>Q</var><dd><var>Q</var><code>(c,k)</code> is the average number of
class c requests at center k. The total number of
requests at center k is <code>sum(</code><var>Q</var><code>(:,k))</code>. 
The total number of class c requests in the system
is <code>sum(</code><var>Q</var><code>(c,:))</code>.

          <br><dt><var>X</var><dd><var>X</var><code>(c,k)</code> is the class c throughput at
center k. The class c system throughput can be computed
as <var>X</var><code>(c,1) / </code><var>V</var><code>(c,1)</code>.

        </dl>

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qnclosed, qnclosedmultimvaapprox.

        </blockquote></div>

<p class="noindent"><strong>NOTE</strong>

   <p>Given a network with K service centers, C job classes and
population vector \bf N=(N_1, N_2, \ldots N_C), the MVA
algorithm requires space O(C \prod_i (N_i + 1)). The time
complexity is O(CK\prod_i (N_i + 1)). This implementation is
slightly more space-efficient (see details in the code). While the space
requirement can be mitigated by using some optimizations, the time
complexity can not. If you need to analyze large closed networks you
should consider the <samp><span class="command">qnclosedmultimvaapprox</span></samp> function, which
implements the approximate MVA algorithm. Note however that
<samp><span class="command">qnclosedmultimvaapprox</span></samp> will only provide approximate results.

<p class="noindent"><strong>REFERENCES</strong>

   <p>M. Reiser and S. S. Lavenberg, <cite>Mean-Value Analysis of Closed
Multichain Queuing Networks</cite>, Journal of the ACM, vol. 27, n. 2, April
1980, pp. 313&ndash;322. <a href="http://doi.acm.org/10.1145/322186.322195">http://doi.acm.org/10.1145/322186.322195</a>

   <p><a name="index-Reiser_002c-M_002e-181"></a><a name="index-Lavenberg_002c-S_002e-S_002e-182"></a>
This implementation is based on G. Bolch, S. Greiner, H. de Meer and
K. Trivedi, <cite>Queueing Networks and Markov Chains: Modeling and
Performance Evaluation with Computer Science Applications</cite>, Wiley,
1998 and Edward D. Lazowska, John Zahorjan, G. Scott Graham, and
Kenneth C. Sevcik, <cite>Quantitative System Performance: Computer
System Analysis Using Queueing Network Models</cite>, Prentice Hall,
1984. <a href="http://www.cs.washington.edu/homes/lazowska/qsp/">http://www.cs.washington.edu/homes/lazowska/qsp/</a>. In
particular, see section 7.4.2.1 ("Exact Solution Techniques").

   <p><a name="index-Bolch_002c-G_002e-183"></a><a name="index-Greiner_002c-S_002e-184"></a><a name="index-de-Meer_002c-H_002e-185"></a><a name="index-Trivedi_002c-K_002e-186"></a><a name="index-Lazowska_002c-E_002e-D_002e-187"></a><a name="index-Zahorjan_002c-J_002e-188"></a><a name="index-Graham_002c-G_002e-S_002e-189"></a><a name="index-Sevcik_002c-K_002e-C_002e-190"></a>
<!-- Approximate MVA, with Bard-Schweitzer approximation -->
<a name="doc_002dqnclosedmultimvaapprox"></a>

<div class="defun">
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qnclosedmultimvaapprox</b> (<var>N, S, V</var>)<var><a name="index-qnclosedmultimvaapprox-191"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qnclosedmultimvaapprox</b> (<var>N, S, V, m</var>)<var><a name="index-qnclosedmultimvaapprox-192"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qnclosedmultimvaapprox</b> (<var>N, S, V, m, Z</var>)<var><a name="index-qnclosedmultimvaapprox-193"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qnclosedmultimvaapprox</b> (<var>N, S, V, m, Z, tol</var>)<var><a name="index-qnclosedmultimvaapprox-194"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qnclosedmultimvaapprox</b> (<var>N, S, V, m, Z, tol, iter_max</var>)<var><a name="index-qnclosedmultimvaapprox-195"></a></var><br>
<blockquote>
        <p><a name="index-Mean-Value-Analysys-_0028MVA_0029_002c-approximate-196"></a><a name="index-Approximate-MVA-197"></a><a name="index-Closed-network_002c-multiple-classes-198"></a><a name="index-Closed-network_002c-approximate-analysis-199"></a>
Analyze closed, multiclass queueing networks with K service
centers and C customer classes using the approximate Mean
Value Analysys (MVA) algorithm.

        <p>This implementation uses Bard and Schweitzer approximation. It is based
on the assumption that
the queue length at service center k with population
set \bf N-\bf 1_c is approximately equal to the queue length
with population set \bf N, times (n-1)/n:

     <pre class="example">          Q_i(N-1c) ~ (n-1)/n Q_i(N)
</pre>
        <p>where \bf N is a valid population mix, \bf N-\bf 1_c
is the population mix \bf N with one class c customer
removed, and n = \sum_c N_c is the total number of requests.

        <p>This implementation works for networks made of infinite server (IS)
nodes and single-server nodes only.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>N</var><dd><var>N</var><code>(c)</code> is the number of
class c requests in the system (<var>N</var><code>(c)&gt;0</code>).

          <br><dt><var>S</var><dd><var>S</var><code>(c,k)</code> is the mean service time for class c
customers at center k (<var>S</var><code>(c,k) &ge; 0</code>).

          <br><dt><var>V</var><dd><var>V</var><code>(c,k)</code> is the average number of visits of class c
requests to center k (<var>V</var><code>(c,k) &ge; 0</code>).

          <br><dt><var>m</var><dd><var>m</var><code>(k)</code> is the number of servers at service center
k. If <var>m</var><code>(k) &lt; 1</code>, then the service center k
is assumed to be a delay center (IS). If <var>m</var><code>(k) == 1</code>,
service center k is a regular queueing center (FCFS, LCFS-PR
or PS) with a single server node. If omitted, each service center has
a single server. Note that multiple server nodes are not supported.

          <br><dt><var>Z</var><dd><var>Z</var><code>(c)</code> is the class c external delay. Default
is 0.

          <br><dt><var>tol</var><dd>Stopping tolerance (<var>tol</var><code>&gt;0</code>). The algorithm stops if
the queue length computed on two subsequent iterations are less than
<var>tol</var>. Default is 10^-5.

          <br><dt><var>iter_max</var><dd>Maximum number of iterations (<var>iter_max</var><code>&gt;0</code>. 
The function aborts if convergenge is not reached within the maximum
number of iterations. Default is 100.

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>U</var><dd>If k is a FCFS, LCFS-PR or PS node, then <var>U</var><code>(c,k)</code>
is the utilization of class c requests on service center
k. If k is an IS node, then <var>U</var><code>(c,k)</code> is the
class c <em>traffic intensity</em> at device k,
defined as <var>U</var><code>(c,k) = </code><var>X</var><code>(c)*</code><var>S</var><code>(c,k)</code>

          <br><dt><var>R</var><dd><var>R</var><code>(c,k)</code> is the response
time of class c requests at service center k.

          <br><dt><var>Q</var><dd><var>Q</var><code>(c,k)</code> is the average number of
class c requests at service center k.

          <br><dt><var>X</var><dd><var>X</var><code>(c,k)</code> is the class c
throughput at service center k.

        </dl>

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qnclosed.

        </blockquote></div>

<p class="noindent"><strong>REFERENCES</strong>

   <p>Y. Bard, <cite>Some Extensions to Multiclass Queueing Network Analysis</cite>,
proc. 4th Int. Symp. on Modelling and Performance Evaluation of
Computer Systems, feb. 1979, pp. 51&ndash;62.

   <p><a name="index-Bard_002c-Y_002e-200"></a>
P. Schweitzer, <cite>Approximate Analysis of Multiclass Closed
Networks of Queues</cite>, Proc. Int. Conf. on Stochastic Control and
Optimization, jun 1979, pp. 25&ndash;29.

   <p><a name="index-Schweitzer_002c-P_002e-201"></a>
This implementation is based on Edward D. Lazowska, John Zahorjan, G. 
Scott Graham, and Kenneth C. Sevcik, <cite>Quantitative System
Performance: Computer System Analysis Using Queueing Network Models</cite>,
Prentice Hall,
1984. <a href="http://www.cs.washington.edu/homes/lazowska/qsp/">http://www.cs.washington.edu/homes/lazowska/qsp/</a>.  In
particular, see section 7.4.2.2 ("Approximate Solution
Techniques"). This implementation is slightly different from the one
described above, as it computes the average response times R
instead of the residence times.

   <p><a name="index-Lazowska_002c-E_002e-D_002e-202"></a><a name="index-Zahorjan_002c-J_002e-203"></a><a name="index-Graham_002c-G_002e-S_002e-204"></a><a name="index-Sevcik_002c-K_002e-C_002e-205"></a>

<h4 class="subsection">6.3.5 Mixed Networks</h4>

<!-- MVA for mixed networks -->
<p><a name="doc_002dqnmix"></a>

<div class="defun">
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qnmix</b> (<var>lambda, N, S, V, m</var>)<var><a name="index-qnmix-206"></a></var><br>
<blockquote>
        <p><a name="index-Mean-Value-Analysys-_0028MVA_0029-207"></a><a name="index-mixed-network-208"></a>
Solution of mixed queueing networks through MVA. The network consists
of K service centers (single-server or delay centers) and
C independent customer chains. Both open and closed chains
are possible. <var>lambda</var> is the vector of per-chain
arrival rates (open classes); <var>N</var> is the vector of populations
for closed chains.

        <blockquote>
<b>Note:</b> In this implementation class switching is <strong>not</strong> allowed. Each
customer class <em>must</em> correspond to an independent chain. 
</blockquote>

        <p>If the network is made of open or closed classes only, then this
function calls <code>qnopenmulti</code> or <code>qnclosedmultimva</code>
respectively, and prints a warning message.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>lambda</var><dt><var>N</var><dd>For each customer chain c:

               <ul>
<li>if c is a closed chain, then <var>N</var><code>(c)&gt;0</code> is the
number of class c requests and <var>lambda</var><code>(c)</code> must be
zero;

               <li>If c is an open chain,
<var>lambda</var><code>(c)&gt;0</code> is the arrival rate of class c
requests and <var>N</var><code>(c)</code> must be zero;

          </ul>

          <p class="noindent">For each c, the following must hold:

          <pre class="example">               (<var>lambda</var>(c)&gt;0 &amp;&amp; <var>N</var>(c)==0) || (<var>lambda</var>(c)==0 &amp;&amp; <var>N</var>(c)&gt;0)
</pre>
          <p>which means that either <var>lambda</var><code>(c)</code> is nonzero and
<var>N</var><code>(n)</code> is zero, or the other way around. If for some
c, <var>lambda</var>(c) \neq 0 and <var>N</var>(c) \neq 0, an
error is reported and this function aborts.

          <br><dt><var>S</var><dd><var>S</var><code>(c,k)</code> is the mean service time for class c
customers on service center k, <var>S</var><code>(c,k) &ge; 0</code>. 
For FCFS nodes, service times must be class-independent.

          <br><dt><var>V</var><dd><var>V</var><code>(c,k)</code> is the average number of visits of class c
customers to service center k (<var>V</var><code>(c,k) &ge; 0</code>).

          <br><dt><var>m</var><dd><var>m</var><code>(k)</code> is the number of servers at service center
k. Only single-server (<var>m</var><code>(k)==1</code>) or IS (Infinite
Server) nodes (<var>m</var><code>(k)&lt;1</code>) are supported. If omitted, each
service center is assumed to have a single server. Queueing discipline
for single-server nodes can be FCFS, PS or LCFS-PR.

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>U</var><dd><var>U</var><code>(c,k)</code> is the
utilization of class c requests on service center k.

          <br><dt><var>R</var><dd><var>R</var><code>(c,k)</code> is the response
time of class c requests on service center k.

          <br><dt><var>Q</var><dd><var>Q</var><code>(c,k)</code> is the average number of
class c requests on service center k.

          <br><dt><var>X</var><dd><var>X</var><code>(c,k)</code> is the class c
throughput on service center k.

        </dl>

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qnclosedmultimva, qnopenmulti.

        </blockquote></div>

<p class="noindent"><strong>REFERENCES</strong>

   <p>Edward D. Lazowska, John Zahorjan, G. Scott Graham, and Kenneth C. 
Sevcik, <cite>Quantitative System Performance: Computer System
Analysis Using Queueing Network Models</cite>, Prentice Hall,
1984. <a href="http://www.cs.washington.edu/homes/lazowska/qsp/">http://www.cs.washington.edu/homes/lazowska/qsp/</a>. In
particular, see section 7.4.3 ("Mixed Model Solution Techniques"). 
Note that in this function we compute the mean response time R
instead of the mean residence time as in the reference.

   <p><a name="index-Lazowska_002c-E_002e-D_002e-209"></a><a name="index-Zahorjan_002c-J_002e-210"></a><a name="index-Graham_002c-G_002e-S_002e-211"></a><a name="index-Sevcik_002c-K_002e-C_002e-212"></a>
Herb Schwetman, <cite>Implementing the Mean Value Algorithm for the
Solution of Queueing Network Models</cite>, Technical Report CSD-TR-355,
Department of Computer Sciences, Purdue University, feb 15, 1982,
available at
<a href="http://www.cs.purdue.edu/research/technical_reports/1980/TR%2080-355.pdf">http://www.cs.purdue.edu/research/technical_reports/1980/TR%2080-355.pdf</a>

   <p><a name="index-Schwetman_002c-H_002e-213"></a>

<div class="node">
<a name="Algorithms-for-non-Product-form-QNs"></a>
<a name="Algorithms-for-non-Product_002dform-QNs"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Bounds-on-performance">Bounds on performance</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Algorithms-for-Product_002dForm-QNs">Algorithms for Product-Form QNs</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Queueing-Networks">Queueing Networks</a>

</div>

<h3 class="section">6.4 Algorithms for non Product-Form QNs</h3>

<!-- MVABLO algorithm for approximate analysis of closed, single class -->
<!-- QN with blocking -->
<p><a name="doc_002dqnmvablo"></a>

<div class="defun">
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qnmvablo</b> (<var>N, S, M, P</var>)<var><a name="index-qnmvablo-214"></a></var><br>
<blockquote>
        <p><a name="index-queueing-network-with-blocking-215"></a><a name="index-blocking-queueing-network-216"></a><a name="index-closed-network_002c-finite-capacity-217"></a>
MVA algorithm for closed queueing networks with blocking. <samp><span class="command">qnmvablo</span></samp>
computes approximate utilization, response time and mean queue length
for closed, single class queueing networks with blocking.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>N</var><dd>population size, i.e., number of requests in the system. <var>N</var> must
be strictly greater than zero, and less than the overall network capacity:
<code>0 &lt; </code><var>N</var><code> &lt; sum(</code><var>M</var><code>)</code>.

          <br><dt><var>S</var><dd>Average service time. <var>S</var><code>(i)</code> is the average service time
requested on server i (<var>S</var><code>(i) &gt; 0</code>).

          <br><dt><var>M</var><dd>Server capacity. <var>M</var><code>(i)</code> is the capacity of service center
i. The capacity is the maximum number of requests in a service
center, including the request currently in service (<var>M</var><code>(i) &ge; 1</code>).

          <br><dt><var>P</var><dd><var>P</var><code>(i,j)</code> is the probability that a request which completes
service at server i will be transferred to server j.

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>U</var><dd><var>U</var><code>(i)</code> is the utilization of
service center i.

          <br><dt><var>R</var><dd><var>R</var><code>(i)</code> is the average response time
of service center i.

          <br><dt><var>Q</var><dd><var>Q</var><code>(i)</code> is
the average number of requests in service center i (including
the request in service).

          <br><dt><var>X</var><dd><var>X</var><code>(i)</code> is the throughput of
service center i.

        </dl>

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qnopen, qnclosed.

        </blockquote></div>

<p class="noindent"><strong>REFERENCES</strong>

   <p>Ian F. Akyildiz, <cite>Mean Value Analysis for Blocking Queueing
Networks</cite>, IEEE Transactions on Software Engineering, vol. 14, n. 2,
april 1988, pp. 418&ndash;428.  <a href="http://dx.doi.org/10.1109/32.4663">http://dx.doi.org/10.1109/32.4663</a>

   <p><a name="index-Akyildiz_002c-I_002e-F_002e-218"></a>
<a name="doc_002dqnmarkov"></a>

<div class="defun">
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qnmarkov</b> (<var>lambda, S, C, P</var>)<var><a name="index-qnmarkov-219"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qnmarkov</b> (<var>lambda, S, C, P, m</var>)<var><a name="index-qnmarkov-220"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qnmarkov</b> (<var>N, S, C, P</var>)<var><a name="index-qnmarkov-221"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qnmarkov</b> (<var>N, S, C, P, m</var>)<var><a name="index-qnmarkov-222"></a></var><br>
<blockquote>
        <p><a name="index-closed-network_002c-multiple-classes-223"></a><a name="index-closed-network_002c-finite-capacity-224"></a><a name="index-blocking-queueing-network-225"></a><a name="index-RS-blocking-226"></a>
Compute utilization, response time, average queue length and
throughput for open or closed queueing networks with finite capacity. 
Blocking type is Repetitive-Service (RS). This function explicitly
generates and solve the underlying Markov chain, and thus might
require a large amount of memory.

        <p>More specifically, networks which can me analyzed by this
function have the following properties:

          <ul>
<li>There exists only a single class of customers.

          <li>The network has K service centers. Center
i has m_i &gt; 0 servers, and has a total (finite) capacity of
C_i \geq m_i which includes both buffer space and servers. 
The buffer space at service center i is therefore
C_i - m_i.

          <li>The network can be open, with external arrival rate to
center i equal to
\lambda_i, or closed with fixed
population size N. For closed networks, the population size
N must be strictly less than the network capacity: N &lt; \sum_i C_i.

          <li>Average service times are load-independent.

          <li>P_ij is the probability that requests completing
execution at center i are transferred to
center j, i \neq j. For open networks, a request may leave the system
from any node i with probability 1-\sum_j P_ij.

          <li>Blocking type is Repetitive-Service (RS). Service
center j is <em>saturated</em> if the number of requests is equal
to its capacity <code>C_j</code>. Under the RS blocking discipline,
a request completing service at center i which is being
transferred to a saturated server j is put back at the end of
the queue of i and will receive service again. Center i
then processes the next request in queue. External arrivals to a
saturated servers are dropped.

        </ul>

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>lambda</var><dt><var>N</var><dd>If the first argument is a vector <var>lambda</var>, it is considered to be
the external arrival rate <var>lambda</var><code>(i) &ge; 0</code> to service center
i of an open network. If the first argument is a scalar, it is
considered as the population size <var>N</var> of a closed network; in this case
<var>N</var> must be strictly
less than the network capacity: <var>N</var><code> &lt; sum(</code><var>C</var><code>)</code>.

          <br><dt><var>S</var><dd><var>S</var><code>(i)</code> is the average service time at service center
i

          <br><dt><var>C</var><dd><var>C</var><code>(i)</code> is the Capacity of service center i. The capacity includes both
the buffer and server space <var>m</var><code>(i)</code>. Thus the buffer space is
<var>C</var><code>(i)-</code><var>m</var><code>(i)</code>.

          <br><dt><var>P</var><dd><var>P</var><code>(i,j)</code> is the transition probability from service center
i to service center j.

          <br><dt><var>m</var><dd><var>m</var><code>(i)</code> is the number of servers at service center
i. Note that <var>m</var><code>(i) &ge; </code><var>C</var><code>(i)</code> for each <var>i</var>. 
If <var>m</var> is omitted, all service centers are assumed to have a
single server (<var>m</var><code>(i) = 1</code> for all i).

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>U</var><dd><var>U</var><code>(i)</code> is the utilization of service center i.

          <br><dt><var>R</var><dd><var>R</var><code>(i)</code> is the response time on service center i.

          <br><dt><var>Q</var><dd><var>Q</var><code>(i)</code> is the average number of customers in the
service center i, <em>including</em> the request in service.

          <br><dt><var>X</var><dd><var>X</var><code>(i)</code> is the throughput of service center i.

        </dl>

        <blockquote>
<b>Note:</b> 
The space complexity of this implementation is
O( \prod_i=1^K (C_i + 1)^2). The time complexity is dominated
by the time needed to solve a linear system with
\prod_i=1^K (C_i + 1)
unknowns.

        </blockquote>

        </blockquote></div>

<div class="node">
<a name="Bounds-on-performance"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Utility-functions">Utility functions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Algorithms-for-non-Product_002dform-QNs">Algorithms for non Product-form QNs</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Queueing-Networks">Queueing Networks</a>

</div>

<h3 class="section">6.5 Bounds on performance</h3>

<p><a name="doc_002dqnopenab"></a>

<div class="defun">
&mdash; Function File: [<var>Xu</var>, <var>Rl</var>] = <b>qnopenab</b> (<var>lambda, D</var>)<var><a name="index-qnopenab-227"></a></var><br>
<blockquote>
        <p><a name="index-bounds_002c-asymptotic-228"></a><a name="index-open-network-229"></a>
Compute Asymptotic Bounds for single-class, open Queueing Networks
with K service centers.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>lambda</var><dd>overall arrival rate to the system (scalar). Abort if
<var>lambda</var><code> &le; 0</code>

          <br><dt><var>D</var><dd><var>D</var><code>(k)</code> is the service demand at center k. 
The service demand vector <var>D</var> must be nonempty, and all demands
must be nonnegative (<var>D</var><code>(k) &ge; 0</code> for all k).

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>Xu</var><dd>Upper bound on the system throughput.

          <br><dt><var>Rl</var><dd>Lower bound on the system response time.

        </dl>

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qnopenbsb.

        </blockquote></div>

<p class="noindent"><strong>REFERENCES</strong>

   <p>Edward D. Lazowska, John Zahorjan, G.  Scott Graham, and Kenneth
C. Sevcik, <cite>Quantitative System Performance: Computer System
Analysis Using Queueing Network Models</cite>, Prentice Hall,
1984. <a href="http://www.cs.washington.edu/homes/lazowska/qsp/">http://www.cs.washington.edu/homes/lazowska/qsp/</a>. In
particular, see section 5.2 ("Asymptotic Bounds").

   <p><a name="index-Lazowska_002c-E_002e-D_002e-230"></a><a name="index-Zahorjan_002c-J_002e-231"></a><a name="index-Graham_002c-G_002e-S_002e-232"></a><a name="index-Sevcik_002c-K_002e-C_002e-233"></a>
<a name="doc_002dqnclosedab"></a>

<div class="defun">
&mdash; Function File: [<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] = <b>qnclosedab</b> (<var>N, D</var>)<var><a name="index-qnclosedab-234"></a></var><br>
&mdash; Function File: [<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] = <b>qnclosedab</b> (<var>N, D, Z</var>)<var><a name="index-qnclosedab-235"></a></var><br>
<blockquote>
        <p><a name="index-bounds_002c-asymptotic-236"></a><a name="index-closed-network-237"></a>
Compute Asymptotic Bounds for single-class, closed Queueing Networks
with K service centers.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>N</var><dd>number of requests in the system (scalar, <var>N</var><code>&gt;0</code>).

          <br><dt><var>D</var><dd><var>D</var><code>(k)</code> is the service demand of service center k,
<var>D</var><code>(k) &ge; 0</code>.

          <br><dt><var>Z</var><dd>external delay (think time, scalar, <var>Z</var><code> &ge; 0</code>). If
omitted, it is assumed to be zero.

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>Xl</var><dt><var>Xu</var><dd>Lower and upper bound on the system throughput.

          <br><dt><var>Rl</var><dt><var>Ru</var><dd>Lower and upper bound on the system response time.

        </dl>

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qnclosedbsb, qnclosedgb, qnclosedpb.

        </blockquote></div>

<p class="noindent"><strong>REFERENCES</strong>

<p class="noindent">Edward D. Lazowska, John Zahorjan, G.  Scott Graham, and Kenneth
C. Sevcik, <cite>Quantitative System Performance: Computer System
Analysis Using Queueing Network Models</cite>, Prentice Hall,
1984. <a href="http://www.cs.washington.edu/homes/lazowska/qsp/">http://www.cs.washington.edu/homes/lazowska/qsp/</a>. In
particular, see section 5.2 ("Asymptotic Bounds").

   <p><a name="index-Lazowska_002c-E_002e-D_002e-238"></a><a name="index-Zahorjan_002c-J_002e-239"></a><a name="index-Graham_002c-G_002e-S_002e-240"></a><a name="index-Sevcik_002c-K_002e-C_002e-241"></a>

   <p><a name="doc_002dqnopenbsb"></a>

<div class="defun">
&mdash; Function File: [<var>Xu</var>, <var>Rl</var>, <var>Ru</var>] = <b>qnopenbsb</b> (<var>lambda, D</var>)<var><a name="index-qnopenbsb-242"></a></var><br>
<blockquote>
        <p><a name="index-bounds_002c-balanced-system-243"></a><a name="index-open-network-244"></a>
Compute Balanced System Bounds for single-class, open Queueing Networks
with K service centers.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>lambda</var><dd>overall arrival rate to the system (scalar). Abort if
<var>lambda</var><code> &lt; 0 </code>

          <br><dt><var>D</var><dd><var>D</var><code>(k)</code> is the service demand at center k. 
The service demand vector <var>D</var> must be nonempty, and all demands
must be nonnegative (<var>D</var><code>(k) &ge; 0</code> for all k).

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>Xl</var><dd>Lower bound on the system throughput.

          <br><dt><var>Rl</var><dt><var>Ru</var><dd>Lower and upper bound on the system response time.

        </dl>

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qnopenab.

        </blockquote></div>

<p class="noindent"><strong>REFERENCES</strong>

   <p>Edward D. Lazowska, John Zahorjan, G.  Scott Graham, and Kenneth
C. Sevcik, <cite>Quantitative System Performance: Computer System
Analysis Using Queueing Network Models</cite>, Prentice Hall,
1984. <a href="http://www.cs.washington.edu/homes/lazowska/qsp/">http://www.cs.washington.edu/homes/lazowska/qsp/</a>. In
particular, see section 5.4 ("Balanced Systems Bounds").

   <p><a name="index-Lazowska_002c-E_002e-D_002e-245"></a><a name="index-Zahorjan_002c-J_002e-246"></a><a name="index-Graham_002c-G_002e-S_002e-247"></a><a name="index-Sevcik_002c-K_002e-C_002e-248"></a>
<a name="doc_002dqnclosedbsb"></a>

<div class="defun">
&mdash; Function File: [<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] = <b>qnclosedbsb</b> (<var>N, D</var>)<var><a name="index-qnclosedbsb-249"></a></var><br>
&mdash; Function File: [<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] = <b>qnclosedbsb</b> (<var>N, D, Z</var>)<var><a name="index-qnclosedbsb-250"></a></var><br>
<blockquote>
        <p><a name="index-bounds_002c-balanced-system-251"></a><a name="index-closed-network-252"></a>
Compute Balanced System Bounds for single-class, closed Queueing Networks
with K service centers.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>N</var><dd>number of requests in the system (scalar).

          <br><dt><var>D</var><dd><var>D</var><code>(k)</code> is the service demand at center k;
<var>K</var><code>(k) &ge; 0</code>.

          <br><dt><var>Z</var><dd>external delay (think time, scalar, <var>Z</var><code> &ge; 0</code>). If
omitted, it is assumed to be zero.

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>Xl</var><dt><var>Xu</var><dd>Lower and upper bound on the system throughput.

          <br><dt><var>Rl</var><dt><var>Ru</var><dd>Lower and upper bound on the system response time.

        </dl>

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qnclosedab, qnclosedgb, qnclosedpb.

        </blockquote></div>

   <p><a name="doc_002dqnclosedpb"></a>

<div class="defun">
&mdash; Function File: [<var>Xl</var>, <var>Xu</var>] = <b>qnclosedpb</b> (<var>N, D </var>)<var><a name="index-qnclosedpb-253"></a></var><br>
<blockquote>
        <p>Compute PB Bounds (C. H. Hsieh and S. Lam, 1987)
for single-class, closed Queueing Networks
with K service centers.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>N</var><dd>number of requests in the system (scalar). Must be <var>N</var><code> &gt; 0</code>.

          <br><dt><var>D</var><dd><var>D</var><code>(k)</code> is the service demand of service center k. Must be
<var>D</var><code>(k) &ge; 0</code> for all k.

          <br><dt><var>Z</var><dd>external delay (think time, scalar). If omitted, it is assumed to be zero. 
Must be <var>Z</var><code> &ge; 0</code>.

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>Xl</var><dt><var>Xu</var><dd>Lower and upper bounds on the system throughput.

        </dl>

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qnclosedab, qbclosedbsb, qnclosedgb.

        </blockquote></div>

<p class="noindent"><strong>REFERENCES</strong>

   <p>The original paper describing PB Bounds is C. H. Hsieh and S. Lam,
<cite>Two classes of performance bounds for closed queueing networks</cite>,
PEVA, vol. 7, n. 1, pp. 3&ndash;30, 1987

   <p>This function implements the non-iterative variant described in G. 
Casale, R. R. Muntz, G. Serazzi, <cite>Geometric Bounds: a
Non-Iterative Analysis Technique for Closed Queueing Networks</cite>, IEEE
Transactions on Computers, 57(6):780-794, June 2008.

   <p><a name="index-Hsieh_002c-C_002e-H-254"></a><a name="index-Lam_002c-S_002e-255"></a><a name="index-Casale_002c-G_002e-256"></a><a name="index-Muntz_002c-R_002e-R_002e-257"></a><a name="index-Serazzi_002c-G_002e-258"></a>
<a name="doc_002dqnclosedgb"></a>

<div class="defun">
&mdash; Function File: [<var>Xl</var>, <var>Xu</var>, <var>Ql</var>, <var>Qu</var>] = <b>qnclosedgb</b> (<var>N, D, Z</var>)<var><a name="index-qnclosedgb-259"></a></var><br>
<blockquote>
        <p><a name="index-bounds_002c-geometric-260"></a><a name="index-closed-network-261"></a>
Compute Geometric Bounds (GB) for single-class, closed Queueing Networks.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>N</var><dd>number of requests in the system (scalar, <var>N</var><code> &gt; 0</code>).

          <br><dt><var>D</var><dd><var>D</var><code>(k)</code> is the service demand of service center k
(<var>D</var><code>(k) &ge; 0</code>).

          <br><dt><var>Z</var><dd>external delay (think time, scalar). If omitted, it is assumed to be zero.

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>Xl</var><dt><var>Xu</var><dd>Lower and upper bound on the system throughput. If <var>Z</var><code>&gt;0</code>,
these bounds are computed using <em>Geometric Square-root Bounds</em>
(GSB). If <var>Z</var><code>==0</code>, these bounds are computed using <em>Geometric Bounds</em> (GB)

          <br><dt><var>Ql</var><dt><var>Qu</var><dd><var>Ql</var><code>(i)</code> and <var>Qu</var><code>(i)</code> are the lower and upper
bounds respectively of the queue length for service center i.

        </dl>

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qnclosedab.

        </blockquote></div>

<p class="noindent"><strong>REFERENCES</strong>

   <p>G. Casale, R. R. Muntz, G. Serazzi,
<cite>Geometric Bounds: a Non-Iterative Analysis Technique for Closed
Queueing Networks</cite>, IEEE Transactions on Computers, 57(6):780-794,
June 2008. <a href="http://doi.ieeecomputersociety.org/10.1109/TC.2008.37">http://doi.ieeecomputersociety.org/10.1109/TC.2008.37</a>

   <p><a name="index-Casale_002c-G_002e-262"></a><a name="index-Muntz_002c-R_002e-R_002e-263"></a><a name="index-Serazzi_002c-G_002e-264"></a>
In this implementation we set X^+ and X^- as the upper
and lower Asymptotic Bounds as computed by the <code>qnclosedab</code>
function, respectively.

<div class="node">
<a name="Utility-functions"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Bounds-on-performance">Bounds on performance</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Queueing-Networks">Queueing Networks</a>

</div>

<h3 class="section">6.6 Utility functions</h3>

<h4 class="subsection">6.6.1 Open or closed networks</h4>

<p><a name="doc_002dqnclosed"></a>

<div class="defun">
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qnclosed</b> (<var>N, S, V, <small class="dots">...</small></var>)<var><a name="index-qnclosed-265"></a></var><br>
<blockquote>
        <p><a name="index-closed-network-266"></a>
This function computes steady-state performance measures of closed
queueing networks using the Mean Value Analysis (MVA) algorithm. The
qneneing network is allowed to contain fixed-capacity centers, delay
centers or general load-dependent centers. Multiple request
classes are supported.

        <p>This function dispatches the computation to one of
<code>qnclosedsinglemva</code>, <code>qnclosedsinglemvald</code> or
<code>qnclosedmultimva</code>.

          <ul>
<li>If <var>N</var> is a scalar, the network is assumed to have a single
class of requests; in this case, the exact MVA algorithm is used to
analyze the network. If <var>S</var> is a vector, then <var>S</var><code>(k)</code>
is the average service time of center k, and this function
calls <code>qnclosedsinglemva</code> which supports load-independent
service centers. If <var>S</var> is a matrix, <var>S</var><code>(k,i)</code> is the
average service time at service center k when i &ge;
1 jobs are present; in this case, the network is analyzed with the
<code>qnclosedsinglemvald</code> function.

          <li>If <var>N</var> is a vector, the network is assumed to have multiple
classes of requests, and is analyzed using the exact multiclass
MVA algorithm as implemented in the <code>qnclosedmultimva</code> function.

        </ul>

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qnclosedsinglemva, qnclosedsinglemvald, qnclosedmultimva.

        </blockquote></div>

<p class="noindent"><strong>EXAMPLE</strong>

<pre class="example"><pre class="verbatim">      P = [0 0.3 0.7; 1 0 0; 1 0 0]; # Transition probability matrix
      S = [1 0.6 0.2]; # Average service times
      m = ones(1,3); # All centers are single-server
      Z = 2; # External delay
      N = 15; # Maximum population to consider
     
      V = qnvisits(P); # Compute number of visits from P
      D = V .* S; # Compute service demand from S and V
      X_bsb_lower = X_bsb_upper = zeros(1,N);
      X_ab_lower = X_ab_upper = zeros(1,N);
      X_mva = zeros(1,N);
      for n=1:N
        [X_bsb_lower(n) X_bsb_upper(n)] = qnclosedbsb(n, D, Z);
        [X_ab_lower(n) X_ab_upper(n)] = qnclosedab(n, D, Z);
        [U R Q X] = qnclosed( n, S, V, m, Z );
        X_mva(n) = X(1)/V(1);
      endfor
      close all;
      plot(1:N, X_ab_lower,"g;Asymptotic Bounds;", \
           1:N, X_bsb_lower,"k;Balanced System Bounds;", \
           1:N, X_mva,"b;MVA;", "linewidth", 2, \
           1:N, X_bsb_upper,"k", \
           1:N, X_ab_upper,"g" );
      axis([1,N,0,1]);
      xlabel("Number of Requests n");
      ylabel("System Throughput X(n)");
      legend("location","southeast");</pre></pre>
   <p><a name="doc_002dqnopen"></a>

<div class="defun">
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qnopen</b> (<var>lambda, S, V, <small class="dots">...</small></var>)<var><a name="index-qnopen-267"></a></var><br>
<blockquote>
        <p><a name="index-open-network-268"></a>
Compute utilization, response time, average number of requests in the
system, and throughput for open queueing networks. If <var>lambda</var> is
a scalar, the network is considered a single-class QN and is solved
using <code>qnopensingle</code>. If <var>lambda</var> is a vector, the network
is considered as a multiclass QN and solved using <code>qnopenmulti</code>.

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qnopensingle, qnopenmulti.

        </blockquote></div>

<!-- Compute the visit counts -->
<h4 class="subsection">6.6.2 Computation of the visit counts</h4>

<p>For single-class networks the average number of visits satisfy the
following equation:

<pre class="example">     V == P0 + V*P;
</pre>
   <p class="noindent">where P_0 j is the probability that an external
arrival goes to service center j. If \lambda_j is the
external arrival rate to service center j, and \lambda =
\sum_j \lambda_j is the overall external arrival rate, then
P_0 j = \lambda_j / \lambda.

   <p>For closed networks, the visit ratios satisfy the following equation:

<pre class="example">     V(1) == 1 &amp;&amp; V == V*P;
</pre>
   <p>The definitions above can be extended to multiple class networks as
follows. We define the visit ratios V_sj for class s
customers at service center j as follows:

   <p>V_sj = sum_r sum_i V_ri P_risj, for all s,j
V_s1 = 1, for all s

<p class="noindent">while for open networks:

   <p>V_sj = P_0sj + sum_r sum_i V_ri P_risj, for all s,j

<p class="noindent">where P_0sj is the probability that an external
arrival goes to service center j as a class-s request. 
If \lambda_sj is the external arrival rate of class s
requests to service center j, and \lambda = \sum_s \sum_j
\lambda_sj is the overall external arrival rate to the whole system,
then P_0sj = \lambda_sj / \lambda.

   <p><a name="doc_002dqnvisits"></a>

<div class="defun">
&mdash; Function File: [<var>V</var> <var>ch</var>] = <b>qnvisits</b> (<var>P</var>)<var><a name="index-qnvisits-269"></a></var><br>
&mdash; Function File: <var>V</var> = <b>qnvisits</b> (<var>P, lambda</var>)<var><a name="index-qnvisits-270"></a></var><br>
<blockquote>
        <p>Compute the average number of visits to the service centers of a
single class, open or closed Queueing Network with N service
centers.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>P</var><dd>Routing probability matrix. For single class networks,
<var>P</var><code>(i,j)</code> is the probability that a request which completed
service at center i is routed to center j. For closed
networks it must hold that <code>sum(</code><var>P</var><code>,2)==1</code>. The routing
graph myst be strongly connected, meaning that it must be possible to
eventually reach each node starting from each node. For multiple
class networks, <var>P</var><code>(r,i,s,j)</code> is the probability that a
class r request which completed service at center i is
routed to center j as a class s request. Class switching
is supported.

          <br><dt><var>lambda</var><dd>(open networks only) vector of external arrivals. For single class
networks, <var>lambda</var><code>(i)</code> is the external arrival rate to
center i. For multiple class networks,
<var>lambda</var><code>(r,i)</code> is the arrival rate of class r
requests to center i. If this parameter is omitted, the
network is assumed to be closed.

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>V</var><dd>For single class networks, <var>V</var><code>(i)</code> is the average number of
visits to server i. For multiple class networks,
<var>V</var><code>(r,i)</code> is the class r visit ratio at center
i.

          <br><dt><var>ch</var><dd>(For closed networks only). <var>ch</var><code>(c,k)</code> is the
number of the chain that class c at center k belongs to. 
The total number of chains is <code>max(</code><var>ch</var><code>)</code>.

        </dl>

        </blockquote></div>

<p class="noindent"><strong>EXAMPLE</strong>

<pre class="example"><pre class="verbatim">      P = [ 0 0.4 0.6 0; \
            0.2 0 0.2 0.6; \
            0 0 0 1; \
            0 0 0 0 ];
      lambda = [0.1 0 0 0.3];
      V = qnvisits(P,lambda);
      S = [2 1 2 1.8];
      m = [3 1 1 2];
      [U R Q X] = qnopensingle( sum(lambda), S, V, m );</pre></pre>
   <h4 class="subsection">6.6.3 Other utility functions</h4>

<p><a name="doc_002dpopulation_005fmix"></a>

<div class="defun">
&mdash; Function File: pop_mix = <b>population_mix</b> (<var>k, N</var>)<var><a name="index-population_005fmix-271"></a></var><br>
<blockquote>
        <p><a name="index-population-mix-272"></a><a name="index-closed-network_002c-multiple-classes-273"></a>
Return the set of valid population mixes with exactly <var>k</var>
customers, for a closed multiclass Queueing Network with population
vector <var>N</var>. More specifically, given a multiclass Queueing
Network with C customer classes, such that there are
<var>N</var><code>(i)</code> requests of class i, a
k-mix <var>mix</var> is a C-dimensional vector with the
following properties:

     <pre class="example">          all( mix &gt;= 0 );
          all( mix &lt;= N );
          sum( mix ) == k;
</pre>
        <p class="noindent">This function enumerates all valid k-mixes, such that
<var>pop_mix</var><code>(i)</code> is a C dimensional row vector representing
a valid population mix, for all i.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>k</var><dd>Total population size of the requested mix. <var>k</var> must be a nonnegative integer

          <br><dt><var>N</var><dd><var>N</var><code>(i)</code> is the number of class i requests. 
The condition <var>k</var><code> &le; sum(</code><var>N</var><code>)</code> must hold.

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>pop_mix</var><dd><var>pop_mix</var><code>(i,j)</code> is the number of class j requests
in the i-th population mix. The number of
population mixes is <code>rows( </code><var>pop_mix</var><code> ) </code>.

        </dl>

        <p>Note that if you are interested in the number of k-mixes
and you don't care to enumerate them, you can use the funcion
<code>qnmvapop</code>.

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qnmvapop.

        </blockquote></div>

<p class="noindent"><strong>REFERENCES</strong>

   <p>Herb Schwetman, <cite>Implementing the Mean Value Algorithm for the
Solution of Queueing Network Models</cite>, Technical Report CSD-TR-355,
Department of Computer Sciences, Purdue University, feb 15, 1982,
available at
<a href="http://www.cs.purdue.edu/research/technical_reports/1980/TR 80-355.pdf">http://www.cs.purdue.edu/research/technical_reports/1980/TR 80-355.pdf</a>

   <p>Note that the slightly different problem of generating all tuples
k_1, k_2, \ldots k_N such that \sum_i k_i = k and
k_i are nonnegative integers, for some fixed integer k
&ge; 0 has been described in S. Santini, <cite>Computing the
Indices for a Complex Summation</cite>, unpublished report, available at
<a href="http://arantxa.ii.uam.es/~ssantini/writing/notes/s668_summation.pdf">http://arantxa.ii.uam.es/~ssantini/writing/notes/s668_summation.pdf</a>

   <p><a name="index-Schwetman_002c-H_002e-274"></a><a name="index-Santini_002c-S_002e-275"></a>
<a name="doc_002dqnmvapop"></a>

<div class="defun">
&mdash; Function File: <var>H</var> = <b>qnmvapop</b> (<var>N</var>)<var><a name="index-qnmvapop-276"></a></var><br>
<blockquote>
        <p><a name="index-population-mix-277"></a><a name="index-closed-network_002c-multiple-classes-278"></a>
Given a network with C customer classes, this function
computes the number of valid population mixes <var>H</var><code>(r,n)</code> that can
be constructed by the multiclass MVA algorithm by allocating n
customers to the first r classes.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>N</var><dd>Population vector. <var>N</var><code>(c)</code> is the number of class-c
requests in the system. The total number of requests in the network
is <code>sum(</code><var>N</var><code>)</code>.

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>H</var><dd><var>H</var><code>(r,n)</code> is the number of valid populations that can be
constructed allocating n customers to the first r classes.

        </dl>

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qnclosedmultimva,population_mix.

        </blockquote></div>

<p class="noindent"><strong>REFERENCES</strong>

   <p>Zahorjan, J. and Wong, E. <cite>The solution of separable queueing
network models using mean value analysis</cite>. SIGMETRICS
Perform. Eval. Rev. 10, 3 (Sep. 1981), 80-85. DOI
<a href="http://doi.acm.org/10.1145/1010629.805477">http://doi.acm.org/10.1145/1010629.805477</a>

   <p><a name="index-Zahorjan_002c-J_002e-279"></a><a name="index-Wong_002c-E_002e-280"></a>

<!-- Appendix starts here -->
<!-- DO NOT EDIT!  Generated automatically by munge-texi. -->
<!-- *- texinfo -*- -->
<!-- Copyright (C) 2008, 2009, 2010, 2011, 2012 Moreno Marzolla -->
<!-- This file is part of the queueing toolbox, a Queueing Networks -->
<!-- analysis package for GNU Octave. -->
<!-- The queueing toolbox is free software; you can redistribute it -->
<!-- and/or modify it under the terms of the GNU General Public License -->
<!-- as published by the Free Software Foundation; either version 3 of -->
<!-- the License, or (at your option) any later version. -->
<!-- The queueing toolbox is distributed in the hope that it will be -->
<!-- useful, but WITHOUT ANY WARRANTY; without even the implied warranty -->
<!-- of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the -->
<!-- GNU General Public License for more details. -->
<!-- You should have received a copy of the GNU General Public License -->
<!-- along with the queueing toolbox; see the file COPYING.  If not, see -->
<!-- <http://www.gnu.org/licenses/>. -->
<div class="node">
<a name="Contributing-Guidelines"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Acknowledgements">Acknowledgements</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Queueing-Networks">Queueing Networks</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="appendix">Appendix A Contributing Guidelines</h2>

<p>Contributions and bug reports are <em>always</em> welcome. If you want
to contribute to the <code>queueing</code> package, here are some
guidelines:

     <ul>
<li>If you are contributing a new function, please embed proper
documentation within the function itself. The documentation must be in
<code>texinfo</code> format, so that it will be extracted and formatted into
the printable manual. See the existing functions of the
<code>queueing</code> package for the documentation style.

     <li>The documentation should be as precise as possible. In particular,
always state what the valid ranges of the parameters are.

     <li>If you are contributing a new function, ensure that the function
properly checks the validity of its input parameters. For example,
each function accepting vectors should check whether the dimensions
match.

     <li>Always provide bibliographic references for each algorithm you
contribute. If your implementation differs in some way from the
reference you give, please describe how and why your implementation
differs.

     <li>Include Octave test and demo blocks with your code. 
Test blocks are particularly important, because Queueing Network
algorithms tend to be quite complex to implement correctly, and we
must ensure that the implementations provided with the
<code>queueing</code> package are (mostly) correct.

   </ul>

   <p>Send your contribution to Moreno Marzolla
(<a href="mailto:marzolla@cs.unibo.it">marzolla@cs.unibo.it</a>). Even if you are just a user of
<code>queueing</code>, and find this package useful, let me know by
dropping me a line. Thanks.

<!-- DO NOT EDIT!  Generated automatically by munge-texi. -->
<!-- *- texinfo -*- -->
<!-- Copyright (C) 2008, 2009, 2010, 2011, 2012 Moreno Marzolla -->
<!-- This file is part of the queueing toolbox, a Queueing Networks -->
<!-- analysis package for GNU Octave. -->
<!-- The queueing toolbox is free software; you can redistribute it -->
<!-- and/or modify it under the terms of the GNU General Public License -->
<!-- as published by the Free Software Foundation; either version 3 of -->
<!-- the License, or (at your option) any later version. -->
<!-- The queueing toolbox is distributed in the hope that it will be -->
<!-- useful, but WITHOUT ANY WARRANTY; without even the implied warranty -->
<!-- of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the -->
<!-- GNU General Public License for more details. -->
<!-- You should have received a copy of the GNU General Public License -->
<!-- along with the queueing toolbox; see the file COPYING.  If not, see -->
<!-- <http://www.gnu.org/licenses/>. -->
<div class="node">
<a name="Acknowledgements"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Copying">Copying</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Contributing-Guidelines">Contributing Guidelines</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="appendix">Appendix B Acknowledgements</h2>

<p>The following people (listed in alphabetical order) contributed to the
<code>queueing</code> package, either by providing feedback, reporting bugs
or contributing code: Philip Carinhas, Phil Colbourn, Yves Durand,
Marco Guazzone, Dmitry Kolesnikov.

<!-- DO NOT EDIT!  Generated automatically by munge-texi. -->
<div class="node">
<a name="Copying"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Concept-Index">Concept Index</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Acknowledgements">Acknowledgements</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="appendix">Appendix C GNU GENERAL PUBLIC LICENSE</h2>

<p><a name="index-warranty-281"></a><a name="index-copyright-282"></a>
<div align="center">Version 3, 29 June 2007</div>

<pre class="display">     Copyright &copy; 2007 Free Software Foundation, Inc. <a href="http://fsf.org/">http://fsf.org/</a>
     
     Everyone is permitted to copy and distribute verbatim copies of this
     license document, but changing it is not allowed.
</pre>
<h3 class="heading">Preamble</h3>

<p>The GNU General Public License is a free, copyleft license for
software and other kinds of works.

   <p>The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom
to share and change all versions of a program&mdash;to make sure it remains
free software for all its users.  We, the Free Software Foundation,
use the GNU General Public License for most of our software; it
applies also to any other work released this way by its authors.  You
can apply it to your programs, too.

   <p>When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

   <p>To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you
have certain responsibilities if you distribute copies of the
software, or if you modify it: responsibilities to respect the freedom
of others.

   <p>For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too,
receive or can get the source code.  And you must show them these
terms so they know their rights.

   <p>Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

   <p>For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

   <p>Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the
manufacturer can do so.  This is fundamentally incompatible with the
aim of protecting users' freedom to change the software.  The
systematic pattern of such abuse occurs in the area of products for
individuals to use, which is precisely where it is most unacceptable. 
Therefore, we have designed this version of the GPL to prohibit the
practice for those products.  If such problems arise substantially in
other domains, we stand ready to extend this provision to those
domains in future versions of the GPL, as needed to protect the
freedom of users.

   <p>Finally, every program is threatened constantly by software patents. 
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish
to avoid the special danger that patents applied to a free program
could make it effectively proprietary.  To prevent this, the GPL
assures that patents cannot be used to render the program non-free.

   <p>The precise terms and conditions for copying, distribution and
modification follow.

<h3 class="heading">TERMS AND CONDITIONS</h3>

     <ol type=1 start=0>
<li>Definitions.

     <p>&ldquo;This License&rdquo; refers to version 3 of the GNU General Public License.

     <p>&ldquo;Copyright&rdquo; also means copyright-like laws that apply to other kinds
of works, such as semiconductor masks.

     <p>&ldquo;The Program&rdquo; refers to any copyrightable work licensed under this
License.  Each licensee is addressed as &ldquo;you&rdquo;.  &ldquo;Licensees&rdquo; and
&ldquo;recipients&rdquo; may be individuals or organizations.

     <p>To &ldquo;modify&rdquo; a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of
an exact copy.  The resulting work is called a &ldquo;modified version&rdquo; of
the earlier work or a work &ldquo;based on&rdquo; the earlier work.

     <p>A &ldquo;covered work&rdquo; means either the unmodified Program or a work based
on the Program.

     <p>To &ldquo;propagate&rdquo; a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

     <p>To &ldquo;convey&rdquo; a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user
through a computer network, with no transfer of a copy, is not
conveying.

     <p>An interactive user interface displays &ldquo;Appropriate Legal Notices&rdquo; to
the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

     <li>Source Code.

     <p>The &ldquo;source code&rdquo; for a work means the preferred form of the work for
making modifications to it.  &ldquo;Object code&rdquo; means any non-source form
of a work.

     <p>A &ldquo;Standard Interface&rdquo; means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

     <p>The &ldquo;System Libraries&rdquo; of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
&ldquo;Major Component&rdquo;, in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

     <p>The &ldquo;Corresponding Source&rdquo; for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

     <p>The Corresponding Source need not include anything that users can
regenerate automatically from other parts of the Corresponding Source.

     <p>The Corresponding Source for a work in source code form is that same
work.

     <li>Basic Permissions.

     <p>All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

     <p>You may make, run and propagate covered works that you do not convey,
without conditions so long as your license otherwise remains in force. 
You may convey covered works to others for the sole purpose of having
them make modifications exclusively for you, or provide you with
facilities for running those works, provided that you comply with the
terms of this License in conveying all material for which you do not
control copyright.  Those thus making or running the covered works for
you must do so exclusively on your behalf, under your direction and
control, on terms that prohibit them from making any copies of your
copyrighted material outside their relationship with you.

     <p>Conveying under any other circumstances is permitted solely under the
conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

     <li>Protecting Users' Legal Rights From Anti-Circumvention Law.

     <p>No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

     <p>When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such
circumvention is effected by exercising rights under this License with
respect to the covered work, and you disclaim any intention to limit
operation or modification of the work as a means of enforcing, against
the work's users, your or third parties' legal rights to forbid
circumvention of technological measures.

     <li>Conveying Verbatim Copies.

     <p>You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

     <p>You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

     <li>Conveying Modified Source Versions.

     <p>You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these
conditions:

          <ol type=a start=1>
<li>The work must carry prominent notices stating that you modified it,
and giving a relevant date.

          <li>The work must carry prominent notices stating that it is released
under this License and any conditions added under section 7.  This
requirement modifies the requirement in section 4 to &ldquo;keep intact all
notices&rdquo;.

          <li>You must license the entire work, as a whole, under this License to
anyone who comes into possession of a copy.  This License will
therefore apply, along with any applicable section 7 additional terms,
to the whole of the work, and all its parts, regardless of how they
are packaged.  This License gives no permission to license the work in
any other way, but it does not invalidate such permission if you have
separately received it.

          <li>If the work has interactive user interfaces, each must display
Appropriate Legal Notices; however, if the Program has interactive
interfaces that do not display Appropriate Legal Notices, your work
need not make them do so.
          </ol>

     <p>A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
&ldquo;aggregate&rdquo; if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

     <li>Conveying Non-Source Forms.

     <p>You may convey a covered work in object code form under the terms of
sections 4 and 5, provided that you also convey the machine-readable
Corresponding Source under the terms of this License, in one of these
ways:

          <ol type=a start=1>
<li>Convey the object code in, or embodied in, a physical product
(including a physical distribution medium), accompanied by the
Corresponding Source fixed on a durable physical medium customarily
used for software interchange.

          <li>Convey the object code in, or embodied in, a physical product
(including a physical distribution medium), accompanied by a written
offer, valid for at least three years and valid for as long as you
offer spare parts or customer support for that product model, to give
anyone who possesses the object code either (1) a copy of the
Corresponding Source for all the software in the product that is
covered by this License, on a durable physical medium customarily used
for software interchange, for a price no more than your reasonable
cost of physically performing this conveying of source, or (2) access
to copy the Corresponding Source from a network server at no charge.

          <li>Convey individual copies of the object code with a copy of the written
offer to provide the Corresponding Source.  This alternative is
allowed only occasionally and noncommercially, and only if you
received the object code with such an offer, in accord with subsection
6b.

          <li>Convey the object code by offering access from a designated place
(gratis or for a charge), and offer equivalent access to the
Corresponding Source in the same way through the same place at no
further charge.  You need not require recipients to copy the
Corresponding Source along with the object code.  If the place to copy
the object code is a network server, the Corresponding Source may be
on a different server (operated by you or a third party) that supports
equivalent copying facilities, provided you maintain clear directions
next to the object code saying where to find the Corresponding Source. 
Regardless of what server hosts the Corresponding Source, you remain
obligated to ensure that it is available for as long as needed to
satisfy these requirements.

          <li>Convey the object code using peer-to-peer transmission, provided you
inform other peers where the object code and Corresponding Source of
the work are being offered to the general public at no charge under
subsection 6d.

          </ol>

     <p>A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

     <p>A &ldquo;User Product&rdquo; is either (1) a &ldquo;consumer product&rdquo;, which means any
tangible personal property which is normally used for personal,
family, or household purposes, or (2) anything designed or sold for
incorporation into a dwelling.  In determining whether a product is a
consumer product, doubtful cases shall be resolved in favor of
coverage.  For a particular product received by a particular user,
&ldquo;normally used&rdquo; refers to a typical or common use of that class of
product, regardless of the status of the particular user or of the way
in which the particular user actually uses, or expects or is expected
to use, the product.  A product is a consumer product regardless of
whether the product has substantial commercial, industrial or
non-consumer uses, unless such uses represent the only significant
mode of use of the product.

     <p>&ldquo;Installation Information&rdquo; for a User Product means any methods,
procedures, authorization keys, or other information required to
install and execute modified versions of a covered work in that User
Product from a modified version of its Corresponding Source.  The
information must suffice to ensure that the continued functioning of
the modified object code is in no case prevented or interfered with
solely because modification has been made.

     <p>If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

     <p>The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or
updates for a work that has been modified or installed by the
recipient, or for the User Product in which it has been modified or
installed.  Access to a network may be denied when the modification
itself materially and adversely affects the operation of the network
or violates the rules and protocols for communication across the
network.

     <p>Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

     <li>Additional Terms.

     <p>&ldquo;Additional permissions&rdquo; are terms that supplement the terms of this
License by making exceptions from one or more of its conditions. 
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

     <p>When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

     <p>Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders
of that material) supplement the terms of this License with terms:

          <ol type=a start=1>
<li>Disclaiming warranty or limiting liability differently from the terms
of sections 15 and 16 of this License; or

          <li>Requiring preservation of specified reasonable legal notices or author
attributions in that material or in the Appropriate Legal Notices
displayed by works containing it; or

          <li>Prohibiting misrepresentation of the origin of that material, or
requiring that modified versions of such material be marked in
reasonable ways as different from the original version; or

          <li>Limiting the use for publicity purposes of names of licensors or
authors of the material; or

          <li>Declining to grant rights under trademark law for use of some trade
names, trademarks, or service marks; or

          <li>Requiring indemnification of licensors and authors of that material by
anyone who conveys the material (or modified versions of it) with
contractual assumptions of liability to the recipient, for any
liability that these contractual assumptions directly impose on those
licensors and authors.
          </ol>

     <p>All other non-permissive additional terms are considered &ldquo;further
restrictions&rdquo; within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

     <p>If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

     <p>Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions; the
above requirements apply either way.

     <li>Termination.

     <p>You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

     <p>However, if you cease all violation of this License, then your license
from a particular copyright holder is reinstated (a) provisionally,
unless and until the copyright holder explicitly and finally
terminates your license, and (b) permanently, if the copyright holder
fails to notify you of the violation by some reasonable means prior to
60 days after the cessation.

     <p>Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

     <p>Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

     <li>Acceptance Not Required for Having Copies.

     <p>You are not required to accept this License in order to receive or run
a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

     <li>Automatic Licensing of Downstream Recipients.

     <p>Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

     <p>An &ldquo;entity transaction&rdquo; is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

     <p>You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

     <li>Patents.

     <p>A &ldquo;contributor&rdquo; is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's &ldquo;contributor version&rdquo;.

     <p>A contributor's &ldquo;essential patent claims&rdquo; are all patent claims owned
or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, &ldquo;control&rdquo; includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

     <p>Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

     <p>In the following three paragraphs, a &ldquo;patent license&rdquo; is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To &ldquo;grant&rdquo; such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

     <p>If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  &ldquo;Knowingly relying&rdquo; means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

     <p>If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

     <p>A patent license is &ldquo;discriminatory&rdquo; if it does not include within the
scope of its coverage, prohibits the exercise of, or is conditioned on
the non-exercise of one or more of the rights that are specifically
granted under this License.  You may not convey a covered work if you
are a party to an arrangement with a third party that is in the
business of distributing software, under which you make payment to the
third party based on the extent of your activity of conveying the
work, and under which the third party grants, to any of the parties
who would receive the covered work from you, a discriminatory patent
license (a) in connection with copies of the covered work conveyed by
you (or copies made from those copies), or (b) primarily for and in
connection with specific products or compilations that contain the
covered work, unless you entered into that arrangement, or that patent
license was granted, prior to 28 March 2007.

     <p>Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

     <li>No Surrender of Others' Freedom.

     <p>If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey
a covered work so as to satisfy simultaneously your obligations under
this License and any other pertinent obligations, then as a
consequence you may not convey it at all.  For example, if you agree
to terms that obligate you to collect a royalty for further conveying
from those to whom you convey the Program, the only way you could
satisfy both those terms and this License would be to refrain entirely
from conveying the Program.

     <li>Use with the GNU Affero General Public License.

     <p>Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

     <li>Revised Versions of this License.

     <p>The Free Software Foundation may publish revised and/or new versions
of the GNU General Public License from time to time.  Such new
versions will be similar in spirit to the present version, but may
differ in detail to address new problems or concerns.

     <p>Each version is given a distinguishing version number.  If the Program
specifies that a certain numbered version of the GNU General Public
License &ldquo;or any later version&rdquo; applies to it, you have the option of
following the terms and conditions either of that numbered version or
of any later version published by the Free Software Foundation.  If
the Program does not specify a version number of the GNU General
Public License, you may choose any version ever published by the Free
Software Foundation.

     <p>If the Program specifies that a proxy can decide which future versions
of the GNU General Public License can be used, that proxy's public
statement of acceptance of a version permanently authorizes you to
choose that version for the Program.

     <p>Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

     <li>Disclaimer of Warranty.

     <p>THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM &ldquo;AS IS&rdquo; WITHOUT
WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND
PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE PROGRAM PROVE
DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR
CORRECTION.

     <li>Limitation of Liability.

     <p>IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR
CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES
ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT
NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR
LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM
TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER
PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

     <li>Interpretation of Sections 15 and 16.

     <p>If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

     </ol>

<h3 class="heading">END OF TERMS AND CONDITIONS</h3>

<h3 class="heading">How to Apply These Terms to Your New Programs</h3>

<p>If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these
terms.

   <p>To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the &ldquo;copyright&rdquo; line and a pointer to where the full notice is found.

<pre class="smallexample">     <var>one line to give the program's name and a brief idea of what it does.</var>
     Copyright (C) <var>year</var> <var>name of author</var>
     
     This program is free software: you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation, either version 3 of the License, or (at
     your option) any later version.
     
     This program is distributed in the hope that it will be useful, but
     WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     General Public License for more details.
     
     You should have received a copy of the GNU General Public License
     along with this program.  If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.
</pre>
   <p>Also add information on how to contact you by electronic and paper mail.

   <p>If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

<pre class="smallexample">     <var>program</var> Copyright (C) <var>year</var> <var>name of author</var>
     This program comes with ABSOLUTELY NO WARRANTY; for details type &lsquo;<samp><span class="samp">show w</span></samp>&rsquo;.
     This is free software, and you are welcome to redistribute it
     under certain conditions; type &lsquo;<samp><span class="samp">show c</span></samp>&rsquo; for details.
</pre>
   <p>The hypothetical commands &lsquo;<samp><span class="samp">show w</span></samp>&rsquo; and &lsquo;<samp><span class="samp">show c</span></samp>&rsquo; should show
the appropriate parts of the General Public License.  Of course, your
program's commands might be different; for a GUI interface, you would
use an &ldquo;about box&rdquo;.

   <p>You should also get your employer (if you work as a programmer) or school,
if any, to sign a &ldquo;copyright disclaimer&rdquo; for the program, if necessary. 
For more information on this, and how to apply and follow the GNU GPL, see
<a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.

   <p>The GNU General Public License does not permit incorporating your
program into proprietary programs.  If your program is a subroutine
library, you may consider it more useful to permit linking proprietary
applications with the library.  If this is what you want to do, use
the GNU Lesser General Public License instead of this License.  But
first, please read <a href="http://www.gnu.org/philosophy/why-not-lgpl.html">http://www.gnu.org/philosophy/why-not-lgpl.html</a>.

<!-- INDEX -->
<div class="node">
<a name="Concept-Index"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Function-Index">Function Index</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Copying">Copying</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="unnumbered">Concept Index</h2>

<ul class="index-cp" compact>
<li><a href="#index-Approximate-MVA-166">Approximate MVA</a>: <a href="#Algorithms-for-Product_002dForm-QNs">Algorithms for Product-Form QNs</a></li>
<li><a href="#index-Asymmetric-_0040math_007bM_002fM_002fm_007d-system-66">Asymmetric M/M/m system</a>: <a href="#The-Asymmetric-M_002fM_002fm-System">The Asymmetric M/M/m System</a></li>
<li><a href="#index-BCMP-network-121">BCMP network</a>: <a href="#Algorithms-for-Product_002dForm-QNs">Algorithms for Product-Form QNs</a></li>
<li><a href="#index-Birth_002ddeath-process-19">Birth-death process</a>: <a href="#Birth_002dDeath-process">Birth-Death process</a></li>
<li><a href="#index-blocking-queueing-network-216">blocking queueing network</a>: <a href="#Algorithms-for-non-Product_002dform-QNs">Algorithms for non Product-form QNs</a></li>
<li><a href="#index-bounds_002c-asymptotic-228">bounds, asymptotic</a>: <a href="#Bounds-on-performance">Bounds on performance</a></li>
<li><a href="#index-bounds_002c-balanced-system-243">bounds, balanced system</a>: <a href="#Bounds-on-performance">Bounds on performance</a></li>
<li><a href="#index-bounds_002c-geometric-260">bounds, geometric</a>: <a href="#Bounds-on-performance">Bounds on performance</a></li>
<li><a href="#index-closed-network-266">closed network</a>: <a href="#Utility-functions">Utility functions</a></li>
<li><a href="#index-closed-network-237">closed network</a>: <a href="#Bounds-on-performance">Bounds on performance</a></li>
<li><a href="#index-closed-network-98">closed network</a>: <a href="#Algorithms-for-Product_002dForm-QNs">Algorithms for Product-Form QNs</a></li>
<li><a href="#index-Closed-network_002c-approximate-analysis-168">Closed network, approximate analysis</a>: <a href="#Algorithms-for-Product_002dForm-QNs">Algorithms for Product-Form QNs</a></li>
<li><a href="#index-closed-network_002c-finite-capacity-217">closed network, finite capacity</a>: <a href="#Algorithms-for-non-Product_002dform-QNs">Algorithms for non Product-form QNs</a></li>
<li><a href="#index-closed-network_002c-multiple-classes-273">closed network, multiple classes</a>: <a href="#Utility-functions">Utility functions</a></li>
<li><a href="#index-closed-network_002c-multiple-classes-223">closed network, multiple classes</a>: <a href="#Algorithms-for-non-Product_002dform-QNs">Algorithms for non Product-form QNs</a></li>
<li><a href="#index-Closed-network_002c-multiple-classes-198">Closed network, multiple classes</a>: <a href="#Algorithms-for-Product_002dForm-QNs">Algorithms for Product-Form QNs</a></li>
<li><a href="#index-closed-network_002c-multiple-classes-180">closed network, multiple classes</a>: <a href="#Algorithms-for-Product_002dForm-QNs">Algorithms for Product-Form QNs</a></li>
<li><a href="#index-Closed-network_002c-single-class-167">Closed network, single class</a>: <a href="#Algorithms-for-Product_002dForm-QNs">Algorithms for Product-Form QNs</a></li>
<li><a href="#index-closed-network_002c-single-class-137">closed network, single class</a>: <a href="#Algorithms-for-Product_002dForm-QNs">Algorithms for Product-Form QNs</a></li>
<li><a href="#index-CMVA-158">CMVA</a>: <a href="#Algorithms-for-Product_002dForm-QNs">Algorithms for Product-Form QNs</a></li>
<li><a href="#index-Continuous-time-Markov-chain-14">Continuous time Markov chain</a>: <a href="#CTMC-Stationary-Probability">CTMC Stationary Probability</a></li>
<li><a href="#index-convolution-algorithm-100">convolution algorithm</a>: <a href="#Algorithms-for-Product_002dForm-QNs">Algorithms for Product-Form QNs</a></li>
<li><a href="#index-copyright-282">copyright</a>: <a href="#Copying">Copying</a></li>
<li><a href="#index-Discrete-time-Markov-chain-4">Discrete time Markov chain</a>: <a href="#DTMC-Stationary-Probability">DTMC Stationary Probability</a></li>
<li><a href="#index-Expected-sojourn-time-22">Expected sojourn time</a>: <a href="#Expected-Sojourn-Time">Expected Sojourn Time</a></li>
<li><a href="#index-First-passage-times-36">First passage times</a>: <a href="#CTMC-First-Passage-Times">CTMC First Passage Times</a></li>
<li><a href="#index-First-passage-times-10">First passage times</a>: <a href="#DTMC-First-Passage-Times">DTMC First Passage Times</a></li>
<li><a href="#index-Jackson-network-91">Jackson network</a>: <a href="#Algorithms-for-Product_002dForm-QNs">Algorithms for Product-Form QNs</a></li>
<li><a href="#index-load_002ddependent-service-center-110">load-dependent service center</a>: <a href="#Algorithms-for-Product_002dForm-QNs">Algorithms for Product-Form QNs</a></li>
<li><a href="#index-g_t_0040math_007bM_002fG_002f1_007d-system-72">M/G/1 system</a>: <a href="#The-M_002fG_002f1-System">The M/G/1 System</a></li>
<li><a href="#index-g_t_0040math_007bM_002fH_005fm_002f1_007d-system-74">M/H_m/1 system</a>: <a href="#The-M_002fHm_002f1-System">The M/Hm/1 System</a></li>
<li><a href="#index-g_t_0040math_007bM_002fM_002f1_007d-system-38">M/M/1 system</a>: <a href="#The-M_002fM_002f1-System">The M/M/1 System</a></li>
<li><a href="#index-g_t_0040math_007bM_002fM_002f1_002fK_007d-system-58">M/M/1/K system</a>: <a href="#The-M_002fM_002f1_002fK-System">The M/M/1/K System</a></li>
<li><a href="#index-g_t_0040math_007bM_002fM_002f_007dinf-system-51">M/M/inf system</a>: <a href="#The-M_002fM_002finf-System">The M/M/inf System</a></li>
<li><a href="#index-g_t_0040math_007bM_002fM_002fm_007d-system-45">M/M/m system</a>: <a href="#The-M_002fM_002fm-System">The M/M/m System</a></li>
<li><a href="#index-g_t_0040math_007bM_002fM_002fm_002fK_007d-system-60">M/M/m/K system</a>: <a href="#The-M_002fM_002fm_002fK-System">The M/M/m/K System</a></li>
<li><a href="#index-Markov-chain_002c-continuous-time-35">Markov chain, continuous time</a>: <a href="#CTMC-First-Passage-Times">CTMC First Passage Times</a></li>
<li><a href="#index-Markov-chain_002c-continuous-time-27">Markov chain, continuous time</a>: <a href="#Expected-Time-to-Absorption">Expected Time to Absorption</a></li>
<li><a href="#index-Markov-chain_002c-continuous-time-24">Markov chain, continuous time</a>: <a href="#Time_002dAveraged-Expected-Sojourn-Time">Time-Averaged Expected Sojourn Time</a></li>
<li><a href="#index-Markov-chain_002c-continuous-time-21">Markov chain, continuous time</a>: <a href="#Expected-Sojourn-Time">Expected Sojourn Time</a></li>
<li><a href="#index-Markov-chain_002c-continuous-time-18">Markov chain, continuous time</a>: <a href="#Birth_002dDeath-process">Birth-Death process</a></li>
<li><a href="#index-Markov-chain_002c-continuous-time-13">Markov chain, continuous time</a>: <a href="#CTMC-Stationary-Probability">CTMC Stationary Probability</a></li>
<li><a href="#index-Markov-chain_002c-discrete-time-9">Markov chain, discrete time</a>: <a href="#DTMC-First-Passage-Times">DTMC First Passage Times</a></li>
<li><a href="#index-Markov-chain_002c-discrete-time-3">Markov chain, discrete time</a>: <a href="#DTMC-Stationary-Probability">DTMC Stationary Probability</a></li>
<li><a href="#index-Markov-chain_002c-state-occupancy-probabilities-15">Markov chain, state occupancy probabilities</a>: <a href="#CTMC-Stationary-Probability">CTMC Stationary Probability</a></li>
<li><a href="#index-Markov-chain_002c-stationary-probabilities-5">Markov chain, stationary probabilities</a>: <a href="#DTMC-Stationary-Probability">DTMC Stationary Probability</a></li>
<li><a href="#index-Mean-time-to-absorption-28">Mean time to absorption</a>: <a href="#Expected-Time-to-Absorption">Expected Time to Absorption</a></li>
<li><a href="#index-Mean-Value-Analysys-_0028MVA_0029-136">Mean Value Analysys (MVA)</a>: <a href="#Algorithms-for-Product_002dForm-QNs">Algorithms for Product-Form QNs</a></li>
<li><a href="#index-Mean-Value-Analysys-_0028MVA_0029_002c-approximate-165">Mean Value Analysys (MVA), approximate</a>: <a href="#Algorithms-for-Product_002dForm-QNs">Algorithms for Product-Form QNs</a></li>
<li><a href="#index-mixed-network-208">mixed network</a>: <a href="#Algorithms-for-Product_002dForm-QNs">Algorithms for Product-Form QNs</a></li>
<li><a href="#index-normalization-constant-99">normalization constant</a>: <a href="#Algorithms-for-Product_002dForm-QNs">Algorithms for Product-Form QNs</a></li>
<li><a href="#index-open-network-268">open network</a>: <a href="#Utility-functions">Utility functions</a></li>
<li><a href="#index-open-network-229">open network</a>: <a href="#Bounds-on-performance">Bounds on performance</a></li>
<li><a href="#index-open-network_002c-multiple-classes-128">open network, multiple classes</a>: <a href="#Algorithms-for-Product_002dForm-QNs">Algorithms for Product-Form QNs</a></li>
<li><a href="#index-open-network_002c-single-class-90">open network, single class</a>: <a href="#Algorithms-for-Product_002dForm-QNs">Algorithms for Product-Form QNs</a></li>
<li><a href="#index-population-mix-272">population mix</a>: <a href="#Utility-functions">Utility functions</a></li>
<li><a href="#index-queueing-network-with-blocking-215">queueing network with blocking</a>: <a href="#Algorithms-for-non-Product_002dform-QNs">Algorithms for non Product-form QNs</a></li>
<li><a href="#index-queueing-networks-75">queueing networks</a>: <a href="#Queueing-Networks">Queueing Networks</a></li>
<li><a href="#index-RS-blocking-226">RS blocking</a>: <a href="#Algorithms-for-non-Product_002dform-QNs">Algorithms for non Product-form QNs</a></li>
<li><a href="#index-Stationary-probabilities-16">Stationary probabilities</a>: <a href="#CTMC-Stationary-Probability">CTMC Stationary Probability</a></li>
<li><a href="#index-Stationary-probabilities-6">Stationary probabilities</a>: <a href="#DTMC-Stationary-Probability">DTMC Stationary Probability</a></li>
<li><a href="#index-Time_002dalveraged-sojourn-time-25">Time-alveraged sojourn time</a>: <a href="#Time_002dAveraged-Expected-Sojourn-Time">Time-Averaged Expected Sojourn Time</a></li>
<li><a href="#index-traffic-intensity-52">traffic intensity</a>: <a href="#The-M_002fM_002finf-System">The M/M/inf System</a></li>
<li><a href="#index-warranty-281">warranty</a>: <a href="#Copying">Copying</a></li>
   </ul><div class="node">
<a name="Function-Index"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Author-Index">Author Index</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Concept-Index">Concept Index</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="unnumbered">Function Index</h2>



<ul class="index-fn" compact>
<li><a href="#index-ctmc-11"><code>ctmc</code></a>: <a href="#CTMC-Stationary-Probability">CTMC Stationary Probability</a></li>
<li><a href="#index-ctmc_005fbd-17"><code>ctmc_bd</code></a>: <a href="#Birth_002dDeath-process">Birth-Death process</a></li>
<li><a href="#index-ctmc_005fexps-20"><code>ctmc_exps</code></a>: <a href="#Expected-Sojourn-Time">Expected Sojourn Time</a></li>
<li><a href="#index-ctmc_005ffpt-33"><code>ctmc_fpt</code></a>: <a href="#CTMC-First-Passage-Times">CTMC First Passage Times</a></li>
<li><a href="#index-ctmc_005fmtta-26"><code>ctmc_mtta</code></a>: <a href="#Expected-Time-to-Absorption">Expected Time to Absorption</a></li>
<li><a href="#index-ctmc_005ftaexps-23"><code>ctmc_taexps</code></a>: <a href="#Time_002dAveraged-Expected-Sojourn-Time">Time-Averaged Expected Sojourn Time</a></li>
<li><a href="#index-dtmc-1"><code>dtmc</code></a>: <a href="#DTMC-Stationary-Probability">DTMC Stationary Probability</a></li>
<li><a href="#index-dtmc_005ffpt-7"><code>dtmc_fpt</code></a>: <a href="#DTMC-First-Passage-Times">DTMC First Passage Times</a></li>
<li><a href="#index-population_005fmix-271"><code>population_mix</code></a>: <a href="#Utility-functions">Utility functions</a></li>
<li><a href="#index-qnammm-65"><code>qnammm</code></a>: <a href="#The-Asymmetric-M_002fM_002fm-System">The Asymmetric M/M/m System</a></li>
<li><a href="#index-qnclosed-265"><code>qnclosed</code></a>: <a href="#Utility-functions">Utility functions</a></li>
<li><a href="#index-qnclosedab-234"><code>qnclosedab</code></a>: <a href="#Bounds-on-performance">Bounds on performance</a></li>
<li><a href="#index-qnclosedbsb-249"><code>qnclosedbsb</code></a>: <a href="#Bounds-on-performance">Bounds on performance</a></li>
<li><a href="#index-qnclosedgb-259"><code>qnclosedgb</code></a>: <a href="#Bounds-on-performance">Bounds on performance</a></li>
<li><a href="#index-qnclosedmultimva-173"><code>qnclosedmultimva</code></a>: <a href="#Algorithms-for-Product_002dForm-QNs">Algorithms for Product-Form QNs</a></li>
<li><a href="#index-qnclosedmultimvaapprox-191"><code>qnclosedmultimvaapprox</code></a>: <a href="#Algorithms-for-Product_002dForm-QNs">Algorithms for Product-Form QNs</a></li>
<li><a href="#index-qnclosedpb-253"><code>qnclosedpb</code></a>: <a href="#Bounds-on-performance">Bounds on performance</a></li>
<li><a href="#index-qnclosedsinglemva-133"><code>qnclosedsinglemva</code></a>: <a href="#Algorithms-for-Product_002dForm-QNs">Algorithms for Product-Form QNs</a></li>
<li><a href="#index-qnclosedsinglemvaapprox-160"><code>qnclosedsinglemvaapprox</code></a>: <a href="#Algorithms-for-Product_002dForm-QNs">Algorithms for Product-Form QNs</a></li>
<li><a href="#index-qnclosedsinglemvald-146"><code>qnclosedsinglemvald</code></a>: <a href="#Algorithms-for-Product_002dForm-QNs">Algorithms for Product-Form QNs</a></li>
<li><a href="#index-qncmva-155"><code>qncmva</code></a>: <a href="#Algorithms-for-Product_002dForm-QNs">Algorithms for Product-Form QNs</a></li>
<li><a href="#index-qnconvolution-96"><code>qnconvolution</code></a>: <a href="#Algorithms-for-Product_002dForm-QNs">Algorithms for Product-Form QNs</a></li>
<li><a href="#index-qnconvolutionld-106"><code>qnconvolutionld</code></a>: <a href="#Algorithms-for-Product_002dForm-QNs">Algorithms for Product-Form QNs</a></li>
<li><a href="#index-qnjackson-87"><code>qnjackson</code></a>: <a href="#Algorithms-for-Product_002dForm-QNs">Algorithms for Product-Form QNs</a></li>
<li><a href="#index-qnmarkov-219"><code>qnmarkov</code></a>: <a href="#Algorithms-for-non-Product_002dform-QNs">Algorithms for non Product-form QNs</a></li>
<li><a href="#index-qnmg1-71"><code>qnmg1</code></a>: <a href="#The-M_002fG_002f1-System">The M/G/1 System</a></li>
<li><a href="#index-qnmh1-73"><code>qnmh1</code></a>: <a href="#The-M_002fHm_002f1-System">The M/Hm/1 System</a></li>
<li><a href="#index-qnmix-206"><code>qnmix</code></a>: <a href="#Algorithms-for-Product_002dForm-QNs">Algorithms for Product-Form QNs</a></li>
<li><a href="#index-qnmknode-76"><code>qnmknode</code></a>: <a href="#Generic-Algorithms">Generic Algorithms</a></li>
<li><a href="#index-qnmm1-37"><code>qnmm1</code></a>: <a href="#The-M_002fM_002f1-System">The M/M/1 System</a></li>
<li><a href="#index-qnmm1k-57"><code>qnmm1k</code></a>: <a href="#The-M_002fM_002f1_002fK-System">The M/M/1/K System</a></li>
<li><a href="#index-qnmminf-50"><code>qnmminf</code></a>: <a href="#The-M_002fM_002finf-System">The M/M/inf System</a></li>
<li><a href="#index-qnmmm-43"><code>qnmmm</code></a>: <a href="#The-M_002fM_002fm-System">The M/M/m System</a></li>
<li><a href="#index-qnmmmk-59"><code>qnmmmk</code></a>: <a href="#The-M_002fM_002fm_002fK-System">The M/M/m/K System</a></li>
<li><a href="#index-qnmvablo-214"><code>qnmvablo</code></a>: <a href="#Algorithms-for-non-Product_002dform-QNs">Algorithms for non Product-form QNs</a></li>
<li><a href="#index-qnmvapop-276"><code>qnmvapop</code></a>: <a href="#Utility-functions">Utility functions</a></li>
<li><a href="#index-qnopen-267"><code>qnopen</code></a>: <a href="#Utility-functions">Utility functions</a></li>
<li><a href="#index-qnopenab-227"><code>qnopenab</code></a>: <a href="#Bounds-on-performance">Bounds on performance</a></li>
<li><a href="#index-qnopenbsb-242"><code>qnopenbsb</code></a>: <a href="#Bounds-on-performance">Bounds on performance</a></li>
<li><a href="#index-qnopenmulti-126"><code>qnopenmulti</code></a>: <a href="#Algorithms-for-Product_002dForm-QNs">Algorithms for Product-Form QNs</a></li>
<li><a href="#index-qnopensingle-118"><code>qnopensingle</code></a>: <a href="#Algorithms-for-Product_002dForm-QNs">Algorithms for Product-Form QNs</a></li>
<li><a href="#index-qnsolve-83"><code>qnsolve</code></a>: <a href="#Generic-Algorithms">Generic Algorithms</a></li>
<li><a href="#index-qnvisits-269"><code>qnvisits</code></a>: <a href="#Utility-functions">Utility functions</a></li>
   </ul><div class="node">
<a name="Author-Index"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Function-Index">Function Index</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="unnumbered">Author Index</h2>



<ul class="index-au" compact>
<li><a href="#index-Akyildiz_002c-I_002e-F_002e-218">Akyildiz, I. F.</a>: <a href="#Algorithms-for-non-Product_002dform-QNs">Algorithms for non Product-form QNs</a></li>
<li><a href="#index-Bard_002c-Y_002e-200">Bard, Y.</a>: <a href="#Algorithms-for-Product_002dForm-QNs">Algorithms for Product-Form QNs</a></li>
<li><a href="#index-Bolch_002c-G_002e-92">Bolch, G.</a>: <a href="#Algorithms-for-Product_002dForm-QNs">Algorithms for Product-Form QNs</a></li>
<li><a href="#index-Bolch_002c-G_002e-67">Bolch, G.</a>: <a href="#The-Asymmetric-M_002fM_002fm-System">The Asymmetric M/M/m System</a></li>
<li><a href="#index-Bolch_002c-G_002e-61">Bolch, G.</a>: <a href="#The-M_002fM_002fm_002fK-System">The M/M/m/K System</a></li>
<li><a href="#index-Bolch_002c-G_002e-53">Bolch, G.</a>: <a href="#The-M_002fM_002finf-System">The M/M/inf System</a></li>
<li><a href="#index-Bolch_002c-G_002e-46">Bolch, G.</a>: <a href="#The-M_002fM_002fm-System">The M/M/m System</a></li>
<li><a href="#index-Bolch_002c-G_002e-39">Bolch, G.</a>: <a href="#The-M_002fM_002f1-System">The M/M/1 System</a></li>
<li><a href="#index-Bolch_002c-G_002e-29">Bolch, G.</a>: <a href="#Expected-Time-to-Absorption">Expected Time to Absorption</a></li>
<li><a href="#index-Buzen_002c-J_002e-P_002e-101">Buzen, J. P.</a>: <a href="#Algorithms-for-Product_002dForm-QNs">Algorithms for Product-Form QNs</a></li>
<li><a href="#index-Casale_002c-G_002e-256">Casale, G.</a>: <a href="#Bounds-on-performance">Bounds on performance</a></li>
<li><a href="#index-Casale_002c-G_002e-159">Casale, G.</a>: <a href="#Algorithms-for-Product_002dForm-QNs">Algorithms for Product-Form QNs</a></li>
<li><a href="#index-de-Meer_002c-H_002e-94">de Meer, H.</a>: <a href="#Algorithms-for-Product_002dForm-QNs">Algorithms for Product-Form QNs</a></li>
<li><a href="#index-de-Meer_002c-H_002e-69">de Meer, H.</a>: <a href="#The-Asymmetric-M_002fM_002fm-System">The Asymmetric M/M/m System</a></li>
<li><a href="#index-de-Meer_002c-H_002e-63">de Meer, H.</a>: <a href="#The-M_002fM_002fm_002fK-System">The M/M/m/K System</a></li>
<li><a href="#index-de-Meer_002c-H_002e-55">de Meer, H.</a>: <a href="#The-M_002fM_002finf-System">The M/M/inf System</a></li>
<li><a href="#index-de-Meer_002c-H_002e-48">de Meer, H.</a>: <a href="#The-M_002fM_002fm-System">The M/M/m System</a></li>
<li><a href="#index-de-Meer_002c-H_002e-41">de Meer, H.</a>: <a href="#The-M_002fM_002f1-System">The M/M/1 System</a></li>
<li><a href="#index-de-Meer_002c-H_002e-31">de Meer, H.</a>: <a href="#Expected-Time-to-Absorption">Expected Time to Absorption</a></li>
<li><a href="#index-Graham_002c-G_002e-S_002e-232">Graham, G. S.</a>: <a href="#Bounds-on-performance">Bounds on performance</a></li>
<li><a href="#index-Graham_002c-G_002e-S_002e-131">Graham, G. S.</a>: <a href="#Algorithms-for-Product_002dForm-QNs">Algorithms for Product-Form QNs</a></li>
<li><a href="#index-Greiner_002c-S_002e-93">Greiner, S.</a>: <a href="#Algorithms-for-Product_002dForm-QNs">Algorithms for Product-Form QNs</a></li>
<li><a href="#index-Greiner_002c-S_002e-68">Greiner, S.</a>: <a href="#The-Asymmetric-M_002fM_002fm-System">The Asymmetric M/M/m System</a></li>
<li><a href="#index-Greiner_002c-S_002e-62">Greiner, S.</a>: <a href="#The-M_002fM_002fm_002fK-System">The M/M/m/K System</a></li>
<li><a href="#index-Greiner_002c-S_002e-54">Greiner, S.</a>: <a href="#The-M_002fM_002finf-System">The M/M/inf System</a></li>
<li><a href="#index-Greiner_002c-S_002e-47">Greiner, S.</a>: <a href="#The-M_002fM_002fm-System">The M/M/m System</a></li>
<li><a href="#index-Greiner_002c-S_002e-40">Greiner, S.</a>: <a href="#The-M_002fM_002f1-System">The M/M/1 System</a></li>
<li><a href="#index-Greiner_002c-S_002e-30">Greiner, S.</a>: <a href="#Expected-Time-to-Absorption">Expected Time to Absorption</a></li>
<li><a href="#index-Hsieh_002c-C_002e-H-254">Hsieh, C. H</a>: <a href="#Bounds-on-performance">Bounds on performance</a></li>
<li><a href="#index-Jain_002c-R_002e-141">Jain, R.</a>: <a href="#Algorithms-for-Product_002dForm-QNs">Algorithms for Product-Form QNs</a></li>
<li><a href="#index-Kobayashi_002c-H_002e-113">Kobayashi, H.</a>: <a href="#Algorithms-for-Product_002dForm-QNs">Algorithms for Product-Form QNs</a></li>
<li><a href="#index-Lam_002c-S_002e-255">Lam, S.</a>: <a href="#Bounds-on-performance">Bounds on performance</a></li>
<li><a href="#index-Lavenberg_002c-S_002e-S_002e-140">Lavenberg, S. S.</a>: <a href="#Algorithms-for-Product_002dForm-QNs">Algorithms for Product-Form QNs</a></li>
<li><a href="#index-Lazowska_002c-E_002e-D_002e-230">Lazowska, E. D.</a>: <a href="#Bounds-on-performance">Bounds on performance</a></li>
<li><a href="#index-Lazowska_002c-E_002e-D_002e-129">Lazowska, E. D.</a>: <a href="#Algorithms-for-Product_002dForm-QNs">Algorithms for Product-Form QNs</a></li>
<li><a href="#index-Muntz_002c-R_002e-R_002e-257">Muntz, R. R.</a>: <a href="#Bounds-on-performance">Bounds on performance</a></li>
<li><a href="#index-Reiser_002c-M_002e-112">Reiser, M.</a>: <a href="#Algorithms-for-Product_002dForm-QNs">Algorithms for Product-Form QNs</a></li>
<li><a href="#index-Santini_002c-S_002e-275">Santini, S.</a>: <a href="#Utility-functions">Utility functions</a></li>
<li><a href="#index-Schweitzer_002c-P_002e-201">Schweitzer, P.</a>: <a href="#Algorithms-for-Product_002dForm-QNs">Algorithms for Product-Form QNs</a></li>
<li><a href="#index-Schwetman_002c-H_002e-274">Schwetman, H.</a>: <a href="#Utility-functions">Utility functions</a></li>
<li><a href="#index-Schwetman_002c-H_002e-111">Schwetman, H.</a>: <a href="#Algorithms-for-Product_002dForm-QNs">Algorithms for Product-Form QNs</a></li>
<li><a href="#index-Serazzi_002c-G_002e-258">Serazzi, G.</a>: <a href="#Bounds-on-performance">Bounds on performance</a></li>
<li><a href="#index-Sevcik_002c-K_002e-C_002e-233">Sevcik, K. C.</a>: <a href="#Bounds-on-performance">Bounds on performance</a></li>
<li><a href="#index-Sevcik_002c-K_002e-C_002e-132">Sevcik, K. C.</a>: <a href="#Algorithms-for-Product_002dForm-QNs">Algorithms for Product-Form QNs</a></li>
<li><a href="#index-Trivedi_002c-K_002e-95">Trivedi, K.</a>: <a href="#Algorithms-for-Product_002dForm-QNs">Algorithms for Product-Form QNs</a></li>
<li><a href="#index-Trivedi_002c-K_002e-70">Trivedi, K.</a>: <a href="#The-Asymmetric-M_002fM_002fm-System">The Asymmetric M/M/m System</a></li>
<li><a href="#index-Trivedi_002c-K_002e-64">Trivedi, K.</a>: <a href="#The-M_002fM_002fm_002fK-System">The M/M/m/K System</a></li>
<li><a href="#index-Trivedi_002c-K_002e-56">Trivedi, K.</a>: <a href="#The-M_002fM_002finf-System">The M/M/inf System</a></li>
<li><a href="#index-Trivedi_002c-K_002e-49">Trivedi, K.</a>: <a href="#The-M_002fM_002fm-System">The M/M/m System</a></li>
<li><a href="#index-Trivedi_002c-K_002e-42">Trivedi, K.</a>: <a href="#The-M_002fM_002f1-System">The M/M/1 System</a></li>
<li><a href="#index-Trivedi_002c-K_002e-32">Trivedi, K.</a>: <a href="#Expected-Time-to-Absorption">Expected Time to Absorption</a></li>
<li><a href="#index-Wong_002c-E_002e-280">Wong, E.</a>: <a href="#Utility-functions">Utility functions</a></li>
<li><a href="#index-Zahorjan_002c-J_002e-279">Zahorjan, J.</a>: <a href="#Utility-functions">Utility functions</a></li>
<li><a href="#index-Zahorjan_002c-J_002e-231">Zahorjan, J.</a>: <a href="#Bounds-on-performance">Bounds on performance</a></li>
<li><a href="#index-Zahorjan_002c-J_002e-130">Zahorjan, J.</a>: <a href="#Algorithms-for-Product_002dForm-QNs">Algorithms for Product-Form QNs</a></li>
   </ul></body></html>

