diff -urN -x *.o -x *.dll -x *.a -x *.exe -x *.def -x Makefile -x config.log -x configure -x config.status -x config.h glob-1.0-orig/Makefile.in glob-1.0/Makefile.in
--- glob-1.0-orig/Makefile.in	Wed Sep 14 11:57:57 2005
+++ glob-1.0/Makefile.in	Fri Jun 15 22:17:29 2007
@@ -40,12 +40,21 @@
 RANLIB = @RANLIB@
 
 .PHONY: all
-all: libglob.a
+all: libglob.a glob.dll
 
 libglob.a: glob.o fnmatch.o $(ALLOCA)
 	$(AR) $(ARFLAGS) $@ glob.o fnmatch.o $(ALLOCA)
 	$(RANLIB) $@
 
+glob.dll : libglob.a
+	$(CC) -shared -o $@ \
+		-Wl,--export-all-symbols \
+		-Wl,--whole-archive $< \
+		-Wl,--out-implib,$(basename $<).dll.a \
+		-Wl,--output-def,$(basename $<).def \
+		-Wl,--no-whole-archive 
+	strip $(STRIP_FLAGS) $@
+
 # For some reason, Unix make wants the dependencies on the source files.
 # Otherwise it refuses to use an implicit rule!
 # And, get this: it doesn't work to use $(srcdir)/foo.c!!
@@ -58,7 +67,7 @@
 
 .PHONY: clean maintainer-clean glob-clean glob-maintainer-clean distclean
 clean glob-clean:
-	-rm -f libglob.a *.o core
+	-rm -f libglob.a *.o core glob.dll
 
 distclean glob-maintainer-clean: clean
 	-rm -f Makefile config.status config.cache config.h config.log
diff -urN -x *.o -x *.dll -x *.a -x *.exe -x *.def -x Makefile -x config.log -x configure -x config.status -x config.h glob-1.0-orig/glob.c glob-1.0/glob.c
--- glob-1.0-orig/glob.c	Wed Sep 14 11:57:57 2005
+++ glob-1.0/glob.c	Sun Jun 10 17:00:37 2007
@@ -506,7 +506,11 @@
     }
 
   /* Find the filename.  */
+#ifdef WINDOWS32
+  filename = strrchr (pattern, '\\');
+#else  
   filename = strrchr (pattern, '/');
+#endif  /* WINDOWS32 */  
 #if defined __MSDOS__ || defined WINDOWS32
   /* The case of "d:pattern".  Since `:' is not allowed in
      file names, we can safely assume that wherever it
@@ -543,7 +547,11 @@
   else if (filename == pattern)
     {
       /* "/pattern".  */
+#ifdef WINDOWS32
+      dirname = "\\";
+#else
       dirname = "/";
+#endif
       dirlen = 1;
       ++filename;
     }
@@ -588,7 +596,7 @@
 #if defined __MSDOS__ || defined WINDOWS32
           && dirname[dirlen - 1] != ':'
 	  && (dirlen < 3 || dirname[dirlen - 2] != ':'
-	      || dirname[dirlen - 1] != '/')
+	      || dirname[dirlen - 1] != '\\')
 #endif
 	  && dirlen > 1)
 	/* "pattern/".  Expand "pattern", appending slashes.  */
@@ -612,7 +620,13 @@
 #ifndef VMS
   if ((flags & (GLOB_TILDE|GLOB_TILDE_CHECK)) && dirname[0] == '~')
     {
-      if (dirname[1] == '\0' || dirname[1] == '/')
+      if (dirname[1] == '\0' || 
+#ifdef WINDOWS32      
+          dirname[1] == '\\'
+#else
+          dirname[1] == '/'
+#endif
+	 )
 	{
 	  /* Look up home directory.  */
 #ifdef VMS
@@ -968,13 +982,24 @@
 		    }
 
 #ifdef HAVE_MEMPCPY
+ #ifdef WINDOWS32
 		  mempcpy (mempcpy (mempcpy (pglob->gl_pathv[pglob->gl_pathc],
 					     dir, dir_len),
+				    "\\", 1),
+			   filename, filename_len);
+ #else
+ 		  mempcpy (mempcpy (mempcpy (pglob->gl_pathv[pglob->gl_pathc],
+					     dir, dir_len),
 				    "/", 1),
 			   filename, filename_len);
+ #endif
 #else
 		  memcpy (pglob->gl_pathv[pglob->gl_pathc], dir, dir_len);
+#ifdef WINDOWS32
+		  pglob->gl_pathv[pglob->gl_pathc][dir_len] = '\\';
+#else
 		  pglob->gl_pathv[pglob->gl_pathc][dir_len] = '/';
+#endif
 		  memcpy (&pglob->gl_pathv[pglob->gl_pathc][dir_len + 1],
 			  filename, filename_len);
 #endif
@@ -1039,7 +1064,11 @@
 		globfree (pglob);
 		return GLOB_NOSPACE;
 	      }
+#ifdef WINDOWS32
+	    strcpy (&new[len - 2], "\\");
+#else
 	    strcpy (&new[len - 2], "/");
+#endif
 	    pglob->gl_pathv[i] = new;
 	  }
     }
@@ -1109,20 +1138,20 @@
   register size_t i;
   size_t dirlen = strlen (dirname);
 #if defined __MSDOS__ || defined WINDOWS32
-  int sep_char = '/';
+  int sep_char = '\\';
 # define DIRSEP_CHAR sep_char
 #else
 # define DIRSEP_CHAR '/'
 #endif
 
-  if (dirlen == 1 && dirname[0] == '/')
+  if (dirlen == 1 && dirname[0] == sep_char)
     /* DIRNAME is just "/", so normal prepending would get us "//foo".
        We want "/foo" instead, so don't prepend any chars from DIRNAME.  */
     dirlen = 0;
 #if defined __MSDOS__ || defined WINDOWS32
   else if (dirlen > 1)
     {
-      if (dirname[dirlen - 1] == '/' && dirname[dirlen - 2] == ':')
+      if (dirname[dirlen - 1] == '\\' && dirname[dirlen - 2] == ':')
 	/* DIRNAME is "d:/".  Don't prepend the slash from DIRNAME.  */
 	--dirlen;
       else if (dirname[dirlen - 1] == ':')
@@ -1252,12 +1281,22 @@
 	  char *fullname = (char *) __alloca (dirlen + 1 + patlen + 1);
 
 # ifdef HAVE_MEMPCPY
+ #ifdef WINDOWS32
+	  mempcpy (mempcpy (mempcpy (fullname, directory, dirlen),
+			    "\\", 1),
+		   pattern, patlen + 1);
+ #else
 	  mempcpy (mempcpy (mempcpy (fullname, directory, dirlen),
 			    "/", 1),
 		   pattern, patlen + 1);
+ #endif
 # else
 	  memcpy (fullname, directory, dirlen);
+#ifdef WINDOWS32
+	  fullname[dirlen] = '\\';
+#else
 	  fullname[dirlen] = '/';
+#endif
 	  memcpy (&fullname[dirlen + 1], pattern, patlen + 1);
 # endif
 	  if (((flags & GLOB_ALTDIRFUNC)
