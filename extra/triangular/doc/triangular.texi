\input texinfo

@setfilename triangular.info

@settitle

@titlepage
@title  Communications Toolbox for Octave
@subtitle June 2007
@author David Bateman
@page
@vskip 0pt plus 1filll
Copyright @copyright{} 2007

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the same conditions as for modified versions.
@end titlepage

@contents

@ifinfo
@node Top, User Types in Oct-Files
@top
@end ifinfo

@menu
* User Types in Oct-Files::
@end menu

@node User Types in Oct-Files
@chapter User Types in Oct-Files

As Octave is written largely in C++, it can benefit from all of the
object oriented programming capabilities of the C++ language. This makes
it easy to add additional types to the Octave scripting language using
the overloading capabilities of the C++ language.

Any of the existing Octave classes might be used as a basis for a new
C++ class representing the new type. The basic class for the new user
type to inherit from is @code{octave_base_value}, that contains all the
default behaviors for the basic functionality of all Octave classes. 

The following pages includes a simple example of a user type in an
oct-file. It produces a new type for triangular matrices based on the
@code{octave_matrix} class, and overloads certain operators including
the left division operator, to allow rapid solution of linear equations
including triangular 

@example
@verbatiminclude uppertri.cc
@end example

It should be noted that the above class, is given as an example only, as
Octave includes the ability to identify triangular matrices and use
the appropriate method for the left division operator. It is however
useful as an example.

Before the new user type can be used, it has to be registered as a valid
Octave type. This is performed by the @code{register_type} method in the
@code{install_triangular} function above. The @code{install_triangular}
function also sets up the overloaded functions in the
@code{install_tri_ops} function.  A number of functions are overloaded,
including the transpose, unary operators and the left division
operators. Also note that there are three different assignment operators
defined.

Finally, the constructor functions are locked in to Octave memory with
the @code{mlock} function. The reason the constructor functions need to
be locked into memory is that

@example
@group
a = uppertri (randn (3,3));
clear uppertri
disp(a)
@end group
@end example

@noindent
would result in @code{a} being left defined, but the type it refers to
being cleared from Octave's memory. The next reference to @code{a}, will
then result in Octave exiting abnormally.

Note that in most ways user types have the same capabilities as any
other Octave type. There are a few minor points were user types
differ. Firstly, as the @code{octave_value} class has no knowledge of
the user type, extracting the user type from the @code{octave_value} or
setting the @code{octave_value} to the user type is necessarily
different. Extracting the user type from the @code{octave_value} is done
with 

@example
@group
const octave_triangular_matrix ((const octave_triangular_matrix&) 
        args(0).get_rep();
@end group
@end example

@noindent
and setting the @code{octave_value} is done with

@example
@group
octave_value retval = new octave_triangular_matrix (@dots{})
retval.maybe_mutate ();
@end group
@end example

It should be noted that the normal @code{octave_value} constructors call
the @code{maybe_mutate} method, that check whether the previous
operations should result in the type of the returned value being
changed, using the @code{try_narrowing_conversion} function. The
constructor functions in the example code, know the type won't change
and so can ignore te @code{maybe_mutate} functions.

Two other important functions in the above class are the @code{subsref}
and @code{subsasgn} functions. The @code{subsref} function is used for
indexed referencing of variable of the user type such as @code{a (1)},
@code{a.type} or even @code{a (1).type}. The @code{subsasgn} function is
similar, but is used for indexed assignments to the user type (ie. when
the variable is on the left-hand side of the assigment). 

It should be noted that to allow assignments such as

@example
@group
a = uppertri (@dots{});
a.type = @dots{};
@end group
@end example

@noindent
to work as expected, then the user type must be declared as a map by
having the @code{is_map} method return true. The use of  ".type" above
to reference the type of the triangular matrix, is not necessarily
recommended, but is rather an indication of how this type of indexing
might be implemented.

A final important function included in the above class is the
@code{numeric_conversion_function}. This returns a pointer to a
function, that converts the triangular matrix to a normal Octave
matrix. This allows the operators for normal Octave matrices to be
applied to the user defined triangular matrices, with the return type
being a normal Octave matrix type.

@bye
