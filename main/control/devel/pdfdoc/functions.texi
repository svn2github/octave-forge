@chapter Examples
@section MDSSystem

 Robust control of a mass-damper-spring system.
 Type @code{which MDSSystem} to locate,
 @code{edit MDSSystem} to open and simply
 @code{MDSSystem} to run the example file.
@section optiPID

 Numerical optimization of a PID controller using an objective function.
 The objective function is located in the file @command{optiPIDfun}.
 Type @code{which optiPID} to locate, @code{edit optiPID} to open
 and simply @code{optiPID} to run the example file.
@chapter Linear Time Invariant Models
@section dss

 @deftypefn {Function File} {@var{sys} =} dss (@var{sys})
 @deftypefnx {Function File} {@var{sys} =} dss (@var{d})
 @deftypefnx {Function File} {@var{sys} =} dss (@var{a}, @var{b}, @var{c}, @var{d}, @var{e}, @dots{})
 @deftypefnx {Function File} {@var{sys} =} dss (@var{a}, @var{b}, @var{c}, @var{d}, @var{e}, @var{tsam}, @dots{})
 Create or convert to descriptor state-space model.

 @strong{Inputs}
 @table @var
 @item sys
 LTI model to be converted to state-space.
 @item a
 State transition matrix (n-by-n).
 @item b
 Input matrix (n-by-m).
 @item c
 Measurement matrix (p-by-n).
 @item d
 Feedthrough matrix (p-by-m).
 @item e
 Descriptor matrix (n-by-n).
 @item tsam
 Sampling time in seconds.  If @var{tsam} is not specified, 
 a continuous-time model is assumed.
 @item @dots{}
 Optional pairs of properties and values.
 Type @command{set (dss)} for more information.
 @end table

 @strong{Outputs}
 @table @var
 @item sys
 Descriptor state-space model.
 @end table

 @strong{Equations}
 @example
 @group
   .
 E x = A x + B u
   y = C x + D u
 @end group
 @end example

 @seealso{ss, tf}
 @end deftypefn
@section frd

 @deftypefn {Function File} {@var{sys} =} frd (@var{sys})
 @deftypefnx {Function File} {@var{sys} =} frd (@var{sys}, @var{w})
 @deftypefnx {Function File} {@var{sys} =} frd (@var{H}, @var{w}, @dots{})
 @deftypefnx {Function File} {@var{sys} =} frd (@var{H}, @var{w}, @var{tsam}, @dots{})
 Create or convert to frequency response data.

 @strong{Inputs}
 @table @var
 @item sys
 LTI model to be converted to frequency response data.
 If second argument @var{w} is omitted, the interesting
 frequency range is calculated by the zeros and poles of @var{sys}.
 @item H
 Frequency response array (p-by-m-by-lw).  H(i,j,k) contains the
 response from input j to output i at frequency k.  In the SISO case,
 a vector (lw-by-1) or (1-by-lw) is accepted as well.
 @item w
 Frequency vector (lw-by-1) in radian per second [rad/s].
 Frequencies must be in ascending order.
 @item tsam
 Sampling time in seconds.  If @var{tsam} is not specified,
 a continuous-time model is assumed.
 @item @dots{}
 Optional pairs of properties and values.
 Type @command{set (frd)} for more information.
 @end table

 @strong{Outputs}
 @table @var
 @item sys
 Frequency response data object.
 @end table

 @seealso{dss, ss, tf}
 @end deftypefn
@section ss

 @deftypefn {Function File} {@var{sys} =} ss (@var{sys})
 @deftypefnx {Function File} {@var{sys} =} ss (@var{d})
 @deftypefnx {Function File} {@var{sys} =} ss (@var{a}, @var{b})
 @deftypefnx {Function File} {@var{sys} =} ss (@var{a}, @var{b}, @var{c})
 @deftypefnx {Function File} {@var{sys} =} ss (@var{a}, @var{b}, @var{c}, @var{d}, @dots{})
 @deftypefnx {Function File} {@var{sys} =} ss (@var{a}, @var{b}, @var{c}, @var{d}, @var{tsam}, @dots{})
 Create or convert to state-space model.

 @strong{Inputs}
 @table @var
 @item sys
 LTI model to be converted to state-space.
 @item a
 State transition matrix (n-by-n).
 @item b
 Input matrix (n-by-m).
 @item c
 Measurement matrix (p-by-n).
 If @var{c} is empty @code{[]} or not specified, an identity matrix is assumed.
 @item d
 Feedthrough matrix (p-by-m).
 If @var{d} is empty @code{[]} or not specified, a zero matrix is assumed.
 @item tsam
 Sampling time in seconds.  If @var{tsam} is not specified, a continuous-time model is assumed.
 @item @dots{}
 Optional pairs of properties and values.
 Type @command{set (ss)} for more information.
 @end table

 @strong{Outputs}
 @table @var
 @item sys
 State-space model.
 @end table

 @strong{Example}
 @example
 @group
 octave:1> a = [1 2 3; 4 5 6; 7 8 9];
 octave:2> b = [10; 11; 12];
 octave:3> stname = @{"V", "A", "kJ"@};
 octave:4> sys = ss (a, b, [], [], "stname", stname)
 
 sys.a =
         V   A  kJ
    V    1   2   3
    A    4   5   6
    kJ   7   8   9
 
 sys.b =
        u1
    V   10
    A   11
    kJ  12
 
 sys.c =
         V   A  kJ
    y1   1   0   0
    y2   0   1   0
    y3   0   0   1
 
 sys.d =
        u1
    y1   0
    y2   0
    y3   0
 
 Continuous-time model.
 octave:5> 
 @end group
 @end example

 @seealso{tf, dss}
 @end deftypefn
@section tf

 @deftypefn {Function File} {@var{s} =} tf (@var{"s"})
 @deftypefnx {Function File} {@var{z} =} tf (@var{"z"}, @var{tsam})
 @deftypefnx {Function File} {@var{sys} =} tf (@var{sys})
 @deftypefnx {Function File} {@var{sys} =} tf (@var{num}, @var{den}, @dots{})
 @deftypefnx {Function File} {@var{sys} =} tf (@var{num}, @var{den}, @var{tsam}, @dots{})
 Create or convert to transfer function model.

 @strong{Inputs}
 @table @var
 @item sys
 LTI model to be converted to transfer function.
 @item num
 Numerator or cell of numerators.  Each numerator must be a row vector
 containing the coefficients of the polynomial in descending powers of
 the transfer function variable.
 num@{i,j@} contains the numerator polynomial from input j to output i.
 In the SISO case, a single vector is accepted as well.
 @item den
 Denominator or cell of denominators.  Each denominator must be a row vector
 containing the coefficients of the polynomial in descending powers of
 the transfer function variable.
 den@{i,j@} contains the denominator polynomial from input j to output i.
 In the SISO case, a single vector is accepted as well.
 @item tsam
 Sampling time in seconds.  If @var{tsam} is not specified, a continuous-time
 model is assumed.
 @item @dots{}
 Optional pairs of properties and values.
 Type @command{set (tf)} for more information.
 @end table

 @strong{Outputs}
 @table @var
 @item sys
 Transfer function model.
 @end table

 @strong{Example}
 @example
 @group
 octave:1> s = tf ("s");
 octave:2> G = 1/(s+1)

 Transfer function "G" from input "u1" to output ...
 
         1  
  y1:  -----
       s + 1
 
 Continuous-time model.
 @end group
 @end example
 @example
 @group
 octave:3> z = tf ("z", 0.2);
 octave:4> H = 0.095/(z-0.9)
 
 Transfer function "H" from input "u1" to output ...
 
        0.095 
  y1:  -------
       z - 0.9
 
 Sampling time: 0.2 s
 Discrete-time model.
 @end group
 @end example
 @example
 @group
 octave:5> num = @{[1, 5, 7], [1]; [1, 7], [1, 5, 5]@};
 octave:6> den = @{[1, 5, 6], [1, 2]; [1, 8, 6], [1, 3, 2]@};
 octave:7> sys = tf (num, den)
 
 Transfer function "sys" from input "u1" to output ...
 
       s^2 + 5 s + 7
  y1:  -------------
       s^2 + 5 s + 6
 
           s + 7    
  y2:  -------------
       s^2 + 8 s + 6
 
 Transfer function "sys" from input "u2" to output ...
 
         1  
  y1:  -----
       s + 2
 
       s^2 + 5 s + 5
  y2:  -------------
       s^2 + 3 s + 2
 
 Continuous-time model.
 octave:8> 
 @end group
 @end example

 @seealso{ss, dss}
 @end deftypefn
@section zpk

 @deftypefn {Function File} {@var{s} =} zpk (@var{"s"})
 @deftypefnx {Function File} {@var{z} =} zpk (@var{"z"}, @var{tsam})
 @deftypefnx {Function File} {@var{sys} =} zpk (@var{sys})
 @deftypefnx {Function File} {@var{sys} =} zpk (@var{k})
 @deftypefnx {Function File} {@var{sys} =} zpk (@var{z}, @var{p}, @var{k}, @dots{})
 @deftypefnx {Function File} {@var{sys} =} zpk (@var{z}, @var{p}, @var{k}, @var{tsam}, @dots{})
 @deftypefnx {Function File} {@var{sys} =} zpk (@var{z}, @var{p}, @var{k}, @var{tsam}, @dots{})
 Create transfer function model from zero-pole-gain data.
 This is just a stop-gap compatibility wrapper since zpk
 models are not yet implemented.

 @strong{Inputs}
 @table @var
 @item sys
 LTI model to be converted to transfer function.
 @item z
 Cell of vectors containing the zeros for each channel.
 z@{i,j@} contains the zeros from input j to output i.
 In the SISO case, a single vector is accepted as well.
 @item p
 Cell of vectors containing the poles for each channel.
 p@{i,j@} contains the poles from input j to output i.
 In the SISO case, a single vector is accepted as well.
 @item k
 Matrix containing the gains for each channel.
 k(i,j) contains the gain from input j to output i.
 @item tsam
 Sampling time in seconds.  If @var{tsam} is not specified,
 a continuous-time model is assumed.
 @item @dots{}
 Optional pairs of properties and values.
 Type @command{set (tf)} for more information.
 @end table

 @strong{Outputs}
 @table @var
 @item sys
 Transfer function model.
 @end table

 @seealso{tf, ss, dss, frd}
 @end deftypefn
@chapter Model Data Access
@section @@lti/dssdata

 @deftypefn {Function File} {[@var{a}, @var{b}, @var{c}, @var{d}, @var{e}, @var{tsam}] =} dssdata (@var{sys})
 @deftypefnx {Function File} {[@var{a}, @var{b}, @var{c}, @var{d}, @var{e}, @var{tsam}] =} dssdata (@var{sys}, @var{[]})
 Access descriptor state-space model data.
 Argument @var{sys} is not limited to descriptor state-space models.
 If @var{sys} is not a descriptor state-space model, it is converted automatically.

 @strong{Inputs}
 @table @var
 @item sys
 Any type of LTI model.
 @item []
 In case @var{sys} is not a dss model (descriptor matrix @var{e} empty),
 @code{dssdata (sys, [])} returns the empty element @code{e = []} whereas
 @code{dssdata (sys)} returns the identity matrix @code{e = eye (size (a))}.
 @end table

 @strong{Outputs}
 @table @var
 @item a
 State transition matrix (n-by-n).
 @item b
 Input matrix (n-by-m).
 @item c
 Measurement matrix (p-by-n).
 @item d
 Feedthrough matrix (p-by-m).
 @item e
 Descriptor matrix (n-by-n).
 @item tsam
 Sampling time in seconds.  If @var{sys} is a continuous-time model,
 a zero is returned.
 @end table
 @end deftypefn
@section @@lti/frdata

 @deftypefn {Function File} {[@var{H}, @var{w}, @var{tsam}] =} frdata (@var{sys})
 @deftypefnx {Function File} {[@var{H}, @var{w}, @var{tsam}] =} frdata (@var{sys}, @var{"vector"})
 Access frequency response data.
 Argument @var{sys} is not limited to frequency response data objects.
 If @var{sys} is not a frd object, it is converted automatically.

 @strong{Inputs}
 @table @var
 @item sys
 Any type of LTI model.
 @item "v", "vector"
 In case @var{sys} is a SISO model, this option returns the frequency response
 as a column vector (lw-by-1) instead of an array (p-by-m-by-lw).
 @end table

 @strong{Outputs}
 @table @var
 @item H
 Frequency response array (p-by-m-by-lw).  H(i,j,k) contains the
 response from input j to output i at frequency k.  In the SISO case,
 a vector (lw-by-1) is possible as well.
 @item w
 Frequency vector (lw-by-1) in radian per second [rad/s].
 Frequencies are in ascending order.
 @item tsam
 Sampling time in seconds.  If @var{sys} is a continuous-time model,
 a zero is returned.
 @end table
 @end deftypefn
@section @@lti/get

 @deftypefn {Function File} get (@var{sys})
 @deftypefnx {Function File} {@var{value} =} get (@var{sys}, @var{"property"})
 Access property values of LTI objects.
 @end deftypefn
@section @@lti/set

 @deftypefn {Function File} set (@var{sys})
 @deftypefnx {Function File} {@var{sys} =} set (@var{sys}, @var{"property"}, @var{value})
 Set or modify properties of LTI objects.
 @end deftypefn
@section @@lti/ssdata

 @deftypefn {Function File} {[@var{a}, @var{b}, @var{c}, @var{d}, @var{tsam}] =} ssdata (@var{sys})
 Access state-space model data.
 Argument @var{sys} is not limited to state-space models.
 If @var{sys} is not a state-space model, it is converted automatically.

 @strong{Inputs}
 @table @var
 @item sys
 Any type of LTI model.
 @end table

 @strong{Outputs}
 @table @var
 @item a
 State transition matrix (n-by-n).
 @item b
 Input matrix (n-by-m).
 @item c
 Measurement matrix (p-by-n).
 @item d
 Feedthrough matrix (p-by-m).
 @item tsam
 Sampling time in seconds.  If @var{sys} is a continuous-time model,
 a zero is returned.
 @end table
 @end deftypefn
@section @@lti/tfdata

 @deftypefn {Function File} {[@var{num}, @var{den}, @var{tsam}] =} tfdata (@var{sys})
 @deftypefnx {Function File} {[@var{num}, @var{den}, @var{tsam}] =} tfdata (@var{sys}, @var{"vector"})
 @deftypefnx {Function File} {[@var{num}, @var{den}, @var{tsam}] =} tfdata (@var{sys}, @var{"tfpoly"})
 Access transfer function data.
 Argument @var{sys} is not limited to transfer function models.
 If @var{sys} is not a transfer function, it is converted automatically.

 @strong{Inputs}
 @table @var
 @item sys
 Any type of LTI model.
 @item "v", "vector"
 For SISO models, return @var{num} and @var{den} directly as column vectors
 instead of cells containing a single column vector.
 @end table

 @strong{Outputs}
 @table @var
 @item num
 Cell of numerator(s).  Each numerator is a row vector
 containing the coefficients of the polynomial in descending powers of
 the transfer function variable.
 num@{i,j@} contains the numerator polynomial from input j to output i.
 In the SISO case, a single vector is possible as well.
 @item den
 Cell of denominator(s).  Each denominator is a row vector
 containing the coefficients of the polynomial in descending powers of
 the transfer function variable.
 den@{i,j@} contains the denominator polynomial from input j to output i.
 In the SISO case, a single vector is possible as well.
 @item tsam
 Sampling time in seconds.  If @var{sys} is a continuous-time model,
 a zero is returned.
 @end table
 @end deftypefn
@section @@lti/zpkdata

 @deftypefn {Function File} {[@var{z}, @var{p}, @var{k}, @var{tsam}] =} zpkdata (@var{sys})
 @deftypefnx {Function File} {[@var{z}, @var{p}, @var{k}, @var{tsam}] =} zpkdata (@var{sys}, @var{"v"})
 Access zero-pole-gain data.

 @strong{Inputs}
 @table @var
 @item sys
 Any type of LTI model.
 @item "v", "vector"
 For SISO models, return @var{z} and @var{p} directly as column vectors
 instead of cells containing a single column vector.
 @end table

 @strong{Outputs}
 @table @var
 @item z
 Cell of column vectors containing the zeros for each channel.
 z@{i,j@} contains the zeros from input j to output i.
 @item p
 Cell of column vectors containing the poles for each channel.
 p@{i,j@} contains the poles from input j to output i.
 @item k
 Matrix containing the gains for each channel.
 k(i,j) contains the gain from input j to output i.
 @item tsam
 Sampling time in seconds.  If @var{sys} is a continuous-time model,
 a zero is returned.
 @end table
 @end deftypefn
@chapter Model Conversions
@section @@lti/c2d

 @deftypefn {Function File} {@var{sys} =} c2d (@var{sys}, @var{tsam})
 @deftypefnx {Function File} {@var{sys} =} c2d (@var{sys}, @var{tsam}, @var{method})
 @deftypefnx {Function File} {@var{sys} =} c2d (@var{sys}, @var{tsam}, @var{"prewarp"}, @var{w0})
 Convert the continuous lti model into its discrete-time equivalent.

 @strong{Inputs}
 @table @var
 @item sys
 Continuous-time LTI model.
 @item tsam
 Sampling time in seconds.
 @item method
 Optional conversion method.  If not specified, default method @var{"zoh"}
 is taken.
 @table @var
 @item "zoh"
 Zero-order hold or matrix exponential.
 @item "tustin", "bilin"
 Bilinear transformation or Tustin approximation.
 @item "prewarp"
 Bilinear transformation with pre-warping at frequency @var{w0}.
 @end table
 @end table

 @strong{Outputs}
 @table @var
 @item sys
 Discrete-time LTI model.
 @end table
 @end deftypefn
@section @@lti/d2c

 @deftypefn {Function File} {@var{sys} =} d2c (@var{sys})
 @deftypefnx {Function File} {@var{sys} =} d2c (@var{sys}, @var{method})
 @deftypefnx {Function File} {@var{sys} =} d2c (@var{sys}, @var{"prewarp"}, @var{w0})
 Convert the discrete lti model into its continuous-time equivalent.

 @strong{Inputs}
 @table @var
 @item sys
 Discrete-time LTI model.
 @item method
 Optional conversion method.  If not specified, default method @var{"zoh"}
 is taken.
 @table @var
 @item "zoh"
 Zero-order hold or matrix logarithm.
 @item "tustin", "bilin"
 Bilinear transformation or Tustin approximation.
 @item "prewarp"
 Bilinear transformation with pre-warping at frequency @var{w0}.
 @end table
 @end table

 @strong{Outputs}
 @table @var
 @item sys
 Continuous-time LTI model.
 @end table
 @end deftypefn
@section @@lti/prescale

 @deftypefn {Function File} {[@var{scaledsys}, @var{info}] =} prescale (@var{sys})
 Prescale state-space model.
 Frequency response commands perform automatic scaling unless model property
 @var{scaled} is set to @var{true}.

 @strong{Inputs}
 @table @var
 @item sys
 LTI model.
 @end table

 @strong{Outputs}
 @table @var
 @item scaledsys
 Scaled state-space model.
 @item info
 Structure containing additional information.
 @item info.SL
 Left scaling factors.  @code{Tl = diag (info.SL)}.
 @item info.SR
 Right scaling factors.  @code{Tr = diag (info.SR)}.
 @end table

 @strong{Equations}
 @example
 @group
 Es = Tl * E * Tr
 As = Tl * A * Tr
 Bs = Tl * B
 Cs =      C * Tr
 Ds =      D
 @end group
 @end example

 For proper state-space models, @var{Tl} and @var{Tr} are inverse of each other.

 @strong{Algorithm}@*
 Uses SLICOT TB01ID and TG01AD by courtesy of
 @uref{http://www.slicot.org, NICONET e.V.}.
 @end deftypefn
@section @@lti/xperm

 @deftypefn {Function File} {@var{sys} =} xperm (@var{sys}, @var{st_idx})
 Reorder states in state-space models.
 @end deftypefn
@chapter Model Interconnections
@section @@lti/append

 @deftypefn {Function File} {@var{sys} =} append (@var{sys1}, @var{sys2})
 Group LTI models by appending their inputs and outputs.
 @end deftypefn
@section @@lti/blkdiag

 @deftypefn {Function File} {@var{sys} =} blkdiag (@var{sys1}, @var{sys2})
 Block-diagonal concatenation of LTI models.
 @end deftypefn
@section @@lti/connect

 @deftypefn {Function File} {@var{sys} =} connect (@var{sys}, @var{cm}, @var{inputs}, @var{outputs})
 Arbitrary interconnections between the inputs and outputs of an LTI model.
 @end deftypefn
@section @@lti/feedback

 @deftypefn {Function File} {@var{sys} =} feedback (@var{sys1})
 @deftypefnx {Function File} {@var{sys} =} feedback (@var{sys1}, @var{"+"})
 @deftypefnx {Function File} {@var{sys} =} feedback (@var{sys1}, @var{sys2})
 @deftypefnx {Function File} {@var{sys} =} feedback (@var{sys1}, @var{sys2}, @var{"+"})
 @deftypefnx {Function File} {@var{sys} =} feedback (@var{sys1}, @var{sys2}, @var{feedin}, @var{feedout})
 @deftypefnx {Function File} {@var{sys} =} feedback (@var{sys1}, @var{sys2}, @var{feedin}, @var{feedout}, @var{"+"})
 Feedback connection of two LTI models.

 @strong{Inputs}
 @table @var
 @item sys1
 LTI model of forward transmission.  @code{[p1, m1] = size (sys1)}.
 @item sys2
 LTI model of backward transmission.
 If not specified, an identity matrix of appropriate size is taken.
 @item feedin
 Vector containing indices of inputs to @var{sys1} which are involved in the feedback loop.
 The number of @var{feedin} indices and outputs of @var{sys2} must be equal.
 If not specified, @code{1:m1} is taken.
 @item feedout
 Vector containing indices of outputs from @var{sys1} which are to be connected to @var{sys2}.
 The number of @var{feedout} indices and inputs of @var{sys2} must be equal.
 If not specified, @code{1:p1} is taken.
 @item "+"
 Positive feedback sign.  If not specified, @var{"-"} for a negative feedback interconnection
 is assumed.  @var{+1} and @var{-1} are possible as well, but only from the third argument
 onward due to ambiguity.
 @end table

 @strong{Outputs}
 @table @var
 @item sys
 Resulting LTI model.
 @end table

 @strong{Block Diagram}
 @example
 @group
  u    +         +--------+             y
 ------>(+)----->|  sys1  |-------+------->
         ^ -     +--------+       |
         |                        |
         |       +--------+       |
         +-------|  sys2  |<------+
                 +--------+
 @end group
 @end example
 @end deftypefn
@section @@lti/lft

 @deftypefn {Function File} {@var{sys} =} lft (@var{sys1}, @var{sys2})
 @deftypefnx {Function File} {@var{sys} =} lft (@var{sys1}, @var{sys2}, @var{nu}, @var{ny})
 Linear fractional tranformation, also known as Redheffer star product.

 @strong{Inputs}
 @table @var
 @item sys1
 Upper LTI model.
 @item sys2
 Lower LTI model.
 @item nu
 The last nu inputs of @var{sys1} are connected with the first nu outputs of @var{sys2}.
 If not specified, @code{min (m1, p2)} is taken.
 @item ny
 The last ny outputs of @var{sys1} are connected with the first ny inputs of @var{sys2}.
 If not specified, @code{min (p1, m2)} is taken.
 @end table

 @strong{Outputs}
 @table @var
 @item sys
 Resulting LTI model.
 @end table

 @strong{Block Diagram}
 @example
 @group
       .............sys..............
       :         +--------+         :
 w1 ------------>|        |------------> z1
       :         |  sys1  |         :
       : u +---->|        |-----+ y :
       :   |     +--------+     |   :          Lower LFT
       :   |                    |   :
       :   |     +--------+     |   :          lft (sys1, sys2)
       :   +-----|  sys2  |<----+   :
       :         +--------+         :
       :............................:
 @end group
 @end example
 @example
 @group
       .............sys..............
       :         +--------+         :
       : u +---->|  sys1  |-----+ y :
       :   |     +--------+     |   :          Upper LFT
       :   |                    |   :
       :   |     +--------+     |   :          lft (sys1, sys2)
       :   +-----|        |<----+   :
       :         |  sys2  |         :
 z2 <------------|        |<------------ w2
       :         +--------+         :
       :............................:
 @end group
 @end example
 @example
 @group
       .............sys..............
       :         +--------+         :
 w1 ------------>|        |------------> z1
       :         |  sys1  |         :
       : u +---->|        |-----+ y :
       :   |     +--------+     |   :
       :   |                    |   :          lft (sys1, sys2, nu, ny)
       :   |     +--------+     |   :
       :   +-----|        |<----+   :
       :         |  sys2  |         :
 z2 <------------|        |<------------ w2
       :         +--------+         :
       :............................: 
 @end group
 @end example
 @end deftypefn
@section @@lti/mconnect

 @deftypefn {Function File} {@var{sys} =} mconnect (@var{sys}, @var{m})
 @deftypefnx {Function File} {@var{sys} =} mconnect (@var{sys}, @var{m}, @var{inputs}, @var{outputs})
 Arbitrary interconnections between the inputs and outputs of an LTI model.

 @strong{Inputs}
 @table @var
 @item sys
 LTI system.
 @item m
 Connection matrix.  Each row belongs to an input and each column represents an output.
 @item inputs
 Vector of indices of those inputs which are retained.  If not specified, all inputs are kept.
 @item outputs
 Vector of indices of those outputs which are retained.  If not specified, all outputs are kept.
 @end table

 @strong{Outputs}
 @table @var
 @item sys
 Interconnected system.
 @end table

 @strong{Example}
 @example
 @group
 Solve the system equations of
 y(t) = G e(t)
 e(t) = u(t) + M y(t)
 in order to build
 y(t) = H u(t)
 The matrix M for a (p-by-m) system G
 has m rows and p columns (m-by-p).

 Example for a 3x2 system:
 u1 = -1*y1 + 5*y2 + 0*y3
 u2 = pi*y1 + 0*y2 - 7*y3

     | -1      5      0 |
 M = | pi      0      7 |
 @end group
 @end example
 @end deftypefn
@section @@lti/parallel

 @deftypefn{Function File} {@var{sys} =} parallel (@var{sys1}, @var{sys2})
 Parallel connection of two LTI systems.

 @strong{Block Diagram}
 @example
 @group
     ..........................
     :      +--------+        :
     :  +-->|  sys1  |---+    :
  u  :  |   +--------+   | +  :  y
 -------+                O--------->
     :  |   +--------+   | +  :
     :  +-->|  sys2  |---+    :
     :      +--------+        :
     :.........sys............:

 sys = parallel (sys1, sys2)
 @end group
 @end example
 @end deftypefn
@section @@lti/series

 @deftypefn {Function File} {@var{sys} =} series (@var{sys1}, @var{sys2})
 @deftypefnx {Function File} {@var{sys} =} series (@var{sys1}, @var{sys2}, @var{outputs1}, @var{inputs2})
 Series connection of two LTI models.

 @strong{Block Diagram}
 @example
 @group
     .....................................
  u  :  +--------+ y1    u2  +--------+  :  y
 ------>|  sys1  |---------->|  sys2  |------->
     :  +--------+           +--------+  :
     :................sys.................

 sys = series (sys1, sys2)
 @end group
 @end example
 @example
 @group
     .....................................
     :                   v2  +--------+  :
     :            ---------->|        |  :  y
     :  +--------+ y1    u2  |  sys2  |------->
  u  :  |        |---------->|        |  :
 ------>|  sys1  |       z1  +--------+  :
     :  |        |---------->            :
     :  +--------+                       :
     :................sys.................

 outputs1 = [1]
 inputs2 = [2]
 sys = series (sys1, sys2, outputs1, inputs2)
 @end group
 @end example
 @end deftypefn
@chapter Model Characteristics
@section ctrb

 @deftypefn {Function File} {@var{co} =} ctrb (@var{sys})
 @deftypefnx {Function File} {@var{co} =} ctrb (@var{a}, @var{b})
 Return controllability matrix.

 @strong{Inputs}
 @table @var
 @item sys
 LTI model.
 @item a
 State transition matrix (n-by-n).
 @item b
 Input matrix (n-by-m).
 @end table

 @strong{Outputs}
 @table @var
 @item co
 Controllability matrix.
 @end table

 @strong{Equation}
 @iftex
 @tex
 $$ C_o = [ B \ \ AB \ \ A^2B \ \ldots \ A^{n-1}B ] $$
 @end tex
 @end iftex
 @ifnottex
 @example
              2       n-1
 Co = [ B AB A B ... A   B ]
 @end example
 @end ifnottex
 @end deftypefn
@section ctrbf

 @deftypefn{Function File} {[@var{sysbar}, @var{T}, @var{K}] =} ctrbf (@var{sys})
 @deftypefnx{Function File} {[@var{sysbar}, @var{T}, @var{K}] =} ctrbf (@var{sys}, @var{tol})
 @deftypefnx{Function File} {[@var{Abar}, @var{Bbar}, @var{Cbar}, @var{T}, @var{K}] =} ctrbf (@var{A}, @var{B}, @var{C})
 @deftypefnx{Function File} {[@var{Abar}, @var{Bbar}, @var{Cbar}, @var{T}, @var{K}] =} ctrbf (@var{A}, @var{B}, @var{C}, @var{TOL})
 If Co=ctrb(A,B) has rank r <= n = SIZE(A,1), then there is a 
 similarity transformation Tc such that Tc = [t1 t2] where t1
 is the controllable subspace and t2 is orthogonal to t1

 @example
 @group
 Abar = Tc  A * Tc ,  Bbar = Tc  B ,  Cbar = C * Tc
 @end group
 @end example

 and the transformed system has the form

 @example
 @group
        | Ac    A12|           | Bc |
 Abar = |----------|,   Bbar = | ---|,  Cbar = [Cc | Cnc].
        | 0     Anc|           |  0 |
 @end group
 @end example
                                     
 where (Ac,Bc) is controllable, and Cc(sI-Ac)^(-1)Bc = C(sI-A)^(-1)B.
 and the system is stabilizable if Anc has no eigenvalues in
 the right half plane. The last output K is a vector of length n
 containing the number of controllable states.
 @end deftypefn
@section @@lti/dcgain

 @deftypefn {Function File} {@var{k} =} dcgain (@var{sys})
 DC gain of LTI model.

 @strong{Inputs}
 @table @var
 @item sys
 LTI system.
 @end table

 @strong{Outputs}
 @table @var
 @item k
 DC gain matrice.  For a system with m inputs and p outputs, the array @var{k}
 has dimensions [p, m].
 @end table

 @seealso{freqresp}
 @end deftypefn
@section gram

 @deftypefn {Function File} {@var{W} =} gram (@var{sys}, @var{mode})
 @deftypefnx {Function File} {@var{Wc} =} gram (@var{a}, @var{b})
 @code{gram (@var{sys}, "c")} returns the controllability gramian of
 the (continuous- or discrete-time) system @var{sys}.
 @code{gram (@var{sys}, "o")} returns the observability gramian of the
 (continuous- or discrete-time) system @var{sys}.
 @code{gram (@var{a}, @var{b})} returns the controllability gramian
 @var{Wc} of the continuous-time system @math{dx/dt = a x + b u};
 i.e., @var{Wc} satisfies @math{a Wc + m Wc' + b b' = 0}.

 @end deftypefn
@section hsvd

 @deftypefn{Function File} {@var{hsv} =} hsvd (@var{sys})
 @deftypefnx{Function File} {@var{hsv} =} hsvd (@var{sys}, @var{"offset"}, @var{offset})
 @deftypefnx{Function File} {@var{hsv} =} hsvd (@var{sys}, @var{"alpha"}, @var{alpha})
 Hankel singular values of the stable part of an LTI model.  If no output arguments are
 given, the Hankel singular values are displayed in a plot.

 @strong{Algorithm}@*
 Uses SLICOT AB13AD by courtesy of
 @uref{http://www.slicot.org, NICONET e.V.}
 @end deftypefn
@section @@lti/isct

 @deftypefn {Function File} {@var{bool} =} isct (@var{sys})
 Determine whether LTI model is a continuous-time system.

 @strong{Inputs}
 @table @var
 @item sys
 LTI system.
 @end table

 @strong{Outputs}
 @table @var
 @item bool = 0
 @var{sys} is a discrete-time system.
 @item bool = 1
 @var{sys} is a continuous-time system or a static gain.
 @end table
 @end deftypefn
@section isctrb

 @deftypefn {Function File} {[@var{bool}, @var{ncon}] =} isctrb (@var{sys})
 @deftypefnx {Function File} {[@var{bool}, @var{ncon}] =} isctrb (@var{sys}, @var{tol})
 @deftypefnx {Function File} {[@var{bool}, @var{ncon}] =} isctrb (@var{a}, @var{b})
 @deftypefnx {Function File} {[@var{bool}, @var{ncon}] =} isctrb (@var{a}, @var{b}, @var{e})
 @deftypefnx {Function File} {[@var{bool}, @var{ncon}] =} isctrb (@var{a}, @var{b}, @var{[]}, @var{tol})
 @deftypefnx {Function File} {[@var{bool}, @var{ncon}] =} isctrb (@var{a}, @var{b}, @var{e}, @var{tol})
 Logical check for system controllability.
 For numerical reasons, @code{isctrb (sys)}
 should be used instead of @code{rank (ctrb (sys))}.

 @strong{Inputs}
 @table @var
 @item sys
 LTI model.  Descriptor state-space models are possible.
 @item a
 State transition matrix.
 @item b
 Input matrix.
 @item e
 Descriptor matrix.
 @item tol
 Optional roundoff parameter.  Default value is 0.
 @end table

 @strong{Outputs}
 @table @var
 @item bool = 0
 System is not controllable.
 @item bool = 1
 System is controllable.
 @item ncon
 Number of controllable states.
 @end table

 @strong{Algorithm}@*
 Uses SLICOT AB01OD and TG01HD by courtesy of
 @uref{http://www.slicot.org, NICONET e.V.}

 @seealso{isobsv}
 @end deftypefn
@section isdetectable

 @deftypefn {Function File} {@var{bool} =} isdetectable (@var{sys})
 @deftypefnx {Function File} {@var{bool} =} isdetectable (@var{sys}, @var{tol})
 @deftypefnx {Function File} {@var{bool} =} isdetectable (@var{a}, @var{c})
 @deftypefnx {Function File} {@var{bool} =} isdetectable (@var{a}, @var{c}, @var{e})
 @deftypefnx {Function File} {@var{bool} =} isdetectable (@var{a}, @var{c}, @var{[]}, @var{tol})
 @deftypefnx {Function File} {@var{bool} =} isdetectable (@var{a}, @var{c}, @var{e}, @var{tol})
 @deftypefnx {Function File} {@var{bool} =} isdetectable (@var{a}, @var{c}, @var{[]}, @var{[]}, @var{dflg})
 @deftypefnx {Function File} {@var{bool} =} isdetectable (@var{a}, @var{c}, @var{e}, @var{[]}, @var{dflg})
 @deftypefnx {Function File} {@var{bool} =} isdetectable (@var{a}, @var{c}, @var{[]}, @var{tol}, @var{dflg})
 @deftypefnx {Function File} {@var{bool} =} isdetectable (@var{a}, @var{c}, @var{e}, @var{tol}, @var{dflg})
 Logical test for system detectability.
 All unstable modes must be observable or all unobservable states must be stable.

 @strong{Inputs}
 @table @var
 @item sys
 LTI system.
 @item a
 State transition matrix.
 @item c
 Measurement matrix.
 @item e
 Descriptor matrix.
 @item tol
 Optional tolerance for stability.  Default value is 0.
 @item dflg = 0
 Matrices (@var{a}, @var{c}) are part of a continuous-time system.  Default Value.
 @item dflg = 1
 Matrices (@var{a}, @var{c}) are part of a discrete-time system.
 @end table

 @strong{Outputs}
 @table @var
 @item bool = 0
 System is not detectable.
 @item bool = 1
 System is detectable.
 @end table


 @strong{Algorithm}@*
 Uses SLICOT AB01OD and TG01HD by courtesy of
 @uref{http://www.slicot.org, NICONET e.V.}
 See @command{isstabilizable} for description of computational method.
 @seealso{isstabilizable, isstable, isctrb, isobsv}
 @end deftypefn
@section @@lti/isdt

 @deftypefn {Function File} {@var{bool} =} isdt (@var{sys})
 Determine whether LTI model is a discrete-time system.

 @strong{Inputs}
 @table @var
 @item sys
 LTI system.
 @end table

 @strong{Outputs}
 @table @var
 @item bool = 0
 @var{sys} is a continuous-time system.
 @item bool = 1
 @var{sys} is a discrete-time system or a static gain.
 @end table
 @end deftypefn
@section @@lti/isminimumphase

 @deftypefn {Function File} {@var{bool} =} isminimumphase (@var{sys})
 @deftypefnx {Function File} {@var{bool} =} isminimumphase (@var{sys}, @var{tol})
 Determine whether LTI system is minimum phase.
 The zeros must lie in the left complex half-plane.
 The name minimum-phase refers to the fact that such a system has the
 minimum possible phase lag for the given magnitude response |sys(jw)|.
 @end deftypefn
@section isobsv

 @deftypefn {Function File} {[@var{bool}, @var{nobs}] =} isobsv (@var{sys})
 @deftypefnx {Function File} {[@var{bool}, @var{nobs}] =} isobsv (@var{sys}, @var{tol})
 @deftypefnx {Function File} {[@var{bool}, @var{nobs}] =} isobsv (@var{a}, @var{c})
 @deftypefnx {Function File} {[@var{bool}, @var{nobs}] =} isobsv (@var{a}, @var{c}, @var{e})
 @deftypefnx {Function File} {[@var{bool}, @var{nobs}] =} isobsv (@var{a}, @var{c}, @var{[]}, @var{tol})
 @deftypefnx {Function File} {[@var{bool}, @var{nobs}] =} isobsv (@var{a}, @var{c}, @var{e}, @var{tol})
 Logical check for system observability.
 For numerical reasons, @code{isobsv (sys)}
 should be used instead of @code{rank (obsv (sys))}.

 @strong{Inputs}
 @table @var
 @item sys
 LTI model.  Descriptor state-space models are possible.
 @item a
 State transition matrix.
 @item c
 Measurement matrix.
 @item e
 Descriptor matrix.
 @item tol
 Optional roundoff parameter.  Default value is 0.
 @end table

 @strong{Outputs}
 @table @var
 @item bool = 0
 System is not observable.
 @item bool = 1
 System is observable.
 @item nobs
 Number of observable states.
 @end table

 @strong{Algorithm}@*
 Uses SLICOT AB01OD and TG01HD by courtesy of
 @uref{http://www.slicot.org, NICONET e.V.}

 @seealso{isctrb}
 @end deftypefn
@section @@lti/issiso

 @deftypefn {Function File} {@var{bool} =} issiso (@var{sys})
 Determine whether LTI model is single-input/single-output (SISO).
 @end deftypefn
@section isstabilizable

 @deftypefn {Function File} {@var{bool} =} isstabilizable (@var{sys})
 @deftypefnx {Function File} {@var{bool} =} isstabilizable (@var{sys}, @var{tol})
 @deftypefnx {Function File} {@var{bool} =} isstabilizable (@var{a}, @var{b})
 @deftypefnx {Function File} {@var{bool} =} isstabilizable (@var{a}, @var{b}, @var{e})
 @deftypefnx {Function File} {@var{bool} =} isstabilizable (@var{a}, @var{b}, @var{[]}, @var{tol})
 @deftypefnx {Function File} {@var{bool} =} isstabilizable (@var{a}, @var{b}, @var{e}, @var{tol})
 @deftypefnx {Function File} {@var{bool} =} isstabilizable (@var{a}, @var{b}, @var{[]}, @var{[]}, @var{dflg})
 @deftypefnx {Function File} {@var{bool} =} isstabilizable (@var{a}, @var{b}, @var{e}, @var{[]}, @var{dflg})
 @deftypefnx {Function File} {@var{bool} =} isstabilizable (@var{a}, @var{b}, @var{[]}, @var{tol}, @var{dflg})
 @deftypefnx {Function File} {@var{bool} =} isstabilizable (@var{a}, @var{b}, @var{e}, @var{tol}, @var{dflg})
 Logical check for system stabilizability.
 All unstable modes must be controllable or all uncontrollable states must be stable.

 @strong{Inputs}
 @table @var
 @item sys
 LTI system.
 @item a
 State transition matrix.
 @item b
 Input matrix.
 @item e
 Descriptor matrix.
 @item tol
 Optional tolerance for stability.  Default value is 0.
 @item dflg = 0
 Matrices (@var{a}, @var{b}) are part of a continuous-time system.  Default Value.
 @item dflg = 1
 Matrices (@var{a}, @var{b}) are part of a discrete-time system.
 @end table

 @strong{Outputs}
 @table @var
 @item bool = 0
 System is not stabilizable.
 @item bool = 1
 System is stabilizable.
 @end table

 @strong{Algorithm}@*
 Uses SLICOT AB01OD and TG01HD by courtesy of
 @uref{http://www.slicot.org, NICONET e.V.}
 @example
 @group
 * Calculate staircase form (SLICOT AB01OD)
 * Extract unobservable part of state transition matrix
 * Calculate eigenvalues of unobservable part
 * Check whether
   real (ev) < -tol*(1 + abs (ev))   continuous-time
   abs (ev) < 1 - tol                discrete-time
 @end group
 @end example
 @seealso{isdetectable, isstable, isctrb, isobsv}
 @end deftypefn
@section @@lti/isstable

 @deftypefn {Function File} {@var{bool} =} isstable (@var{sys})
 @deftypefnx {Function File} {@var{bool} =} isstable (@var{sys}, @var{tol})
 Determine whether LTI system is stable.
 @end deftypefn
@section @@lti/norm

 @deftypefn {Function File} {@var{gain} =} norm (@var{sys}, @var{2})
 @deftypefnx {Function File} {[@var{gain}, @var{wpeak}] =} norm (@var{sys}, @var{inf})
 @deftypefnx {Function File} {[@var{gain}, @var{wpeak}] =} norm (@var{sys}, @var{inf}, @var{tol})
 Return H-2 or L-inf norm of LTI model.

 @strong{Algorithm}@*
 Uses SLICOT AB13BD and AB13DD by courtesy of
 @uref{http://www.slicot.org, NICONET e.V.}
 @end deftypefn
@section obsv

 @deftypefn {Function File} {@var{ob} =} obsv (@var{sys})
 @deftypefnx {Function File} {@var{ob} =} obsv (@var{a}, @var{c})
 Return observability matrix.

 @strong{Inputs}
 @table @var
 @item sys
 LTI model.
 @item a
 State transition matrix (n-by-n).
 @item c
 Measurement matrix (p-by-n).
 @end table

 @strong{Outputs}
 @table @var
 @item ob
 Observability matrix.
 @end table

 @strong{Equation}
 @iftex
 @tex
 $$ O_b = \left[ \matrix{  C       \cr
                             CA    \cr
                             CA^2  \cr
                             \vdots  \cr
                             CA^{n-1} } \right ] $$
 @end tex
 @end iftex
 @ifnottex
 @example
 @group
      | C        |
      | CA       |
 Ob = | CA^2     |
      | ...      |
      | CA^(n-1) |
 @end group
 @end example
 @end ifnottex
 @end deftypefn
@section obsvf

 @deftypefn{Function File} {[@var{sysbar}, @var{T}, @var{K}] =} obsvf (@var{sys})
 @deftypefnx{Function File} {[@var{sysbar}, @var{T}, @var{K}] =} obsvf (@var{sys}, @var{tol})
 @deftypefnx{Function File} {[@var{Abar}, @var{Bbar}, @var{Cbar}, @var{T}, @var{K}] =} obsvf (@var{A}, @var{B}, @var{C})
 @deftypefnx{Function File} {[@var{Abar}, @var{Bbar}, @var{Cbar}, @var{T}, @var{K}] =} obsvf (@var{A}, @var{B}, @var{C}, @var{TOL})
 If Ob=obsv(A,C) has rank r <= n = SIZE(A,1), then there is a 
 similarity transformation Tc such that To = [t1;t2] where t1 is c
 and t2 is orthogonal to t1

 @example
 @group
 Abar = To  A * To ,  Bbar = To  B ,  Cbar = C * To
 @end group
 @end example
 
 and the transformed system has the form

 @example
 @group
        | Ao     0 |           | Bo  |
 Abar = |----------|,   Bbar = | --- |,  Cbar = [Co | 0 ].
        | A21   Ano|           | Bno |
 @end group
 @end example
                                                      
 where (Ao,Bo) is observable, and Co(sI-Ao)^(-1)Bo = C(sI-A)^(-1)B. And 
 system is detectable if Ano has no eigenvalues in the right 
 half plane. The last output K is a vector of length n containing the 
 number of observable states.
 @end deftypefn
@section @@lti/pole

 @deftypefn {Function File} {@var{p} =} pole (@var{sys})
 Compute poles of LTI system.

 @strong{Inputs}
 @table @var
 @item sys
 LTI model.
 @end table

 @strong{Outputs}
 @table @var
 @item p
 Poles of @var{sys}.
 @end table
 @end deftypefn
@section pzmap

 @deftypefn {Function File} pzmap (@var{sys})
 @deftypefnx {Function File} {[@var{p}, @var{z}] =} pzmap (@var{sys})
 Plot the poles and zeros of an LTI system in the complex plane.
 If no output arguments are given, the result is plotted on the screen.
 Otherwise, the poles and zeros are computed and returned.

 @strong{Inputs}
 @table @var
 @item sys
 LTI model.
 @end table

 @strong{Outputs}
 @table @var
 @item p
 Poles of @var{sys}.
 @item z
 Transmission zeros of @var{sys}.
 @end table
 @end deftypefn
@section @@lti/size

 @deftypefn {Function File} {@var{nvec} =} size (@var{sys})
 @deftypefnx {Function File} {@var{n} =} size (@var{sys}, @var{dim})
 @deftypefnx {Function File} {[@var{p}, @var{m}] =} size (@var{sys})
 LTI model size, i.e. number of outputs and inputs.

 @strong{Inputs}
 @table @var
 @item sys
 LTI system.
 @item dim
 If given a second argument, @command{size} will return the size of the
 corresponding dimension.
 @end table

 @strong{Outputs}
 @table @var
 @item nvec
 Row vector.  The first element is the number of outputs (rows) and the second
 element the number of inputs (columns).
 @item n
 Scalar value.  The size of the dimension @var{dim}.
 @item p
 Number of outputs.
 @item m
 Number of inputs.
 @end table
 @end deftypefn
@section @@lti/zero

 @deftypefn {Function File} {@var{z} =} zero (@var{sys})
 @deftypefnx {Function File} {[@var{z}, @var{k}] =} zero (@var{sys})
 Compute transmission zeros and gain of LTI model.

 @strong{Inputs}
 @table @var
 @item sys
 LTI model.
 @end table

 @strong{Outputs}
 @table @var
 @item z
 Transmission zeros of @var{sys}.
 @item k
 Gain of @var{sys}.
 @end table
 @end deftypefn
@chapter Model Simplification
@section @@lti/minreal

 @deftypefn {Function File} {@var{sys} =} minreal (@var{sys})
 @deftypefnx {Function File} {@var{sys} =} minreal (@var{sys}, @var{tol})
 Minimal realization or zero-pole cancellation of LTI models.
 @end deftypefn
@section @@lti/sminreal

 @deftypefn {Function File} {@var{sys} =} sminreal (@var{sys})
 @deftypefnx {Function File} {@var{sys} =} sminreal (@var{sys}, @var{tol})
 Perform state-space model reduction based on structure.
 Remove states which have no influence on the input-output behaviour.
 The physical meaning of the states is retained.

 @strong{Inputs}
 @table @var
 @item sys
 State-space model.
 @item tol
 Optional tolerance for controllability and observability. 
 Entries of the state-space matrices whose moduli are less or equal to @var{tol}
 are assumed to be zero.  Default value is 0.
 @end table

 @strong{Outputs}
 @table @var
 @item sys
 Reduced state-space model.
 @end table

 @seealso{minreal}
 @end deftypefn
@chapter Time Domain Analysis
@section covar

 @deftypefn{Function File} {[@var{p}, @var{q}] =} covar (@var{sys}, @var{w})
 Return the steady-state covariance.

 @strong{Inputs}
 @table @var
 @item sys
 LTI model.
 @item w
 Intensity of white noise inputs which drive @var{sys}.
 @end table

 @strong{Outputs}
 @table @var
 @item p
 Output covariance.
 @item q
 State covariance.
 @end table

 @seealso{lyap, dlyap}
 @end deftypefn
@section gensig

 @deftypefn{Function File} {[@var{u}, @var{t}] =} gensig (@var{sigtype}, @var{tau})
 @deftypefnx{Function File} {[@var{u}, @var{t}] =} gensig (@var{sigtype}, @var{tau}, @var{tfinal})
 @deftypefnx{Function File} {[@var{u}, @var{t}] =} gensig (@var{sigtype}, @var{tau}, @var{tfinal}, @var{tsam})
 Generate periodic signal.  Useful in combination with lsim.

 @strong{Inputs}
 @table @var
 @item sigtype = "sin"
 Sine wave.
 @item sigtype = "cos"
 Cosine wave.
 @item sigtype = "square"
 Square wave.
 @item sigtype = "pulse"
 Periodic pulse.
 @item tau
 Duration of one period in seconds.
 @item tfinal
 Optional duration of the signal in seconds.  Default duration is 5 periods.
 @item tsam
 Optional sampling time in seconds.  Default spacing is tau/64.
 @end table

 @strong{Outputs}
 @table @var
 @item u
 Vector of signal values.
 @item t
 Time vector of the signal.
 @end table

 @seealso{lsim}
 @end deftypefn
@section impulse

 @deftypefn{Function File} {[@var{y}, @var{t}, @var{x}] =} impulse (@var{sys})
 @deftypefnx{Function File} {[@var{y}, @var{t}, @var{x}] =} impulse (@var{sys}, @var{t})
 @deftypefnx{Function File} {[@var{y}, @var{t}, @var{x}] =} impulse (@var{sys}, @var{tfinal})
 @deftypefnx{Function File} {[@var{y}, @var{t}, @var{x}] =} impulse (@var{sys}, @var{tfinal}, @var{dt})
 Impulse response of LTI system.
 If no output arguments are given, the response is printed on the screen.

 @strong{Inputs}
 @table @var
 @item sys
 LTI model.
 @item t
 Time vector.  Should be evenly spaced.  If not specified, it is calculated by
 the poles of the system to reflect adequately the response transients.
 @item tfinal
 Optional simulation horizon.  If not specified, it is calculated by
 the poles of the system to reflect adequately the response transients.
 @item dt
 Optional sampling time.  Be sure to choose it small enough to capture transient
 phenomena.  If not specified, it is calculated by the poles of the system.
 @end table

 @strong{Outputs}
 @table @var
 @item y
 Output response array.  Has as many rows as time samples (length of t)
 and as many columns as outputs.
 @item t
 Time row vector.
 @item x
 State trajectories array.  Has @code{length (t)} rows and as many columns as states.
 @end table

 @seealso{initial, lsim, step}
 @end deftypefn
@section initial

 @deftypefn{Function File} {[@var{y}, @var{t}, @var{x}] =} initial (@var{sys}, @var{x0})
 @deftypefnx{Function File} {[@var{y}, @var{t}, @var{x}] =} initial (@var{sys}, @var{x0}, @var{t})
 @deftypefnx{Function File} {[@var{y}, @var{t}, @var{x}] =} initial (@var{sys}, @var{x0}, @var{tfinal})
 @deftypefnx{Function File} {[@var{y}, @var{t}, @var{x}] =} initial (@var{sys}, @var{x0}, @var{tfinal}, @var{dt})
 Initial condition response of state-space model.
 If no output arguments are given, the response is printed on the screen.

 @strong{Inputs}
 @table @var
 @item sys
 State-space model.
 @item x0
 Vector of initial conditions for each state.
 @item t
 Optional time vector.  Should be evenly spaced.  If not specified, it is calculated
 by the poles of the system to reflect adequately the response transients.
 @item tfinal
 Optional simulation horizon.  If not specified, it is calculated by
 the poles of the system to reflect adequately the response transients.
 @item dt
 Optional sampling time.  Be sure to choose it small enough to capture transient
 phenomena.  If not specified, it is calculated by the poles of the system.
 @end table

 @strong{Outputs}
 @table @var
 @item y
 Output response array.  Has as many rows as time samples (length of t)
 and as many columns as outputs.
 @item t
 Time row vector.
 @item x
 State trajectories array.  Has @code{length (t)} rows and as many columns as states.
 @end table

 @strong{Example}
 @example
 @group
                    .
 Continuous Time:   x = A x ,   y = C x ,   x(0) = x0

 Discrete Time:   x[k+1] = A x[k] ,   y[k] = C x[k] ,   x[0] = x0
 @end group
 @end example

 @seealso{impulse, lsim, step}
 @end deftypefn
@section lsim

 @deftypefn{Function File} {[@var{y}, @var{t}, @var{x}] =} lsim (@var{sys}, @var{u})
 @deftypefnx{Function File} {[@var{y}, @var{t}, @var{x}] =} lsim (@var{sys}, @var{u}, @var{t})
 @deftypefnx{Function File} {[@var{y}, @var{t}, @var{x}] =} lsim (@var{sys}, @var{u}, @var{t}, @var{x0})
 @deftypefnx{Function File} {[@var{y}, @var{t}, @var{x}] =} lsim (@var{sys}, @var{u}, @var{t}, @var{[]}, @var{method})
 @deftypefnx{Function File} {[@var{y}, @var{t}, @var{x}] =} lsim (@var{sys}, @var{u}, @var{t}, @var{x0}, @var{method})
 Simulate LTI model response to arbitrary inputs.  If no output arguments are given,
 the system response is plotted on the screen.

 @strong{Inputs}
 @table @var
 @item sys
 LTI model.  System must be proper, i.e. it must not have more zeros than poles.
 @item u
 Vector or array of input signal.  Needs @code{length(t)} rows and as many columns
 as there are inputs.  If @var{sys} is a single-input system, row vectors @var{u}
 of length @code{length(t)} are accepted as well.
 @item t
 Time vector.  Should be evenly spaced.  If @var{sys} is a continuous-time system
 and @var{t} is a real scalar, @var{sys} is discretized with sampling time
 @code{tsam = t/(rows(u)-1)}.  If @var{sys} is a discrete-time system and @var{t}
 is not specified, vector @var{t} is assumed to be @code{0 : tsam : tsam*(rows(u)-1)}.
 @item x0
 Vector of initial conditions for each state.  If not specified, a zero vector is assumed.
 @item method
 Discretization method for continuous-time models.  Default value is zoh
 (zero-order hold).  All methods from @code{c2d} are supported. 
 @end table

 @strong{Outputs}
 @table @var
 @item y
 Output response array.  Has as many rows as time samples (length of t)
 and as many columns as outputs.
 @item t
 Time row vector.  It is always evenly spaced.
 @item x
 State trajectories array.  Has @code{length (t)} rows and as many columns as states.
 @end table

 @seealso{impulse, initial, step}
 @end deftypefn
@section step

 @deftypefn{Function File} {[@var{y}, @var{t}, @var{x}] =} step (@var{sys})
 @deftypefnx{Function File} {[@var{y}, @var{t}, @var{x}] =} step (@var{sys}, @var{t})
 @deftypefnx{Function File} {[@var{y}, @var{t}, @var{x}] =} step (@var{sys}, @var{tfinal})
 @deftypefnx{Function File} {[@var{y}, @var{t}, @var{x}] =} step (@var{sys}, @var{tfinal}, @var{dt})
 Step response of LTI system.
 If no output arguments are given, the response is printed on the screen.

 @strong{Inputs}
 @table @var
 @item sys
 LTI model.
 @item t
 Time vector.  Should be evenly spaced.  If not specified, it is calculated by
 the poles of the system to reflect adequately the response transients.
 @item tfinal
 Optional simulation horizon.  If not specified, it is calculated by
 the poles of the system to reflect adequately the response transients.
 @item dt
 Optional sampling time.  Be sure to choose it small enough to capture transient
 phenomena.  If not specified, it is calculated by the poles of the system.
 @end table

 @strong{Outputs}
 @table @var
 @item y
 Output response array.  Has as many rows as time samples (length of t)
 and as many columns as outputs.
 @item t
 Time row vector.
 @item x
 State trajectories array.  Has @code{length (t)} rows and as many columns as states.
 @end table

 @seealso{impulse, initial, lsim}
 @end deftypefn
@chapter Frequency Domain Analysis
@section bode

 @deftypefn {Function File} {[@var{mag}, @var{pha}, @var{w}] =} bode (@var{sys})
 @deftypefnx {Function File} {[@var{mag}, @var{pha}, @var{w}] =} bode (@var{sys}, @var{w})
 Bode diagram of frequency response.  If no output arguments are given,
 the response is printed on the screen.

 @strong{Inputs}
 @table @var
 @item sys
 LTI system.  Must be a single-input and single-output (SISO) system.
 @item w
 Optional vector of frequency values.  If @var{w} is not specified,
 it is calculated by the zeros and poles of the system.
 Alternatively, the cell @code{@{wmin, wmax@}} specifies a frequency range,
 where @var{wmin} and @var{wmax} denote minimum and maximum frequencies
 in rad/s.
 @end table

 @strong{Outputs}
 @table @var
 @item mag
 Vector of magnitude.  Has length of frequency vector @var{w}.
 @item pha
 Vector of phase.  Has length of frequency vector @var{w}.
 @item w
 Vector of frequency values used.
 @end table

 @seealso{nichols, nyquist, sigma}
 @end deftypefn
@section bodemag

 @deftypefn {Function File} {[@var{mag}, @var{w}] =} bodemag (@var{sys})
 @deftypefnx {Function File} {[@var{mag}, @var{w}] =} bodemag (@var{sys}, @var{w})
 Bode magnitude diagram of frequency response.  If no output arguments are given,
 the response is printed on the screen.

 @strong{Inputs}
 @table @var
 @item sys
 LTI system.  Must be a single-input and single-output (SISO) system.
 @item w
 Optional vector of frequency values.  If @var{w} is not specified,
 it is calculated by the zeros and poles of the system.
 Alternatively, the cell @code{@{wmin, wmax@}} specifies a frequency range,
 where @var{wmin} and @var{wmax} denote minimum and maximum frequencies
 in rad/s.
 @end table

 @strong{Outputs}
 @table @var
 @item mag
 Vector of magnitude.  Has length of frequency vector @var{w}.
 @item w
 Vector of frequency values used.
 @end table

 @seealso{bode, nichols, nyquist, sigma}
 @end deftypefn
@section @@lti/freqresp

 @deftypefn{Function File} {@var{H} =} freqresp (@var{sys}, @var{w})
 Evaluate frequency response at given frequencies.

 @strong{Inputs}
 @table @var
 @item sys
 LTI system.
 @item w
 Vector of frequency values.
 @end table

 @strong{Outputs}
 @table @var
 @item H
 Array of frequency response.  For a system with m inputs and p outputs, the array @var{H}
 has dimensions [p, m, length (w)].
 The frequency response at the frequency w(k) is given by H(:,:,k).
 @end table

 @seealso{dcgain}
 @end deftypefn
@section margin

 @deftypefn{Function File} {[@var{gamma}, @var{phi}, @var{w_gamma}, @var{w_phi}] =} margin (@var{sys})
 @deftypefnx{Function File} {[@var{gamma}, @var{phi}, @var{w_gamma}, @var{w_phi}] =} margin (@var{sys}, @var{tol})
 Gain and phase margin of a system.  If no output arguments are given, both gain and phase margin
 are plotted on a bode diagram.  Otherwise, the margins and their corresponding frequencies are
 computed and returned.

 @strong{Inputs}
 @table @var
 @item sys
 LTI model.  Must be a single-input and single-output (SISO) system.
 @item tol
 Imaginary parts below @var{tol} are assumed to be zero.
 If not specified, default value @code{sqrt (eps)} is taken.
 @end table

 @strong{Outputs}
 @table @var
 @item gamma
 Gain margin (as gain, not dBs).
 @item phi
 Phase margin (in degrees).
 @item w_gamma
 Frequency for the gain margin (in rad/s).
 @item w_phi
 Frequency for the phase margin (in rad/s).
 @end table

 @strong{Equations}
 @example
 @group
 CONTINUOUS SYSTEMS
 Gain Margin
         _               _
 L(jw) = L(jw)      BTW: L(jw) = L(-jw) = conj (L(jw))

 num(jw)   num(-jw)
 ------- = --------
 den(jw)   den(-jw)

 num(jw) den(-jw) = num(-jw) den(jw)

 imag (num(jw) den(-jw)) = 0
 imag (num(-jw) den(jw)) = 0
 @end group
 @end example
 @example
 @group
 Phase Margin
           |num(jw)|
 |L(jw)| = |-------| = 1
           |den(jw)|
   _     2      2
 z z = Re z + Im z

 num(jw)   num(-jw)
 ------- * -------- = 1
 den(jw)   den(-jw)

 num(jw) num(-jw) - den(jw) den(-jw) = 0

 real (num(jw) num(-jw) - den(jw) den(-jw)) = 0
 @end group
 @end example
 @example
 @group
 DISCRETE SYSTEMS
 Gain Margin
                              jwT         log z
 L(z) = L(1/z)      BTW: z = e    --> w = -----
                                           j T
 num(z)   num(1/z)
 ------ = --------
 den(z)   den(1/z)

 num(z) den(1/z) - num(1/z) den(z) = 0
 @end group
 @end example
 @example
 @group
 Phase Margin
          |num(z)|
 |L(z)| = |------| = 1
          |den(z)|

 L(z) L(1/z) = 1

 num(z)   num(1/z)
 ------ * -------- = 1
 den(z)   den(1/z)

 num(z) num(1/z) - den(z) den(1/z) = 0
 @end group
 @end example
 @example
 @group
 PS: How to get L(1/z)
           4       3       2
 p(z) = a z  +  b z  +  c z  +  d z  +  e

             -4      -3      -2      -1
 p(1/z) = a z  +  b z  +  c z  +  d z  +  e

           -4                    2       3       4
        = z   ( a  +  b z  +  c z  +  d z  +  e z  )

               4       3       2                     4
        = ( e z  +  d z  +  c z  +  b z  +  a ) / ( z  )
 @end group
 @end example

 @seealso{roots}
 @end deftypefn
@section nichols

 @deftypefn {Function File} {[@var{mag}, @var{pha}, @var{w}] =} nichols (@var{sys})
 @deftypefnx {Function File} {[@var{mag}, @var{pha}, @var{w}] =} nichols (@var{sys}, @var{w})
 Nichols chart of frequency response.  If no output arguments are given,
 the response is printed on the screen.

 @strong{Inputs}
 @table @var
 @item sys
 LTI system.  Must be a single-input and single-output (SISO) system.
 @item w
 Optional vector of frequency values.  If @var{w} is not specified,
 it is calculated by the zeros and poles of the system.
 Alternatively, the cell @code{@{wmin, wmax@}} specifies a frequency range,
 where @var{wmin} and @var{wmax} denote minimum and maximum frequencies
 in rad/s.
 @end table

 @strong{Outputs}
 @table @var
 @item mag
 Vector of magnitude.  Has length of frequency vector @var{w}.
 @item pha
 Vector of phase.  Has length of frequency vector @var{w}.
 @item w
 Vector of frequency values used.
 @end table

 @seealso{bode, nyquist, sigma}
 @end deftypefn
@section nyquist

 @deftypefn {Function File} {[@var{re}, @var{im}, @var{w}] =} nyquist (@var{sys})
 @deftypefnx {Function File} {[@var{re}, @var{im}, @var{w}] =} nyquist (@var{sys}, @var{w})
 Nyquist diagram of frequency response.  If no output arguments are given,
 the response is printed on the screen.

 @strong{Inputs}
 @table @var
 @item sys
 LTI system.  Must be a single-input and single-output (SISO) system.
 @item w
 Optional vector of frequency values.  If @var{w} is not specified,
 it is calculated by the zeros and poles of the system.
 Alternatively, the cell @code{@{wmin, wmax@}} specifies a frequency range,
 where @var{wmin} and @var{wmax} denote minimum and maximum frequencies
 in rad/s.
 @end table

 @strong{Outputs}
 @table @var
 @item re
 Vector of real parts.  Has length of frequency vector @var{w}.
 @item im
 Vector of imaginary parts.  Has length of frequency vector @var{w}.
 @item w
 Vector of frequency values used.
 @end table

 @seealso{bode, nichols, sigma}
 @end deftypefn
@section sigma

 @deftypefn{Function File} {[@var{sv}, @var{w}] =} sigma (@var{sys})
 @deftypefnx{Function File} {[@var{sv}, @var{w}] =} sigma (@var{sys}, @var{w})
 @deftypefnx{Function File} {[@var{sv}, @var{w}] =} sigma (@var{sys}, @var{[]}, @var{ptype})
 @deftypefnx{Function File} {[@var{sv}, @var{w}] =} sigma (@var{sys}, @var{w}, @var{ptype})
 Singular values of frequency response.  If no output arguments are given,
 the singular value plot is printed on the screen;

 @strong{Inputs}
 @table @var
 @item sys
 LTI system.  Multiple inputs and/or outputs (MIMO systems) make practical sense.
 @item w
 Optional vector of frequency values.  If @var{w} is not specified,
 it is calculated by the zeros and poles of the system.
 Alternatively, the cell @code{@{wmin, wmax@}} specifies a frequency range,
 where @var{wmin} and @var{wmax} denote minimum and maximum frequencies
 in rad/s.
 @item ptype = 0
 Singular values of the frequency response @var{H} of system @var{sys}.  Default Value.
 @item ptype = 1
 Singular values of the frequency response @code{inv(H)}; i.e. inversed system.
 @item ptype = 2
 Singular values of the frequency response @code{I + H}; i.e. inversed sensitivity
 (or return difference) if @code{H = P * C}.
 @item ptype = 3
 Singular values of the frequency response @code{I + inv(H)}; i.e. inversed complementary
 sensitivity if @code{H = P * C}.
 @end table

 @strong{Outputs}
 @table @var
 @item sv
 Array of singular values.  For a system with m inputs and p outputs, the array sv
 has @code{min (m, p)} rows and as many columns as frequency points @code{length (w)}.
 The singular values at the frequency @code{w(k)} are given by @code{sv(:,k)}.
 @item w
 Vector of frequency values used.
 @end table

 @seealso{bodemag, svd}
 @end deftypefn
@chapter Pole Placement
@section place

 @deftypefn {Function File} {@var{f} =} place (@var{sys}, @var{p})
 @deftypefnx {Function File} {@var{f} =} place (@var{a}, @var{b}, @var{p})
 @deftypefnx {Function File} {[@var{f}, @var{info}] =} place (@var{sys}, @var{p}, @var{alpha})
 @deftypefnx {Function File} {[@var{f}, @var{info}] =} place (@var{a}, @var{b}, @var{p}, @var{alpha})
 Pole assignment for a given matrix pair (@var{A},@var{B}) such that @code{p = eig (A-B*F)}.
 If parameter @var{alpha} is specified, poles with real parts (continuous-time)
 or moduli (discrete-time) below @var{alpha} are left untouched.

 @strong{Inputs}
 @table @var
 @item sys
 LTI system.
 @item a
 State transition matrix (n-by-n) of a continuous-time system.
 @item b
 Input matrix (n-by-m) of a continuous-time system.
 @item p
 Desired eigenvalues of the closed-loop system state-matrix @var{A-B*F}.
 @code{length (p) <= rows (A)}.
 @item alpha
 Specifies the maximum admissible value, either for real
 parts or for moduli, of the eigenvalues of @var{A} which will
 not be modified by the eigenvalue assignment algorithm.
 @code{alpha >= 0} for discrete-time systems.
 @end table

 @strong{Outputs}
 @table @var
 @item f
 State feedback gain matrix.
 @item info
 Structure containing additional information.
 @item info.nfp
 The number of fixed poles, i.e. eigenvalues of @var{A} having
 real parts less than @var{alpha}, or moduli less than @var{alpha}.
 These eigenvalues are not modified by @command{place}.
 @item info.nap
 The number of assigned eigenvalues.  @code{nap = n-nfp-nup}.
 @item info.nup
 The number of uncontrollable eigenvalues detected by the
 eigenvalue assignment algorithm.
 @item info.z
 The orthogonal matrix @var{z} reduces the closed-loop
 system state matrix @code{A + B*F} to upper real Schur form.
 Note the positive sign in @code{A + B*F}.
 @end table

 @strong{Note}
 @example
 Place is also suitable to design estimator gains:
 @group
 L = place (A.', C.', p).'
 L = place (sys.', p).'   # useful for discrete-time systems
 @end group
 @end example

 @strong{Algorithm}@*
 Uses SLICOT SB01BD by courtesy of
 @uref{http://www.slicot.org, NICONET e.V.}
 @end deftypefn
@section rlocus

 @deftypefn {Function File} rlocus (@var{sys}) 
 @deftypefnx {Function File} {[@var{rldata}, @var{k}] =} rlocus (@var{sys}, @var{increment}, @var{min_k}, @var{max_k}) 
 Display root locus plot of the specified @acronym{SISO} system.

 @strong{Inputs}
 @table @var
 @item sys
 LTI model.  Must be a single-input and single-output (SISO) system.
 @item min_k
 Minimum value of @var{k}.
 @item max_k
 Maximum value of @var{k}.
 @item increment
 The increment used in computing gain values.
 @end table

 @strong{Outputs}
 @table @var 
 @item rldata
 Data points plotted: in column 1 real values, in column 2 the imaginary values.
 @item k
 Gains for real axis break points.
 @end table

 @strong{Block Diagram}
 @example
 @group
  u    +         +---+      +------+             y
 ------>(+)----->| k |----->| SISO |-------+------->
         ^ -     +---+      +------+       |
         |                                 |
         +---------------------------------+
 @end group
 @end example
 @end deftypefn
@chapter Linear-Quadratic Control
@section dlqr

 @deftypefn {Function File} {[@var{g}, @var{x}, @var{l}] =} dlqr (@var{sys}, @var{q}, @var{r})
 @deftypefnx {Function File} {[@var{g}, @var{x}, @var{l}] =} dlqr (@var{sys}, @var{q}, @var{r}, @var{s})
 @deftypefnx {Function File} {[@var{g}, @var{x}, @var{l}] =} dlqr (@var{a}, @var{b}, @var{q}, @var{r})
 @deftypefnx {Function File} {[@var{g}, @var{x}, @var{l}] =} dlqr (@var{a}, @var{b}, @var{q}, @var{r}, @var{s})
 @deftypefnx {Function File} {[@var{g}, @var{x}, @var{l}] =} dlqr (@var{a}, @var{b}, @var{q}, @var{r}, @var{[]}, @var{e})
 @deftypefnx {Function File} {[@var{g}, @var{x}, @var{l}] =} dlqr (@var{a}, @var{b}, @var{q}, @var{r}, @var{s}, @var{e})
 Linear-quadratic regulator for discrete-time systems.

 @strong{Inputs}
 @table @var
 @item sys
 Continuous or discrete-time LTI model.
 @item a
 State transition matrix of discrete-time system.
 @item b
 Input matrix of discrete-time system.
 @item q
 State weighting matrix.
 @item r
 Input weighting matrix.
 @item s
 Optional cross term matrix.  If @var{s} is not specified, a zero matrix is assumed.
 @item e
 Optional descriptor matrix.  If @var{e} is not specified, an identity matrix is assumed.
 @end table

 @strong{Outputs}
 @table @var
 @item g
 State feedback matrix.
 @item x
 Unique stabilizing solution of the discrete-time Riccati equation.
 @item l
 Closed-loop poles.
 @end table

 @strong{Equations}
 @example
 @group
 x[k+1] = A x[k] + B u[k],   x[0] = x0

         inf
 J(x0) = SUM (x' Q x  +  u' R u  +  2 x' S u)
         k=0

 L = eig (A - B*G)
 @end group
 @end example
 @seealso{dare, care, lqr}
 @end deftypefn
@section estim

 @deftypefn {Function File} {@var{est} =} estim (@var{sys}, @var{l})
 @deftypefnx {Function File} {@var{est} =} estim (@var{sys}, @var{l}, @var{sensors}, @var{known})
 Return state estimator for a given estimator gain.

 @strong{Inputs}
 @table @var
 @item sys
 LTI model.
 @item l
 State feedback matrix.
 @item sensors
 Indices of measured output signals y from @var{sys}.  If omitted, all outputs are measured.
 @item known
 Indices of known input signals u (deterministic) to @var{sys}.  All other inputs to @var{sys}
 are assumed stochastic.  If argument @var{known} is omitted, no inputs u are known.
 @end table

 @strong{Outputs}
 @table @var
 @item est
 State-space model of estimator.
 @end table
 @seealso{kalman, place}
 @end deftypefn
@section kalman

 @deftypefn {Function File} {[@var{est}, @var{g}, @var{x}] =} kalman (@var{sys}, @var{q}, @var{r})
 @deftypefnx {Function File} {[@var{est}, @var{g}, @var{x}] =} kalman (@var{sys}, @var{q}, @var{r}, @var{s})
 @deftypefnx {Function File} {[@var{est}, @var{g}, @var{x}] =} kalman (@var{sys}, @var{q}, @var{r}, @var{[]}, @var{sensors}, @var{known})
 @deftypefnx {Function File} {[@var{est}, @var{g}, @var{x}] =} kalman (@var{sys}, @var{q}, @var{r}, @var{s}, @var{sensors}, @var{known})
 Design Kalman estimator for LTI systems.

 @strong{Inputs}
 @table @var
 @item sys
 Nominal plant model.
 @item q
 Covariance of white process noise.
 @item r
 Covariance of white measurement noise.
 @item s
 Optional cross term covariance.  Default value is 0.
 @item sensors
 Indices of measured output signals y from @var{sys}.  If omitted, all outputs are measured.
 @item known
 Indices of known input signals u (deterministic) to @var{sys}.  All other inputs to @var{sys}
 are assumed stochastic.  If argument @var{known} is omitted, no inputs u are known.
 @end table

 @strong{Outputs}
 @table @var
 @item est
 State-space model of the Kalman estimator.
 @item g
 Estimator gain.
 @item x
 Solution of the Riccati equation.
 @end table

 @strong{Block Diagram}
 @example
 @group
                                  u  +-------+         ^
       +---------------------------->|       |-------> y
       |    +-------+     +       y  |  est  |         ^
 u ----+--->|       |----->(+)------>|       |-------> x
            |  sys  |       ^ +      +-------+
 w -------->|       |       |
            +-------+       | v

 Q = cov (w, w')     R = cov (v, v')     S = cov (w, v')
 @end group
 @end example

 @seealso{care, dare, estim, lqr}
 @end deftypefn
@section lqr

 @deftypefn {Function File} {[@var{g}, @var{x}, @var{l}] =} lqr (@var{sys}, @var{q}, @var{r})
 @deftypefnx {Function File} {[@var{g}, @var{x}, @var{l}] =} lqr (@var{sys}, @var{q}, @var{r}, @var{s})
 @deftypefnx {Function File} {[@var{g}, @var{x}, @var{l}] =} lqr (@var{a}, @var{b}, @var{q}, @var{r})
 @deftypefnx {Function File} {[@var{g}, @var{x}, @var{l}] =} lqr (@var{a}, @var{b}, @var{q}, @var{r}, @var{s})
 @deftypefnx {Function File} {[@var{g}, @var{x}, @var{l}] =} lqr (@var{a}, @var{b}, @var{q}, @var{r}, @var{[]}, @var{e})
 @deftypefnx {Function File} {[@var{g}, @var{x}, @var{l}] =} lqr (@var{a}, @var{b}, @var{q}, @var{r}, @var{s}, @var{e})
 Linear-quadratic regulator.

 @strong{Inputs}
 @table @var
 @item sys
 Continuous or discrete-time LTI model.
 @item a
 State transition matrix of continuous-time system.
 @item b
 Input matrix of continuous-time system.
 @item q
 State weighting matrix.
 @item r
 Input weighting matrix.
 @item s
 Optional cross term matrix.  If @var{s} is not specified, a zero matrix is assumed.
 @item e
 Optional descriptor matrix.  If @var{e} is not specified, an identity matrix is assumed.
 @end table

 @strong{Outputs}
 @table @var
 @item g
 State feedback matrix.
 @item x
 Unique stabilizing solution of the continuous-time Riccati equation.
 @item l
 Closed-loop poles.
 @end table

 @strong{Equations}
 @example
 @group
 .
 x = A x + B u,   x(0) = x0

         inf
 J(x0) = INT (x' Q x  +  u' R u  +  2 x' S u)  dt
          0

 L = eig (A - B*G)
 @end group
 @end example
 @seealso{care, dare, dlqr}
 @end deftypefn
@chapter Robust Control
@section augw

 @deftypefn{Function File} {@var{P} =} augw (@var{G}, @var{W1}, @var{W2}, @var{W3})
 Extend plant for stacked S/KS/T problem.  Subsequently, the robust control problem
 can be solved by h2syn or hinfsyn.

 @strong{Inputs}
 @table @var
 @item G
 LTI model of plant.
 @item W1
 LTI model of performance weight.  Bounds the largest singular values of sensitivity @var{S}.
 Model must be empty @code{[]}, SISO or of appropriate size.
 @item W2
 LTI model to penalize large control inputs.  Bounds the largest singular values of @var{KS}.
 Model must be empty @code{[]}, SISO or of appropriate size.
 @item W3
 LTI model of robustness and noise sensitivity weight.  Bounds the largest singular values of 
 complementary sensitivity @var{T}.  Model must be empty @code{[]}, SISO or of appropriate size.
 @end table

 All inputs must be proper/realizable.
 Scalars, vectors and matrices are possible instead of LTI models.

 @strong{Outputs}
 @table @var
 @item P
 State-space model of augmented plant.
 @end table

 @strong{Block Diagram}
 @example
 @group

     | W1 | -W1*G |     z1 = W1 r  -  W1 G u
     | 0  |  W2   |     z2 =          W2   u
 P = | 0  |  W3*G |     z3 =          W3 G u
     |----+-------|
     | I  |    -G |     e  =    r  -     G u
 @end group
 @end example
 @example
 @group
                                                       +------+  z1
             +---------------------------------------->|  W1  |----->
             |                                         +------+
             |                                         +------+  z2
             |                 +---------------------->|  W2  |----->
             |                 |                       +------+
  r   +    e |   +--------+  u |   +--------+  y       +------+  z3
 ----->(+)---+-->|  K(s)  |----+-->|  G(s)  |----+---->|  W3  |----->
        ^ -      +--------+        +--------+    |     +------+
        |                                        |
        +----------------------------------------+
 @end group
 @end example
 @example
 @group
                +--------+
                |        |-----> z1 (p1x1)          z1 = W1 e
  r (px1) ----->|  P(s)  |-----> z2 (p2x1)          z2 = W2 u
                |        |-----> z3 (p3x1)          z3 = W3 y
  u (mx1) ----->|        |-----> e (px1)            e = r - y
                +--------+
 @end group
 @end example
 @example
 @group
                +--------+  
        r ----->|        |-----> z
                |  P(s)  |
        u +---->|        |-----+ e
          |     +--------+     |
          |                    |
          |     +--------+     |
          +-----|  K(s)  |<----+
                +--------+
 @end group
 @end example
 @example
 @group
 Reference:
 Skogestad, S. and Postlethwaite I.
 Multivariable Feedback Control: Analysis and Design
 Second Edition
 Wiley 2005
 Chapter 3.8: General Control Problem Formulation
 @end group
 @end example
 @seealso{h2syn, hinfsyn, mixsyn}
 @end deftypefn
@section h2syn

 @deftypefn{Function File} {[@var{K}, @var{N}, @var{gamma}, @var{rcond}] =} h2syn (@var{P}, @var{nmeas}, @var{ncon})
 H-2 control synthesis for LTI plant.

 @strong{Inputs}
 @table @var
 @item P
 Generalized plant.  Must be a proper/realizable LTI model.
 @item nmeas
 Number of measured outputs v.  The last nmeas outputs of @var{P} are connected to the
 inputs of controller @var{K}.  The remaining outputs z (indices 1 to p-nmeas) are used
 to calculate the H-2 norm.
 @item ncon
 Number of controlled inputs u.  The last ncon inputs of @var{P} are connected to the
 outputs of controller @var{K}.  The remaining inputs w (indices 1 to m-ncon) are excited
 by a harmonic test signal.
 @end table

 @strong{Outputs}
 @table @var
 @item K
 State-space model of the H-2 optimal controller.
 @item N
 State-space model of the lower LFT of @var{P} and @var{K}.
 @item gamma
 H-2 norm of @var{N}.
 @end table

 @strong{Block Diagram}
 @example
 @group

 gamma = min||N(K)||             N = lft (P, K)
          K         2

                +--------+  
        w ----->|        |-----> z
                |  P(s)  |
        u +---->|        |-----+ v
          |     +--------+     |
          |                    |
          |     +--------+     |
          +-----|  K(s)  |<----+
                +--------+

                +--------+      
        w ----->|  N(s)  |-----> z
                +--------+
 @end group
 @end example

 @strong{Algorithm}@*
 Uses SLICOT SB10HD and SB10ED by courtesy of
 @uref{http://www.slicot.org, NICONET e.V.}

 @seealso{augw, lqr, dlqr, kalman}
 @end deftypefn
@section hinfsyn

 @deftypefn{Function File} {[@var{K}, @var{N}, @var{gamma}, @var{rcond}] =} hinfsyn (@var{P}, @var{nmeas}, @var{ncon})
 @deftypefnx{Function File} {[@var{K}, @var{N}, @var{gamma}, @var{rcond}] =} hinfsyn (@var{P}, @var{nmeas}, @var{ncon}, @var{gmax})
 H-infinity control synthesis for LTI plant.

 @strong{Inputs}
 @table @var
 @item P
 Generalized plant.  Must be a proper/realizable LTI model.
 @item nmeas
 Number of measured outputs v.  The last nmeas outputs of @var{P} are connected to the
 inputs of controller @var{K}.  The remaining outputs z (indices 1 to p-nmeas) are used
 to calculate the H-infinity norm.
 @item ncon
 Number of controlled inputs u.  The last ncon inputs of @var{P} are connected to the
 outputs of controller @var{K}.  The remaining inputs w (indices 1 to m-ncon) are excited
 by a harmonic test signal.
 @item gmax
 The maximum value of the H-infinity norm of @var{N}.  It is assumed that @var{gmax} is
 sufficiently large so that the controller is admissible.
 @end table

 @strong{Outputs}
 @table @var
 @item K
 State-space model of the H-infinity (sub-)optimal controller.
 @item N
 State-space model of the lower LFT of @var{P} and @var{K}.
 @item gamma
 L-infinity norm of @var{N}.
 @end table

 @strong{Block Diagram}
 @example
 @group

 gamma = min||N(K)||             N = lft (P, K)
          K         inf

                +--------+  
        w ----->|        |-----> z
                |  P(s)  |
        u +---->|        |-----+ v
          |     +--------+     |
          |                    |
          |     +--------+     |
          +-----|  K(s)  |<----+
                +--------+

                +--------+      
        w ----->|  N(s)  |-----> z
                +--------+
 @end group
 @end example

 @strong{Algorithm}@*
 Uses SLICOT SB10FD and SB10DD by courtesy of
 @uref{http://www.slicot.org, NICONET e.V.}

 @seealso{augw, mixsyn}
 @end deftypefn
@section mixsyn

 @deftypefn{Function File} {[@var{K}, @var{N}, @var{gamma}] =} mixsyn (@var{G}, @var{W1}, @var{W2}, @var{W3}, @dots{})
 Solve stacked S/KS/T H-infinity problem.  Bound the largest singular values
 of @var{S} (for performance), @var{K S} (to penalize large inputs) and
 @var{T} (for robustness and to avoid sensitivity to noise).
 In other words, the inputs r are excited by a harmonic test signal.
 Then the algorithm tries to find a controller @var{K} which minimizes
 the H-infinity norm calculated from the outputs z.

 @strong{Inputs}
 @table @var
 @item G
 LTI model of plant.
 @item W1
 LTI model of performance weight.  Bounds the largest singular values of sensitivity @var{S}.
 Model must be empty @code{[]}, SISO or of appropriate size.
 @item W2
 LTI model to penalize large control inputs.  Bounds the largest singular values of @var{KS}.
 Model must be empty @code{[]}, SISO or of appropriate size.
 @item W3
 LTI model of robustness and noise sensitivity weight.  Bounds the largest singular values of 
 complementary sensitivity @var{T}.  Model must be empty @code{[]}, SISO or of appropriate size.
 @item @dots{}
 Optional arguments of @command{hinfsyn}.  Type @command{help hinfsyn} for more information.
 @end table

 All inputs must be proper/realizable.
 Scalars, vectors and matrices are possible instead of LTI models.

 @strong{Outputs}
 @table @var
 @item K
 State-space model of the H-infinity (sub-)optimal controller.
 @item N
 State-space model of the lower LFT of @var{P} and @var{K}.
 @item gamma
 L-infinity norm of @var{N}.
 @end table

 @strong{Block Diagram}
 @example
 @group

                                     | W1 S   |
 gamma = min||N(K)||             N = | W2 K S | = lft (P, K)
          K         inf              | W3 T   |
 @end group
 @end example
 @example
 @group
                                                       +------+  z1
             +---------------------------------------->|  W1  |----->
             |                                         +------+
             |                                         +------+  z2
             |                 +---------------------->|  W2  |----->
             |                 |                       +------+
  r   +    e |   +--------+  u |   +--------+  y       +------+  z3
 ----->(+)---+-->|  K(s)  |----+-->|  G(s)  |----+---->|  W3  |----->
        ^ -      +--------+        +--------+    |     +------+
        |                                        |
        +----------------------------------------+
 @end group
 @end example
 @example
 @group
                +--------+
                |        |-----> z1 (p1x1)          z1 = W1 e
  r (px1) ----->|  P(s)  |-----> z2 (p2x1)          z2 = W2 u
                |        |-----> z3 (p3x1)          z3 = W3 y
  u (mx1) ----->|        |-----> e (px1)            e = r - y
                +--------+
 @end group
 @end example
 @example
 @group
                +--------+  
        r ----->|        |-----> z
                |  P(s)  |
        u +---->|        |-----+ e
          |     +--------+     |
          |                    |
          |     +--------+     |
          +-----|  K(s)  |<----+
                +--------+
 @end group
 @end example
 @example
 @group
                +--------+      
        r ----->|  N(s)  |-----> z
                +--------+
 @end group
 @end example
 @example
 @group
 Extended Plant:  P = augw (G, W1, W2, W3)
 Controller:      K = mixsyn (G, W1, W2, W3)
 Entire System:   N = lft (P, K)
 Open Loop:       L = G * K
 Closed Loop:     T = feedback (L)
 @end group
 @end example
 @example
 @group
 Reference:
 Skogestad, S. and Postlethwaite I.
 Multivariable Feedback Control: Analysis and Design
 Second Edition
 Wiley 2005
 Chapter 3.8: General Control Problem Formulation
 @end group
 @end example
 @seealso{hinfsyn, augw}
 @end deftypefn
@section ncfsyn

 @deftypefn{Function File} {[@var{K}, @var{N}, @var{gamma}, @var{info}] =} ncfsyn (@var{G}, @var{W1}, @var{W2}, @var{factor})
 Loop shaping H-infinity synthesis.  Compute positive feedback controller using 
 the McFarlane/Glover normalized coprime factor (NCF) loop shaping design procedure.

 @strong{Inputs}
 @table @var
 @item G
 LTI model of plant.
 @item W1
 LTI model of precompensator.  Model must be SISO or of appropriate size.
 An identity matrix is taken if @var{W1} is not specified or if an empty model
 @code{[]} is passed.
 @item W2
 LTI model of postcompensator.  Model must be SISO or of appropriate size.
 An identity matrix is taken if @var{W2} is not specified or if an empty model
 @code{[]} is passed.
 @item factor
 @code{factor = 1} implies that an optimal controller is required.
 @code{factor > 1} implies that a suboptimal controller is required,
 achieving a performance that is @var{factor} times less than optimal.
 Default value is 1.
 @end table

 @strong{Outputs}
 @table @var
 @item K
 State-space model of the H-infinity loop-shaping controller.
 @item N
 State-space model of the closed loop depicted below.
 @item gamma
 L-infinity norm of @var{N}.  @code{gamma = norm (N, inf)}.
 @item info
 Structure containing additional information.
 @item info.emax
 Nugap robustness.  @code{emax = inv (gamma)}.
 @item info.Gs
 Shaped plant.  @code{Gs = W2 * G * W1}.
 @item info.Ks
 Controller for shaped plant.  @code{Ks = ncfsyn (Gs)}.
 @item info.rcond
 Estimates of the reciprocal condition numbers of the Riccati equations.
 @end table

 @strong{Block Diagram of N}
 @example
 @group

             ^ z1              ^ z2
             |                 |
  w1  +      |   +--------+    |            +--------+
 ----->(+)---+-->|   Ks   |----+--->(+)---->|   Gs   |----+
        ^ +      +--------+          ^      +--------+    |
        |                        w2  |                    |
        |                                                 |
        +-------------------------------------------------+
 @end group
 @end example

 @strong{Algorithm}@*
 Uses SLICOT SB10ID, SB10KD and SB10ZD by courtesy of
 @uref{http://www.slicot.org, NICONET e.V.}
 @end deftypefn
@chapter Matrix Equation Solvers
@section care

 @deftypefn {Function File} {[@var{x}, @var{l}, @var{g}] =} care (@var{a}, @var{b}, @var{q}, @var{r})
 @deftypefnx {Function File} {[@var{x}, @var{l}, @var{g}] =} care (@var{a}, @var{b}, @var{q}, @var{r}, @var{s})
 @deftypefnx {Function File} {[@var{x}, @var{l}, @var{g}] =} care (@var{a}, @var{b}, @var{q}, @var{r}, @var{[]}, @var{e})
 @deftypefnx {Function File} {[@var{x}, @var{l}, @var{g}] =} care (@var{a}, @var{b}, @var{q}, @var{r}, @var{s}, @var{e})
 Solve continuous-time algebraic Riccati equation (ARE).

 @strong{Inputs}
 @table @var
 @item a
 Real matrix (n-by-n).
 @item b
 Real matrix (n-by-m).
 @item q
 Real matrix (n-by-n).
 @item r
 Real matrix (m-by-m).
 @item s
 Optional real matrix (n-by-m).  If @var{s} is not specified, a zero matrix is assumed.
 @item e
 Optional descriptor matrix (n-by-n).  If @var{e} is not specified, an identity matrix is assumed.
 @end table

 @strong{Outputs}
 @table @var
 @item x
 Unique stabilizing solution of the continuous-time Riccati equation (n-by-n).
 @item l
 Closed-loop poles (n-by-1).
 @item g
 Corresponding gain matrix (m-by-n).
 @end table

 @strong{Equations}
 @example
 @group
                -1
 A'X + XA - XB R  B'X + Q = 0
 
                      -1
 A'X + XA - (XB + S) R  (B'X + S') + Q = 0

      -1
 G = R  B'X

      -1
 G = R  (B'X + S')

 L = eig (A - B*G)
 @end group
 @end example
 @example
 @group
                     -1
 A'XE + E'XA - E'XB R   B'XE + Q = 0

                           -1
 A'XE + E'XA - (E'XB + S) R   (B'XE + S') + Q = 0

      -1
 G = R  B'XE

      -1
 G = R  (B'XE + S)

 L = eig (A - B*G, E)
 @end group
 @end example

 @strong{Algorithm}@*
 Uses SLICOT SB02OD and SG02AD by courtesy of
 @uref{http://www.slicot.org, NICONET e.V.}

 @seealso{dare, lqr, dlqr, kalman}
 @end deftypefn
@section dare

 @deftypefn {Function File} {[@var{x}, @var{l}, @var{g}] =} dare (@var{a}, @var{b}, @var{q}, @var{r})
 @deftypefnx {Function File} {[@var{x}, @var{l}, @var{g}] =} dare (@var{a}, @var{b}, @var{q}, @var{r}, @var{s})
 @deftypefnx {Function File} {[@var{x}, @var{l}, @var{g}] =} dare (@var{a}, @var{b}, @var{q}, @var{r}, @var{[]}, @var{e})
 @deftypefnx {Function File} {[@var{x}, @var{l}, @var{g}] =} dare (@var{a}, @var{b}, @var{q}, @var{r}, @var{s}, @var{e})
 Solve discrete-time algebraic Riccati equation (ARE).

 @strong{Inputs}
 @table @var
 @item a
 Real matrix (n-by-n).
 @item b
 Real matrix (n-by-m).
 @item q
 Real matrix (n-by-n).
 @item r
 Real matrix (m-by-m).
 @item s
 Optional real matrix (n-by-m).  If @var{s} is not specified, a zero matrix is assumed.
 @item e
 Optional descriptor matrix (n-by-n).  If @var{e} is not specified, an identity matrix is assumed.
 @end table

 @strong{Outputs}
 @table @var
 @item x
 Unique stabilizing solution of the discrete-time Riccati equation (n-by-n).
 @item l
 Closed-loop poles (n-by-1).
 @item g
 Corresponding gain matrix (m-by-n).
 @end table

 @strong{Equations}
 @example
 @group
                           -1
 A'XA - X - A'XB (B'XB + R)   B'XA + Q = 0

                                 -1
 A'XA - X - (A'XB + S) (B'XB + R)   (B'XA + S') + Q = 0

               -1
 G = (B'XB + R)   B'XA

               -1
 G = (B'XB + R)   (B'XA + S')

 L = eig (A - B*G)
 @end group
 @end example
 @example
 @group
                              -1
 A'XA - E'XE - A'XB (B'XB + R)   B'XA + Q = 0

                                    -1
 A'XA - E'XE - (A'XB + S) (B'XB + R)   (B'XA + S') + Q = 0

               -1
 G = (B'XB + R)   B'XA

               -1
 G = (B'XB + R)   (B'XA + S')

 L = eig (A - B*G, E)
 @end group
 @end example

 @strong{Algorithm}@*
 Uses SLICOT SB02OD and SG02AD by courtesy of
 @uref{http://www.slicot.org, NICONET e.V.}

 @seealso{care, lqr, dlqr, kalman}
 @end deftypefn
@section dlyap

 @deftypefn{Function File} {@var{x} =} dlyap (@var{a}, @var{b})
 @deftypefnx{Function File} {@var{x} =} dlyap (@var{a}, @var{b}, @var{c})
 @deftypefnx{Function File} {@var{x} =} dlyap (@var{a}, @var{b}, @var{[]}, @var{e})
 Solve discrete-time Lyapunov or Sylvester equations.

 @strong{Equations}
 @example
 @group
 AXA' - X + B = 0      (Lyapunov Equation)

 AXB' - X + C = 0      (Sylvester Equation)

 AXA' - EXE' + B = 0   (Generalized Lyapunov Equation)
 @end group
 @end example

 @strong{Algorithm}@*
 Uses SLICOT SB03MD, SB04QD and SG03AD by courtesy of
 @uref{http://www.slicot.org, NICONET e.V.}

 @seealso{dlyapchol, lyap, lyapchol}
 @end deftypefn
@section dlyapchol

 @deftypefn{Function File} {@var{u} =} dlyapchol (@var{a}, @var{b})
 @deftypefnx{Function File} {@var{u} =} dlyapchol (@var{a}, @var{b}, @var{e})
 Compute Cholesky factor of discrete-time Lyapunov equations.

 @strong{Equations}
 @example
 @group
 A U' U A'  -  U' U  +  B B'  =  0           (Lyapunov Equation)

 A U' U A'  -  E U' U E'  +  B B'  =  0      (Generalized Lyapunov Equation)
 @end group
 @end example

 @strong{Algorithm}@*
 Uses SLICOT SB03OD and SG03BD by courtesy of
 @uref{http://www.slicot.org, NICONET e.V.}

 @seealso{dlyap, lyap, lyapchol}
 @end deftypefn
@section lyap

 @deftypefn{Function File} {@var{x} =} lyap (@var{a}, @var{b})
 @deftypefnx{Function File} {@var{x} =} lyap (@var{a}, @var{b}, @var{c})
 @deftypefnx{Function File} {@var{x} =} lyap (@var{a}, @var{b}, @var{[]}, @var{e})
 Solve continuous-time Lyapunov or Sylvester equations.

 @strong{Equations}
 @example
 @group
 AX + XA' + B = 0      (Lyapunov Equation)

 AX + XB + C = 0       (Sylvester Equation)

 AXE' + EXA' + B = 0   (Generalized Lyapunov Equation)
 @end group
 @end example

 @strong{Algorithm}@*
 Uses SLICOT SB03MD, SB04MD and SG03AD by courtesy of
 @uref{http://www.slicot.org, NICONET e.V.}

 @seealso{lyapchol, dlyap, dlyapchol}
 @end deftypefn
@section lyapchol

 @deftypefn{Function File} {@var{u} =} lyapchol (@var{a}, @var{b})
 @deftypefnx{Function File} {@var{u} =} lyapchol (@var{a}, @var{b}, @var{e})
 Compute Cholesky factor of continuous-time Lyapunov equations.

 @strong{Equations}
 @example
 @group
 A U' U  +  U' U A'  +  B B'  =  0           (Lyapunov Equation)

 A U' U E'  +  E U' U A'  +  B B'  =  0      (Generalized Lyapunov Equation)
 @end group
 @end example

 @strong{Algorithm}@*
 Uses SLICOT SB03OD and SG03BD by courtesy of
 @uref{http://www.slicot.org, NICONET e.V.}

 @seealso{lyap, dlyap, dlyapchol}
 @end deftypefn
@chapter Overloaded Operators
@section @@lti/horzcat

 Horizontal concatenation of LTI objects.  If necessary, object conversion
 is done by sys_group.  Used by Octave for "[sys1, sys2]".
@section @@lti/inv

 Inversion of LTI objects.
@section @@lti/minus

 Binary subtraction of LTI objects.  If necessary, object conversion
 is done by sys_group.  Used by Octave for "sys1 - sys2".
@section @@lti/mldivide

 Matrix left division of LTI objects.  If necessary, object conversion
 is done by sys_group in mtimes.  Used by Octave for "sys1 \ sys2".
@section @@lti/mpower

 Matrix power of LTI objects.  The exponent must be an integer.
 Used by Octave for "sys^int".
@section @@lti/mrdivide

 Matrix right division of LTI objects.  If necessary, object conversion
 is done by sys_group in mtimes.  Used by Octave for "sys1 / sys2".
@section @@lti/mtimes

 Matrix multiplication of LTI objects.  If necessary, object conversion
 is done by sys_group.  Used by Octave for "sys1 * sys2".
@section @@lti/plus

 Binary addition of LTI objects.  If necessary, object conversion
 is done by sys_group.  Used by Octave for "sys1 + sys2".
 Operation is also known as "parallel connection".
@section @@lti/subsasgn

 Subscripted assignment for LTI objects.
 Used by Octave for "sys.property = value".
@section @@lti/subsref

 Subscripted reference for LTI objects.
 Used by Octave for "sys = sys(2:4, :)" or "val = sys.prop".
@section @@lti/transpose

 Transpose of LTI objects.  Used by Octave for "sys.'".
@section @@lti/uminus

 Unary minus of LTI object.  Used by Octave for "-sys".
@section @@lti/vertcat

 Vertical concatenation of LTI objects.  If necessary, object conversion
 is done by sys_group.  Used by Octave for "[sys1; sys2]".
@chapter Miscellaneous
@section strseq

 @deftypefn {Function File} {@var{strvec} =} strseq (@var{str}, @var{idx})
 Return a cell vector of indexed strings by appending the indices @var{idx}
 to the string @var{str}.

 @example
 strseq ("x", 1:3) = @{"x1"; "x2"; "x3"@}
 strseq ("u", [1, 2, 5]) = @{"u1"; "u2"; "u5"@}
 @end example
 @end deftypefn
@section test_control

 @deftypefn {Script File} {} test_control
 Execute all available tests at once.
 @end deftypefn
@section BMWengine

 @deftypefn{Function File} {@var{sys} =} BMWengine ()
 @deftypefnx{Function File} {@var{sys} =} BMWengine (@var{"scaled"})
 @deftypefnx{Function File} {@var{sys} =} BMWengine (@var{"unscaled"})
 Model of the BMW 4-cylinder engine at ETH Zurich's control laboratory.
 @example
 @group
 OPERATING POINT
 Drosselklappenstellung     alpha_DK = 10.3 Grad
 Saugrohrdruck              p_s = 0.48 bar
 Motordrehzahl              n = 860 U/min
 Lambda-Messwert            lambda = 1.000
 Relativer Wandfilminhalt   nu = 1
 @end group
 @end example
 @example
 @group
 INPUTS
 U_1 Sollsignal Drosselklappenstellung   [Grad]
 U_2 Relative Einspritzmenge             [-]
 U_3 Zuendzeitpunkt                      [Grad KW]
 M_L Lastdrehmoment                      [Nm]
 @end group
 @end example
 @example
 @group
 STATES
 X_1 Drosselklappenstellung     [Grad]
 X_2 Saugrohrdruck              [bar]
 X_3 Motordrehzahl              [U/min]
 X_4 Messwert Lamba-Sonde       [-]
 X_5 Relativer Wandfilminhalt   [-]
 @end group
 @end example
 @example
 @group
 OUTPUTS
 Y_1 Motordrehzahl              [U/min]    
 Y_2 Messwert Lambda-Sonde      [-]
 @end group
 @end example
 @example
 @group
 SCALING
 U_1N, X_1N   1 Grad
 U_2N, X_4N, X_5N, Y_2N   0.05
 U_3N   1.6 Grad KW
 X_2N   0.05 bar
 X_3N, Y_1N   200 U/min
 @end group
 @end example
 @end deftypefn
@section Boeing707

 @deftypefn {Function File} {@var{sys} =} Boeing707 ()
 Creates a linearized state-space model of a Boeing 707-321 aircraft
 at @var{v}=80 m/s 
 @iftex
 @tex
 ($M = 0.26$, $G_{a0} = -3^{\circ}$, ${\alpha}_0 = 4^{\circ}$, ${\kappa}= 50^{\circ}$).
 @end tex
 @end iftex
 @ifnottex
 (@var{M} = 0.26, @var{Ga0} = -3 deg, @var{alpha0} = 4 deg, @var{kappa} = 50 deg).
 @end ifnottex

 System inputs: (1) thrust and (2) elevator angle.

 System outputs:  (1) airspeed and (2) pitch angle.

 @strong{Reference}: R. Brockhaus: @cite{Flugregelung} (Flight
 Control), Springer, 1994.
 @end deftypefn
@section WestlandLynx

 @deftypefn{Function File} {@var{sys} =} WestlandLynx ()
 Model of the Westland Lynx Helicopter about hover.
 @example
 @group
 INPUTS
 main rotor collective
 longitudinal cyclic
 lateral cyclic
 tail rotor collective
 @end group
 @end example
 @example
 @group
 STATES
 pitch attitude           theta       [rad]
 roll attitude            phi         [rad]
 roll rate (body-axis)    p           [rad/s]
 pitch rate (body-axis)   q           [rad/s]
 yaw rate                 xi          [rad/s]
 forward velocity         v_x         [ft/s]
 lateral velocity         v_y         [ft/s]
 vertical velocity        v_z         [ft/s]
 @end group
 @end example
 @example
 @group
 OUTPUTS
 heave velocity           H_dot       [ft/s]
 pitch attitude           theta       [rad]
 roll attitude            phi         [rad]
 heading rate             psi_dot     [rad/s]
 roll rate                p           [rad/s]
 pitch rate               q           [rad/s]
 @end group
 @end example
 @example
 @group
 Reference:
 Skogestad, S. and Postlethwaite I.
 Multivariable Feedback Control: Analysis and Design
 Second Edition
 Wiley 2005
 http://www.nt.ntnu.no/users/skoge/book/2nd_edition/matlab_m/matfiles.html
 @end group
 @end example
 @end deftypefn
