%% LyX 1.1 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[english]{article}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
% \usepackage{babel}

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
\providecommand{\LyX}{L\kern-.1667em\lower.25em\hbox{Y}\kern-.125emX\@}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
 \newenvironment{lyxcode}
   {\begin{list}{}{
     \setlength{\rightmargin}{\leftmargin}
     \raggedright
     \setlength{\itemsep}{0pt}
     \setlength{\parsep}{0pt}
     \normalfont\ttfamily}%
    \item[]}
   {\end{list}}
 \usepackage{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usepackage{dsfont}

% No date please
\date{}

\makeatother
\begin{document}
% This is for \LyX


\newcommand{\bfrac}[2]{\frac{#1 }{#2 }}



\newcommand{\nth}{^{\textrm{th}}}



\newcommand{\R}{R}



\newcommand{\N}{N}



\newcommand{\Z}{Z}



\newcommand{\tra}{^{T}}



\newcommand{\xx}{\mathbf{x}}


% This is for \LaTeX

\renewcommand{\R}{{\mathds{R}}} 

\renewcommand{\N}{{\mathds{N}}}

\renewcommand{\Z}{{\mathds{Z}}}

\renewcommand{\tra}{^{\top}}

\renewcommand{\bfrac}[2]{\frac{{\textstyle #1 }}{{\textstyle #2 }}}


\title{Mini-HOWTO on using Octave for Unconstrained Nonlinear Optimization%
\thanks{Author : Etienne Grossmann \texttt{<etienne@isr.ist.utl.pt>} (soon
replaced by {}``Octave-Forge developers''?). This document is free
documentation; you can redistribute it and/or modify it under the
terms of the GNU Free Documentation License as published by the Free
Software Foundation.\protect \\
.~~~This is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.
}}

\maketitle
\begin{comment}
Keywords: nonlinear optimization, octave, tutorial, Nelder-Mead, Conjugate
Gradient, Levenberg-Marquardt
\end{comment}
Nonlinear optimization problems are very common and when a solution
cannot be found analytically, one usually tries to find it numerically.
This document shows how to perform unconstrained nonlinear minimization
using the Octave language for numerical computation. We assume to
be so lucky as to have an initial guess from which to start an iterative
method, and so impatient as to avoid as much as possible going into
the details of the algorithm. In the following examples, we consider
multivariable problems, but the single variable case is solved in
exactly the same way.


\section*{Simple example}

We will use a call of the type

\begin{lyxcode}
{[}x\_best,~best\_value,~niter{]}~=~minimize~(func,~x\_init)
\end{lyxcode}
to find the minimum of \[
f\, :\, \left( x_{1},.x_{2},x_{3}\right) \in \R ^{3}\, \longrightarrow \, -\cos \left( x_{1}-1\right) -\cos \left( x_{2}-1\right) -\cos \left( x_{3}-1\right) .\]


The following commands should find a local minimum of \( f() \),
using the Nelder-Mead (aka {}``downhill simplex'') algorithm and
starting from a randomly chosen point \texttt{x0}~:

\begin{lyxcode}
function~cost~=~foo~(xx)

~~~~cost~=~sum~(-cos(xx-1));

endfunction

x0~=~rand~(1,3);

{[}x,v,n{]}~=~minimize~(\char`\"{}foo\char`\"{},~x0)
\end{lyxcode}
The output should look like~:

\begin{lyxcode}
x~=

~~1.00000~1.00000~1.00000



v~=~-3.0000

n~=~241
\end{lyxcode}
This means that a minimum has been found in \( \left( 1,1,1\right)  \)
and that the value at that point is \( -3 \). This is correct, since
all the points of the form \( x_{1}=1+2i\pi ,\, x_{2}=1+2j\pi ,\, x_{3}=1+2k\pi  \),
for some \( i,j,k\in \N  \), minimize \( f() \). The number of function
evaluations, 241 (this number may vary), is also returned.


\section*{Using the first differential}

When a function, like \( f() \) above, is differentiable, it is more
efficient optimization algorithms can be used. If \texttt{minimize()}
is given the differential of the optimized function, using the \texttt{\char`\"{}df\char`\"{}}
option, it will use a conjugate gradient method.

\begin{lyxcode}
\#\#~Function~returning~partial~derivatives

function~dc~=~diffoo~(x)

~~~~dc~=~sin~(x~(:)'~-~1);

endfunction

{[}x,~v,~n{]}~=~minimize~(\char`\"{}foo\char`\"{},~x0,~\char`\"{}df\char`\"{},~\char`\"{}diffoo\char`\"{})
\end{lyxcode}
This produces the output~:

\begin{lyxcode}
x~=

~~1.00000~1.00000~1.00000

v~=~-3~

n~=

~~93~7
\end{lyxcode}
The same minimum has been found, but only 93 function evaluations
were needed, together with 7 evaluations of the differential. Here,
\texttt{diffoo()} takes the same argument as \texttt{foo()} and returns
the partial derivatives of \( f() \) with respect to the corresponding
variables. It doesn't matter if it returns a row or column vector
or a matrix, as long as the \( i\nth  \) element of \texttt{diffoo(x)}
is the partial derivative of \( f() \) with respect to \( x_{i} \)
.


\section*{Using numerical approximations of the first differential}

Sometimes, the minimized function is differentiable, but actually
writing down its differential is more work than one would like. Numerical
differentiation offers a solution which is less efficient in terms
of computation cost, but easy to program~:

\begin{lyxcode}
eval~(cdiff~(\char`\"{}foo\char`\"{}));
\end{lyxcode}
The command \texttt{cdiff(\char`\"{}foo\char`\"{})} returns some octave
code that describes a function callled \texttt{dfoo()} that computes
numerically the partial derivatives of \texttt{foo}. This code looks
like~:

\begin{lyxcode}
function~df~=~dfoo~(dvar)~

~~\#\#~Numerical~differentiation~of~'foo'~wrt~to~it's~1'th~argument~

~~\#\#~This~function~has~been~written~by~'cdiff()'

~~\textrm{...~numerical~differentiation~code~...}

endfunction
\end{lyxcode}
The function \texttt{dfoo()} is defined during the call to \texttt{eval()}
and can then be used with \texttt{minimize}()~:

\begin{lyxcode}
{[}x,~v,~n{]}~=~minimize~(\char`\"{}foo\char`\"{},~x0,~\char`\"{}df\char`\"{},~\char`\"{}dfoo\char`\"{})
\end{lyxcode}
wich yields the same result as above.

\begin{lyxcode}
x~=

~~1.00000~1.00000~1.00000

v~=~-3~

n~=

~~93~7
\end{lyxcode}

\section*{Using the first and second differentials}

When the function is twice differentiable and one knows how to compute
its first and second differentials, still more efficient algorithms
can be used (in our case, a variant of Levenberg-Marquardt). The option
\texttt{\char`\"{}d2f\char`\"{}} allows to specify a function that
returns the value of the function, the first and second differentials
of the minimized function. Entering the commands~: 

\begin{lyxcode}
function~{[}c,~dc,~d2c{]}~=~d2foo~(x)

~~~~c~=~foo(x);

~~~~dc~=~diffoo(x);

~~~~d2c~=~diag~(cos~(x(:)-1));

end

{[}x,v,n{]}~=~minimize~(\char`\"{}foo\char`\"{},~x0,~\char`\"{}d2f\char`\"{},~\char`\"{}d2foo\char`\"{})~
\end{lyxcode}
produces the output~:

\begin{lyxcode}
x~=

~~1.0000~1.0000~1.0000

v~=~-3

n~=

~~48~4
\end{lyxcode}
This time, just 48 function evaluations, and 4 evaluations of \texttt{d2foo()}
were needed.

We have just seen the most basic ways of solving nonlinear unconstrained
optimization problems. The online help system of Octave (try e.g.
{}``\texttt{help minimize}'') will yield information on other issues,
such as passing extra arguments to the minimized function, controling
the termination of the optimization process, choosing the algorithm
etc.

\begin{lyxcode}
\end{lyxcode}

\end{document}
