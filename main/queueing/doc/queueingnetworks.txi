@c -*- texinfo -*-

@c Copyright (C) 2008, 2009, 2010, 2011, 2012 Moreno Marzolla
@c
@c This file is part of the queueing toolbox, a Queueing Networks
@c analysis package for GNU Octave.
@c
@c The queueing toolbox is free software; you can redistribute it
@c and/or modify it under the terms of the GNU General Public License
@c as published by the Free Software Foundation; either version 3 of
@c the License, or (at your option) any later version.
@c
@c The queueing toolbox is distributed in the hope that it will be
@c useful, but WITHOUT ANY WARRANTY; without even the implied warranty
@c of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
@c GNU General Public License for more details.
@c
@c You should have received a copy of the GNU General Public License
@c along with the queueing toolbox; see the file COPYING.  If not, see
@c <http://www.gnu.org/licenses/>.

@node Queueing Networks
@chapter Queueing Networks

@menu
* Introduction to QNs::                 A brief introduction to Queueing Networks.
* Algorithms for Product-Form QNs::     Functions to analyze product-form QNs
* Algorithms for non Product-Form QNs:: Functions to analyze non product-form QNs
* Generic Algorithms::                  High-level functions for QN analysis
* Bounds on performance::               Functions to compute performance bounds
* Utility functions::                   Utility functions to compute miscellaneous quantities
@end menu

@cindex queueing networks

@c
@c INTRODUCTION
@c 
@node Introduction to QNs
@section Introduction to QNs

Queueing Networks (QN) are a very simple yet powerful modeling tool
which can be used to analyze many kind of systems. In its simplest
form, a QN is made of @math{K} service centers. Each center @math{k}
has a queue, which is connected to @math{m_k} (generally identical)
@emph{servers}. Arriving customers (requests) join the queue if there
is a slot available. Then, requests are served according to a
(de)queueing policy (e.g., FIFO). After service completes, requests
leave the server and can join another queue or exit from the system.

Service centers for which @math{m_k = \infty} are called @emph{delay
centers} or @emph{infinite servers}. In this kind of centers, every
request always finds one available server, so queueing never occurs.

Requests join the queue according to a @emph{queueing policy}, such as:

@table @strong

@item FCFS
First-Come-First-Served

@item LCFS-PR
Last-Come-First-Served, Preemptive Resume

@item PS
Processor Sharing

@item IS
Infinite Server (for which @math{m_k = \infty}).

@end table

Queueing models can be @emph{open} or @emph{closed}. In open models
there is an infinite population of requests; new customers are
generated outside the system, and eventually leave the system. In
closed systems there is a fixed population of request.

Queueing models can have a single request class, meaning that all
requests behave in the same way (e.g., they spend the same average
time on each particular server). In multiclass models there are
multiple request classes, each one with its own
parameters. Furthermore, in multiclass models there can be open and
closed classes of requests within the same system.

@subsection Single class models

In single class models, all requests are indistinguishable and belong
to the same class. This means that every request has the same average
service time, and all requests move through the system with the same
routing probabilities.

@noindent @strong{Model Inputs}

@table @math

@item \lambda_k
External arrival rate to service center @math{k}.

@item \lambda
Overall external arrival rate to the whole system: @math{\lambda =
\sum_k \lambda_k}.

@item S_k
Average service time. @math{S_k} is the average service time on service
center @math{k}. In other words, @math{S_k} is the average time from the
instant in which a request is extracted from the queue and starts being
service, and the instant at which service finishes and the request moves
to another queue (or exits the system).

@item P_{i, j}
Routing probability matrix. @math{{\bf P} = [P_{i, j}]} is a @math{K
\times K} matrix such that @math{P_{i, j}} is the probability that a
request completing service at server @math{i} will move directly to
server @math{j}, The probability that a request leaves the system
after service at service center @math{i} is @math{1-\sum_{j=1}^K P_{i,
j}}.

@item V_k
Average number of visits. @math{V_k} is the average number of visits to
the service center @math{k}. This quantity will be described shortly.

@end table

@noindent @strong{Model Outputs}

@table @math

@item U_k
Service center utilization. @math{U_k} is the utilization of service
center @math{k}. The utilization is defined as the fraction of time in
which the resource is busy (i.e., the server is processing requests).

@item R_k
Average response time. @math{R_k} is the average response time of
service center @math{k}. The average response time is defined as the
average time between the arrival of a customer in the queue, and the
completion of service.

@item Q_k
Average number of customers. @math{Q_k} is the average number of
requests in service center @math{k}. This includes both the requests in
the queue, and the request being served.

@item X_k
Throughput. @math{X_k} is the throughput of service center @math{k}.
The throughput is defined as the ratio of job completions (i.e., average
number of jobs completed over a fixed interval of time).

@end table

@noindent Given these output parameters, additional performance measures can
be computed as follows:

@table @math

@item X
System throughput, @math{X = X_1 / V_1}

@item R
System response time, @math{R = \sum_{k=1}^K R_k V_k}

@item Q
Average number of requests in the system, @math{Q = N-XZ}

@end table

For open, single-class models, the scalar @math{\lambda} denotes the
external arrival rate of requests to the system. The average number of
visits satisfy the following equation:

@iftex
@tex
$$ V_j = P_{0, j} + \sum_{i=1}^K V_i P_{i, j} $$
@end tex
@end iftex
@ifnottex
@example
@group
                  K
                 ___
                \
V_j = P_(0, j) + >   V_i P_(i, j)
                /___
                 i=1
@end group
@end example
@end ifnottex

@noindent where @math{P_{0, j}} is the probability that an external 
arrival goes to service center @math{j}. If @math{\lambda_j} is the
external arrival rate to service center @math{j}, and @math{\lambda =
\sum_j \lambda_j} is the overall external arrival rate, then
@math{P_{0, j} = \lambda_j / \lambda}.

For closed models, the visit ratios satisfy the following equation:

@iftex
@tex
$$\eqalign{V_1 & = 1 \cr
           V_j & = \sum_{i=1}^K V_i P_{i, j}} $$
@end tex
@end iftex
@ifnottex
@example

V_1 = 1

        K
       ___
      \
V_j =  >   V_i P_(i, j)
      /___
       i=1

@end example
@end ifnottex

@subsection Multiple class models

In multiple class QN models, we assume that there exist @math{C}
different classes of requests. Each request from class @math{c} spends
on average time @math{S_{c, k}} in service at service center
@math{k}. For open models, we denote with @math{{\bf \lambda} =
\lambda_{ck}} the arrival rates, where @math{\lambda_{c, k}} is the
external arrival rate of class @math{c} customers at service center
@math{k}. For closed models, we denote with @math{{\bf N} = (N_1, N_2,
\ldots, N_C)} the population vector, where @math{N_c} is the number of
class @math{c} requests in the system.

The transition probability matrix for these kind of networks will be a
@math{C \times K \times C \times K} matrix @math{{\bf P} = [P_{r, i, s, j}]}
such that @math{P_{r, i, s, j}} is the probability that a class
@math{r} request which completes service at center @math{i} will join
server @math{j} as a class @math{s} request.

Model input and outputs can be adjusted by adding additional indexes
for the customer classes.

@noindent @strong{Model Inputs}

@table @math

@item \lambda_{c, k}
External arrival rate of class-@math{c} requests to service center @math{k}

@item \lambda
Overall external arrival rate to the whole system: @math{\lambda = \sum_c \sum_k \lambda_{c, k}}

@item S_{c, k}
Average service time. @math{S_{c, k}} is the average service time on
service center @math{k} for class @math{c} requests.

@item P_{r, i, s, j}
Routing probability matrix. @math{{\bf P} = [P_{r, i, s, j}]} is a @math{C
\times K \times C \times K} matrix such that @math{P_{r, i, s, j}} is
the probability that a class @math{r} request which completes service
at server @math{i} will move to server @math{j} as a class @math{s}
request.

@item V_{c, k}
Average number of visits. @math{V_{c, k}} is the average number of visits
of class @math{c} requests to center @math{k}.

@end table

@noindent @strong{Model Outputs}

@table @math

@item U_{c, k}
Utilization of service center @math{k} by class @math{c} requests. The
utilization is defined as the fraction of time in which the resource is
busy (i.e., the server is processing requests).

@item R_{c, k}
Average response time experienced by class @math{c} requests on service
center @math{k}. The average response time is defined as the average
time between the arrival of a customer in the queue, and the completion
of service.

@item Q_{c, k}
Average number of class @math{c} requests on service center
@math{k}. This includes both the requests in the queue, and the request
being served.

@item X_{c, k}
Throughput of service center @math{k} for class @math{c} requests.  The
throughput is defined as the rate of completion of class @math{c}
requests.

@end table

@noindent It is possible to define aggregate performance measures as follows:

@table @math

@item U_k
Utilization of service center @math{k}:
@iftex
@tex
$U_k = \sum_{c=1}^C U_{c, k}$
@end tex
@end iftex
@ifnottex
@code{Uk = sum(U,k);}
@end ifnottex

@item R_c
System response time for class @math{c} requests:
@iftex
@tex
$R_c = \sum_{k=1}^K R_{c, k} V_{c, k}$
@end tex
@end iftex
@ifnottex
@code{Rc = sum( V.*R, 1 );}
@end ifnottex

@item Q_c
Average number of class @math{c} requests in the system:
@iftex
@tex
$Q_c = \sum_{k=1}^K Q_{c, k}$
@end tex
@end iftex
@ifnottex
@code{Qc = sum( Q, 2 );}
@end ifnottex

@item X_c
Class @math{c} throughput:
@iftex
@tex
$X_c = X_{c, 1} / V_{c, 1}$
@end tex
@end iftex
@ifnottex
@code{Xc = X(:,1) ./ V(:,1);}
@end ifnottex

@end table

We can define the visit ratios @math{V_{s, j}} for class @math{s}
customers at service center @math{j} as follows:

@iftex
@tex
$$ \eqalign{ V_{s, j} & = \sum_{r=1}^C \sum_{i=1}^K V_{r, i} P_{r, i, s, j} \cr
             V_{s, 1} & = 1} $$
@end tex
@end iftex
@ifnottex
@group
V_sj = sum_r sum_i V_ri P_risj, for all s,j
@end group
@end ifnottex

@noindent while for open networks:

@iftex
@tex
$$V_{s, j} = P_{0, s, j} + \sum_{r=1}^C \sum_{i=1}^K V_{r, i} P_{r, i, s, j}$$
@end tex
@end iftex
@ifnottex
@group
V_sj = P_0sj + sum_r sum_i V_ri P_risj, for all s,j
@end group
@end ifnottex

@noindent where @math{P_{0, s, j}} is the probability that an external 
arrival goes to service center @math{j} as a class-@math{s} request.
If @math{\lambda_{s, j}} is the external arrival rate of class
@math{s} requests to service center @math{j}, and @math{\lambda =
\sum_s \sum_j \lambda_{s, j}} is the overall external arrival rate to
the whole system, then @math{P_{0, s, j} = \lambda_{s, j} / \lambda}.

@subsection Closed Network Example

We now give a simple example on how the queueing toolbox can be used
to analyze a closed network. Let us consider a simple closed network
with @math{K=3} @math{M/M/1}--FCFS centers. We denote with @math{S_k}
the average service time at center @math{k}, @math{k=1, 2, 3}. We use
@math{S_1 = 1.0}, @math{S_2 = 2.0} and @math{S_3 = 0.8}. The routing
of jobs within the network is described with a @emph{routing
probability matrix} @math{\bf P}. Specifically, a request completing
service at center @math{i} is enqueued at center @math{j} with
probability @math{P_{i, j}}.  We use the following routing matrix:

@iftex
@tex
$$
P = \pmatrix{ 0 & 0.3 & 0.7 \cr
              1 & 0 & 0 \cr
              1 & 0 & 0 }
$$
@end tex
@end iftex
@ifnottex
@example
    / 0  0.3  0.7 \
P = | 1  0    0   |
    \ 1  0    0   /
@end example
@end ifnottex

The network above can be analyzed with the @command{qnclosed} function
@pxref{doc-qnclosed}. @command{qnclosed} requires the following
parameters:

@table @var

@item N
Number of requests in the network (since we are considering a closed
network, the number of requests is fixed)

@item S
Array of average service times at the centers: @code{@var{S}(k)} is
the average service time at center @math{k}.

@item V
Array of visit ratios: @code{@var{V}(k)} is the average number of
visits to center @math{k}.

@end table

We can compute @math{V_k} from the routing probability matrix
@math{P_{i, j}} using the @command{qnvisits} function
@pxref{doc-qnvisits}.  We can analyze the network for a given
population size @math{N} (for example, @math{N=10}) as follows:

@example
@group
@kbd{N = 10;}
@kbd{S = [1 2 0.8];}
@kbd{P = [0 0.3 0.7; 1 0 0; 1 0 0];}
@kbd{V = qnvisits(P);}
@kbd{[U R Q X] = qnclosed( N, S, V )}
   @result{} U = 0.99139 0.59483 0.55518 
   @result{} R = 7.4360  4.7531  1.7500 
   @result{} Q = 7.3719  1.4136  1.2144 
   @result{} X = 0.99139 0.29742 0.69397 
@end group
@end example

The output of @command{qnclosed} includes the vector of utilizations
@math{U_k} at center @math{k}, response time @math{R_k}, average
number of customers @math{Q_k} and throughput @math{X_k}. In our
example, the throughput of center 1 is @math{X_1 = 0.99139}, and the
average number of requests in center 3 is @math{Q_3 = 1.2144}. The
utilization of center 1 is @math{U_1 = 0.99139}, which is the higher
value among the service centers. Tus, center 1 is the @emph{bottleneck
device}.

This network can also be analyzed with the @command{qnsolve} function
@pxref{doc-qnsolve}. @command{qnsolve} can handle open, closed or
mixed networks, and allows the network to be described in a very
flexible way.  First, let @var{Q1}, @var{Q2} and @var{Q3} be the
variables describing the service centers. Each variable is
instantiated with the @command{qnmknode} function.

@example
@group
@kbd{Q1 = qnmknode( "m/m/m-fcfs", 1 );}
@kbd{Q2 = qnmknode( "m/m/m-fcfs", 2 );}
@kbd{Q3 = qnmknode( "m/m/m-fcfs", 0.8 );}
@end group
@end example

The first parameter of @command{qnmknode} is a string describing the
type of the node. Here we use @code{"m/m/m-fcfs"} to denote a
@math{M/M/m}--FCFS center. The second parameter gives the average
service time. An optional third parameter can be used to specify the
number @math{m} of service centers. If omitted, it is assumed
@math{m=1} (single-server node).

Now, the network can be analyzed as follows:

@example
@group
@kbd{N = 10;}
@kbd{V = [1 0.3 0.7];}
@kbd{[U R Q X] = qnsolve( "closed", N, @{ Q1, Q2, Q3 @}, V )}
   @result{} U = 0.99139 0.59483 0.55518 
   @result{} R = 7.4360  4.7531  1.7500 
   @result{} Q = 7.3719  1.4136  1.2144 
   @result{} X = 0.99139 0.29742 0.69397 
@end group
@end example

Of course, we get exactly the same results. Other functions can be used
for closed networks, @pxref{Algorithms for Product-Form QNs}.

@subsection Open Network Example

Open networks can be analyzed in a similar way. Let us consider
an open network with @math{K=3} service centers, and routing
probability matrix as follows:

@iftex
@tex
$$
P = \pmatrix{ 0 & 0.3 & 0.5 \cr
              1 & 0 & 0 \cr
              1 & 0 & 0 }
$$
@end tex
@end iftex
@ifnottex
@example
    / 0  0.3  0.5 \
P = ! 1  0    0   |
    \ 1  0    0   /
@end example
@end ifnottex

In this network, requests can leave the system from center 1 with
probability @math{1-(0.3+0.5) = 0.2}. We suppose that external jobs
arrive at center 1 with rate @math{\lambda_1 = 0.15}; there are no
arrivals at centers 2 and 3.

Similarly to closed networks, we first need to compute the visit
counts @math{V_k} to center @math{k}. Again, we use the
@command{qnvisits} function as follows:

@example
@group
@kbd{P = [0 0.3 0.5; 1 0 0; 1 0 0];}
@kbd{lambda = [0.15 0 0];}
@kbd{V = qnvisits(P, lambda)}
   @result{} V = 5.00000 1.50000 2.50000
@end group
@end example

@noindent where @code{@var{lambda}(k)} is the arrival rate at center @math{k},
and @var{P} is the routing matrix. Assuming the same service times as
in the previous example, the network can be analyzed with the
@command{qnopen} function @pxref{doc-qnopen}, as follows:

@example
@group
@kbd{S = [1 2 0.8];}
@kbd{[U R Q X] = qnopen( sum(lambda), S, V )}
   @result{} U = 0.75000 0.45000 0.30000 
   @result{} R = 4.0000  3.6364  1.1429
   @result{} Q = 3.00000 0.81818 0.42857
   @result{} X = 0.75000 0.22500 0.37500 
@end group
@end example

The first parameter of the @command{qnopen} function is the (scalar)
aggregate arrival rate.

Again, it is possible to use the @command{qnsolve} high-level function:

@example
@group
@kbd{Q1 = qnmknode( "m/m/m-fcfs", 1 );}
@kbd{Q2 = qnmknode( "m/m/m-fcfs", 2 );}
@kbd{Q3 = qnmknode( "m/m/m-fcfs", 0.8 );}
@kbd{lambda = [0.15 0 0];}
@kbd{[U R Q X] = qnsolve( "open", sum(lambda), @{ Q1, Q2, Q3 @}, V )}
   @result{} U = 0.75000 0.45000 0.30000 
   @result{} R = 4.0000  3.6364  1.1429
   @result{} Q = 3.00000 0.81818 0.42857
   @result{} X = 0.75000 0.22500 0.37500 
@end group
@end example

@c
@c
@c
@node Algorithms for Product-Form QNs
@section Algorithms for Product-Form QNs

Product-form queueing networks fulfill the following assumptions:

@itemize

@item The network can consist of open and closed job classes.

@item The following queueing disciplines are allowed: FCFS, PS, LCFS-PR and IS.

@item Service times for FCFS nodes must be exponentially distributed and
class-independent. Service centers at PS, LCFS-PR and IS nodes can
have any kind of service time distribution with a rational Laplace
transform.  Furthermore, for PS, LCFS-PR and IS nodes, different
classes of customers can have different service times.

@item The service rate of an FCFS node is only allowed to depend on the
number of jobs at this node; in a PS, LCFS-PR and IS node the service
rate for a particular job class can also depend on the number of jobs
of that class at the node.

@item In open networks two kinds of arrival processes are allowed: i) the
arrival process is Poisson, with arrival rate @math{\lambda} which can
depend on the number of jobs in the network. ii) the arrival process
consists of @math{U} independent Poisson arrival streams where the
@math{U} job sources are assigned to the @math{U} chains; the arrival
rate can be load dependent.

@end itemize

@c
@c Jackson Networks
@c

@subsection Jackson Networks

Jackson networks satisfy the following conditions:

@itemize

@item 
There is only one job class in the network; the overall number of jobs
in the system is unlimited.

@item 
There are @math{N} service centers in the network. Each service center
may have Poisson arrivals from outside the system. A job can leave
the system from any node.

@item 
Arrival rates as well as routing probabilities are independent from
the number of nodes in the network.

@item 
External arrivals and service times at the service centers are
exponentially distributed, and in general can be load-dependent.

@item
Service discipline at each node is FCFS

@end itemize

We define the @emph{joint probability vector} @math{\pi(k_1, k_2,
\ldots, k_N)} as the steady-state probability that there are @math{k_i}
requests at service center @math{i}, for all @math{i=1, 2, \ldots, N}.
Jackson networks have the property that the joint probability is the
product of the marginal probabilities @math{\pi_i}:

@iftex
@tex
$$ \pi(k_1, k_2, \ldots, k_N) = \prod_{i=1}^N \pi_i(k_i) $$
@end tex
@end iftex
@ifnottex
@example
@var{joint_prob} = prod( @var{pi} )
@end example
@end ifnottex

@noindent where @math{\pi_i(k_i)} is the steady-state probability
that there are @math{k_i} requests at service center @math{i}.

@GETHELP{qnjackson}

@noindent @strong{REFERENCES}

This implementation is based on G. Bolch, S. Greiner, H. de Meer and
K. Trivedi, @cite{Queueing Networks and Markov Chains: Modeling and
Performance Evaluation with Computer Science Applications}, Wiley,
1998, pp. 284--287.

@auindex Bolch, G.
@auindex Greiner, S.
@auindex de Meer, H.
@auindex Trivedi, K.

@subsection The Convolution Algorithm

According to the BCMP theorem, the state probability of a closed
single class queueing network with @math{K} nodes and @math{N} requests
can be expressed as:

@iftex
@tex
$$ \pi(k_1, k_2, \ldots, k_K) = {1 \over G(N)} \prod_{i=1}^N F_i(k_i) $$
@end tex
@end iftex
@ifnottex
@example
@group
k = [k1, k2, @dots{} kn]; @r{population vector}
p = 1/G(N+1) \prod F(i,k);
@end group
@end example
@end ifnottex

Here @math{\pi(k_1, k_2, \ldots, k_K)} is the joint probability of
having @math{k_i} requests at node @math{i}, for all @math{i=1, 2,
\ldots, K}.

The @emph{convolution algorithms} computes the normalization constants
@math{{\bf G} = \left(G(0), G(1), \ldots, G(N)\right)} for single-class, closed networks
with @math{N} requests.  The normalization constants are returned as
vector @code{@var{G}=[@var{G}(1), @var{G}(2), @dots{} @var{G}(N+1)]} where
@code{@var{G}(i+1)} is the value of @math{G(i)} (remember that Octave
uses 1-base vectors). The normalization constant can be used to
compute all performance measures of interest (utilization, average
response time and so on).

@code{queueing} implements the convolution algorithm, in the function
@code{qnconvolution} and @code{qnconvolutionld}. The first one
supports single-station nodes, multiple-station nodes and IS nodes.
The second one supports networks with general load-dependent service
centers.

@c
@c The Convolution Algorithm
@c

@GETHELP{qnconvolution}

@noindent @strong{EXAMPLE}

The normalization constant @math{G} can be used to compute the
steady-state probabilities for a closed single class product-form
Queueing Network with @math{K} nodes. Let @code{@var{k}=[@math{k_1,
k_2, @dots{}, k_K}]} be a valid population vector. Then, the
steady-state probability @code{@var{p}(i)} to have @code{@var{k}(i)}
requests at service center @math{i} can be computed as:

@iftex
@tex
$$
p_i(k_i) = {(V_i S_i)^{k_i} \over G(K)} \left(G(K-k_i) - V_i S_i G(K-k_i-1)\right), \quad i=1, 2, \ldots, K
$$
@end tex
@end iftex

@example
@GETDEMO{qnconvolution,1}
@print{} k(1)=1 prob=0.17975
@print{} k(2)=2 prob=0.48404
@print{} k(3)=0 prob=0.52779
@end example

@noindent @strong{NOTE}

For a network with @math{K} service centers and @math{N} requests,
this implementation of the convolution algorithm has time and space
complexity @math{O(NK)}.

@noindent @strong{REFERENCES}

Jeffrey P. Buzen, @cite{Computational Algorithms for Closed Queueing
Networks with Exponential Servers}, Communications of the ACM, volume
16, number 9, september 1973,
pp. 527--531. @url{http://doi.acm.org/10.1145/362342.362345}

@auindex Buzen, J. P.

This implementation is based on G. Bolch, S. Greiner, H. de Meer and
K. Trivedi, @cite{Queueing Networks and Markov Chains: Modeling and
Performance Evaluation with Computer Science Applications}, Wiley,
1998, pp. 313--317.

@auindex Bolch, G.
@auindex Greiner, S.
@auindex de Meer, H.
@auindex Trivedi, K.

@c
@c Convolution for load-dependent service centers
@c
@GETHELP{qnconvolutionld}

@noindent @strong{REFERENCES}

Herb Schwetman, @cite{Some Computational Aspects of Queueing Network
Models}, Technical Report CSD-TR-354, Department of Computer Sciences,
Purdue University, feb, 1981 (revised).
@url{http://www.cs.purdue.edu/research/technical_reports/1980/TR%2080-354.pdf}

@auindex Schwetman, H.

M. Reiser, H. Kobayashi, @cite{On The Convolution Algorithm for
Separable Queueing Networks}, In Proceedings of the 1976 ACM
SIGMETRICS Conference on Computer Performance Modeling Measurement and
Evaluation (Cambridge, Massachusetts, United States, March 29--31,
1976). SIGMETRICS '76. ACM, New York, NY,
pp. 109--117. @url{http://doi.acm.org/10.1145/800200.806187}

@auindex Reiser, M.
@auindex Kobayashi, H.

This implementation is based on G. Bolch, S. Greiner, H. de Meer and
K. Trivedi, @cite{Queueing Networks and Markov Chains: Modeling and
Performance Evaluation with Computer Science Applications}, Wiley,
1998, pp. 313--317. Function @code{qnconvolutionld} is slightly
different from the version described in Bolch et al. because it
supports general load-dependent centers (while the version in the book
does not). The modification is in the definition of function
@code{F()} in @code{qnconvolutionld} which has been made similar to
function @math{f_i} defined in Schwetman, @code{Some Computational
Aspects of Queueing Network Models}.

@auindex Bolch, G.
@auindex Greiner, S.
@auindex de Meer, H.
@auindex Trivedi, K.


@subsection Open networks

@c
@c Open networks with single class
@c
@GETHELP{qnopensingle}

From the results computed by this function, it is possible to derive
other quantities of interest as follows:

@itemize

@item
@strong{System Response Time}: The overall system response time
can be computed as
@iftex
@tex 
$R_s = \sum_{i=1}^K V_i R_i$
@end tex
@end iftex
@ifnottex
@code{R_s = dot(V,R);}
@end ifnottex

@item
@strong{Average number of requests}: The average number of requests
in the system can be computed as:
@iftex
@tex 
$Q_s = \sum_{i=1}^K Q(i)$
@end tex
@end iftex
@ifnottex
@code{Q_s = sum(Q)}
@end ifnottex

@end itemize

@noindent @strong{EXAMPLE}

@example
@GETDEMO{qnopensingle,1}
@print{} R_s =  1.4062
@print{} N =  4.2186
@end example

@noindent @strong{REFERENCES}

G. Bolch, S. Greiner, H. de Meer and K. Trivedi, @cite{Queueing
Networks and Markov Chains: Modeling and Performance Evaluation with
Computer Science Applications}, Wiley, 1998.

@auindex Bolch, G.
@auindex Greiner, S.
@auindex de Meer, H.
@auindex Trivedi, K.


@c
@c Open network with multiple classes
@c
@GETHELP{qnopenmulti}

@noindent @strong{REFERENCES}

Edward D. Lazowska, John Zahorjan, G. Scott Graham, and Kenneth C.
Sevcik, @cite{Quantitative System Performance: Computer System
Analysis Using Queueing Network Models}, Prentice Hall,
1984. @url{http://www.cs.washington.edu/homes/lazowska/qsp/}. In
particular, see section 7.4.1 ("Open Model Solution Techniques").

@auindex Lazowska, E. D. 
@auindex Zahorjan, J. 
@auindex Graham, G. S.
@auindex Sevcik, K. C.


@subsection Closed Networks

@c
@c MVA for single class, closed networks
@c

@GETHELP{qnclosedsinglemva}

From the results provided by this function, it is possible to derive 
other quantities of interest as follows:

@noindent @strong{EXAMPLE}

@example
@GETDEMO{qnclosedsinglemva,1}
@end example


@noindent @strong{REFERENCES}

M. Reiser and S. S. Lavenberg, @cite{Mean-Value Analysis of Closed
Multichain Queuing Networks}, Journal of the ACM, vol. 27, n. 2, April
1980, pp. 313--322. @url{http://doi.acm.org/10.1145/322186.322195}

@auindex Reiser, M.
@auindex Lavenberg, S. S.

This implementation is described in R. Jain , @cite{The Art of Computer
Systems Performance Analysis}, Wiley, 1991, p. 577.  Multi-server nodes
@c and the computation of @math{G(N)}, 
are treated according to G. Bolch, S. Greiner, H. de Meer and
K. Trivedi, @cite{Queueing Networks and Markov Chains: Modeling and
Performance Evaluation with Computer Science Applications}, Wiley,
1998, Section 8.2.1, "Single Class Queueing Networks".

@auindex Jain, R.
@auindex Bolch, G.
@auindex Greiner, S.
@auindex de Meer, H.
@auindex Trivedi, K.

@c
@c MVA for single class, closed networks with load dependent servers
@c
@GETHELP{qnclosedsinglemvald}

@noindent @strong{REFERENCES}

M. Reiser and S. S. Lavenberg, @cite{Mean-Value Analysis of Closed
Multichain Queuing Networks}, Journal of the ACM, vol. 27, n. 2,
April 1980, pp. 313--322. @url{http://doi.acm.org/10.1145/322186.322195}

This implementation is described in G. Bolch, S. Greiner, H. de Meer
and K. Trivedi, @cite{Queueing Networks and Markov Chains: Modeling
and Performance Evaluation with Computer Science Applications}, Wiley,
1998, Section 8.2.4.1, ``Networks with Load-Deèpendent Service: Closed
Networks''.

@auindex Bolch, G.
@auindex Greiner, S.
@auindex de Meer, H.
@auindex Trivedi, K.

@c
@c CMVA for single class, closed networks with a single load dependent servers
@c
@GETHELP{qncmva}

@noindent @strong{REFERENCES}

G. Casale. @cite{A note on stable flow-equivalent aggregation in
closed networks}. Queueing Syst. Theory Appl., 60:193–202, December
2008.

@auindex Casale, G.

@c
@c Approximate MVA for single class, closed networks
@c

@GETHELP{qnclosedsinglemvaapprox}

@noindent @strong{REFERENCES}

This implementation is based on Edward D. Lazowska, John Zahorjan,
G. Scott Graham, and Kenneth C. Sevcik, @cite{Quantitative System
Performance: Computer System Analysis Using Queueing Network Models},
Prentice Hall,
1984. @url{http://www.cs.washington.edu/homes/lazowska/qsp/}. In
particular, see section 6.4.2.2 ("Approximate Solution Techniques").

@auindex Lazowska, E. D.
@auindex Zahorjan, J.
@auindex Graham, G. S.
@auindex Sevcik, K. C.


@c
@c MVA for multiple class, closed networks
@c
@GETHELP{qnclosedmultimva}

@noindent @strong{NOTE}

Given a network with @math{K} service centers, @math{C} job classes and
population vector @math{{\bf N}=(N_1, N_2, \ldots, N_C)}, the MVA
algorithm requires space @math{O(C \prod_i (N_i + 1))}. The time
complexity is @math{O(CK\prod_i (N_i + 1))}. This implementation is
slightly more space-efficient (see details in the code). While the space
requirement can be mitigated by using some optimizations, the time
complexity can not. If you need to analyze large closed networks you
should consider the @command{qnclosedmultimvaapprox} function, which
implements the approximate MVA algorithm. Note however that
@command{qnclosedmultimvaapprox} will only provide approximate results.


@noindent @strong{REFERENCES}

M. Reiser and S. S. Lavenberg, @cite{Mean-Value Analysis of Closed
Multichain Queuing Networks}, Journal of the ACM, vol. 27, n. 2, April
1980, pp. 313--322. @url{http://doi.acm.org/10.1145/322186.322195}

@auindex Reiser, M.
@auindex Lavenberg, S. S.

This implementation is based on G. Bolch, S. Greiner, H. de Meer and
K. Trivedi, @cite{Queueing Networks and Markov Chains: Modeling and
Performance Evaluation with Computer Science Applications}, Wiley,
1998 and Edward D. Lazowska, John Zahorjan, G. Scott Graham, and
Kenneth C. Sevcik, @cite{Quantitative System Performance: Computer
System Analysis Using Queueing Network Models}, Prentice Hall,
1984. @url{http://www.cs.washington.edu/homes/lazowska/qsp/}. In
particular, see section 7.4.2.1 ("Exact Solution Techniques").

@auindex Bolch, G.
@auindex Greiner, S.
@auindex de Meer, H.
@auindex Trivedi, K.
@auindex Lazowska, E. D.
@auindex Zahorjan, J.
@auindex Graham, G. S.
@auindex Sevcik, K. C.

@c
@c Approximate MVA, with Bard-Schweitzer approximation
@c
@GETHELP{qnclosedmultimvaapprox}

@noindent @strong{REFERENCES}

Y. Bard, @cite{Some Extensions to Multiclass Queueing Network Analysis},
proc. 4th Int. Symp. on Modelling and Performance Evaluation of
Computer Systems, feb. 1979, pp. 51--62.

@auindex Bard, Y.

P. Schweitzer, @cite{Approximate Analysis of Multiclass Closed
Networks of Queues}, Proc. Int. Conf. on Stochastic Control and
Optimization, jun 1979, pp. 25--29.

@auindex Schweitzer, P.

This implementation is based on Edward D. Lazowska, John Zahorjan, G.
Scott Graham, and Kenneth C. Sevcik, @cite{Quantitative System
Performance: Computer System Analysis Using Queueing Network Models},
Prentice Hall,
1984. @url{http://www.cs.washington.edu/homes/lazowska/qsp/}.  In
particular, see section 7.4.2.2 ("Approximate Solution
Techniques"). This implementation is slightly different from the one
described above, as it computes the average response times @math{R}
instead of the residence times.

@auindex Lazowska, E. D.
@auindex Zahorjan, J.
@auindex Graham, G. S.
@auindex Sevcik, K. C.

@subsection Mixed Networks

@c
@c MVA for mixed networks
@c
@GETHELP{qnmix}

@noindent @strong{REFERENCES}

Edward D. Lazowska, John Zahorjan, G. Scott Graham, and Kenneth C.
Sevcik, @cite{Quantitative System Performance: Computer System
Analysis Using Queueing Network Models}, Prentice Hall,
1984. @url{http://www.cs.washington.edu/homes/lazowska/qsp/}. In
particular, see section 7.4.3 ("Mixed Model Solution Techniques").
Note that in this function we compute the mean response time @math{R}
instead of the mean residence time as in the reference.

@auindex Lazowska, E. D. 
@auindex Zahorjan, J. 
@auindex Graham, G. S.
@auindex Sevcik, K. C.

Herb Schwetman, @cite{Implementing the Mean Value Algorithm for the
Solution of Queueing Network Models}, Technical Report CSD-TR-355,
Department of Computer Sciences, Purdue University, feb 15, 1982,
available at
@url{http://www.cs.purdue.edu/research/technical_reports/1980/TR%2080-355.pdf}

@auindex Schwetman, H.

@c
@c
@c

@node Algorithms for non Product-Form QNs
@section Algorithms for non Product-Form QNs

@c
@c MVABLO algorithm for approximate analysis of closed, single class
@c QN with blocking
@c
@GETHELP{qnmvablo}

@noindent @strong{REFERENCES}

Ian F. Akyildiz, @cite{Mean Value Analysis for Blocking Queueing
Networks}, IEEE Transactions on Software Engineering, vol. 14, n. 2,
april 1988, pp. 418--428.  @url{http://dx.doi.org/10.1109/32.4663}

@auindex Akyildiz, I. F.

@GETHELP{qnmarkov}

@c
@c
@c
@node Generic Algorithms
@section Generic Algorithms

The @code{queueing} package provides a high-level function
@code{qnsolve} for analyzing QN models. @code{qnsolve} takes as input
a high-level description of the queueing model, and delegates the
actual solution of the model to one of the lower-level function
described in the previous section. @code{qnsolve} supports single or
multiclass models, but at the moment only product-form networks can be
analyzed. For non product-form networks @xref{Algorithms for non
Product-Form QNs}.

@code{qnsolve} accepts two input parameters. The first one is the list
of nodes, encoded as an Octave @emph{cell array}. The second parameter
is the vector of visit ratios @var{V}, which can be either a vector
(for single-class models) or a two-dimensional matrix (for
multiple-class models).

Individual nodes in the network are structures build using the
@code{qnmknode} function.

@GETHELP{qnmknode}

After the network has been defined, it is possible to solve it using
@code{qnsolve}.

@GETHELP{qnsolve}

@noindent @strong{EXAMPLE}

Let us consider a closed, multiclass network with @math{C=2} classes
and @math{K=3} service center. Let the population be @math{M=(2, 1)}
(class 1 has 2 requests, and class 2 has 1 request). The nodes are as
follows:

@itemize

@item Node 1 is a @math{M/M/1}--FCFS node, with load-dependent service
times. Service times are class-independent, and are defined by the
matrix @code{[0.2 0.1 0.1; 0.2 0.1 0.1]}. Thus, @code{@var{S}(1,2) =
0.2} means that service time for class 1 customers where there are 2
requests in 0.2. Note that service times are class-independent;

@item Node 2 is a @math{-/G/1}--PS node, with service times 
@math{S_{1, 2} = 0.4} for class 1, and @math{S_{2, 2} = 0.6} for class 2
requests;

@item Node 3 is a @math{-/G/\infty} node (delay center), with service
times @math{S_{1, 3}=1} and @math{S_{2, 3}=2} for class 1 and 2
respectively.

@end itemize

After defining the per-class visit count @var{V} such that
@code{@var{V}(c,k)} is the visit count of class @math{c} requests to
service center @math{k}.  We can define and solve the model as
follows:

@example
@GETDEMO{qnsolve,1}
@end example


@c
@c
@c
@node Bounds on performance
@section Bounds on performance

@c
@GETHELP{qnopenab}

@noindent @strong{REFERENCES}

Edward D. Lazowska, John Zahorjan, G.  Scott Graham, and Kenneth
C. Sevcik, @cite{Quantitative System Performance: Computer System
Analysis Using Queueing Network Models}, Prentice Hall,
1984. @url{http://www.cs.washington.edu/homes/lazowska/qsp/}. In
particular, see section 5.2 ("Asymptotic Bounds").

@auindex Lazowska, E. D.
@auindex Zahorjan, J.
@auindex Graham, G. S.
@auindex Sevcik, K. C.

@c
@GETHELP{qnclosedab}

@noindent @strong{REFERENCES}

@noindent Edward D. Lazowska, John Zahorjan, G.  Scott Graham, and Kenneth
C. Sevcik, @cite{Quantitative System Performance: Computer System
Analysis Using Queueing Network Models}, Prentice Hall,
1984. @url{http://www.cs.washington.edu/homes/lazowska/qsp/}. In
particular, see section 5.2 ("Asymptotic Bounds").

@auindex Lazowska, E. D.
@auindex Zahorjan, J.
@auindex Graham, G. S.
@auindex Sevcik, K. C.


@c
@GETHELP{qnopenbsb}

@noindent @strong{REFERENCES}

Edward D. Lazowska, John Zahorjan, G.  Scott Graham, and Kenneth
C. Sevcik, @cite{Quantitative System Performance: Computer System
Analysis Using Queueing Network Models}, Prentice Hall,
1984. @url{http://www.cs.washington.edu/homes/lazowska/qsp/}. In
particular, see section 5.4 ("Balanced Systems Bounds").

@auindex Lazowska, E. D.
@auindex Zahorjan, J.
@auindex Graham, G. S.
@auindex Sevcik, K. C.

@c
@GETHELP{qnclosedbsb}

@c
@GETHELP{qnclosedpb}

@noindent @strong{REFERENCES}

The original paper describing PB Bounds is C. H. Hsieh and S. Lam,
@cite{Two classes of performance bounds for closed queueing networks},
PEVA, vol. 7, n. 1, pp. 3--30, 1987

This function implements the non-iterative variant described in G.
Casale, R. R. Muntz, G. Serazzi, @cite{Geometric Bounds: a
Non-Iterative Analysis Technique for Closed Queueing Networks}, IEEE
Transactions on Computers, 57(6):780-794, June 2008.

@auindex Hsieh, C. H 
@auindex Lam, S.
@auindex Casale, G.
@auindex Muntz, R. R.
@auindex Serazzi, G.

@c
@GETHELP{qnclosedgb}

@noindent @strong{REFERENCES}

G. Casale, R. R. Muntz, G. Serazzi,
@cite{Geometric Bounds: a Non-Iterative Analysis Technique for Closed
Queueing Networks}, IEEE Transactions on Computers, 57(6):780-794,
June 2008. @url{http://doi.ieeecomputersociety.org/10.1109/TC.2008.37}

@auindex Casale, G.
@auindex Muntz, R. R.
@auindex Serazzi, G.
  
In this implementation we set @math{X^+} and @math{X^-} as the upper
and lower Asymptotic Bounds as computed by the @code{qnclosedab}
function, respectively.

@node Utility functions
@section Utility functions

@subsection Open or closed networks 

@GETHELP{qnclosed}

@noindent @strong{EXAMPLE}

@example
@GETDEMO{qnclosed,1}
@end example

@GETHELP{qnopen}

@c
@c Compute the visit counts
@c

@subsection Computation of the visit counts

For single-class networks the average number of visits satisfy the
following equation:

@iftex
@tex
$$V_j = P_{0, j} + \sum_{i=1}^K V_i P_{i, j}$$
@end tex
@end iftex
@ifnottex
@example
V == P0 + V*P;
@end example
@end ifnottex

@noindent where @math{P_{0, j}} is the probability that an external 
arrival goes to service center @math{j}. If @math{\lambda_j} is the
external arrival rate to service center @math{j}, and @math{\lambda =
\sum_j \lambda_j} is the overall external arrival rate, then
@math{P_{0, j} = \lambda_j / \lambda}. 

For closed networks, the visit ratios satisfy the following equation:

@iftex
@tex
$$\eqalign{ V_j & = \sum_{i=1}^K V_i P_{i, j} \cr
            V_1 & = 1 }$$
@end tex
@end iftex
@ifnottex
@example
V(1) == 1 && V == V*P;
@end example
@end ifnottex

The definitions above can be extended to multiple class networks as
follows. We define the visit ratios @math{V_{s, j}} for class @math{s}
customers at service center @math{j} as follows:

@iftex
@tex
$$\eqalign{ V_{s, j} & = \sum_{r=1}^C \sum_{i=1}^K V_{r, i} P_{r, i, s, j} \cr
            V_{s, 1} & = 1 }$$
@end tex
@end iftex
@ifnottex
@group
V_sj = sum_r sum_i V_ri P_risj, for all s,j
V_s1 = 1, for all s
@end group
@end ifnottex

@noindent while for open networks:

@iftex
@tex
$$V_{s, j} = P_{0, s, j} + \sum_{r=1}^C \sum_{i=1}^K V_{r, i} P_{r, i, s, j}$$
@end tex
@end iftex
@ifnottex
@group
V_sj = P_0sj + sum_r sum_i V_ri P_risj, for all s,j
@end group
@end ifnottex

@noindent where @math{P_{0, s, j}} is the probability that an external 
arrival goes to service center @math{j} as a class-@math{s} request.
If @math{\lambda_{s, j}} is the external arrival rate of class @math{s}
requests to service center @math{j}, and @math{\lambda = \sum_s \sum_j
\lambda_{s, j}} is the overall external arrival rate to the whole system,
then @math{P_{0, s, j} = \lambda_{s, j} / \lambda}.

@GETHELP{qnvisits}

@noindent @strong{EXAMPLE}

@example
@GETDEMO{qnvisits,1}
@end example

@subsection Other utility functions

@c
@GETHELP{population_mix}

@noindent @strong{REFERENCES}

Herb Schwetman, @cite{Implementing the Mean Value Algorithm for the
Solution of Queueing Network Models}, Technical Report CSD-TR-355,
Department of Computer Sciences, Purdue University, feb 15, 1982,
available at
@url{http://www.cs.purdue.edu/research/technical_reports/1980/TR
80-355.pdf}

Note that the slightly different problem of generating all tuples
@math{k_1, k_2, \ldots, k_N} such that @math{\sum_i k_i = k} and
@math{k_i} are nonnegative integers, for some fixed integer @math{k
@geq{} 0} has been described in S. Santini, @cite{Computing the
Indices for a Complex Summation}, unpublished report, available at
@url{http://arantxa.ii.uam.es/~ssantini/writing/notes/s668_summation.pdf}

@auindex Schwetman, H.
@auindex Santini, S.

@c
@GETHELP{qnmvapop}

@noindent @strong{REFERENCES}

Zahorjan, J. and Wong, E. @cite{The solution of separable queueing
network models using mean value analysis}. SIGMETRICS
Perform. Eval. Rev. 10, 3 (Sep. 1981), 80-85. DOI
@url{http://doi.acm.org/10.1145/1010629.805477}

@auindex Zahorjan, J.
@auindex Wong, E.

