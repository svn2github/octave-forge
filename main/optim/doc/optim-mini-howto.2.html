<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD><TITLE></TITLE>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.06">
</HEAD>
<BODY >
<!--HEVEA command line is: /usr/bin/hevea optim-mini-howto.2.tex -->
<!--HTMLHEAD-->
<!--ENDHTML-->
<!--PREFIX <ARG ></ARG>-->
<!--CUT DEF section 1 -->

<BR>
<BR>
cmss<BR>
<BR>
 

<H1 ALIGN=center>Mini-HOWTO on using Octave for Unconstrained Nonlinear Optimization<A NAME="text1" HREF="#note1"><SUP><FONT SIZE=2>1</FONT></SUP></A></H1>

Nonlinear optimization problems are very common and when a solution
cannot be found analytically, one usually tries to find it numerically.
This document shows how to perform unconstrained nonlinear minimization
using the Octave language for numerical computation. We assume to
be so lucky as to have an initial guess from which to start an iterative
method, and so impatient as to avoid as much as possible going into
the details of the algorithm. In the following examples, we consider
multivariable problems, but the single variable case is solved in
exactly the same way.<BR>
<BR>
All the algorithms used below return numerical approximations of <EM>local
minima</EM> of the optimized function. In the following examples, we minimize
a function with a single minimum (Figure&nbsp;<A HREF="#fig:function">1</A>), which
is relatively easily found. In practice, success of optimization algorithms
greatly depend on the optimized function and on the starting point.<BR>
<BR>
<!--TOC section cmss A simple example-->

<H2>cmss A simple example</H2><!--SEC END -->

<BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV>
<DIV ALIGN=center>6mm<IMG SRC="optim-mini-howto.2001.png"> &nbsp;<IMG SRC="optim-mini-howto.2002.png"> </DIV><BR>
<DIV ALIGN=center>Figure 1: <A NAME="fig:function"></A> 2D and 1D slices of the function that is minimized
throughout this tutorial. Although not obvious at first sight, it
has a unique minimum.</DIV><BR>

<DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE>
We will use a call of the type
<DIV ALIGN=left><DL COMPACT=compact><DT><DD><TT>
[x_best,&nbsp;best_value,&nbsp;niter]&nbsp;=&nbsp;minimize&nbsp;(func,&nbsp;x_init)
</TT></DL></DIV>
to find the minimum of <DIV ALIGN=center><TABLE>
<TR VALIGN=middle><TD NOWRAP>
</TD>
<TD NOWRAP><TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=center NOWRAP><I>f</I>&nbsp; :</TD>
<TD ALIGN=center NOWRAP><TABLE>
<TR VALIGN=middle><TD NOWRAP>(</TD>
<TD NOWRAP><I>x</I><SUB><FONT SIZE=2>1</FONT></SUB>,.<I>x</I><SUB><FONT SIZE=2>2</FONT></SUB>,<I>x</I><SUB><FONT SIZE=2>3</FONT></SUB></TD>
<TD NOWRAP>)</TD>
<TD NOWRAP><FONT FACE=symbol>Î</FONT> <I>R</I> <SUP><FONT SIZE=2>3</FONT></SUP></TD>
</TR></TABLE></TD>
<TD ALIGN=center NOWRAP><FONT FACE=symbol>¾®</FONT></TD>
<TD ALIGN=center NOWRAP><TABLE>
<TR VALIGN=middle><TD NOWRAP>(</TD>
<TD NOWRAP><I>x</I><SUB><FONT SIZE=2>1</FONT></SUB>-1</TD>
<TD NOWRAP>)</TD>
<TD NOWRAP><TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2>2</FONT></TD>
</TR>
<TR><TD ALIGN=left>&nbsp;</TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
</TR></TABLE></TD>
<TD NOWRAP>/9+</TD>
<TD NOWRAP>(</TD>
<TD NOWRAP><I>x</I><SUB><FONT SIZE=2>3</FONT></SUB>-1</TD>
<TD NOWRAP>)</TD>
<TD NOWRAP><TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2>2</FONT></TD>
</TR>
<TR><TD ALIGN=left>&nbsp;</TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
</TR></TABLE></TD>
<TD NOWRAP>/9+</TD>
<TD NOWRAP>(</TD>
<TD NOWRAP><I>x</I><SUB><FONT SIZE=2>3</FONT></SUB>-1</TD>
<TD NOWRAP>)</TD>
<TD NOWRAP><TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2>2</FONT></TD>
</TR>
<TR><TD ALIGN=left>&nbsp;</TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
</TR></TABLE></TD>
<TD NOWRAP>/9</TD>
</TR></TABLE></TD>
</TR>
<TR><TD ALIGN=center NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP><TABLE>
<TR VALIGN=middle><TD NOWRAP>-cos</TD>
<TD NOWRAP>(</TD>
<TD NOWRAP><I>x</I><SUB><FONT SIZE=2>1</FONT></SUB>-1</TD>
<TD NOWRAP>)</TD>
<TD NOWRAP>-cos</TD>
<TD NOWRAP>(</TD>
<TD NOWRAP><I>x</I><SUB><FONT SIZE=2>2</FONT></SUB>-1</TD>
<TD NOWRAP>)</TD>
<TD NOWRAP>-cos</TD>
<TD NOWRAP>(</TD>
<TD NOWRAP><I>x</I><SUB><FONT SIZE=2>3</FONT></SUB>-1</TD>
<TD NOWRAP>)</TD>
<TD NOWRAP>.</TD>
</TR></TABLE></TD>
</TR></TABLE></TD>
</TR></TABLE></DIV><BR>
The following commands should find a local minimum of  <I>f</I>() ,
using the Nelder-Mead (aka ``downhill simplex'') algorithm and
starting from a randomly chosen point <TT>x0</TT>&nbsp;:
<DIV ALIGN=left><DL COMPACT=compact><DT><DD><TT>
function&nbsp;cost&nbsp;=&nbsp;foo&nbsp;(xx)<BR>
<BR>
&nbsp;&nbsp;xx--;&nbsp;&nbsp;<BR>
<BR>
&nbsp;&nbsp;cost&nbsp;=&nbsp;sum&nbsp;(-cos(xx)+xx.2/9);<BR>
<BR>
endfunction<BR>
<BR>
x0&nbsp;=&nbsp;[-1,&nbsp;3,&nbsp;-2];<BR>
<BR>
[x,v,n]&nbsp;=&nbsp;minimize&nbsp;("foo",&nbsp;x0)
</TT></DL></DIV>
The output should look like&nbsp;:
<DIV ALIGN=left><DL COMPACT=compact><DT><DD><TT>
x&nbsp;=<BR>
<BR>
&nbsp;&nbsp;1.00000&nbsp;1.00000&nbsp;1.00000<BR>
<BR>
v&nbsp;=&nbsp;-3.0000<BR>
<BR>
n&nbsp;=&nbsp;248
</TT></DL></DIV>
This means that a minimum has been found in  <TABLE>
<TR VALIGN=middle><TD NOWRAP>(</TD>
<TD NOWRAP>1,1,1</TD>
<TD NOWRAP>)</TD>
</TR></TABLE>
and that the value at that point is  -3 . This is correct, since
all the points of the form  <I>x</I><SUB><FONT SIZE=2>1</FONT></SUB>=1+2<I>i</I><FONT FACE=symbol>p</FONT> ,&nbsp; <I>x</I><SUB><FONT SIZE=2>2</FONT></SUB>=1+2<I>j</I><FONT FACE=symbol>p</FONT> ,&nbsp; <I>x</I><SUB><FONT SIZE=2>3</FONT></SUB>=1+2<I>k</I><FONT FACE=symbol>p</FONT> ,
for some  <I>i</I>,<I>j</I>,<I>k</I><FONT FACE=symbol>Î</FONT> <I>N</I> , minimize  <I>f</I>() . The number of function
evaluations, 248, is also returned. Note that this number depends
on the starting point. You will most likely obtain different numbers
if you change <TT>x0</TT>.<BR>
<BR>
The Nelder-Mead algorithm is quite robust, but unfortunately it is
not very efficient. For high-dimensional problems, its execution time
may become prohibitive.<BR>
<BR>
<!--TOC section cmss Using the first differential-->

<H2>cmss Using the first differential</H2><!--SEC END -->

Fortunately, when a function, like  <I>f</I>()  above, is differentiable,
more efficient optimization algorithms can be used. If <TT>minimize()</TT>
is given the differential of the optimized function, using the <TT>"df"</TT>
option, it will use a conjugate gradient method.
<DIV ALIGN=left><DL COMPACT=compact><DT><DD><TT>
##&nbsp;Function&nbsp;returning&nbsp;partial&nbsp;derivatives<BR>
<BR>
function&nbsp;dc&nbsp;=&nbsp;diffoo&nbsp;(x)<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;x(:)'&nbsp;-&nbsp;1;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;dc&nbsp;=&nbsp;sin&nbsp;(x)&nbsp;+&nbsp;2*x/9;<BR>
<BR>
endfunction<BR>
<BR>
[x,&nbsp;v,&nbsp;n]&nbsp;=&nbsp;minimize&nbsp;("foo",&nbsp;x0,&nbsp;"df",&nbsp;"diffoo")
</TT></DL></DIV>
This produces the output&nbsp;:
<DIV ALIGN=left><DL COMPACT=compact><DT><DD><TT>
x&nbsp;=<BR>
<BR>
&nbsp;&nbsp;1.00000&nbsp;1.00000&nbsp;1.00000<BR>
<BR>
v&nbsp;=&nbsp;-3&nbsp;<BR>
<BR>
n&nbsp;=<BR>
<BR>
&nbsp;&nbsp;108&nbsp;6
</TT></DL></DIV>
The same minimum has been found, but only 108 function evaluations
were needed, together with 6 evaluations of the differential. Here,
<TT>diffoo()</TT> takes the same argument as <TT>foo()</TT> and returns
the partial derivatives of  <I>f</I>()  with respect to the corresponding
variables. It doesn't matter if it returns a row or column vector
or a matrix, as long as the  <I>i</I><SUP><FONT SIZE=2>th</FONT></SUP>  element of <TT>diffoo(x)</TT>
is the partial derivative of  <I>f</I>()  with respect to  <I>x</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB> 
.<BR>
<BR>
<!--TOC section cmss Using numerical approximations of
the first differential-->

<H2>cmss Using numerical approximations of
the first differential</H2><!--SEC END -->

Sometimes, the minimized function is differentiable, but actually
writing down its differential is more work than one would like. Numerical
differentiation offers a solution which is less efficient in terms
of computation cost, but easy to implement. The <TT>"ndiff"</TT>
option of <TT>minimize()</TT> uses numerical differentiation to execute
exactly the same algorithm as in the previous example. However, because
numerical approximation of the differentia is used, the outpud may
differ slightly&nbsp;:
<DIV ALIGN=left><DL COMPACT=compact><DT><DD><TT>
[x,&nbsp;v,&nbsp;n]&nbsp;=&nbsp;minimize&nbsp;("foo",&nbsp;x0,&nbsp;"ndiff")
</TT></DL></DIV>
wich yields&nbsp;:
<DIV ALIGN=left><DL COMPACT=compact><DT><DD><TT>
x&nbsp;=<BR>
<BR>
&nbsp;&nbsp;1.00000&nbsp;1.00000&nbsp;1.00000<BR>
<BR>
v&nbsp;=&nbsp;-3&nbsp;<BR>
<BR>
n&nbsp;=<BR>
<BR>
&nbsp;&nbsp;78&nbsp;6
</TT></DL></DIV>
Note that each time the differential is numerically approximated,
<TT>foo()</TT> is called 6 times (twice per input element), so that
<TT>foo()</TT> is evaluated a total of (78+6*6=) 114 times in this
example.<BR>
<BR>
<!--TOC section cmss Using the first and second differentials-->

<H2>cmss Using the first and second differentials</H2><!--SEC END -->

When the function is twice differentiable and one knows how to compute
its first and second differentials, still more efficient algorithms
can be used (in our case, a variant of Levenberg-Marquardt). The option
<TT>"d2f"</TT> allows to specify a function that
returns the value of the function, the first and second differentials
of the minimized function. Entering the commands&nbsp;: 
<DIV ALIGN=left><DL COMPACT=compact><DT><DD><TT>
function&nbsp;[c,&nbsp;dc,&nbsp;d2c]&nbsp;=&nbsp;d2foo&nbsp;(x)<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;foo(x);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;dc&nbsp;=&nbsp;diffoo(x);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;d2c&nbsp;=&nbsp;diag&nbsp;(cos&nbsp;(x(:)-1)&nbsp;+&nbsp;2/9);<BR>
<BR>
end<BR>
<BR>
[x,v,n]&nbsp;=&nbsp;minimize&nbsp;("foo",&nbsp;x0,&nbsp;"d2f",&nbsp;"d2foo")&nbsp;
</TT></DL></DIV>
produces the output&nbsp;:
<DIV ALIGN=left><DL COMPACT=compact><DT><DD><TT>
x&nbsp;=<BR>
<BR>
&nbsp;&nbsp;1.0000&nbsp;1.0000&nbsp;1.0000<BR>
<BR>
v&nbsp;=&nbsp;-3<BR>
<BR>
n&nbsp;=<BR>
<BR>
&nbsp;&nbsp;34&nbsp;5
</TT></DL></DIV>
This time, 34 function evaluations, and 5 evaluations of <TT>d2foo()</TT>
were needed.<BR>
<BR>
<!--TOC section cmss Summary-->

<H2>cmss Summary</H2><!--SEC END -->

We have just seen the most basic ways of solving nonlinear unconstrained
optimization problems. The online help system of Octave (try e.g.
``<TT>help minimize</TT>'') will yield information on other issues,
such as <EM>passing extra arguments</EM> to the minimized function,
<EM>controling the termination</EM> of the optimization process, choosing
the algorithm etc.
<DIV ALIGN=left><DL COMPACT=compact><DT><DD><TT>
</TT></DL></DIV>
<!--BEGIN NOTES document-->
<HR WIDTH="50%" SIZE=1><DL><DT><A NAME="note1" HREF="#text1"><FONT SIZE=5>1</FONT></A><DD>Author : Etienne Grossmann <TT>&lt;etienne@isr.ist.utl.pt&gt;</TT> (soon
replaced by ``Octave-Forge developers''?). This document is free
documentation; you can redistribute it and/or modify it under the
terms of the GNU Free Documentation License as published by the Free
Software Foundation.<BR>
.&nbsp;&nbsp;&nbsp;This is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.

</DL>
<!--END NOTES-->
<!--HTMLFOOT-->
<!--ENDHTML-->
<!--FOOTER-->
<HR SIZE=2>
<BLOCKQUOTE><EM>This document was translated from L<sup>A</sup>T<sub>E</sub>X by
</EM><A HREF="http://pauillac.inria.fr/~maranget/hevea/index.html"><EM>H<FONT SIZE=2><sup>E</sup></FONT>V<FONT SIZE=2><sup>E</sup></FONT>A</EM></A><EM>.
</EM></BLOCKQUOTE>
</BODY>
</HTML>
